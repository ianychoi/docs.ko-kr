---
title: 보안 규칙 (코드 분석)
description: 코드 분석 보안 규칙에 대해 알아봅니다.
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 861827662a771ec7cc1827cdd8125be6c05bf05c
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99719723"
---
# <a name="security-rules"></a><span data-ttu-id="ab285-103">보안 규칙</span><span class="sxs-lookup"><span data-stu-id="ab285-103">Security rules</span></span>

<span data-ttu-id="ab285-104">보안 규칙은 더 안전한 라이브러리 및 응용 프로그램을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-104">Security rules support safer libraries and applications.</span></span> <span data-ttu-id="ab285-105">이러한 규칙은 프로그램의 보안 결함을 방지 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-105">These rules help prevent security flaws in your program.</span></span> <span data-ttu-id="ab285-106">이러한 규칙을 사용 하지 않도록 설정 하는 경우 코드에서 이유를 명확 하 게 표시 하 고 개발 프로젝트에 대해 지정 된 보안 담당자에 게 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-106">If you disable any of these rules, you should clearly mark the reason in code and also inform the designated security officer for your development project.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="ab285-107">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="ab285-107">In this section</span></span>

|<span data-ttu-id="ab285-108">규칙</span><span class="sxs-lookup"><span data-stu-id="ab285-108">Rule</span></span>|<span data-ttu-id="ab285-109">설명</span><span class="sxs-lookup"><span data-stu-id="ab285-109">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="ab285-110">CA2100: 보안상 취약한 부분이 있는지 SQL 쿼리를 검토하십시오.</span><span class="sxs-lookup"><span data-stu-id="ab285-110">CA2100: Review SQL queries for security vulnerabilities</span></span>](ca2100.md)|<span data-ttu-id="ab285-111">메서드가 메서드에 대한 문자열 인수로부터 만들어진 문자열을 사용하여 System.Data.IDbCommand.CommandText 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-111">A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method.</span></span> <span data-ttu-id="ab285-112">이 규칙에서는 문자열 인수에 사용자 입력이 포함된 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-112">This rule assumes that the string argument contains user input.</span></span> <span data-ttu-id="ab285-113">사용자 입력으로부터 만들어진 SQL 명령 문자열은 SQL 삽입 공격에 취약합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-113">A SQL command string built from user input is vulnerable to SQL injection attacks.</span></span>|
|[<span data-ttu-id="ab285-114">CA2109: 표시되는 이벤트 처리기를 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-114">CA2109: Review visible event handlers</span></span>](ca2109.md)|<span data-ttu-id="ab285-115">public 또는 protected 이벤트 처리 메서드를 발견했습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-115">A public or protected event-handling method was detected.</span></span> <span data-ttu-id="ab285-116">이벤트 처리 메서드는 반드시 필요한 경우를 제외하고 노출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-116">Event-handling methods should not be exposed unless absolutely necessary.</span></span>|
|[<span data-ttu-id="ab285-117">CA2119: private 인터페이스를 만족하는 메서드를 봉인하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-117">CA2119: Seal methods that satisfy private interfaces</span></span>](ca2119.md)|<span data-ttu-id="ab285-118">상속할 수 있는 public 형식에서는 internal(Visual Basic의 경우 Friend) 인터페이스의 재정의 가능한 메서드 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-118">An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface.</span></span> <span data-ttu-id="ab285-119">이 규칙 위반 문제를 해결하려면 어셈블리 외부에서 메서드가 재정의되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-119">To fix a violation of this rule, prevent the method from being overridden outside the assembly.</span></span>|
|[<span data-ttu-id="ab285-120">CA2153: 손상 된 상태 예외 처리 방지</span><span class="sxs-lookup"><span data-stu-id="ab285-120">CA2153: Avoid Handling Corrupted State Exceptions</span></span>](ca2153.md)|<span data-ttu-id="ab285-121">[CSE(손상된 상태 예외)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) 는 프로세스에 메모리 손상이 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-121">[Corrupted State Exceptions (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) indicate that memory corruption exists in your process.</span></span> <span data-ttu-id="ab285-122">프로세스 충돌을 허용하는 대신 catch하면 공격자가 손상된 메모리 영역에 익스플로잇을 배치할 수 있는 경우 보안 취약점이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-122">Catching these rather than allowing the process to crash can lead to security vulnerabilities if an attacker can place an exploit into the corrupted memory region.</span></span>|
|[<span data-ttu-id="ab285-123">CA2300: 안전하지 않은 역직렬 변환기 BinaryFormatter를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-123">CA2300: Do not use insecure deserializer BinaryFormatter</span></span>](ca2300.md)|<span data-ttu-id="ab285-124">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-124">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-125">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-125">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-126">CA2301: 먼저 BinaryFormatter.Binder를 설정하지 않고 BinaryFormatter.Deserialize를 호출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-126">CA2301: Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</span></span>](ca2301.md)|<span data-ttu-id="ab285-127">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-127">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-128">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-128">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-129">CA2302: BinaryFormatter.Deserialize를 호출하기 전에 BinaryFormatter.Binder가 설정되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-129">CA2302: Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</span></span>](ca2302.md)|<span data-ttu-id="ab285-130">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-130">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-131">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-131">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-132">CA2305: 안전하지 않은 역직렬 변환기 LosFormatter를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-132">CA2305: Do not use insecure deserializer LosFormatter</span></span>](ca2305.md)|<span data-ttu-id="ab285-133">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-133">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-134">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-134">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-135">CA2310: 안전하지 않은 역직렬 변환기 NetDataContractSerializer를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-135">CA2310: Do not use insecure deserializer NetDataContractSerializer</span></span>](ca2310.md)|<span data-ttu-id="ab285-136">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-136">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-137">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-137">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-138">CA2311: 먼저 NetDataContractSerializer.Binder를 설정하지 않고 역직렬화하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-138">CA2311: Do not deserialize without first setting NetDataContractSerializer.Binder</span></span>](ca2311.md)|<span data-ttu-id="ab285-139">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-139">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-140">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-140">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-141">CA2312: 역직렬화하기 전에 NetDataContractSerializer.Binder를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-141">CA2312: Ensure NetDataContractSerializer.Binder is set before deserializing</span></span>](ca2312.md)|<span data-ttu-id="ab285-142">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-142">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-143">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-143">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-144">CA2315: 안전하지 않은 역직렬 변환기 ObjectStateFormatter를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-144">CA2315: Do not use insecure deserializer ObjectStateFormatter</span></span>](ca2315.md)|<span data-ttu-id="ab285-145">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-145">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-146">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-146">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-147">CA2321: SimpleTypeResolver를 사용하여 JavaScriptSerializer를 통해 역직렬화하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-147">CA2321: Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</span></span>](ca2321.md)|<span data-ttu-id="ab285-148">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-148">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-149">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-149">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-150">CA2322: JavaScriptSerializer가 역직렬화하기 전에 SimpleTypeResolver로 초기화되지 않는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-150">CA2322: Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</span></span>](ca2322.md)|<span data-ttu-id="ab285-151">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-151">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-152">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-152">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-153">CA2326: None 이외의 TypeNameHandling 값을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-153">CA2326: Do not use TypeNameHandling values other than None</span></span>](ca2326.md)|<span data-ttu-id="ab285-154">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-154">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-155">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-155">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-156">CA2327: 안전하지 않은 JsonSerializerSettings를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-156">CA2327: Do not use insecure JsonSerializerSettings</span></span>](ca2327.md)|<span data-ttu-id="ab285-157">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-157">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-158">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-158">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-159">CA2328: JsonSerializerSettings가 안전한지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-159">CA2328: Ensure that JsonSerializerSettings are secure</span></span>](ca2328.md)|<span data-ttu-id="ab285-160">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-160">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-161">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-161">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-162">CA2329: 안전하지 않은 구성을 사용하여 JsonSerializer로 역직렬화하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-162">CA2329: Do not deserialize with JsonSerializer using an insecure configuration</span></span>](ca2329.md)|<span data-ttu-id="ab285-163">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-163">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-164">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-164">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-165">CA2330: 역직렬화할 때 JsonSerializer에 보안 구성이 있는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-165">CA2330: Ensure that JsonSerializer has a secure configuration when deserializing</span></span>](ca2330.md)|<span data-ttu-id="ab285-166">안전 하지 않은 데이터는 deserialize 할 때 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-166">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="ab285-167">공격자는 예기치 않은 형식을 포함 하도록 serialize 된 데이터를 수정 하 여 악의적인 부작용으로 개체를 주입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-167">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span>|
|[<span data-ttu-id="ab285-168">CA2350: DataTable.ReadXml()의 입력을 신뢰할 수 있는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-168">CA2350: Ensure DataTable.ReadXml()'s input is trusted</span></span>](ca2350.md)|<span data-ttu-id="ab285-169">신뢰할 수 없는 입력으로를 deserialize 할 때 <xref:System.Data.DataTable> 공격자는 서비스 거부 공격을 수행할 악성 입력을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-169">When deserializing a <xref:System.Data.DataTable> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="ab285-170">알 수 없는 원격 코드 실행 취약점이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-170">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="ab285-171">CA2351: DataSet.ReadXml()의 입력을 신뢰할 수 있는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-171">CA2351: Ensure DataSet.ReadXml()'s input is trusted</span></span>](ca2351.md)|<span data-ttu-id="ab285-172">신뢰할 수 없는 입력으로를 deserialize 할 때 <xref:System.Data.DataSet> 공격자는 서비스 거부 공격을 수행할 악성 입력을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-172">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="ab285-173">알 수 없는 원격 코드 실행 취약점이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-173">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="ab285-174">CA2352: 직렬화 가능 형식의 안전하지 않은 데이터 세트 또는 DataTable은 원격 코드 실행 공격에 취약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-174">CA2352: Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</span></span>](ca2352.md)|<span data-ttu-id="ab285-175">로 표시 된 클래스 또는 구조체에 <xref:System.SerializableAttribute> <xref:System.Data.DataSet> 또는 <xref:System.Data.DataTable> 필드 또는 속성이 포함 되어 있고가 없는 <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> 경우</span><span class="sxs-lookup"><span data-stu-id="ab285-175">A class or struct marked with <xref:System.SerializableAttribute> contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property, and doesn't have a <xref:System.CodeDom.Compiler.GeneratedCodeAttribute>.</span></span>|
|[<span data-ttu-id="ab285-176">CA2353: 직렬화 가능 형식의 안전하지 않은 데이터 세트 또는 DataTable입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-176">CA2353: Unsafe DataSet or DataTable in serializable type</span></span>](ca2353.md)|<span data-ttu-id="ab285-177">XML serialization 특성 또는 데이터 계약 특성으로 표시 된 클래스 또는 구조체에 <xref:System.Data.DataSet> 또는 <xref:System.Data.DataTable> 필드 또는 속성이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-177">A class or struct marked with an XML serialization attribute or a data contract attribute contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property.</span></span>|
|[<span data-ttu-id="ab285-178">CA2354: 역직렬화된 개체 그래프의 안전하지 않은 데이터 세트 또는 DataTable은 원격 코드 실행 공격에 취약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-178">CA2354: Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attack</span></span>](ca2354.md)|<span data-ttu-id="ab285-179">Serialize 된로 deserialize <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> 하 고, 캐스트 된 형식의 개체 그래프에 또는가 포함 될 수 있습니다 <xref:System.Data.DataSet> <xref:System.Data.DataTable> .</span><span class="sxs-lookup"><span data-stu-id="ab285-179">Deserializing with an <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serialized, and the casted type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="ab285-180">CA2355: 역직렬화된 개체 그래프의 안전하지 않은 데이터 세트 또는 DataTable</span><span class="sxs-lookup"><span data-stu-id="ab285-180">CA2355: Unsafe DataSet or DataTable in deserialized object graph</span></span>](ca2355.md)|<span data-ttu-id="ab285-181">캐스팅 되거나 지정 된 형식의 개체 그래프에 또는가 포함 될 수 있는 경우 deserialize <xref:System.Data.DataSet> <xref:System.Data.DataTable></span><span class="sxs-lookup"><span data-stu-id="ab285-181">Deserializing when the casted or specified type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="ab285-182">CA2356: 웹 deserialize 된 개체 그래프의 안전 하지 않은 데이터 집합 또는 DataTable</span><span class="sxs-lookup"><span data-stu-id="ab285-182">CA2356: Unsafe DataSet or DataTable in web deserialized object graph</span></span>](ca2356.md)|<span data-ttu-id="ab285-183">또는를 사용 하는 메서드에 <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> 또는를 참조할 수 있는 매개 변수가 있습니다 <xref:System.Data.DataSet> <xref:System.Data.DataTable> .</span><span class="sxs-lookup"><span data-stu-id="ab285-183">A method with a <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> or <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> has a parameter that may reference a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span>|
|[<span data-ttu-id="ab285-184">CA2361: DataSet.ReadXml()을 포함하는 자동 생성된 클래스가 신뢰할 수 없는 데이터와 함께 사용되지 않도록 하기</span><span class="sxs-lookup"><span data-stu-id="ab285-184">CA2361: Ensure autogenerated class containing DataSet.ReadXml() is not used with untrusted data</span></span>](ca2361.md)|<span data-ttu-id="ab285-185">신뢰할 수 없는 입력으로를 deserialize 할 때 <xref:System.Data.DataSet> 공격자는 서비스 거부 공격을 수행할 악성 입력을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-185">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="ab285-186">알 수 없는 원격 코드 실행 취약점이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-186">There may be unknown remote code execution vulnerabilities.</span></span>|
|[<span data-ttu-id="ab285-187">CA2362: 자동 생성된 직렬화 가능 형식의 안전하지 않은 DataSet 또는 DataTable은 원격 코드 실행 공격에 취약할 수 있음</span><span class="sxs-lookup"><span data-stu-id="ab285-187">CA2362: Unsafe DataSet or DataTable in autogenerated serializable type can be vulnerable to remote code execution attacks</span></span>](ca2362.md)|<span data-ttu-id="ab285-188">를 사용 하 여 신뢰할 수 없는 입력 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 을 deserialize 하 고 deserialize 된 개체 그래프에 또는가 포함 된 경우 <xref:System.Data.DataSet> <xref:System.Data.DataTable> 공격자는 악의적인 페이로드를 만들어 원격 코드 실행 공격을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-188">When deserializing untrusted input with <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the deserialized object graph contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>, an attacker can craft a malicious payload to perform a remote code execution attack.</span></span>|
|[<span data-ttu-id="ab285-189">CA3001: 코드에서 SQL 주입 취약점에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-189">CA3001: Review code for SQL injection vulnerabilities</span></span>](ca3001.md)|<span data-ttu-id="ab285-190">신뢰할 수 없는 입력 및 SQL 명령으로 작업 하는 경우 SQL 삽입 공격에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-190">When working with untrusted input and SQL commands, be mindful of SQL injection attacks.</span></span> <span data-ttu-id="ab285-191">SQL 삽입 공격은 악의적인 SQL 명령을 실행 하 여 응용 프로그램의 보안 및 무결성을 손상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-191">An SQL injection attack can execute malicious SQL commands, compromising the security and integrity of your application.</span></span>|
|[<span data-ttu-id="ab285-192">CA3002: 코드에서 XSS 취약점에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-192">CA3002: Review code for XSS vulnerabilities</span></span>](ca3002.md)|<span data-ttu-id="ab285-193">웹 요청에서 신뢰할 수 없는 입력으로 작업할 때는 XSS (사이트 간 스크립팅) 공격에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-193">When working with untrusted input from web requests, be mindful of cross-site scripting (XSS) attacks.</span></span> <span data-ttu-id="ab285-194">XSS 공격은 신뢰할 수 없는 입력을 원시 HTML 출력에 삽입 하 여 공격자가 악의적인 스크립트를 실행 하거나 웹 페이지의 콘텐츠를 악의적으로 수정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-194">An XSS attack injects untrusted input into raw HTML output, allowing the attacker to execute malicious scripts or maliciously modify content in your web page.</span></span>|
|[<span data-ttu-id="ab285-195">CA3003: 코드에서 파일 경로 삽입 취약성에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-195">CA3003: Review code for file path injection vulnerabilities</span></span>](ca3003.md)|<span data-ttu-id="ab285-196">웹 요청에서 신뢰할 수 없는 입력으로 작업 하는 경우 파일에 대 한 경로를 지정 하는 경우 사용자가 제어 하는 입력을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-196">When working with untrusted input from web requests, be mindful of using user-controlled input when specifying paths to files.</span></span>|
|[<span data-ttu-id="ab285-197">CA3004: 코드에서 정보 공개 취약성에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-197">CA3004: Review code for information disclosure vulnerabilities</span></span>](ca3004.md)|<span data-ttu-id="ab285-198">예외 정보를 공개 하면 공격자가 응용 프로그램의 내부 정보를 파악할 수 있으므로 공격자가 다른 취약점을 악용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-198">Disclosing exception information gives attackers insight into the internals of your application, which can help attackers find other vulnerabilities to exploit.</span></span>|
|[<span data-ttu-id="ab285-199">CA3006: 코드에서 프로세스 명령 주입 취약점에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-199">CA3006: Review code for process command injection vulnerabilities</span></span>](ca3006.md)|<span data-ttu-id="ab285-200">신뢰할 수 없는 입력으로 작업 하는 경우 명령 삽입 공격에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-200">When working with untrusted input, be mindful of command injection attacks.</span></span> <span data-ttu-id="ab285-201">명령 삽입 공격은 서버와의 보안 및 무결성을 손상 시키는 기본 운영 체제에서 악성 명령을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-201">A command injection attack can execute malicious commands on the underlying operating system, compromising the security and integrity of your server.</span></span>|
|[<span data-ttu-id="ab285-202">CA3007: 코드에서 오픈 리디렉션 취약점에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-202">CA3007: Review code for open redirect vulnerabilities</span></span>](ca3007.md)|<span data-ttu-id="ab285-203">신뢰할 수 없는 입력으로 작업 하는 경우 개방형 리디렉션 취약성에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-203">When working with untrusted input, be mindful of open redirect vulnerabilities.</span></span> <span data-ttu-id="ab285-204">공격자는 오픈 리디렉션 취약성을 악용 하 여 합법적인 URL의 모양을 제공 하는 데 웹 사이트를 사용할 수 있지만, 의심 되는 방문자를 피싱 또는 기타 악성 웹 페이지로 리디렉션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-204">An attacker can exploit an open redirect vulnerability to use your website to give the appearance of a legitimate URL, but redirect an unsuspecting visitor to a phishing or other malicious webpage.</span></span>|
|[<span data-ttu-id="ab285-205">CA3008: 코드에서 XPath 삽입 취약성에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-205">CA3008: Review code for XPath injection vulnerabilities</span></span>](ca3008.md)|<span data-ttu-id="ab285-206">신뢰할 수 없는 입력으로 작업할 때는 XPath 삽입 공격에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-206">When working with untrusted input, be mindful of XPath injection attacks.</span></span> <span data-ttu-id="ab285-207">신뢰할 수 없는 입력을 사용 하 여 XPath 쿼리를 생성 하면 공격자가 쿼리를 악의적으로 조작 하 여 의도 하지 않은 결과를 반환 하 고 쿼리 된 XML의 콘텐츠를 공개할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-207">Constructing XPath queries using untrusted input may allow an attacker to maliciously manipulate the query to return an unintended result, and possibly disclose the contents of the queried XML.</span></span>|
|[<span data-ttu-id="ab285-208">CA3009: 코드에서 XML 삽입 취약성에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-208">CA3009: Review code for XML injection vulnerabilities</span></span>](ca3009.md)|<span data-ttu-id="ab285-209">신뢰할 수 없는 입력으로 작업 하는 경우 XML 삽입 공격에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-209">When working with untrusted input, be mindful of XML injection attacks.</span></span>|
|[<span data-ttu-id="ab285-210">CA3010: 코드에서 XAML 삽입 취약성에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-210">CA3010: Review code for XAML injection vulnerabilities</span></span>](ca3010.md)|<span data-ttu-id="ab285-211">신뢰할 수 없는 입력으로 작업 하는 경우 XAML 삽입 공격에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-211">When working with untrusted input, be mindful of XAML injection attacks.</span></span> <span data-ttu-id="ab285-212">XAML은 개체 인스턴스화 및 실행을 직접적으로 나타내는 태그 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-212">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="ab285-213">즉, XAML로 생성 된 요소는 시스템 리소스 (예: 네트워크 액세스 및 파일 시스템 IO)와 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-213">That means elements created in XAML can interact with system resources (for example, network access and file system IO).</span></span>|
|[<span data-ttu-id="ab285-214">CA3011: 코드에서 DLL 삽입 취약성에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-214">CA3011: Review code for DLL injection vulnerabilities</span></span>](ca3011.md)|<span data-ttu-id="ab285-215">신뢰할 수 없는 입력으로 작업할 때는 신뢰할 수 없는 코드를 로드 하는 것에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-215">When working with untrusted input, be mindful of loading untrusted code.</span></span> <span data-ttu-id="ab285-216">웹 응용 프로그램이 신뢰할 수 없는 코드를 로드 하는 경우 공격자가 프로세스에 악성 Dll을 삽입 하 고 악성 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-216">If your web application loads untrusted code, an attacker may be able to inject malicious DLLs into your process and execute malicious code.</span></span>|
|[<span data-ttu-id="ab285-217">CA3012: 코드에서 regex 삽입 취약성에 대해 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-217">CA3012: Review code for regex injection vulnerabilities</span></span>](ca3012.md)|<span data-ttu-id="ab285-218">신뢰할 수 없는 입력으로 작업할 때는 regex 삽입 공격에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-218">When working with untrusted input, be mindful of regex injection attacks.</span></span> <span data-ttu-id="ab285-219">공격자는 regex 주입을 사용 하 여 정규식을 악의적으로 수정 하거나 regex가 의도 하지 않은 결과와 일치 하도록 하거나 regex가 과도 한 CPU를 사용 하 여 서비스 거부 공격을 내릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-219">An attacker can use regex injection to maliciously modify a regular expression, to make the regex match unintended results, or to make the regex consume excessive CPU resulting in a Denial of Service attack.</span></span>|
|[<span data-ttu-id="ab285-220">CA3061: URL로 스키마를 추가하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-220">CA3061: Do not add schema by URL</span></span>](ca3061.md)|<span data-ttu-id="ab285-221">위험한 외부 참조를 유발할 수 있으므로 Add 메서드의 unsafe 오버 로드를 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-221">Do not use the unsafe overload of the Add method because it may cause dangerous external references.</span></span>|
|[<span data-ttu-id="ab285-222">CA3075: DTD 처리가 안전하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-222">CA3075: Insecure DTD Processing</span></span>](ca3075.md)|<span data-ttu-id="ab285-223">안전하지 않은 DTDProcessing 인스턴스를 사용하거나 외부 엔터티 소스를 참조하면 파서는 신뢰할 수 없는 입력을 허용하고 공격자에게 중요 한 정보를 공개할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-223">If you use insecure DTDProcessing instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.</span></span>|
|[<span data-ttu-id="ab285-224">CA3076: XSLT 스크립트 실행이 안전하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-224">CA3076: Insecure XSLT Script Execution</span></span>](ca3076.md)|<span data-ttu-id="ab285-225">.NET 응용 프로그램에서 비보안 방식에서 XSLT (Extensible StyleSheet Language) 변환 (XSLT)을 실행 하는 경우 프로세서는 공격자에 게 중요 한 정보를 노출 하 여 서비스 거부 및 사이트 간 공격을 유발할 수 있는 신뢰할 수 없는 URI 참조를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-225">If you execute Extensible StyleSheet Language Transformations (XSLT) in .NET applications insecurely, the processor may resolve untrusted URI references that could disclose sensitive information to attackers, leading to Denial of Service and Cross-Site attacks.</span></span>|
|[<span data-ttu-id="ab285-226">CA3077: API 디자인, XML 문서 및 XML 텍스트 판독기의 처리가 안전하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-226">CA3077: Insecure Processing in API Design, XML Document and XML Text Reader</span></span>](ca3077.md)|<span data-ttu-id="ab285-227">XMLDocument 및 XMLTextReader에서 파생된 API를 디자인할 경우 DtdProcessing에 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-227">When designing an API derived from XMLDocument and XMLTextReader, be mindful of DtdProcessing.</span></span> <span data-ttu-id="ab285-228">외부 엔터티 소스를 참조하거나 확인할 때 안전하지 않은 DTDProcessing 인스턴스를 사용하거나 XML에서 안전하지 않은 값을 설정하면 정보가 공개될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-228">Using insecure DTDProcessing instances when referencing or resolving external entity sources or setting insecure values in the XML may lead to information disclosure.</span></span>|
|[<span data-ttu-id="ab285-229">CA3147: ValidateAntiForgeryToken을 사용하여 동사 처리기를 표시하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-229">CA3147: Mark verb handlers with ValidateAntiForgeryToken</span></span>](ca3147.md)|<span data-ttu-id="ab285-230">ASP.NET MVC 컨트롤러를 설계할 때 사이트 간 요청 위조 공격을 염두에 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-230">When designing an ASP.NET MVC controller, be mindful of cross-site request forgery attacks.</span></span> <span data-ttu-id="ab285-231">교차 사이트 요청 위조 공격은 인증 된 사용자의 악성 요청을 ASP.NET MVC 컨트롤러로 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-231">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET MVC controller.</span></span>|
|[<span data-ttu-id="ab285-232">CA5350: 취약한 암호화 알고리즘을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-232">CA5350: Do Not Use Weak Cryptographic Algorithms</span></span>](ca5350.md)|<span data-ttu-id="ab285-233">오늘날 여러 가지 이유로 약한 암호화 알고리즘 및 해시 함수가 사용되지만 데이터의 무결성과 기밀성을 보장하기 위해서는 이 방법을 사용하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-233">Weak encryption algorithms and hashing functions are used today for a number of reasons, but they should not be used to guarantee the confidentiality or integrity of the data they protect.</span></span> <span data-ttu-id="ab285-234">이 규칙은 코드에 TripleDES, SHA1 또는 RIPEMD160 알고리즘이 있을 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-234">This rule triggers when it finds TripleDES, SHA1, or RIPEMD160 algorithms in the code.</span></span>|
|[<span data-ttu-id="ab285-235">CA5351: 손상 된 암호화 알고리즘을 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ab285-235">CA5351: Do Not Use Broken Cryptographic Algorithms</span></span>](ca5351.md)|<span data-ttu-id="ab285-236">끊어진 암호화 알고리즘은 안전하지 않은 것으로 간주되므로 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-236">Broken cryptographic algorithms are not considered secure and their use should be strongly discouraged.</span></span> <span data-ttu-id="ab285-237">이 규칙은 코드에 MD5 해시 알고리즘 또는 DES나 RC2 암호화 알고리즘이 있을 때 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-237">This rule triggers when it finds the MD5 hash algorithm or either the DES or RC2 encryption algorithms in code.</span></span>|
|[<span data-ttu-id="ab285-238">CA5358: 안전하지 않은 암호화 모드를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-238">CA5358: Do Not Use Unsafe Cipher Modes</span></span>](ca5358.md)|<span data-ttu-id="ab285-239">안전하지 않은 암호화 모드를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-239">Do Not Use Unsafe Cipher Modes</span></span>|
|[<span data-ttu-id="ab285-240">CA5359: 인증서 유효성 검사를 비활성화하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-240">CA5359: Do not disable certificate validation</span></span>](ca5359.md)|<span data-ttu-id="ab285-241">인증서는 서버의 id를 인증 하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-241">A certificate can help authenticate the identity of the server.</span></span> <span data-ttu-id="ab285-242">클라이언트는 서버 인증서의 유효성을 검사 하 여 요청이 원하는 서버로 전송 되도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-242">Clients should validate the server certificate to ensure requests are sent to the intended server.</span></span> <span data-ttu-id="ab285-243">ServerCertificateValidationCallback에서 항상를 반환 `true` 하는 경우 모든 인증서가 유효성 검사를 통과 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-243">If the ServerCertificateValidationCallback always returns `true`, any certificate will pass validation.</span></span>|
|[<span data-ttu-id="ab285-244">CA5360: deserialization에서 위험한 메서드를 호출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-244">CA5360: Do not call dangerous methods in deserialization</span></span>](ca5360.md)|<span data-ttu-id="ab285-245">안전 하지 않은 deserialization은 응용 프로그램의 논리를 악용 하거나 DoS (서비스 거부) 공격을 하거나 deserialize 될 때 임의의 코드를 실행 하기 위해 신뢰할 수 없는 데이터를 사용할 때 발생 하는 취약성입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-245">Insecure deserialization is a vulnerability that occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized.</span></span> <span data-ttu-id="ab285-246">악의적인 사용자가 응용 프로그램에서 제어 되는 신뢰할 수 없는 데이터를 deserialize 하는 경우 이러한 deserialization 기능을 악용할 수 있는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-246">It's frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data that is under their control.</span></span> <span data-ttu-id="ab285-247">특히 deserialization 프로세스에서 위험한 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-247">Specifically, invoke dangerous methods in the process of deserialization.</span></span> <span data-ttu-id="ab285-248">안전 하지 않은 deserialization 공격에 성공 하면 공격자가 DoS 공격, 인증 바이패스 및 원격 코드 실행과 같은 공격을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-248">Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</span></span>|
|[<span data-ttu-id="ab285-249">CA5361: 강력한 암호화의 SChannel 사용을 사용 하지 않도록 설정 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ab285-249">CA5361: Do not disable SChannel use of strong crypto</span></span>](ca5361.md)|<span data-ttu-id="ab285-250">`Switch.System.Net.DontEnableSchUseStrongCrypto`를로 설정 `true` 하면 weakens TLS (전송 계층 보안) 연결에 사용 되는 암호화가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-250">Setting `Switch.System.Net.DontEnableSchUseStrongCrypto` to `true` weakens the cryptography used in outgoing Transport Layer Security (TLS) connections.</span></span> <span data-ttu-id="ab285-251">약한 암호화는 응용 프로그램과 서버 간 통신의 기밀성을 손상 시켜 공격자가 중요 한 데이터를 보다 쉽게 도청 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-251">Weaker cryptography can compromise the confidentiality of communication between your application and the server, making it easier for attackers to eavesdrop sensitive data.</span></span>|
|[<span data-ttu-id="ab285-252">CA5362: 역직렬화된 개체 그래프의 잠재적 참조 주기</span><span class="sxs-lookup"><span data-stu-id="ab285-252">CA5362: Potential reference cycle in deserialized object graph</span></span>](ca5362.md)|<span data-ttu-id="ab285-253">신뢰할 수 없는 데이터를 deserialize 하는 경우 deserialize 된 개체 그래프를 처리 하는 모든 코드는 무한 루프로 이동 하지 않고 참조 주기를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-253">If deserializing untrusted data, then any code processing the deserialized object graph needs to handle reference cycles without going into infinite loops.</span></span> <span data-ttu-id="ab285-254">여기에는 deserialization 콜백의 일부인 코드와 deserialization 완료 후 개체 그래프를 처리 하는 코드가 모두 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-254">This includes both code that's part of a deserialization callback and code that processes the object graph after deserialization completed.</span></span> <span data-ttu-id="ab285-255">그렇지 않으면 공격자가 참조 주기를 포함 하는 악성 데이터를 사용 하 여 서비스 거부 공격을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-255">Otherwise, an attacker could perform a Denial-of-Service attack with malicious data containing a reference cycle.</span></span>|
|[<span data-ttu-id="ab285-256">CA5363: 요청 유효성 검사를 사용하지 않도록 설정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-256">CA5363: Do not disable request validation</span></span>](ca5363.md)|<span data-ttu-id="ab285-257">요청 유효성 검사는 HTTP 요청을 검사 하 고 사이트 간 스크립팅을 포함 하 여 삽입 공격으로 이어질 수 있는 잠재적으로 위험한 콘텐츠가 포함 되어 있는지 여부를 확인 하는 ASP.NET의 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-257">Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content that can lead to injection attacks, including cross-site-scripting.</span></span>|
|[<span data-ttu-id="ab285-258">CA5364: 사용되지 않는 보안 프로토콜을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-258">CA5364: Do not use deprecated security protocols</span></span>](ca5364.md)|<span data-ttu-id="ab285-259">TLS (전송 계층 보안)는 일반적으로 http (하이퍼텍스트 전송 프로토콜 보안)를 사용 하는 컴퓨터 간의 통신을 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-259">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="ab285-260">이전 프로토콜 버전의 TLS는 TLS 1.2 및 TLS 1.3 보다 안전 하지 않으며 새로운 취약성이 있을 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-260">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="ab285-261">위험을 최소화 하기 위해 이전 프로토콜 버전을 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-261">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="ab285-262">CA5365: HTTP 헤더 검사를 사용하지 않도록 설정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-262">CA5365: Do Not Disable HTTP Header Checking</span></span>](ca5365.md)|<span data-ttu-id="ab285-263">HTTP 헤더 검사는 응답 헤더에 있는 캐리지 리턴 및 줄 바꿈 문자 (\r 및 \n)의 인코딩을 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-263">HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers.</span></span> <span data-ttu-id="ab285-264">이 인코딩 헤더에 포함 된 신뢰할 수 없는 데이터를 표시 하는 애플리케이션을 악용 하는 삽입 공격을 방지 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-264">This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</span></span>|
|[<span data-ttu-id="ab285-265">CA5366: 데이터 세트 읽기 XML에 XmlReader를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-265">CA5366: Use XmlReader For DataSet Read XML</span></span>](ca5366.md)|<span data-ttu-id="ab285-266">를 사용 하 여 <xref:System.Data.DataSet> 신뢰할 수 없는 데이터가 있는 XML을 읽으면 <xref:System.Xml.XmlReader> 보안 해결 프로그램을 사용 하거나 DTD 처리를 사용할 수 없는를 사용 하 여 제한 해야 하는 위험한 외부 참조가 로드 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-266">Using a <xref:System.Data.DataSet> to read XML with untrusted data may load dangerous external references, which should be restricted by using an <xref:System.Xml.XmlReader> with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="ab285-267">CA5367: 포인터 필드를 사용하여 형식을 직렬화하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-267">CA5367: Do Not Serialize Types With Pointer Fields</span></span>](ca5367.md)|<span data-ttu-id="ab285-268">이 규칙은 포인터 필드 또는 속성이 있는 serializable 클래스가 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-268">This rule checks whether there's a serializable class with a pointer field or property.</span></span> <span data-ttu-id="ab285-269">Serialize 할 수 없는 멤버는 정적 멤버 또는로 표시 된 필드와 같은 포인터 일 수 있습니다 <xref:System.NonSerializedAttribute> .</span><span class="sxs-lookup"><span data-stu-id="ab285-269">Members that can't be serialized can be a pointer, such as static members or fields marked with <xref:System.NonSerializedAttribute>.</span></span>|
|[<span data-ttu-id="ab285-270">CA5368: Page에서 파생된 클래스의 ViewStateUserKey를 설정하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-270">CA5368: Set ViewStateUserKey For Classes Derived From Page</span></span>](ca5368.md)|<span data-ttu-id="ab285-271">속성을 설정 하면 공격자가 변수를 사용 하 여 <xref:System.Web.UI.Page.ViewStateUserKey> 공격을 생성할 수 없도록 개별 사용자의 뷰 상태 변수에 식별자를 할당할 수 있으므로 응용 프로그램에 대 한 공격을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-271">Setting the <xref:System.Web.UI.Page.ViewStateUserKey> property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that attackers cannot use the variable to generate an attack.</span></span> <span data-ttu-id="ab285-272">그렇지 않으면 교차 사이트 요청 위조에 대 한 취약성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-272">Otherwise, there will be vulnerabilities to cross-site request forgery.</span></span>|
|[<span data-ttu-id="ab285-273">CA5369: 역직렬화에 XmlReader를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-273">CA5369: Use XmlReader for Deserialize</span></span>](ca5369.md)|<span data-ttu-id="ab285-274">신뢰할 수 없는 DTD 및 XML 스키마를 처리 하면 보안 해결 프로그램이 포함 된 XmlReader를 사용 하 여 제한 하거나 DTD 및 XML 인라인 스키마 처리를 사용 하지 않도록 설정 해야 하는 위험한 외부 참조를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-274">Processing untrusted DTD and XML schemas may enable loading dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="ab285-275">CA5370: 판독기 유효성 검사에 XmlReader를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-275">CA5370: Use XmlReader for validating reader</span></span>](ca5370.md)|<span data-ttu-id="ab285-276">신뢰할 수 없는 DTD 및 XML 스키마를 처리 하면 위험한 외부 참조를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-276">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="ab285-277">이 위험한 로드는 보안 해결 프로그램이 포함 된 XmlReader를 사용 하거나 DTD 및 XML 인라인 스키마 처리를 사용 하지 않도록 설정 하 여 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-277">This dangerous loading can be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span>|
|[<span data-ttu-id="ab285-278">CA5371: 스키마 읽기에 XmlReader를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-278">CA5371: Use XmlReader for schema read</span></span>](ca5371.md)|<span data-ttu-id="ab285-279">신뢰할 수 없는 DTD 및 XML 스키마를 처리 하면 위험한 외부 참조를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-279">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="ab285-280">보안 해결 프로그램을 사용 하거나 DTD 및 XML 인라인 스키마 처리를 사용 하지 않는 XmlReader를 사용 하면이이 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-280">Using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled restricts this.</span></span>|
|[<span data-ttu-id="ab285-281">CA5372: XPathDocument에 XmlReader를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-281">CA5372: Use XmlReader for XPathDocument</span></span>](ca5372.md)|<span data-ttu-id="ab285-282">신뢰할 수 없는 데이터에서 XML을 처리 하면 위험한 외부 참조가 로드 될 수 있으며,이는 보안 해결 프로그램이 포함 된 XmlReader를 사용 하 여 제한 하거나 DTD 처리를 사용 하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-282">Processing XML from untrusted data may load dangerous external references, which can be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</span></span>|
|[<span data-ttu-id="ab285-283">CA5373: 사용되지 않는 키 파생 함수를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-283">CA5373: Do not use obsolete key derivation function</span></span>](ca5373.md)|<span data-ttu-id="ab285-284">이 규칙은 약한 키 파생 메서드 및의 호출을 검색 합니다 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> `Rfc2898DeriveBytes.CryptDeriveKey` .</span><span class="sxs-lookup"><span data-stu-id="ab285-284">This rule detects the invocation of weak key derivation methods <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> and `Rfc2898DeriveBytes.CryptDeriveKey`.</span></span> <span data-ttu-id="ab285-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> 약한 알고리즘 PBKDF1을 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-285"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> used a weak algorithm PBKDF1.</span></span>|
|[<span data-ttu-id="ab285-286">CA5374: XslTransform을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-286">CA5374: Do Not Use XslTransform</span></span>](ca5374.md)|<span data-ttu-id="ab285-287">이 규칙 <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 은가 코드에서 인스턴스화되어 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-287">This rule checks if <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is instantiated in the code.</span></span> <span data-ttu-id="ab285-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> 는 이제 사용 되지 않으며 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-288"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is now obsolete and shouldn't be used.</span></span>|
|[<span data-ttu-id="ab285-289">CA5375: 계정 공유 액세스 시그니처를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-289">CA5375: Do not use account shared access signature</span></span>](ca5375.md)|<span data-ttu-id="ab285-290">계정 SAS는 서비스 SAS로 허용 되지 않는 blob 컨테이너, 테이블, 큐 및 파일 공유에 대 한 읽기, 쓰기 및 삭제 작업에 대 한 액세스를 위임할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-290">An account SAS can delegate access to read, write, and delete operations on blob containers, tables, queues, and file shares that are not permitted with a service SAS.</span></span> <span data-ttu-id="ab285-291">그러나 컨테이너 수준 정책을 지원 하지 않으며 부여 된 사용 권한에 대 한 유연성과 제어 수준이 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-291">However, it doesn't support container-level policies and has less flexibility and control over the permissions that are granted.</span></span> <span data-ttu-id="ab285-292">악의적인 사용자가이를 가져오면 저장소 계정이 쉽게 손상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-292">Once malicious users get it, your storage account will be compromised easily.</span></span>|
|[<span data-ttu-id="ab285-293">CA5376: SharedAccessProtocol HttpsOnly를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-293">CA5376: Use SharedAccessProtocol HttpsOnly</span></span>](ca5376.md)|<span data-ttu-id="ab285-294">SAS는 HTTP에서 일반 텍스트로 전송할 수 없는 중요 한 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-294">SAS is sensitive data that can't be transported in plain text on HTTP.</span></span>|
|[<span data-ttu-id="ab285-295">CA5377: 컨테이너 수준 액세스 정책을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-295">CA5377: Use container level access policy</span></span>](ca5377.md)|<span data-ttu-id="ab285-296">컨테이너 수준 액세스 정책은 언제 든 지 수정 하거나 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-296">A container-level access policy can be modified or revoked at any time.</span></span> <span data-ttu-id="ab285-297">이를 통해 부여 되는 사용 권한을 보다 유연 하 게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-297">It provides greater flexibility and control over the permissions that are granted.</span></span>|
|[<span data-ttu-id="ab285-298">CA5378: ServicePointManagerSecurityProtocols를 비활성화하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-298">CA5378: Do not disable ServicePointManagerSecurityProtocols</span></span>](ca5378.md)|<span data-ttu-id="ab285-299">`DisableUsingServicePointManagerSecurityProtocols`로 설정 `true` 하면 Windows Communication FRAMEWORK의 Tls (전송 계층 보안) 연결을 tls 1.0을 사용 하도록 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-299">Setting `DisableUsingServicePointManagerSecurityProtocols` to `true` limits Windows Communication Framework's (WCF) Transport Layer Security (TLS) connections to using TLS 1.0.</span></span> <span data-ttu-id="ab285-300">해당 버전의 TLS는 더 이상 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-300">That version of TLS will be deprecated.</span></span>|
|[<span data-ttu-id="ab285-301">CA5379: 키 파생 함수 알고리즘이 충분히 강력한 지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-301">CA5379: Ensure key derivation function algorithm is sufficiently strong</span></span>](ca5379.md)|<span data-ttu-id="ab285-302"><xref:System.Security.Cryptography.Rfc2898DeriveBytes>클래스는 기본적으로 알고리즘을 사용 <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-302">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class defaults to using the <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorithm.</span></span> <span data-ttu-id="ab285-303">이상에서 생성자의 일부 오버 로드에 사용할 해시 알고리즘을 지정 해야 합니다 <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> .</span><span class="sxs-lookup"><span data-stu-id="ab285-303">You should specify the hash algorithm to use in some overloads of the constructor with <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> or higher.</span></span> <span data-ttu-id="ab285-304">속성에는 <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> 접근자만 있으며 `get` 한정자가 없습니다 `overriden` .</span><span class="sxs-lookup"><span data-stu-id="ab285-304">Note, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> property only has a `get` accessor and doesn't have a `overriden` modifier.</span></span>|
|[<span data-ttu-id="ab285-305">CA5380: 루트 저장소에 인증서를 추가하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-305">CA5380: Do not add certificates to root store</span></span>](ca5380.md)|<span data-ttu-id="ab285-306">이 규칙은 신뢰할 수 있는 루트 인증 기관 인증서 저장소에 인증서를 추가 하는 코드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-306">This rule detects code that adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="ab285-307">기본적으로 신뢰할 수 있는 루트 인증 기관 인증서 저장소는 Microsoft 루트 인증서 프로그램의 요구 사항을 충족 하는 공용 Ca 집합을 사용 하 여 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-307">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="ab285-308">CA5381: 인증서가 루트 저장소에 추가되지 않았는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-308">CA5381: Ensure certificates are not added to root store</span></span>](ca5381.md)|<span data-ttu-id="ab285-309">이 규칙은 잠재적으로 신뢰할 수 있는 루트 인증 기관 인증서 저장소에 인증서를 추가 하는 코드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-309">This rule detects code that potentially adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="ab285-310">기본적으로 신뢰할 수 있는 루트 인증 기관 인증서 저장소는 Microsoft 루트 인증서 프로그램의 요구 사항을 충족 하는 공용 Ca (인증 기관) 집합으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-310">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public certification authorities (CAs) that has met the requirements of the Microsoft Root Certificate Program.</span></span>|
|[<span data-ttu-id="ab285-311">CA5382: ASP.NET Core에서 보안 쿠키를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-311">CA5382: Use secure cookies in ASP.NET Core</span></span>](ca5382.md)|<span data-ttu-id="ab285-312">HTTPS를 통해 사용할 수 있는 응용 프로그램은 보안 쿠키를 사용 해야 합니다 .이 쿠키는 TLS (전송 계층 보안)를 사용 하 여 쿠키를 전송 해야 함을 브라우저에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-312">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="ab285-313">CA5383: ASP.NET Core에서 보안 쿠키를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-313">CA5383: Ensure use secure cookies in ASP.NET Core</span></span>](ca5383.md)|<span data-ttu-id="ab285-314">HTTPS를 통해 사용할 수 있는 응용 프로그램은 보안 쿠키를 사용 해야 합니다 .이 쿠키는 TLS (전송 계층 보안)를 사용 하 여 쿠키를 전송 해야 함을 브라우저에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-314">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).</span></span>|
|[<span data-ttu-id="ab285-315">CA5384: DSA(디지털 시그니처 알고리즘)를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-315">CA5384: Do not use digital signature algorithm (DSA)</span></span>](ca5384.md)|<span data-ttu-id="ab285-316">DSA는 약한 비대칭 암호화 알고리즘입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-316">DSA is a weak asymmetric encryption algorithm.</span></span>|
|[<span data-ttu-id="ab285-317">CA5385: 충분한 키 크기로 RSA(Rivest–Shamir–Adleman) 알고리즘을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-317">CA5385: Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size</span></span>](ca5385.md)|<span data-ttu-id="ab285-318">2048 비트 보다 작은 RSA 키는 무차별 암호 대입 공격에 보다 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-318">An RSA key smaller than 2048 bits is more vulnerable to brute force attacks.</span></span>|
|[<span data-ttu-id="ab285-319">CA5386: SecurityProtocolType 값을 하드 코딩하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-319">CA5386: Avoid hardcoding SecurityProtocolType value</span></span>](ca5386.md)|<span data-ttu-id="ab285-320">TLS (전송 계층 보안)는 일반적으로 http (하이퍼텍스트 전송 프로토콜 보안)를 사용 하는 컴퓨터 간의 통신을 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-320">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="ab285-321">프로토콜 버전 TLS 1.0 및 TLS 1.1은 사용 되지 않지만 TLS 1.2 및 TLS 1.3은 최신 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-321">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="ab285-322">향후에는 TLS 1.2 및 TLS 1.3이 더 이상 사용 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-322">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="ab285-323">응용 프로그램의 보안을 유지 하려면 프로토콜 버전을 하드 코딩 하지 않고 .NET Framework v 4.7.1 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-323">To ensure that your application remains secure, avoid hardcoding a protocol version and target at least .NET Framework v4.7.1.</span></span>|
|[<span data-ttu-id="ab285-324">CA5387: 부족한 반복 횟수로 취약한 키 파생 함수를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-324">CA5387: Do not use weak key derivation function with insufficient iteration count</span></span>](ca5387.md)|<span data-ttu-id="ab285-325">이 규칙은 암호화 키가 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 10만 보다 작은 반복 횟수를 사용 하 여 생성 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-325">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count of less than 100,000.</span></span> <span data-ttu-id="ab285-326">반복 횟수를 높이면 생성 된 암호화 키를 추측 하려고 시도 하는 사전 공격을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-326">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="ab285-327">CA5388: 취약한 키 파생 함수를 사용할 때 충분한 반복 횟수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-327">CA5388: Ensure sufficient iteration count when using weak key derivation function</span></span>](ca5388.md)|<span data-ttu-id="ab285-328">이 규칙은 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 10만 보다 작은 반복 횟수를 사용 하 여 암호화 키가 생성 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-328">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count that may be less than 100,000.</span></span> <span data-ttu-id="ab285-329">반복 횟수를 높이면 생성 된 암호화 키를 추측 하려고 시도 하는 사전 공격을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-329">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span>|
|[<span data-ttu-id="ab285-330">CA5389: 대상 파일 시스템 경로에 보관 항목의 경로를 추가하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-330">CA5389: Do not add archive item's path to the target file system path</span></span>](ca5389.md)|<span data-ttu-id="ab285-331">파일 경로는 상대적일 수 있으며, 예상 된 파일 시스템 대상 경로 외부에서 파일 시스템에 액세스할 수 있으며,이로 인해 악의적인 구성 변경 내용 및 대기 방식 기술을 통해 원격 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-331">File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</span></span>|
|[<span data-ttu-id="ab285-332">CA5390: 암호화 키를 하드 코딩하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-332">CA5390: Do not hard-code encryption key</span></span>](ca5390.md)|<span data-ttu-id="ab285-333">대칭 알고리즘을 성공적으로 수행 하려면 비밀 키를 발신자와 수신자 에게만 인식 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-333">For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver.</span></span> <span data-ttu-id="ab285-334">키가 하드 코드 되 면 쉽게 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-334">When a key is hard-coded, it is easily discovered.</span></span> <span data-ttu-id="ab285-335">컴파일된 이진 파일의 경우에도 악의적인 사용자가 쉽게 추출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-335">Even with compiled binaries, it is easy for malicious users to extract it.</span></span> <span data-ttu-id="ab285-336">개인 키가 손상 되 면 암호화 텍스트를 직접 해독 하 여 더 이상 보호할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-336">Once the private key is compromised, the cipher text can be decrypted directly and is not protected anymore.</span></span>|
|[<span data-ttu-id="ab285-337">CA5391: ASP.NET Core MVC 컨트롤러에서 위조 방지 토큰을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-337">CA5391: Use antiforgery tokens in ASP.NET Core MVC controllers</span></span>](ca5391.md)|<span data-ttu-id="ab285-338">`POST` `PUT` `PATCH` `DELETE` 위조 방지 토큰의 유효성을 검사 하지 않고,, 또는 요청을 처리 하면 교차 사이트 요청 위조 공격에 취약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-338">Handling a `POST`, `PUT`, `PATCH`, or `DELETE` request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks.</span></span> <span data-ttu-id="ab285-339">사이트 간 요청 위조 공격은 인증 된 사용자의 악성 요청을 ASP.NET Core MVC 컨트롤러로 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-339">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</span></span>|
|[<span data-ttu-id="ab285-340">CA5392: P/Invokes에 DefaultDllImportSearchPaths 특성을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-340">CA5392: Use DefaultDllImportSearchPaths attribute for P/Invokes</span></span>](ca5392.md)|<span data-ttu-id="ab285-341">기본적으로 P/Invoke 함수는 <xref:System.Runtime.InteropServices.DllImportAttribute> 로드 하는 라이브러리에 대 한 현재 작업 디렉터리를 포함 하 여 많은 디렉터리를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-341">By default, P/Invoke functions using <xref:System.Runtime.InteropServices.DllImportAttribute> probe a number of directories, including the current working directory for the library to load.</span></span> <span data-ttu-id="ab285-342">이는 특정 응용 프로그램에 대 한 보안 문제 이며 DLL 하이재킹이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-342">This can be a security issue for certain applications, leading to DLL hijacking.</span></span>|
|[<span data-ttu-id="ab285-343">CA5393: 안전하지 않은 DllImportSearchPath 값을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-343">CA5393: Do not use unsafe DllImportSearchPath value</span></span>](ca5393.md)|<span data-ttu-id="ab285-344">기본 DLL 검색 디렉터리와 어셈블리 디렉터리에 악성 DLL이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-344">There could be a malicious DLL in the default DLL search directories and assembly directories.</span></span> <span data-ttu-id="ab285-345">또는 응용 프로그램이 실행 되는 위치에 따라 응용 프로그램 디렉터리에 악성 DLL이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-345">Or, depending on where your application is run from, there could be a malicious DLL in the application's directory.</span></span>|
|[<span data-ttu-id="ab285-346">CA5394: 안전하지 않은 임의성을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-346">CA5394: Do not use insecure randomness</span></span>](ca5394.md)|<span data-ttu-id="ab285-347">공격자는 암호화 된 약한 의사 난수 생성기를 사용 하 여 보안에 중요 한 값이 생성 되는 것을 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-347">Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated.</span></span>|
|[<span data-ttu-id="ab285-348">CA5395: 작업 메서드의 HttpVerb 특성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-348">CA5395: Miss HttpVerb attribute for action methods</span></span>](ca5395.md)|<span data-ttu-id="ab285-349">데이터를 만들거나 편집, 삭제 또는 수정 하는 모든 작업 메서드는 사이트 간 요청 위조 공격 으로부터 위조 방지 특성으로 보호 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-349">All the action methods that create, edit, delete, or otherwise modify data needs to be protected with the antiforgery attribute from cross-site request forgery attacks.</span></span> <span data-ttu-id="ab285-350">GET 작업을 수행 하는 것은 부작용이 없으며 지속형 데이터를 수정 하지 않는 안전 작업 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-350">Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</span></span>|
|[<span data-ttu-id="ab285-351">CA5396: HttpCookie에 대해 HttpOnly를 true로 설정하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-351">CA5396: Set HttpOnly to true for HttpCookie</span></span>](ca5396.md)|<span data-ttu-id="ab285-352">심층 방어 수단으로 보안에 민감한 HTTP 쿠키가 HttpOnly로 표시 되어 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-352">As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly.</span></span> <span data-ttu-id="ab285-353">이는 웹 브라우저에서 스크립트가 쿠키에 액세스 하지 못하도록 하는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-353">This indicates web browsers should disallow scripts from accessing the cookies.</span></span> <span data-ttu-id="ab285-354">삽입 된 악성 스크립트는 쿠키를 도용 하는 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-354">Injected malicious scripts are a common way of stealing cookies.</span></span>|
|[<span data-ttu-id="ab285-355">CA5397: 사용되지 않는 SslProtocols 값을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-355">CA5397: Do not use deprecated SslProtocols values</span></span>](ca5397.md)|<span data-ttu-id="ab285-356">TLS (전송 계층 보안)는 일반적으로 http (하이퍼텍스트 전송 프로토콜 보안)를 사용 하는 컴퓨터 간의 통신을 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-356">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="ab285-357">이전 프로토콜 버전의 TLS는 TLS 1.2 및 TLS 1.3 보다 안전 하지 않으며 새로운 취약성이 있을 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-357">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="ab285-358">위험을 최소화 하기 위해 이전 프로토콜 버전을 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-358">Avoid older protocol versions to minimize risk.</span></span>|
|[<span data-ttu-id="ab285-359">CA5398: SslProtocols 값을 하드 코딩하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-359">CA5398: Avoid hardcoded SslProtocols values</span></span>](ca5398.md)|<span data-ttu-id="ab285-360">TLS (전송 계층 보안)는 일반적으로 http (하이퍼텍스트 전송 프로토콜 보안)를 사용 하는 컴퓨터 간의 통신을 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-360">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="ab285-361">프로토콜 버전 TLS 1.0 및 TLS 1.1은 사용 되지 않지만 TLS 1.2 및 TLS 1.3은 최신 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-361">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="ab285-362">향후에는 TLS 1.2 및 TLS 1.3이 더 이상 사용 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-362">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="ab285-363">응용 프로그램이 안전 하 게 유지 되도록 하려면 프로토콜 버전을 하드 코딩 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ab285-363">To ensure that your application remains secure, avoid hardcoding a protocol version.</span></span>|
|[<span data-ttu-id="ab285-364">CA5399: HttpClient 인증서 해지 목록 확인을 사용하지 않도록 명시적으로 설정하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-364">CA5399: Definitely disable HttpClient certificate revocation list check</span></span>](ca5399.md)|<span data-ttu-id="ab285-365">해지 된 인증서를 더 이상 신뢰할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-365">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="ab285-366">공격자는 악성 데이터를 전달 하거나 HTTPS 통신에서 중요 한 데이터를 도용 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-366">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="ab285-367">CA5400: HttpClient 인증서 해지 목록 확인을 사용할 수 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-367">CA5400: Ensure HttpClient certificate revocation list check is not disabled</span></span>](ca5400.md)|<span data-ttu-id="ab285-368">해지 된 인증서를 더 이상 신뢰할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-368">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="ab285-369">공격자는 악성 데이터를 전달 하거나 HTTPS 통신에서 중요 한 데이터를 도용 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-369">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span>|
|[<span data-ttu-id="ab285-370">CA5401: 기본이 아닌 IV와 함께 CreateEncryptor를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-370">CA5401: Do not use CreateEncryptor with non-default IV</span></span>](ca5401.md)|<span data-ttu-id="ab285-371">대칭 암호화는 항상 반복 되지 않는 초기화 벡터를 사용 하 여 사전 공격을 방지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-371">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="ab285-372">CA5402: 기본 IV와 함께 CreateEncryptor를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="ab285-372">CA5402: Use CreateEncryptor with the default IV</span></span>](ca5402.md)|<span data-ttu-id="ab285-373">대칭 암호화는 항상 반복 되지 않는 초기화 벡터를 사용 하 여 사전 공격을 방지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-373">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span>|
|[<span data-ttu-id="ab285-374">CA5403: 인증서 하드 코딩 안 함</span><span class="sxs-lookup"><span data-stu-id="ab285-374">CA5403: Do not hard-code certificate</span></span>](ca5403.md)|<span data-ttu-id="ab285-375">`data` `rawData` 또는 생성자의 또는 매개 변수는 <xref:System.Security.Cryptography.X509Certificates.X509Certificate> <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> 하드 코드 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab285-375">The `data` or `rawData` parameter of a <xref:System.Security.Cryptography.X509Certificates.X509Certificate> or <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> constructor is hard-coded.</span></span>|
