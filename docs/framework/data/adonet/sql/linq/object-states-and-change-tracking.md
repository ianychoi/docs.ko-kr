---
description: '자세한 정보: 개체 상태 및 Change-Tracking'
title: 개체 상태 및 변경 내용 추적
ms.date: 03/30/2017
ms.assetid: 7a808b00-9c3c-479a-aa94-717280fefd71
ms.openlocfilehash: 5f3aa6197fa44d8b5ea9333c85255202cbfe519b
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99695504"
---
# <a name="object-states-and-change-tracking"></a><span data-ttu-id="d4c1f-103">개체 상태 및 변경 내용 추적</span><span class="sxs-lookup"><span data-stu-id="d4c1f-103">Object States and Change-Tracking</span></span>

[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="d4c1f-104">개체는 항상 특정 *상태* 에 참여 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-104">objects always participate in some *state*.</span></span> <span data-ttu-id="d4c1f-105">예를 들어, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]에서 새 개체를 만들 경우 개체는 `Unchanged` 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-105">For example, when [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] creates a new object, the object is in `Unchanged` state.</span></span> <span data-ttu-id="d4c1f-106">직접 만든 새 개체는 <xref:System.Data.Linq.DataContext>에 알려져 있지 않으며 `Untracked` 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-106">A new object that you yourself create is unknown to the <xref:System.Data.Linq.DataContext> and is in `Untracked` state.</span></span> <span data-ttu-id="d4c1f-107"><xref:System.Data.Linq.DataContext.SubmitChanges%2A>를 실행하고 나면 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]에 알려진 모든 개체는 `Unchanged` 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-107">Following successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, all objects known to [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] are in `Unchanged` state.</span></span> <span data-ttu-id="d4c1f-108">유일한 예외는 데이터베이스에서 삭제된 개체로 이러한 개체는 `Deleted` 상태이고 해당 <xref:System.Data.Linq.DataContext> 인스턴스에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-108">(The single exception is represented by those that have been successfully deleted from the database, which are in `Deleted` state and unusable in that <xref:System.Data.Linq.DataContext> instance.)</span></span>

## <a name="object-states"></a><span data-ttu-id="d4c1f-109">개체 상태</span><span class="sxs-lookup"><span data-stu-id="d4c1f-109">Object States</span></span>

<span data-ttu-id="d4c1f-110">다음 표에서는 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 개체의 가능한 상태를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-110">The following table lists the possible states for [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] objects.</span></span>

|<span data-ttu-id="d4c1f-111">시스템 상태</span><span class="sxs-lookup"><span data-stu-id="d4c1f-111">State</span></span>|<span data-ttu-id="d4c1f-112">설명</span><span class="sxs-lookup"><span data-stu-id="d4c1f-112">Description</span></span>|
|-----------|-----------------|
|`Untracked`|<span data-ttu-id="d4c1f-113">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]에 의해 추적되지 않는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-113">An object not tracked by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span> <span data-ttu-id="d4c1f-114">이러한 데이터의 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-114">Examples include the following:</span></span><br /><br /> <span data-ttu-id="d4c1f-115">-새로 만든 개체와 같이 현재을 통해 쿼리하지 않는 개체 <xref:System.Data.Linq.DataContext> 입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-115">-   An object not queried through the current <xref:System.Data.Linq.DataContext> (such as a newly created object).</span></span><br /><span data-ttu-id="d4c1f-116">-Deserialization을 통해 만든 개체</span><span class="sxs-lookup"><span data-stu-id="d4c1f-116">-   An object created through deserialization</span></span><br /><span data-ttu-id="d4c1f-117">-다른를 통해 쿼리 되는 개체 <xref:System.Data.Linq.DataContext> 입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-117">-   An object queried through a different <xref:System.Data.Linq.DataContext>.</span></span>|
|`Unchanged`|<span data-ttu-id="d4c1f-118">현재 <xref:System.Data.Linq.DataContext>를 사용하여 검색되었으며 만들어진 이후 수정된 것으로 알려지지 않은 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-118">An object retrieved by using the current <xref:System.Data.Linq.DataContext> and not known to have been modified since it was created.</span></span>|
|`PossiblyModified`|<span data-ttu-id="d4c1f-119">에 *연결* 된 개체입니다 <xref:System.Data.Linq.DataContext> .</span><span class="sxs-lookup"><span data-stu-id="d4c1f-119">An object which is *attached* to a <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="d4c1f-120">자세한 내용은 [데이터 검색 및 CUD 작업에서 N 계층 애플리케이션 (LINQ to SQL)](data-retrieval-and-cud-operations-in-n-tier-applications.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-120">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>|
|`ToBeInserted`|<span data-ttu-id="d4c1f-121">현재 <xref:System.Data.Linq.DataContext>를 사용하여 검색되지 않은 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-121">An object not retrieved by using the current <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="d4c1f-122">이로 인해 `INSERT` 동안 데이터베이스에 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-122">This causes a database `INSERT` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|
|`ToBeUpdated`|<span data-ttu-id="d4c1f-123">검색된 이후로 수정되었다는 것이 알려진 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-123">An object known to have been modified since it was retrieved.</span></span> <span data-ttu-id="d4c1f-124">이로 인해 `UPDATE` 동안 데이터베이스에 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-124">This causes a database `UPDATE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|
|`ToBeDeleted`|<span data-ttu-id="d4c1f-125">삭제되도록 표시된 개체이며 이로 인해 `DELETE` 동안 데이터베이스에 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-125">An object marked for deletion, causing a database `DELETE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|
|`Deleted`|<span data-ttu-id="d4c1f-126">데이터베이스에서 삭제된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-126">An object that has been deleted in the database.</span></span> <span data-ttu-id="d4c1f-127">이 상태는 최종 상태이며 더 이상의 전환은 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-127">This state is final and does not allow for additional transitions.</span></span>|

## <a name="inserting-objects"></a><span data-ttu-id="d4c1f-128">개체 삽입</span><span class="sxs-lookup"><span data-stu-id="d4c1f-128">Inserting Objects</span></span>

<span data-ttu-id="d4c1f-129">`Inserts`을 사용하여 <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>를 명시적으로 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-129">You can explicitly request `Inserts` by using <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.</span></span> <span data-ttu-id="d4c1f-130">또는 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]에서는 업데이트해야 하는 알려진 개체 중 하나에 연결된 개체를 찾아 `Inserts`를 유추할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-130">Alternatively, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] can infer `Inserts` by finding objects connected to one of the known objects that must be updated.</span></span> <span data-ttu-id="d4c1f-131">예를 들어 `Untracked` 개체를 <xref:System.Data.Linq.EntitySet%601>에 추가하거나 <xref:System.Data.Linq.EntityRef%601>을 `Untracked` 개체로 설정할 경우 그래프에서 추적된 개체를 통해 `Untracked` 개체에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-131">For example, if you add an `Untracked` object to an <xref:System.Data.Linq.EntitySet%601> or set an <xref:System.Data.Linq.EntityRef%601> to an `Untracked` object, you make the `Untracked` object reachable by way of tracked objects in the graph.</span></span> <span data-ttu-id="d4c1f-132"><xref:System.Data.Linq.DataContext.SubmitChanges%2A>를 처리하는 동안 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]은 추적된 개체를 순회하면서 추적되지 않는 도달 가능한 모든 영구 개체를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-132">While processing <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] traverses the tracked objects and discovers any reachable persistent objects that are not tracked.</span></span> <span data-ttu-id="d4c1f-133">이러한 개체는 데이터베이스에 삽입할 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-133">Such objects are candidates for insertion into the database.</span></span>

<span data-ttu-id="d4c1f-134">상속 계층 구조에 있는 클래스의 경우 <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> ( `o` )도 개체 형식과 일치 하도록 *판별자* 로 지정 된 멤버의 값을 설정 합니다 `o` .</span><span class="sxs-lookup"><span data-stu-id="d4c1f-134">For classes in an inheritance hierarchy, <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>(`o`) also sets the value of the member designated as the *discriminator* to match the type of the object `o`.</span></span> <span data-ttu-id="d4c1f-135">기본 판별자 값과 일치하는 형식의 경우 이 작업이 수행되면 판별자 값을 기본값이 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-135">In the case of a type matching the default discriminator value, this action causes the discriminator value to be overwritten with the default value.</span></span> <span data-ttu-id="d4c1f-136">자세한 내용은 [상속 지원](inheritance-support.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-136">For more information, see [Inheritance Support](inheritance-support.md).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d4c1f-137">`Table`에 추가된 개체는 ID 캐시에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-137">An object added to a `Table` is not in the identity cache.</span></span> <span data-ttu-id="d4c1f-138">ID 캐시는 데이터베이스에서 검색된 개체만 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-138">The identity cache reflects only what is retrieved from the database.</span></span> <span data-ttu-id="d4c1f-139"><xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> 호출 이후 <xref:System.Data.Linq.DataContext.SubmitChanges%2A>가 완료될 때까지 추가된 엔터티는 데이터베이스에 대한 쿼리에 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-139">After a call to <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>, the added entity does not appear in queries against the database until <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is successfully completed.</span></span>

## <a name="deleting-objects"></a><span data-ttu-id="d4c1f-140">개체 삭제</span><span class="sxs-lookup"><span data-stu-id="d4c1f-140">Deleting Objects</span></span>

<span data-ttu-id="d4c1f-141">적절한 `o`에서 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o)을 호출하여 추적된 개체 <xref:System.Data.Linq.Table%601>를 삭제 대상으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-141">You mark a tracked object `o` for deletion by calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o) on the appropriate <xref:System.Data.Linq.Table%601>.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d4c1f-142">은 <xref:System.Data.Linq.EntitySet%601>에서 개체를 제거하는 것을 업데이트 작업으로 간주하며 해당 외래 키 값이 null로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-142">considers the removal of an object from an <xref:System.Data.Linq.EntitySet%601> as an update operation, and the corresponding foreign key value is set to null.</span></span> <span data-ttu-id="d4c1f-143">작업의 대상(`o`)은 해당 테이블에서 삭제되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-143">The target of the operation (`o`) is not deleted from its table.</span></span> <span data-ttu-id="d4c1f-144">예를 들어, `cust.Orders.DeleteOnSubmit(ord)`는 외래 키 `cust`를 null로 설정하여 `ord` 및 `ord.CustomerID` 간의 관계를 끊는 업데이트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-144">For example, `cust.Orders.DeleteOnSubmit(ord)` indicates an update where the relationship between `cust` and `ord` is severed by setting the foreign key `ord.CustomerID` to null.</span></span> <span data-ttu-id="d4c1f-145">이로 인해 `ord`에 해당하는 행이 삭제되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-145">It does not cause the deletion of the row corresponding to `ord`.</span></span>

[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]<span data-ttu-id="d4c1f-146">은 개체가 해당 테이블에서 삭제될 때(<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>) 다음 작업을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-146">performs the following processing when an object is deleted (<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>) from its table:</span></span>

- <span data-ttu-id="d4c1f-147"><xref:System.Data.Linq.DataContext.SubmitChanges%2A>가 호출될 경우 `DELETE` 작업이 해당 개체에 대해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-147">When <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called, a `DELETE` operation is performed for that object.</span></span>

- <span data-ttu-id="d4c1f-148">관련 개체가 로드되었는지 여부에 상관없이 제거는 관련 개체에 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-148">The removal is not propagated to related objects regardless of whether they are loaded.</span></span> <span data-ttu-id="d4c1f-149">특히 관계 속성을 업데이트하기 위해 관련 개체가 로드되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-149">Specifically, related objects are not loaded for updating the relationship property.</span></span>

- <span data-ttu-id="d4c1f-150"><xref:System.Data.Linq.DataContext.SubmitChanges%2A>가 실행된 후 개체는 `Deleted` 상태로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-150">After successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, the objects are set to the `Deleted` state.</span></span> <span data-ttu-id="d4c1f-151">결과적으로 해당 `id`에서 개체나 개체의 <xref:System.Data.Linq.DataContext>를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-151">As a result, you cannot use the object or its `id` in that <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="d4c1f-152"><xref:System.Data.Linq.DataContext> 인스턴스에 의해 유지 관리되는 내부 캐시는 개체가 데이터베이스에서 삭제된 이후에도 검색되거나 새로 추가되는 개체를 제거하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-152">The internal cache maintained by a <xref:System.Data.Linq.DataContext> instance does not eliminate objects that are retrieved or added as new, even after the objects have been deleted in the database.</span></span>

<span data-ttu-id="d4c1f-153"><xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>에 의해 추적되는 개체에서만 <xref:System.Data.Linq.DataContext>을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-153">You can call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> only on an object tracked by the <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="d4c1f-154">`Untracked` 개체의 경우 <xref:System.Data.Linq.Table%601.Attach%2A>을 호출하기 전에 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-154">For an `Untracked` object, you must call <xref:System.Data.Linq.Table%601.Attach%2A> before you call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.</span></span> <span data-ttu-id="d4c1f-155"><xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> 개체에서 `Untracked`를 호출하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-155">Calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> on an `Untracked` object throws an exception.</span></span>

> [!NOTE]
> <span data-ttu-id="d4c1f-156">테이블에서 개체를 제거하면 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]은 `DELETE` 시점에 해당 SQL <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 명령을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-156">Removing an object from a table tells [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] to generate a corresponding SQL `DELETE` command at the time of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="d4c1f-157">이 작업으로 인해 캐시에서 개체가 제거되거나 관련된 개체에 삭제가 전파되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-157">This action does not remove the object from the cache or propagate the deletion to related objects.</span></span>
>
> <span data-ttu-id="d4c1f-158">삭제된 개체의 `id`를 회수하려면 새 <xref:System.Data.Linq.DataContext> 인스턴스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-158">To reclaim the `id` of a deleted object, use a new <xref:System.Data.Linq.DataContext> instance.</span></span> <span data-ttu-id="d4c1f-159">관련 개체를 정리 하기 위해 데이터베이스의 *cascade delete* 기능을 사용 하거나 관련 개체를 수동으로 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-159">For cleanup of related objects, you can use the *cascade delete* feature of the database, or else manually delete the related objects.</span></span>
>
> <span data-ttu-id="d4c1f-160">데이터베이스에서와 달리 관련 개체를 특정 순서로 삭제할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-160">The related objects do not have to be deleted in any special order (unlike in the database).</span></span>

## <a name="updating-objects"></a><span data-ttu-id="d4c1f-161">개체 업데이트</span><span class="sxs-lookup"><span data-stu-id="d4c1f-161">Updating Objects</span></span>

<span data-ttu-id="d4c1f-162">변경 내용에 대한 알림을 확인하여 `Updates`를 감지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-162">You can detect `Updates` by observing notifications of changes.</span></span> <span data-ttu-id="d4c1f-163">알림은 속성 setter의 <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> 이벤트를 통해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-163">Notifications are provided through the <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> event in property setters.</span></span> <span data-ttu-id="d4c1f-164">개체에 대한 첫 번째 변경 내용이 알려질 경우 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]은 개체의 복사본을 만들고 `Update` 문 생성을 위한 후보로 개체를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-164">When [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is notified of the first change to an object, it creates a copy of the object and considers the object a candidate for generating an `Update` statement.</span></span>

<span data-ttu-id="d4c1f-165"><xref:System.ComponentModel.INotifyPropertyChanging>을 구현하지 않는 개체의 경우 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]은 개체가 처음 구체화될 때 갖고 있던 값의 복사본을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-165">For objects that do not implement <xref:System.ComponentModel.INotifyPropertyChanging>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] maintains a copy of the values that objects had when they were first materialized.</span></span> <span data-ttu-id="d4c1f-166"><xref:System.Data.Linq.DataContext.SubmitChanges%2A>가 호출되면 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]은 현재 값과 원래 값을 비교하여 개체가 변경되었는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-166">When you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] compares the current and original values to decide whether the object has been changed.</span></span>

<span data-ttu-id="d4c1f-167">관계 업데이트의 경우 자식에서 부모로의 참조(즉, 외래 키에 해당하는 참조)가 우선권을 가집니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-167">For updates to relationships, the reference from the child to the parent (that is, the reference corresponding to the foreign key) is considered the authority.</span></span> <span data-ttu-id="d4c1f-168">반대 방향의 참조(즉, 부모에서 자식으로의 참조)는 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-168">The reference in the reverse direction (that is, from parent to child) is optional.</span></span> <span data-ttu-id="d4c1f-169">관계 클래스(<xref:System.Data.Linq.EntitySet%601> 및 <xref:System.Data.Linq.EntityRef%601>)는 일대다 및 일대일 관계에서 양방향 참조가 일관되도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-169">Relationship classes (<xref:System.Data.Linq.EntitySet%601> and <xref:System.Data.Linq.EntityRef%601>) guarantee that the bidirectional references are consistent for one-to-many and one-to-one relationships.</span></span> <span data-ttu-id="d4c1f-170">개체 모델에 <xref:System.Data.Linq.EntitySet%601> 또는 <xref:System.Data.Linq.EntityRef%601>가 사용되지 않는 상태에서 역방향 참조가 존재할 경우 관계 업데이트 시에 역방향 참조와 정방향 참조의 일관성을 유지하는 작업을 직접 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-170">If the object model does not use <xref:System.Data.Linq.EntitySet%601> or <xref:System.Data.Linq.EntityRef%601>, and if the reverse reference is present, it is your responsibility to keep it consistent with the forward reference when the relationship is updated.</span></span>

<span data-ttu-id="d4c1f-171">필수 참조와 해당 외래 키를 둘 다 업데이트할 경우 서로 일치하는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-171">If you update both the required reference and the corresponding foreign key, you must make sure that they agree.</span></span> <span data-ttu-id="d4c1f-172"><xref:System.InvalidOperationException>를 호출할 때 두 항목이 동기화되지 않은 경우 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-172">An <xref:System.InvalidOperationException> exception is thrown if the two are not synchronized at the time that you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="d4c1f-173">외래 키 값 변경을 통해 기본 행 업데이트에 충분히 영향을 줄 수 있지만 개체 그래프의 연결과 관계의 양방향 일관성을 유지 관리하기 위해 참조를 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4c1f-173">Although foreign key value changes are sufficient for affecting an update of the underlying row, you should change the reference to maintain connectivity of the object graph and bidirectional consistency of relationships.</span></span>

## <a name="see-also"></a><span data-ttu-id="d4c1f-174">참고 항목</span><span class="sxs-lookup"><span data-stu-id="d4c1f-174">See also</span></span>

- [<span data-ttu-id="d4c1f-175">배경 정보</span><span class="sxs-lookup"><span data-stu-id="d4c1f-175">Background Information</span></span>](background-information.md)
- [<span data-ttu-id="d4c1f-176">삽입, 업데이트 및 삭제 작업</span><span class="sxs-lookup"><span data-stu-id="d4c1f-176">Insert, Update, and Delete Operations</span></span>](insert-update-and-delete-operations.md)
