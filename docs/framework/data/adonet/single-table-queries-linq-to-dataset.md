---
description: '다음에 대 한 자세한 정보: Single-Table 쿼리 (LINQ to DataSet)'
title: 단일 클래스 쿼리(LINQ to DataSet)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 0b74bcf8-3f87-449f-bff7-6bcb0d69d212
ms.openlocfilehash: a4b6ce2a60eeafc9221d838d1b86c9964774df60
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99718761"
---
# <a name="single-table-queries-linq-to-dataset"></a><span data-ttu-id="0fec7-103">단일 클래스 쿼리(LINQ to DataSet)</span><span class="sxs-lookup"><span data-stu-id="0fec7-103">Single-Table Queries (LINQ to DataSet)</span></span>

<span data-ttu-id="0fec7-104">LINQ (Language-Integrated Query) 쿼리는 인터페이스 또는 인터페이스를 구현 하는 데이터 소스에서 작동 <xref:System.Collections.Generic.IEnumerable%601> <xref:System.Linq.IQueryable%601> 합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-104">Language-Integrated Query (LINQ) queries work on data sources that implement the <xref:System.Collections.Generic.IEnumerable%601> interface or the <xref:System.Linq.IQueryable%601> interface.</span></span> <span data-ttu-id="0fec7-105"><xref:System.Data.DataTable>클래스는 두 인터페이스를 모두 구현 하지 않으므로 <xref:System.Data.DataTableExtensions.AsEnumerable%2A> <xref:System.Data.DataTable> LINQ 쿼리의 절에서를 소스로 사용 하려면 메서드를 호출 해야 합니다 `From` .</span><span class="sxs-lookup"><span data-stu-id="0fec7-105">The <xref:System.Data.DataTable> class does not implement either interface, so you must call the <xref:System.Data.DataTableExtensions.AsEnumerable%2A> method if you want to use the <xref:System.Data.DataTable> as a source in the `From` clause of a LINQ query.</span></span>  
  
 <span data-ttu-id="0fec7-106">다음 예제에서는 SalesOrderHeader 테이블에서 모든 온라인 주문을 가져와서 주문 ID, 주문 날짜 및 주문 번호를 콘솔에 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-106">The following example gets all the online orders from the SalesOrderHeader table and outputs the order ID, order date, and order number to the console.</span></span>  
  
 [!code-csharp[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/CS/Program.cs#where1)]  
 [!code-vb[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/VB/Module1.vb#where1)]
  
 <span data-ttu-id="0fec7-107">지역 변수 쿼리는 표준 쿼리 연산자에서 하나 이상의 쿼리 연산자를 적용 하 여 하나 이상의 정보 소스에 대해 작동 하는 쿼리 식으로 초기화 되 고, LINQ to DataSet의 경우에는 클래스에만 적용 되는 연산자입니다 <xref:System.Data.DataSet> .</span><span class="sxs-lookup"><span data-stu-id="0fec7-107">The local variable query is initialized with a query expression, which operates on one or more information sources by applying one or more query operators from either the standard query operators or, in the case of LINQ to DataSet, operators specific to the <xref:System.Data.DataSet> class.</span></span> <span data-ttu-id="0fec7-108">이전 예제의 쿼리 식에서는 두 개의 표준 쿼리 연산자인 `Where`와 `Select`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-108">The query expression in the previous example uses two of the standard query operators: `Where` and `Select`.</span></span>  
  
 <span data-ttu-id="0fec7-109">`Where` 절에서는 조건을 기준으로 시퀀스를 필터링하며, 이 경우에는 `OnlineOrderFlag`가 `true`로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-109">The `Where` clause filters the sequence based on a condition, in this case that the `OnlineOrderFlag` is set to `true`.</span></span> <span data-ttu-id="0fec7-110">`Select` 연산자는 연산자로 전달된 인수를 캡처하는 열거 가능한 개체를 할당하고 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-110">The `Select` operator allocates and returns an enumerable object that captures the arguments passed to the operator.</span></span> <span data-ttu-id="0fec7-111">위 예제에서는 세 개의 `SalesOrderID`, `OrderDate` 및 `SalesOrderNumber` 속성을 가진 익명 형식이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-111">In this above example, an anonymous type is created with three properties: `SalesOrderID`, `OrderDate`, and `SalesOrderNumber`.</span></span> <span data-ttu-id="0fec7-112">이러한 세 속성의 값은 `SalesOrderID` 테이블에 있는 `OrderDate`, `SalesOrderNumber` 및 `SalesOrderHeader` 열의 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-112">The values of these three properties are set to the values of the `SalesOrderID`, `OrderDate`, and `SalesOrderNumber` columns from the `SalesOrderHeader` table.</span></span>  
  
 <span data-ttu-id="0fec7-113">그런 다음 `foreach` 루프에서는 `Select`에서 반환된 열거 가능한 개체를 열거하고 쿼리 결과를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-113">The `foreach` loop then enumerates the enumerable object returned by `Select` and yields the query results.</span></span> <span data-ttu-id="0fec7-114">쿼리는 <xref:System.Linq.Enumerable>을 구현하는 <xref:System.Collections.Generic.IEnumerable%601> 형식이므로 `foreach` 루프를 사용하는 동안 쿼리 변수가 반복될 때까지 쿼리에 대한 계산이 지연됩니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-114">Because query is an <xref:System.Linq.Enumerable> type, which implements <xref:System.Collections.Generic.IEnumerable%601>, the evaluation of the query is deferred until the query variable is iterated over using the `foreach` loop.</span></span> <span data-ttu-id="0fec7-115">쿼리 계산이 지연되면 여러 차례 계산할 수 있으면서 계산할 때마다 다른 결과가 나올 수 있는 값으로 쿼리를 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-115">Deferred query evaluation allows queries to be kept as values that can be evaluated multiple times, each time yielding potentially different results.</span></span>  
  
 <span data-ttu-id="0fec7-116"><xref:System.Data.DataRowExtensions.Field%2A> 메서드는 <xref:System.Data.DataRow>의 열 값에 대한 액세스를 제공하며 이전 예제에서 나오지 않은 <xref:System.Data.DataRowExtensions.SetField%2A>는 <xref:System.Data.DataRow>의 열 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-116">The <xref:System.Data.DataRowExtensions.Field%2A> method provides access to the column values of a <xref:System.Data.DataRow> and the <xref:System.Data.DataRowExtensions.SetField%2A> (not shown in the previous example) sets column values in a <xref:System.Data.DataRow>.</span></span> <span data-ttu-id="0fec7-117"><xref:System.Data.DataRowExtensions.Field%2A>메서드와 메서드는 모두 <xref:System.Data.DataRowExtensions.SetField%2A> nullable 값 형식을 처리 하므로 null 값을 명시적으로 확인할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-117">Both the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method handle nullable value types, so you do not have to explicitly check for null values.</span></span> <span data-ttu-id="0fec7-118">또한 두 메서드 모두 제네릭 메서드이므로 반환 형식을 캐스팅하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-118">Both methods are generic methods, also, which means you do not have to cast the return type.</span></span> <span data-ttu-id="0fec7-119"><xref:System.Data.DataRow>의 기존 열 접근자(예: `o["OrderDate"]`)를 사용할 수도 있지만 그렇게 하려면 반환 개체를 적절한 형식으로 캐스팅해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-119">You could use the pre-existing column accessor in <xref:System.Data.DataRow> (for example, `o["OrderDate"]`), but doing so would require you to cast the return object to the appropriate type.</span></span>  <span data-ttu-id="0fec7-120">열이 nullable 값 형식인 경우 메서드를 사용 하 여 값이 null 인지 확인 해야 합니다 <xref:System.Data.DataRow.IsNull%2A> .</span><span class="sxs-lookup"><span data-stu-id="0fec7-120">If the column is a nullable value type you have to check if the value is null by using the <xref:System.Data.DataRow.IsNull%2A> method.</span></span> <span data-ttu-id="0fec7-121">자세한 내용은 [제네릭 Field 및 SetField 메서드](generic-field-and-setfield-methods-linq-to-dataset.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-121">For more information, see [Generic Field and SetField Methods](generic-field-and-setfield-methods-linq-to-dataset.md).</span></span>  
  
 <span data-ttu-id="0fec7-122">`T` 메서드 및 <xref:System.Data.DataRowExtensions.Field%2A> 메서드의 제네릭 매개 변수 <xref:System.Data.DataRowExtensions.SetField%2A>에 지정된 데이터 형식은 내부 값의 형식과 일치해야 하며, 그렇지 않으면 <xref:System.InvalidCastException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-122">Note that the data type specified in the generic parameter `T` of the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method must match the type of the underlying value or an <xref:System.InvalidCastException> will be thrown.</span></span> <span data-ttu-id="0fec7-123">지정된 열 이름도 <xref:System.Data.DataSet>의 열 이름과 일치해야 하며, 그렇지 않으면 <xref:System.ArgumentException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-123">The specified column name must also match the name of a column in the <xref:System.Data.DataSet> or an <xref:System.ArgumentException> will be thrown.</span></span> <span data-ttu-id="0fec7-124">두 경우 모두 쿼리가 실행되는 런타임에 데이터 열거형에서 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="0fec7-124">In both cases, the exception is thrown at run time data enumeration when the query is executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0fec7-125">참고 항목</span><span class="sxs-lookup"><span data-stu-id="0fec7-125">See also</span></span>

- [<span data-ttu-id="0fec7-126">크로스 테이블 쿼리</span><span class="sxs-lookup"><span data-stu-id="0fec7-126">Cross-Table Queries</span></span>](cross-table-queries-linq-to-dataset.md)
- [<span data-ttu-id="0fec7-127">형식화된 데이터 세트 쿼리</span><span class="sxs-lookup"><span data-stu-id="0fec7-127">Querying Typed DataSets</span></span>](querying-typed-datasets.md)
- [<span data-ttu-id="0fec7-128">제네릭 필드 및 SetField 메서드</span><span class="sxs-lookup"><span data-stu-id="0fec7-128">Generic Field and SetField Methods</span></span>](generic-field-and-setfield-methods-linq-to-dataset.md)
