---
description: .NET 네이티브 및 컴파일에 대해 자세히 알아보세요.
title: .NET 네이티브 및 컴파일
ms.date: 03/30/2017
ms.assetid: e38ae4f3-3e3d-42c3-a4b8-db1aa9d84f85
ms.openlocfilehash: 1a847340f48d97eb255869895f9a5b963e45e8ab
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99738561"
---
# <a name="net-native-and-compilation"></a><span data-ttu-id="3bddd-103">.NET 네이티브 및 컴파일</span><span class="sxs-lookup"><span data-stu-id="3bddd-103">.NET Native and Compilation</span></span>

<span data-ttu-id="3bddd-104">.NET Framework를 대상으로 지정하는 Windows 8.1 애플리케이션과 Windows 데스크톱 애플리케이션은 특정 프로그래밍 언어로 작성되고 IL(중간 언어)로 컴파일됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-104">Windows 8.1 applications and Windows Desktop applications that target the.NET Framework are written in a particular programming language and compiled into intermediate language (IL).</span></span> <span data-ttu-id="3bddd-105">런타임에 JIT(Just-In-Time) 컴파일러는 메서드가 처음 실행되기 바로 전에 로컬 컴퓨터에 대한 네이티브 코드로 IL을 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-105">At runtime, a just-in-time (JIT) compiler is responsible for compiling the IL into native code for the local machine just before a method is executed for the first time.</span></span> <span data-ttu-id="3bddd-106">반대로 .NET 네이티브 도구 체인은 컴파일 타임에 소스 코드를 네이티브 코드로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-106">In contrast, the .NET Native tool chain converts source code to native code at compile time.</span></span> <span data-ttu-id="3bddd-107">이 항목에서는 .NET Framework 앱에 사용할 수 있는 다른 컴파일 기술과 .NET 네이티브를 비교하고 .NET 네이티브로 컴파일된 코드에서 발생하는 예외가 JIT로 컴파일된 코드에서 발생하지 않는 이유를 이해하는 데 도움이 될 수 있는 네이티브 코드를 .NET 네이티브에서 생성하는 방법에 대한 실제적인 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-107">This topic compares .NET Native with other compilation technologies available for .NET Framework apps, and also provides a practical overview of how .NET Native produces native code that can help you understand why exceptions that occur in code compiled with .NET Native do not occur in JIT-compiled code.</span></span>

## <a name="net-native-generating-native-binaries"></a><span data-ttu-id="3bddd-108">.NET 네이티브: 네이티브 이진 파일 생성</span><span class="sxs-lookup"><span data-stu-id="3bddd-108">.NET Native: Generating native binaries</span></span>

<span data-ttu-id="3bddd-109">.NET Framework를 대상으로 지정하고 .NET 네이티브 도구 체인으로 컴파일되지 않은 애플리케이션은 다음이 포함된 애플리케이션 어셈블리로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-109">An application that targets the .NET Framework and that is not compiled by using the .NET Native tool chain consists of your application assembly, which includes the following:</span></span>

- <span data-ttu-id="3bddd-110">어셈블리, 해당 종속성, 포함된 형식, 해당 멤버를 설명하는 [메타데이터](../../standard/metadata-and-self-describing-components.md).</span><span class="sxs-lookup"><span data-stu-id="3bddd-110">[Metadata](../../standard/metadata-and-self-describing-components.md) that describes the assembly, its dependencies, the types it contains, and their members.</span></span> <span data-ttu-id="3bddd-111">메타데이터는 리플렉션 및 런타임에 바인딩된 액세스에 사용되고 때때로 컴파일러 및 빌드 도구에서도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-111">The metadata is used for reflection and late-bound access, and in some cases by compiler and build tools as well.</span></span>

- <span data-ttu-id="3bddd-112">구현 코드.</span><span class="sxs-lookup"><span data-stu-id="3bddd-112">Implementation code.</span></span> <span data-ttu-id="3bddd-113">IL(중간 언어) opcodes로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-113">This consists of intermediate language (IL) opcodes.</span></span> <span data-ttu-id="3bddd-114">런타임에 JIT(Just-In-Time) 컴파일러가 이 코드를 대상 플랫폼에 대한 네이티브 코드로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-114">At runtime, the just-in-time (JIT) compiler translates it into native code for the target platform.</span></span>

 <span data-ttu-id="3bddd-115">주 애플리케이션 어셈블리 이외에 앱에는 다음 항목이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-115">In addition to your main application assembly, an app requires that the following be present:</span></span>

- <span data-ttu-id="3bddd-116">앱에 필요한 추가적인 클래스 라이브러리 또는 타사 어셈블리.</span><span class="sxs-lookup"><span data-stu-id="3bddd-116">Any additional class libraries or third-party assemblies that are required by your app.</span></span> <span data-ttu-id="3bddd-117">이들 어셈블리에도 어셈블리, 해당 형식, 해당 멤버를 설명하는 메타데이터와 모든 형식 멤버를 구현하는 IL이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-117">These assemblies similarly include metadata that describes the assembly, its types, and their members, as well as the IL that implements all type members.</span></span>

- <span data-ttu-id="3bddd-118">.NET Framework 클래스 라이브러리.</span><span class="sxs-lookup"><span data-stu-id="3bddd-118">The .NET Framework Class Library.</span></span> <span data-ttu-id="3bddd-119">.NET Framework 설치와 함께 로컬 시스템에 설치되는 어셈블리 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-119">This is a collection of assemblies that is installed on the local system with the .NET Framework installation.</span></span> <span data-ttu-id="3bddd-120">.NET Framework 클래스 라이브러리에 포함된 어셈블리에는 전체 메타데이터 및 구현 코드 집합이 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-120">The assemblies included in the .NET Framework Class Library include a complete set of metadata and implementation code.</span></span>

- <span data-ttu-id="3bddd-121">공용 언어 런타임.</span><span class="sxs-lookup"><span data-stu-id="3bddd-121">The common language runtime.</span></span> <span data-ttu-id="3bddd-122">어셈블리 로드, 메모리 관리 및 가비지 컬렉션, 예외 처리, Just-In-Time 컴파일, 원격, interop와 같은 서비스를 수행하는 동적 링크 라이브러리 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-122">This is a collection of dynamic link libraries that perform such services as assembly loading, memory management and garbage collection, exception handling, just-in-time compilation, remoting, and interop.</span></span> <span data-ttu-id="3bddd-123">클래스 라이브러리처럼 런타임은 로컬 시스템에 .NET Framework 설치와 함께 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-123">Like the class library, the runtime is installed on the local system as part of the .NET Framework installation.</span></span>

<span data-ttu-id="3bddd-124">앱을 성공적으로 실행하려면 전체 공용 언어 런타임과 애플리케이션별 어셈블리의 모든 형식에 대한 메타데이터 및 IL, 타사 어셈블리 및 시스템 어셈블리가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-124">Note that the entire common language runtime, as well as metadata and IL for all types in application-specific assemblies, third-party assemblies, and system assemblies must be present for the app to execute successfully.</span></span>

## <a name="net-native-and-just-in-time-compilation"></a><span data-ttu-id="3bddd-125">.NET 네이티브 및 Just-In-Time 컴파일</span><span class="sxs-lookup"><span data-stu-id="3bddd-125">.NET Native and just-in-time compilation</span></span>

<span data-ttu-id="3bddd-126">.NET 네이티브 도구 체인에 대한 입력은 C# 또는 Visual Basic 컴파일러로 빌드된 Windows 스토어 앱입니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-126">The input for the .NET Native tool chain is the Windows store app built by the C# or Visual Basic compiler.</span></span> <span data-ttu-id="3bddd-127">즉. .NET Native 네이티브 도구 체인은 언어 컴파일러가 Windows 스토어 앱 컴파일을 마쳤을 때 실행을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-127">In other words, the .NET Native tool chain begins execution when the language compiler has finished compilation of a Windows Store app.</span></span>

> [!TIP]
> <span data-ttu-id="3bddd-128">.NET 네이티브에 대한 입력은 관리되는 어셈블리에 기록되는 IL 및 메타데이터이므로 빌드 전 또는 빌드 후 이벤트를 사용하거나 MSBuild 프로젝트 파일을 수정하여 사용자 지정 코드 생성 또는 기타 사용자 지정 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-128">Because the input to .NET Native is the IL and metadata written to managed assemblies, you can still perform custom code generation or other custom operations by using pre-build or post-build events or by modifying the MSBuild project file.</span></span>
>
> <span data-ttu-id="3bddd-129">그러나 IL을 수정하고 이에 따라 .NET 도구 체인이 앱의 IL을 분석하지 않도록 방지하는 도구 범주는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-129">However, categories of tools that modify IL and thereby prevent the .NET tool chain from analyzing an app's IL are not supported.</span></span> <span data-ttu-id="3bddd-130">난독 처리기는 이 형식의 가장 주목할 만한 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-130">Obfuscators are the most notable tools of this type.</span></span>

<span data-ttu-id="3bddd-131">앱을 IL에서 네이티브 코드로 변환하는 과정에서 .NET 네이티브 도구 체인은 다음과 같은 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-131">In the course of converting an app from IL to native code, the .NET Native tool chain performs operations like the following:</span></span>

- <span data-ttu-id="3bddd-132">특정 코드 경로에서 리플렉션 및 메타데이터에 의존하는 코드를 정적 네이티브 코드로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-132">For certain code paths, it replaces code that relies on reflection and metadata with static native code.</span></span> <span data-ttu-id="3bddd-133">예를 들어 값 형식이 <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> 메서드를 재정의하지 않으면 기본 같음 테스트에서는 리플렉션을 사용하여 값 형식 필드를 나타내는 <xref:System.Reflection.FieldInfo> 개체를 검색하고 나서 두 인스턴스의 필드 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-133">For example, if a value type does not override the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method, the default test for equality uses reflection to retrieve <xref:System.Reflection.FieldInfo> objects that represent the value type's fields, then compares the field values of two instances.</span></span> <span data-ttu-id="3bddd-134">네이티브 코드를 컴파일할 때 .NET 네이티브 도구 체인은 리플렉션 코드 및 메타데이터를 필드 값의 정적 비교로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-134">When compiling to native code, the .NET Native tool chain replaces the reflection code and metadata with a static comparison of the field values.</span></span>

- <span data-ttu-id="3bddd-135">가능할 경우 네이티브 코드는 모든 메타데이터를 제거하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-135">Where possible, it attempts to eliminate all metadata.</span></span>

- <span data-ttu-id="3bddd-136">네이티브 코드는 실제로 앱에서 호출되는 구현 코드만 최종 앱 어셈블리에 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-136">It includes in the final app assemblies only the implementation code that is actually invoked by the app.</span></span> <span data-ttu-id="3bddd-137">이는 특히 타사 라이브러리 및 .NET Framework 클래스 라이브러리에 있는 코드에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-137">This particularly affects code in third-party libraries and in the .NET Framework Class Library.</span></span> <span data-ttu-id="3bddd-138">따라서 애플리케이션은 더 이상 타사 라이브러리나 전체 .NET Framework 클래스 라이브러리에 의존하지 않고, 타사 및 .NET Framework 클래스 라이브러리의 코드는 앱에 대한 로컬 위치에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-138">As a result, an application no longer depends on either third-party libraries or the full .NET Framework Class Library; instead, code in third-party and .NET Framework class libraries is now local to the app.</span></span>

- <span data-ttu-id="3bddd-139">네이티브 코드는 전체 CLR을 주로 가비지 수집기를 포함하는 리팩터링된 런타임으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-139">It replaces the full CLR with a refactored runtime that primarily contains the garbage collector.</span></span> <span data-ttu-id="3bddd-140">리팩터링된 런타임은 앱에 대한 로컬 위치에 있는 mrt100_app.dll 라이브러리에서 찾을 수 있고 크기가 겨우 몇백 킬로바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-140">The refactored runtime is found in a library named mrt100_app.dll that is local to the app and is only a few hundred kilobytes in size.</span></span> <span data-ttu-id="3bddd-141">정적 링크를 사용하면 공용 언어 런타임에서 수행되는 대부분 서비스가 필요하지 않으므로 이 상황이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-141">This is possible because static linking eliminates the need for many of the services performed by the common language runtime.</span></span>

  > [!NOTE]
  > <span data-ttu-id="3bddd-142">.NET 네이티브에서는 표준 공용 언어 런타임과 같은 가비지 수집기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-142">.NET Native uses the same garbage collector as the standard common language runtime.</span></span> <span data-ttu-id="3bddd-143">.NET 네이티브 가비지 수집기에서 백그라운드 가비지 수집은 기본적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-143">In the .NET Native garbage collector, background garbage collection is enabled by default.</span></span> <span data-ttu-id="3bddd-144">가비지 수집에 대한 자세한 내용은 [가비지 수집 기본 사항](../../standard/garbage-collection/fundamentals.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3bddd-144">For more information about garbage collection, see [Fundamentals of Garbage Collection](../../standard/garbage-collection/fundamentals.md).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3bddd-145">.NET 네이티브에서는 전체 애플리케이션을 네이티브 애플리케이션으로 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-145">.NET Native compiles an entire application to a native application.</span></span> <span data-ttu-id="3bddd-146">관리 코드와 독립적으로 호출될 수 있도록 클래스 라이브러리가 포함된 단일 어셈블리를 네이티브 코드로 컴파일할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-146">It does not allow you to compile a single assembly that contains a class library to native code so that it can be called independently from managed code.</span></span>

<span data-ttu-id="3bddd-147">.NET 네이티브 도구 체인에서 생성되는 결과 앱은 프로젝트 디렉터리의 디버그 또는 릴리스 디렉터리에 있는 ilc.out 디렉터리에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-147">The resulting app that is produced by the .NET Native tool chain is written to a directory named ilc.out in the Debug or Release directory of your project directory.</span></span> <span data-ttu-id="3bddd-148">결과 앱은 다음 파일로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-148">It consists of the following files:</span></span>

- <span data-ttu-id="3bddd-149">*\<appName>*.exe. .exe는 단순히 .dll의 특수 내보내기로 제어를 전달 하는 스텁 실행 파일입니다. `Main` *\<appName>*</span><span class="sxs-lookup"><span data-stu-id="3bddd-149">*\<appName>*.exe, a stub executable that simply transfers control to a special `Main` export in *\<appName>*.dll.</span></span>

- <span data-ttu-id="3bddd-150">*\<appName>*.dll, 모든 응용 프로그램 코드를 포함 하는 Windows 동적 연결 라이브러리와 .NET Framework 클래스 라이브러리 및 종속성이 있는 타사 라이브러리의 코드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-150">*\<appName>*.dll, a Windows dynamic link library that contains all your application code, as well as code from the .NET Framework Class Library and any third-party libraries that you have a dependency on.</span></span>  <span data-ttu-id="3bddd-151">Windows와 상호 운용하고 앱에서 개체를 직렬화하는 데 필요한 코드와 같은 지원 코드도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-151">It also contains support code, such as the code necessary to interoperate with Windows and to serialize objects in your app.</span></span>

- <span data-ttu-id="3bddd-152">mrt100_app.dll - 가비지 컬렉션과 같은 런타임 서비스를 제공하는 리팩터링된 런타임.</span><span class="sxs-lookup"><span data-stu-id="3bddd-152">mrt100_app.dll, a refactored runtime that provides runtime services such as garbage collection.</span></span>

 <span data-ttu-id="3bddd-153">모든 종속성은 앱의 APPX 매니페스트에 의해 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-153">All dependencies are captured by the app's APPX manifest.</span></span>  <span data-ttu-id="3bddd-154">appx 패키지로 직접 번들로 제공되는 애플리케이션 exe, dll 및 mrt100_app.dll 이외에 다음 파일 두 개가 추가로 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-154">In addition to the application exe, dll, and mrt100_app.dll, which are bundled directly in the appx package, this includes two more files:</span></span>

- <span data-ttu-id="3bddd-155">msvcr140_app.dll - mrt100_app.dll에서 사용되는 CRT(C 런타임) 라이브러리.</span><span class="sxs-lookup"><span data-stu-id="3bddd-155">msvcr140_app.dll, the C run-time (CRT) library used by mrt100_app.dll.</span></span> <span data-ttu-id="3bddd-156">이 파일은 프레임워크 참조를 통해 패키지에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-156">It is included by a framework reference in the package.</span></span>

- <span data-ttu-id="3bddd-157">mrt100.dll.</span><span class="sxs-lookup"><span data-stu-id="3bddd-157">mrt100.dll.</span></span> <span data-ttu-id="3bddd-158">이 라이브러리에는 라이브러리가 없어서 mrt100_app.dll 작동을 방지할 수 없더라도 mrt100_app.dll 성능을 향상할 수 있는 함수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-158">This library includes functions that can improve the performance of mrt100_app.dll, although its absence does not prevent mrt100_app.dll from functioning.</span></span> <span data-ttu-id="3bddd-159">이 라이브러리는 로컬 컴퓨터의 system32 디렉터리에 로드됩니다(있는 경우).</span><span class="sxs-lookup"><span data-stu-id="3bddd-159">It is loaded from the system32 directory on the local machine, if it is present.</span></span>

<span data-ttu-id="3bddd-160">.NET 네이티브 도구 체인은 앱이 실제로 구현 코드를 호출하는지를 인식하는 경우에만 해당 코드를 앱에 연결하므로 다음 시나리오에 필요한 메타데이터 또는 구현 코드가 앱에 포함되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-160">Because the .NET Native tool chain links implementation code into your app only if it knows that your app actually invokes that code, either the metadata or the implementation code required in the following scenarios may not be included with your app:</span></span>

- <span data-ttu-id="3bddd-161">리플렉션.</span><span class="sxs-lookup"><span data-stu-id="3bddd-161">Reflection.</span></span>

- <span data-ttu-id="3bddd-162">동적 또는 런타임 바인딩 호출.</span><span class="sxs-lookup"><span data-stu-id="3bddd-162">Dynamic or late-bound invocation.</span></span>

- <span data-ttu-id="3bddd-163">serialization 및 deserialization</span><span class="sxs-lookup"><span data-stu-id="3bddd-163">Serialization and deserialization.</span></span>

- <span data-ttu-id="3bddd-164">COM interop</span><span class="sxs-lookup"><span data-stu-id="3bddd-164">COM interop.</span></span>

<span data-ttu-id="3bddd-165">런타임에 필요한 메타데이터나 구현 코드가 있으면 .NET 네이티브 런타임이 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-165">If the necessary metadata or implementation code is absent at runtime, the .NET Native runtime throws an exception.</span></span> <span data-ttu-id="3bddd-166">런타임에 사용할 수 있어야 하는 메타데이터나 구현 코드가 포함된 프로그램 요소를 지정하고 런타임 정책을 프로그램 요소에 할당하는 XML 파일인 [런타임 지시문 파일](runtime-directives-rd-xml-configuration-file-reference.md)을 사용하여 이 예외를 방지하고 .NET 네이티브 도구 체인에 필요한 메타데이터와 구현 코드가 포함되어 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-166">You can prevent these exceptions, and ensure that the .NET Native tool chain includes the required metadata and implementation code, by using a [runtime directives file](runtime-directives-rd-xml-configuration-file-reference.md), an XML file that designates the program elements whose metadata or implementation code must be available at runtime and assigns a runtime policy to them.</span></span> <span data-ttu-id="3bddd-167">.NET 네이티브 도구 체인으로 컴파일된 Windows 스토어 프로젝트에 추가되는 기본 런타임 지시문 파일은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-167">The following is the default runtime directives file that is added to a Windows Store project that is compiled by the .NET Native tool chain:</span></span>

```xml
<Directives xmlns="http://schemas.microsoft.com/netfx/2013/01/metadata">
  <Application>
    <Assembly Name="*Application*" Dynamic="Required All" />
  </Application>
</Directives>
```

<span data-ttu-id="3bddd-168">이 파일을 통해 앱 패키지의 모든 어셈블리에서 모든 형식 및 모든 해당 멤버를 리플렉션하고 동적으로 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-168">This enables all the types, as well as all their members, in all the assemblies in your app package for reflection and dynamic invocation.</span></span> <span data-ttu-id="3bddd-169">그러나 .NET Framework 클래스 라이브러리 어셈블리의 형식을 리플렉션하거나 동적으로 활성화할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-169">However, it does not enable reflection or dynamic activation of types in .NET Framework Class Library assemblies.</span></span> <span data-ttu-id="3bddd-170">대부분 경우에 이것으로 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-170">In many cases, this is adequate.</span></span>

## <a name="net-native-and-ngen"></a><span data-ttu-id="3bddd-171">.NET 네이티브 및 NGEN</span><span class="sxs-lookup"><span data-stu-id="3bddd-171">.NET Native and NGEN</span></span>

<span data-ttu-id="3bddd-172">[네이티브 이미지 생성기](../tools/ngen-exe-native-image-generator.md)(NGEN)에서는 어셈블리를 네이티브 코드로 컴파일하고 로컬 컴퓨터의 네이티브 이미지 캐시에 어셈블리를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-172">The [(Native Image Generator](../tools/ngen-exe-native-image-generator.md) (NGEN) compiles assemblies to native code and installs them in the native image cache on the local computer.</span></span> <span data-ttu-id="3bddd-173">그러나 .NET 네이티브처럼 NGEN이 네이티브 코드를 생성하더라도 몇 가지 중요한 방식에서 .NET 네이티브와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-173">However, although NGEN, like .NET Native, produces native code, it differs from .NET Native in some significant ways:</span></span>

- <span data-ttu-id="3bddd-174">특정 메서드에 대한 네이티브 이미지를 사용할 수 없으면 NGEN이 JITing 코드로 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-174">If no native image is available for a particular method, NGEN falls back to JITing code.</span></span> <span data-ttu-id="3bddd-175">즉, 네이티브 이미지에서는 계속해서 NGEN이 JIT 컴파일로 대체되어야 하는 이벤트에 메타데이터와 IL을 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-175">This means that native images must continue to include metadata and IL in the event that NGEN needs to fall back to JIT compilation.</span></span> <span data-ttu-id="3bddd-176">반대로 .NET 네이티브는 네이티브 이미지만 생성하고 JIT 컴파일로 대체되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-176">In contrast, .NET Native produces only native images and does not fall back to JIT compilation.</span></span> <span data-ttu-id="3bddd-177">따라서 일부 리플렉션, 직렬화 및 interop 시나리오에 필요한 메타데이터만 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-177">As a result, only metadata required for some reflection, serialization, and interop scenarios must be preserved.</span></span>

- <span data-ttu-id="3bddd-178">NGEN은 어셈블리 로드, 원격, interop, 메모리 관리, 가비지 컬렉션, 필요한 경우 JIT 컴파일과 같은 서비스를 위해 계속해서 전체 공용 언어 런타임에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-178">NGEN continues to rely on the full common language runtime for services such as assembly loading, remoting, interop, memory management, garbage collection, and, if necessary, JIT compilation.</span></span> <span data-ttu-id="3bddd-179">.NET 네이티브에서는 이들 서비스 대부분이 필요하지 않거나(JIT 컴파일), 빌드 타임에 해결되고 앱 어셈블리에 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-179">In .NET Native, many of these services are either unnecessary (JIT compilation) or are resolved at build-time and incorporated in the app assembly.</span></span> <span data-ttu-id="3bddd-180">가장 중요한 가비지 수집을 비롯한 나머지 서비스는 훨씬 더 작은 리팩터링된 mrt100_app.dll 런타임에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-180">The remaining services, the most important of which is garbage collection, are included in a much smaller, refactored runtime named mrt100_app.dll.</span></span>

- <span data-ttu-id="3bddd-181">NGEN 이미지는 손상되기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-181">NGEN images tend to be fragile.</span></span> <span data-ttu-id="3bddd-182">예를 들어 종속성에 패치나 변경을 적용하려면 일반적으로 패치나 변경을 사용하는 어셈블리도 다시 NGEN되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-182">For example, a patch or change to a dependency typically requires that the assemblies that use it also be re-NGENed.</span></span> <span data-ttu-id="3bddd-183">이는 특히 .NET Framework 클래스 라이브러리의 시스템 라이브러리에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-183">This is particularly true of system assemblies in the .NET Framework Class Library.</span></span> <span data-ttu-id="3bddd-184">반대로 .NET 네이티브에서는 애플리케이션을 서로 독립적으로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3bddd-184">In contrast, .NET Native allows applications to be served independently of one another.</span></span>

## <a name="see-also"></a><span data-ttu-id="3bddd-185">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3bddd-185">See also</span></span>

- [<span data-ttu-id="3bddd-186">메타데이터 및 자동 기술 구성 요소</span><span class="sxs-lookup"><span data-stu-id="3bddd-186">Metadata and Self-Describing Components</span></span>](../../standard/metadata-and-self-describing-components.md)
- [<span data-ttu-id="3bddd-187">.NET 네이티브 정보(채널 9 비디오)</span><span class="sxs-lookup"><span data-stu-id="3bddd-187">Inside .NET Native (Channel 9 Video)</span></span>](https://channel9.msdn.com/Shows/Going+Deep/Inside-NET-Native)
- [<span data-ttu-id="3bddd-188">리플렉션 및 .NET 네이티브</span><span class="sxs-lookup"><span data-stu-id="3bddd-188">Reflection and .NET Native</span></span>](reflection-and-net-native.md)
- [<span data-ttu-id="3bddd-189">.NET 네이티브 일반 문제 해결</span><span class="sxs-lookup"><span data-stu-id="3bddd-189">.NET Native General Troubleshooting</span></span>](net-native-general-troubleshooting.md)
