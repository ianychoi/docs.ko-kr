---
title: 최선의 어셈블리 로드 방법
description: .NET에서 어셈블리 로드에 대한 모범 사례를 알아봅니다. 잘못된 캐스트, 누락된 메서드 및 기타 예외가 발생할 수 있는 형식 ID 문제를 방지합니다.
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
ms.openlocfilehash: 9e09c9e43a4bd8b13712d5fbbf85830394ac0b58
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96236444"
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="fa6a7-104">최선의 어셈블리 로드 방법</span><span class="sxs-lookup"><span data-stu-id="fa6a7-104">Best Practices for Assembly Loading</span></span>

<span data-ttu-id="fa6a7-105">이 문서에서는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException> 및 다른 오류를 발생시킬 수 있는 형식 ID 문제를 방지하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-105">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="fa6a7-106">이 문서에서는 다음 권장 사항을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-106">The article discusses the following recommendations:</span></span>  
  
- [<span data-ttu-id="fa6a7-107">로드 컨텍스트의 장점 및 단점 이해</span><span class="sxs-lookup"><span data-stu-id="fa6a7-107">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
- [<span data-ttu-id="fa6a7-108">부분 어셈블리 이름에 대한 바인딩 방지</span><span class="sxs-lookup"><span data-stu-id="fa6a7-108">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
- [<span data-ttu-id="fa6a7-109">여러 컨텍스트에 어셈블리 로드 방지</span><span class="sxs-lookup"><span data-stu-id="fa6a7-109">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
- [<span data-ttu-id="fa6a7-110">같은 컨텍스트에 어셈블리의 여러 버전 로드 방지</span><span class="sxs-lookup"><span data-stu-id="fa6a7-110">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
- [<span data-ttu-id="fa6a7-111">기본 로드 컨텍스트로 전환 고려</span><span class="sxs-lookup"><span data-stu-id="fa6a7-111">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="fa6a7-112">첫 번째 권장 사항인 [로드 컨텍스트의 장점 및 단점 이해](#load_contexts)에서는 다른 권장 사항에 대한 배경 정보를 제공합니다. 그 이유는 권장 사항은 모두 로드 컨텍스트의 지식에 의존하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-112">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>

## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="fa6a7-113">로드 컨텍스트의 장점 및 단점 이해</span><span class="sxs-lookup"><span data-stu-id="fa6a7-113">Understand the Advantages and Disadvantages of Load Contexts</span></span>  

 <span data-ttu-id="fa6a7-114">애플리케이션 도메인 내에서 어셈블리는 세 개의 컨텍스트 중 하나로 로드되거나 컨텍스트 없이 로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-114">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
- <span data-ttu-id="fa6a7-115">기본 로드 컨텍스트에는 전역 어셈블리 캐시, 런타임이 호스트된 경우 호스트 어셈블리 저장소(예: SQL Server에서), 애플리케이션 도메인의 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A>를 검색하여 찾은 어셈블리가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-115">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="fa6a7-116"><xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-116">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
- <span data-ttu-id="fa6a7-117">로드 소스 컨텍스트에는 로더를 통해 검색되지 않은 위치에서 로드된 어셈블리가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-117">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="fa6a7-118">예를 들어 추가 기능은 애플리케이션 경로 아래에 없는 디렉터리에 설치될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-118">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="fa6a7-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> 및 <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType>는 경로로 로드되는 메서드의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
- <span data-ttu-id="fa6a7-120">리플렉션 전용 컨텍스트에는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드를 사용하여 로드되는 어셈블리가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-120">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="fa6a7-121">이 컨텍스트의 코드는 실행될 수 없으므로 여기서 설명하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-121">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="fa6a7-122">자세한 내용은 [방법: 리플렉션 전용 컨텍스트에 어셈블리 로드](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-122">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
- <span data-ttu-id="fa6a7-123">리플렉션 내보내기를 사용하여 임시 동적 어셈블리를 생성한 경우 이 어셈블리는 컨텍스트에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-123">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="fa6a7-124">또한 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드를 사용하여 로드된 대부분 어셈블리는 컨텍스트 없이 로드되고, 바이트 배열에서 로드된 어셈블리는 전역 어셈블리 캐시에 포함되도록 해당 ID(정책이 적용된 후)에 설정된 경우가 아니면 컨텍스트 없이 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-124">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="fa6a7-125">실행 컨텍스트에는 다음 섹션에서 설명된 장점과 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-125">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="fa6a7-126">기본 로드 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="fa6a7-126">Default Load Context</span></span>  

 <span data-ttu-id="fa6a7-127">어셈블리가 기본 로드 컨텍스트에 로드되면 해당 종속성은 자동으로 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-127">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="fa6a7-128">기본 로드 컨텍스트 또는 로드 소스 컨텍스트의 어셈블리의 경우 기본 로드 컨텍스트에 로드된 종속성은 자동으로 발견됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-128">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="fa6a7-129">어셈블리 ID로 로드하면 알 수 없는 버전의 어셈블리가 사용되지 않았는지 확인되므로 애플리케이션의 안정성이 증가합니다([부분 어셈블리 이름에 대한 바인딩 방지](#avoid_partial_names) 섹션 참조).</span><span class="sxs-lookup"><span data-stu-id="fa6a7-129">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="fa6a7-130">기본 로드 컨텍스트 사용에는 다음과 같은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-130">Using the default load context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="fa6a7-131">다른 컨텍스트에 로드된 종속성은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-131">Dependencies that are loaded into other contexts are not available.</span></span>  
  
- <span data-ttu-id="fa6a7-132">검색 경로 외부의 위치에서 기본 로드 컨텍스트로 어셈블리를 로드할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-132">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="fa6a7-133">로드 소스 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="fa6a7-133">Load-From Context</span></span>  

 <span data-ttu-id="fa6a7-134">로드 소스 컨텍스트를 통해 애플리케이션 경로 아래에 없는 경로에서 어셈블리를 로드할 수 있으므로 검색에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-134">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="fa6a7-135">경로 정보는 컨텍스트에서 유지 관리되므로 이 컨텍스트를 사용하여 해당 경로에서 종속성을 찾고 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-135">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="fa6a7-136">또한 이 컨텍스트의 어셈블리는 기본 로드 컨텍스트에 로드되는 종속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-136">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="fa6a7-137"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드나 경로로 로드되는 다른 메서드 중 하나를 사용하여 어셈블리를 로드하면 다음과 같은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-137">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
- <span data-ttu-id="fa6a7-138">같은 ID를 가진 어셈블리가 이미 로드 소스 컨텍스트에서 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-138">If an assembly with the same identity is already loaded in the load-from context, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
- <span data-ttu-id="fa6a7-139">어셈블리가 <xref:System.Reflection.Assembly.LoadFrom%2A>을 사용하여 로드되고 나중에 기본 로드 컨텍스트의 어셈블리가 표시 이름으로 같은 어셈블리를 로드하려고 하면 로드 시도가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="fa6a7-140">어셈블리가 역직렬화되면 이 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-140">This can occur when an assembly is deserialized.</span></span>  
  
- <span data-ttu-id="fa6a7-141">어셈블리가 <xref:System.Reflection.Assembly.LoadFrom%2A>을 사용하여 로드되고 검색 경로에 ID가 같지만 위치가 다른 어셈블리가 포함되면 <xref:System.InvalidCastException>, <xref:System.MissingMethodException> 또는 기타 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-141">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
- <span data-ttu-id="fa6a7-142"><xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-142"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
- <span data-ttu-id="fa6a7-143">어셈블리에 대한 네이티브 이미지가 있는 경우 이 이미지가 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-143">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="fa6a7-144">어셈블리는 도메인 중립적으로 로드될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-144">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="fa6a7-145">.NET Framework 버전 1.0 및 1.1에서는 정책이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-145">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="fa6a7-146">컨텍스트 없음</span><span class="sxs-lookup"><span data-stu-id="fa6a7-146">No Context</span></span>  

 <span data-ttu-id="fa6a7-147">리플렉션 내보내기를 사용하여 생성된 임시 어셈블리의 경우 컨텍스트 없이 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-147">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="fa6a7-148">같은 ID를 가진 여러 어셈블리를 하나의 애플리케이션 도메인에 로드하려면 컨텍스트 없이 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-148">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="fa6a7-149">검색 비용이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-149">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="fa6a7-150">정책이 적용될 때 설정되는 어셈블리의 ID가 전역 어셈블리 캐시의 어셈블리 ID와 일치하는 경우가 아니면 바이트 배열에서 로드된 어셈블리는 컨텍스트 없이 로드됩니다. 이 경우 어셈블리는 전역 어셈블리 캐시에서 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-150">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="fa6a7-151">컨텍스트 없이 어셈블리를 로드하는 방법에는 다음과 같은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-151">Loading assemblies without context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="fa6a7-152"><xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트를 처리하는 경우가 아니면 컨텍스트 없이 로드된 어셈블리에 다른 어셈블리를 바인딩할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-152">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="fa6a7-153">종속성은 자동으로 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-153">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="fa6a7-154">어셈블리를 컨텍스트 없이 미리 로드하거나, 기본 로드 컨텍스트에 미리 로드하거나, <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트를 처리하여 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-154">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="fa6a7-155">컨텍스트 없이 같은 ID를 가진 여러 어셈블리를 로드하면 같은 ID를 가진 어셈블리를 여러 컨텍스트에 로드하는 경우 발생한 문제와 비슷한 형식 ID 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-155">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="fa6a7-156">[여러 컨텍스트에 어셈블리 로드 방지](#avoid_loading_into_multiple_contexts)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-156">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
- <span data-ttu-id="fa6a7-157">어셈블리에 대한 네이티브 이미지가 있는 경우 이 이미지가 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-157">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="fa6a7-158">어셈블리는 도메인 중립적으로 로드될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-158">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="fa6a7-159">.NET Framework 버전 1.0 및 1.1에서는 정책이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-159">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>

## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="fa6a7-160">부분 어셈블리 이름에 대한 바인딩 방지</span><span class="sxs-lookup"><span data-stu-id="fa6a7-160">Avoid Binding on Partial Assembly Names</span></span>  

 <span data-ttu-id="fa6a7-161">부분 이름 바인딩은 어셈블리 로드 시 어셈블리 표시 이름(<xref:System.Reflection.Assembly.FullName%2A>)의 일부만 지정할 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-161">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="fa6a7-162">예를 들어 버전, 문화권 및 공개 키 토큰을 생략한 어셈블리의 간단한 이름만 사용하여 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-162">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="fa6a7-163">또는 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 메서드를 호출할 수 있습니다. 이 메서드는 먼저 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드를 호출하고, 어셈블리를 찾지 못하면 전역 어셈블리 캐시를 검색하고 가장 최근 사용 가능한 버전의 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-163">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="fa6a7-164">부분 이름 바인딩을 사용하면 다음과 같은 여러 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-164">Partial name binding can cause many problems, including the following:</span></span>  
  
- <span data-ttu-id="fa6a7-165"><xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 메서드는 같은 간단한 이름을 가진 다른 어셈블리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-165">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="fa6a7-166">예를 들어 두 개의 애플리케이션이 둘 다 간단한 이름 `GraphicsLibrary`를 가진 두 개의 완전히 다른 어셈블리를 전역 어셈블리 캐시에 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-166">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
- <span data-ttu-id="fa6a7-167">실제로 로드되는 어셈블리가 이전 버전과 호환되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-167">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="fa6a7-168">예를 들어 버전을 지정하지 않으면 프로그램이 원래 사용하도록 기록된 버전보다 훨씬 이후 버전이 로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-168">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="fa6a7-169">이후 버전의 변경 내용으로 인해 애플리케이션에서 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-169">Changes in the later version might cause errors in your application.</span></span>  
  
- <span data-ttu-id="fa6a7-170">실제로 로드되는 어셈블리가 이후 버전과 호환되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-170">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="fa6a7-171">예를 들어 최신 버전의 어셈블리를 사용하여 애플리케이션을 빌드하고 테스트했을 수 있지만 부분 바인딩은 애플리케이션에서 사용하는 기능이 없는 훨씬 이전 버전을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-171">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
- <span data-ttu-id="fa6a7-172">새 애플리케이션을 설치하면 기존 애플리케이션이 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-172">Installing new applications can break existing applications.</span></span> <span data-ttu-id="fa6a7-173">공유 어셈블리의 더 새로운 호환되지 않는 버전을 설치하면 <xref:System.Reflection.Assembly.LoadWithPartialName%2A> 메서드를 사용하는 애플리케이션이 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-173">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
- <span data-ttu-id="fa6a7-174">예기치 않은 종속성 로드가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-174">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="fa6a7-175">종속성을 공유하는 두 개의 어셈블리를 로드할 경우 부분 바인딩을 사용하여 로드하면 빌드 또는 테스트에 사용되지 않은 구성 요소를 사용하는 하나의 어셈블리가 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-175">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="fa6a7-176">이로 인해 발생할 수 있는 문제 때문에 <xref:System.Reflection.Assembly.LoadWithPartialName%2A> 메서드는 obsolete로 표시되었습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-176">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="fa6a7-177">대신에 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드를 사용하고 전체 어셈블리 표시 이름을 지정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-177">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="fa6a7-178">[로드 컨텍스트의 장점 및 단점 이해](#load_contexts) 및 [기본 로드 컨텍스트로 전환 고려](#switch_to_default)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-178">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="fa6a7-179">어셈블리를 쉽게 로드할 수 있기 때문에 <xref:System.Reflection.Assembly.LoadWithPartialName%2A> 메서드를 사용하려는 경우 누락된 어셈블리를 나타내는 오류 메시지와 함께 애플리케이션이 실패하게 하면 알 수 없는 버전의 어셈블리를 자동으로 사용하여 예측할 수 없는 동작 및 보안 허점을 유발하는 것보다 사용자에게 더 나은 환경이 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-179">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>

## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="fa6a7-180">여러 컨텍스트에 어셈블리 로드 방지</span><span class="sxs-lookup"><span data-stu-id="fa6a7-180">Avoid Loading an Assembly into Multiple Contexts</span></span>  

 <span data-ttu-id="fa6a7-181">어셈블리를 여러 컨텍스트에 로드하면 형식 ID 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-181">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="fa6a7-182">같은 형식이 같은 어셈블리에서 두 개의 다른 컨텍스트로 로드되는 경우는 같은 이름을 가진 두 개의 다른 형식이 로드된 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-182">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="fa6a7-183">한 형식을 다른 형식으로 캐스팅하려고 하면 <xref:System.InvalidCastException>이 throw되고 `MyType` 형식을 `MyType` 형식으로 캐스팅할 수 없다는 혼동되는 메시지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-183">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="fa6a7-184">예를 들어 프로그램에서 참조되거나 프로그램이 로드하는 다른 어셈블리에서 참조되는 `Utility` 어셈블리에 `ICommunicate` 인터페이스가 선언된 경우를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-184">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="fa6a7-185">이러한 다른 어셈블리에는 프로그램에서 사용할 수 있도록 `ICommunicate` 인터페이스를 구현하는 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-185">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="fa6a7-186">이제 프로그램이 실행될 경우 어떤 일이 발생하는지 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-186">Now consider what happens when your program is run.</span></span> <span data-ttu-id="fa6a7-187">프로그램에서 참조하는 어셈블리는 기본 로드 컨텍스트로 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-187">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="fa6a7-188"><xref:System.Reflection.Assembly.Load%2A> 메서드를 사용하여 ID로 대상 어셈블리를 로드하면 어셈블리 및 종속성이 기본 로드 컨텍스트에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-188">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="fa6a7-189">프로그램 및 대상 어셈블리는 둘 다 같은 `Utility` 어셈블리를 사용하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-189">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="fa6a7-190">하지만 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드를 사용하여 파일 경로로 대상 어셈블리를 로드하는 경우를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-190">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="fa6a7-191">어셈블리는 컨텍스트 없이 로드되므로 종속성이 자동으로 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-191">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="fa6a7-192">종속성을 제공하기 위한 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 처리기가 있을 수 있고 이 처리기가 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드를 사용하여 `Utility` 어셈블리를 컨텍스트 없이 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-192">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="fa6a7-193">이제 대상 어셈블리에 포함된 형식의 인스턴스를 만들고 인스턴스에 `ICommunicate` 형식의 변수를 지정하려고 하면 <xref:System.InvalidCastException>이 throw됩니다. 그 이유는 런타임은 `Utility` 어셈블리의 두 가지 복사본에 있는 `ICommunicate` 인터페이스를 서로 다른 형식으로 간주하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-193">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="fa6a7-194">어셈블리를 여러 컨텍스트에 로드할 수 있는 다양한 다른 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-194">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="fa6a7-195">가장 좋은 방법은 대상 어셈블리를 애플리케이션 경로에 재배치하고 <xref:System.Reflection.Assembly.Load%2A> 메서드를 전체 표시 이름과 함께 사용하여 충돌을 피하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-195">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="fa6a7-196">어셈블리는 기본 로드 컨텍스트에 로드되고 두 어셈블리는 모두 같은 `Utility` 어셈블리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-196">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="fa6a7-197">대상 어셈블리가 애플리케이션 경로 외부에서 유지되어야 하는 경우 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 사용하여 어셈블리를 로드 소스 컨텍스트에 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-197">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="fa6a7-198">대상 어셈블리가 애플리케이션의 `Utility` 어셈블리에 대한 참조를 사용하여 컴파일된 경우 이 어셈블리는 애플리케이션이 기본 로드 컨텍스트에 로드된 `Utility` 어셈블리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-198">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="fa6a7-199">대상 어셈블리에 애플리케이션 경로 외부에 있는 `Utility` 어셈블리의 복사본에 대한 종속성이 있는 경우에는 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-199">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="fa6a7-200">애플리케이션이 `Utility` 어셈블리를 로드하기 전에 해당 어셈블리가 로드 소스 컨텍스트에 로드되면 애플리케이션의 로드가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-200">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="fa6a7-201">[기본 로드 컨텍스트로 전환 고려](#switch_to_default) 섹션에서는 <xref:System.Reflection.Assembly.LoadFile%2A> 및 <xref:System.Reflection.Assembly.LoadFrom%2A>과 같은 파일 경로 로드 대신 사용할 수 있는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-201">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>

## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="fa6a7-202">같은 컨텍스트에 어셈블리의 여러 버전 로드 방지</span><span class="sxs-lookup"><span data-stu-id="fa6a7-202">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  

 <span data-ttu-id="fa6a7-203">여러 버전의 어셈블리를 하나의 로드 컨텍스트에 로드하면 형식 ID 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-203">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="fa6a7-204">같은 형식이 같은 어셈블리의 두 가지 버전에서 로드되는 경우는 같은 이름을 가진 두 개의 다른 형식이 로드된 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-204">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="fa6a7-205">한 형식을 다른 형식으로 캐스팅하려고 하면 <xref:System.InvalidCastException>이 throw되고 `MyType` 형식을 `MyType` 형식으로 캐스팅할 수 없다는 혼동되는 메시지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-205">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="fa6a7-206">예를 들어 프로그램은 `Utility` 어셈블리의 한 가지 버전을 직접 로드하거나 나중에 `Utility` 어셈블리의 여러 가지 버전을 로드하는 또 다른 어셈블리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-206">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="fa6a7-207">또는 코딩 오류로 인해 애플리케이션의 두 가지 다른 코드 경로가 어셈블리의 서로 다른 버전을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-207">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="fa6a7-208">기본 로드 컨텍스트에서 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드를 사용하고 서로 다른 버전 번호를 포함하는 전체 어셈블리 표시 이름을 지정할 경우 이 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-208">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="fa6a7-209">컨텍스트 없이 로드된 어셈블리의 경우 <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> 메서드를 사용하여 서로 다른 경로에서 같은 어셈블리를 로드하면 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-209">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="fa6a7-210">런타임은 ID가 같은 경우에도 서로 다른 경로에서 로드된 두 개의 어셈블리를 서로 다른 어셈블리로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-210">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="fa6a7-211">형식 ID 문제 이외에 어셈블리의 여러 버전이 있으면 어셈블리의 한 버전에서 로드된 형식이 다른 버전의 해당 형식을 필요로 하는 코드에 전달될 경우 <xref:System.MissingMethodException>이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-211">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="fa6a7-212">예를 들어 코드에는 이후 버전에 추가된 메서드가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-212">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="fa6a7-213">형식의 동작이 버전 간에 변경된 경우 더 교묘한 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-213">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="fa6a7-214">예를 들어 메서드가 예기치 않은 예외를 throw하거나 예기치 않은 값을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-214">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="fa6a7-215">어셈블리의 한 가지 버전만 로드되도록 코드를 주의해서 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-215">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="fa6a7-216"><xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> 메서드를 사용하여 특정 시점에 로드되는 어셈블리를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-216">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>

## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="fa6a7-217">기본 로드 컨텍스트로 전환 고려</span><span class="sxs-lookup"><span data-stu-id="fa6a7-217">Consider Switching to the Default Load Context</span></span>  

 <span data-ttu-id="fa6a7-218">애플리케이션 어셈블리 로드 및 배포 패턴을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-218">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="fa6a7-219">바이트 배열에서 로드된 어셈블리를 제거할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="fa6a7-219">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="fa6a7-220">어셈블리를 검색 경로로 이동할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="fa6a7-220">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="fa6a7-221">어셈블리가 전역 어셈블리 캐시 또는 애플리케이션 도메인의 검색 경로(<xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A>)에 있는 경우 ID로 어셈블리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-221">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="fa6a7-222">모든 어셈블리를 검색 경로에 포함할 수 없는 경우에는 .NET Framework 추가 기능 모델을 사용하거나 어셈블리를 전역 어셈블리 캐시에 포함하거나 애플리케이션 도메인을 만드는 것과 같은 대체 방법을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-222">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="fa6a7-223">.NET Framework 추가 기능 모델 사용 고려</span><span class="sxs-lookup"><span data-stu-id="fa6a7-223">Consider Using the .NET Framework Add-In Model</span></span>  

 <span data-ttu-id="fa6a7-224">일반적으로 애플리케이션 기준 위치에 설치되지 않는 추가 기능을 구현하는 데 로드 소스 컨텍스트를 사용할 경우 .NET Framework 추가 기능 모델을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-224">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="fa6a7-225">이 모델은 애플리케이션 도메인 또는 프로세스 수준에서 격리되므로, 사용자가 애플리케이션 도메인을 직접 관리할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-225">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="fa6a7-226">추가 기능 모델에 대한 자세한 내용은 [추가 기능 및 확장성](/previous-versions/dotnet/netframework-4.0/bb384200(v=vs.100))을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-226">For information about the add-in model, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v=vs.100)).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="fa6a7-227">전역 어셈블리 캐시 사용 고려</span><span class="sxs-lookup"><span data-stu-id="fa6a7-227">Consider Using the Global Assembly Cache</span></span>  

 <span data-ttu-id="fa6a7-228">어셈블리를 전역 어셈블리 캐시에 포함하면 기본 로드 컨텍스트의 장점을 잃거나 다른 컨텍스트의 단점을 떠맡지 않고 애플리케이션 기준 위치 외부에 있는 공유 어셈블리 경로를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-228">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="fa6a7-229">애플리케이션 도메인 사용 고려</span><span class="sxs-lookup"><span data-stu-id="fa6a7-229">Consider Using Application Domains</span></span>  

 <span data-ttu-id="fa6a7-230">일부 어셈블리를 애플리케이션의 검색 경로에 배포할 수 없는 것으로 확인되면 해당 어셈블리에 대한 새 애플리케이션 도메인을 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-230">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="fa6a7-231"><xref:System.AppDomainSetup>을 사용하여 새 애플리케이션 도메인을 만들고 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> 속성을 사용하여 로드할 어셈블리가 포함된 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-231">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="fa6a7-232">검색할 디렉터리가 여러 개 있는 경우에는 <xref:System.AppDomainSetup.ApplicationBase%2A>를 루트 디렉터리로 설정하고 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 속성을 사용하여 검색할 하위 디렉터리를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-232">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="fa6a7-233">또는 여러 애플리케이션 도메인을 만들고 각 애플리케이션 도메인의 <xref:System.AppDomainSetup.ApplicationBase%2A>를 어셈블리의 적절한 경로로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-233">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="fa6a7-234">이러한 어셈블리를 로드하는 데는 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-234">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="fa6a7-235">이제 어셈블리가 검색 경로에 있으므로 어셈블리는 로드 소스 컨텍스트가 아닌 기본 로드 컨텍스트에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-235">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="fa6a7-236">하지만 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드로 전환하고 전체 어셈블리 표시 이름을 제공하여 올바른 버전이 항상 사용되는지 확인하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fa6a7-236">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fa6a7-237">참조</span><span class="sxs-lookup"><span data-stu-id="fa6a7-237">See also</span></span>

- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>
- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>
