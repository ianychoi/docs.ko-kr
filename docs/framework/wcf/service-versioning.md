---
title: 서비스 버전 관리
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: fae0a5eca5737c3d7885cbe6c678678adabbea01
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96245347"
---
# <a name="service-versioning"></a><span data-ttu-id="9c828-102">서비스 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-102">Service Versioning</span></span>

<span data-ttu-id="9c828-103">서비스 및 서비스가 노출하는 엔드포인트는 비즈니스 요구의 변경, 정보 기술의 요구 사항 또는 다른 문제 해결 등의 다양한 이유 때문에 최초로 배포된 후, 수명 동안 여러 차례에 걸쳐 변경되어야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="9c828-104">각 변경 작업에는 새 버전의 서비스가 도입됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="9c828-105">이 항목에서는 WCF (Windows Communication Foundation)에서 버전 관리를 고려 하는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="9c828-106">서비스 변경의 네 가지 범주</span><span class="sxs-lookup"><span data-stu-id="9c828-106">Four Categories of Service Changes</span></span>  

 <span data-ttu-id="9c828-107">변경될 수 있는 서비스는 다음과 같이 네 가지 범주로 분류할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="9c828-108">계약 변경: 예를 들어 작업이 추가되거나, 메시지의 데이터 요소가 추가되거나 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="9c828-109">주소 변경: 예를 들어 엔드포인트가 새 주소를 가진 다른 위치로 서비스가 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="9c828-110">바인딩 변경: 예를 들어 보안 메커니즘이 변경되거나 해당 설정이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="9c828-111">구현 변경: 예를 들어 내부 메서드 구현이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="9c828-112">이러한 변경 중 일부는 "주요" 변경 내용이고, 나머지는 "주요하지 않은" 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="9c828-113">이전 버전에서 성공적으로 처리 된 모든 메시지가 새 버전에서 성공적으로 처리 되 면 변경 내용이 *줄 바꿈하지* 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="9c828-114">이 조건을 충족 하지 않는 변경 내용은 *주요* 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="9c828-115">서비스 방향 및 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-115">Service Orientation and Versioning</span></span>  

 <span data-ttu-id="9c828-116">서비스 방향의 개념 중 하나는 서비스와 클라이언트가 자율적 또는 독립적이라는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="9c828-117">특히, 이는 서비스 개발자가 모든 서비스 클라이언트를 제어한다거나, 심지어 알고 있다고도 가정할 수 없음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="9c828-118">이로 인해 서비스의 버전이 변경될 때 모든 클라이언트를 다시 빌드하고 다시 배포할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="9c828-119">이 항목에서는 서비스가 이러한 개념을 따르기 때문에 해당 클라이언트와 독립적으로 변경되거나 "버전 관리"되어야 한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="9c828-120">예기치 않게 주요 내용이 변경되고 이를 피할 수 없는 경우, 애플리케이션에서는 이 개념을 무시하도록 선택할 수 있으며, 서비스의 새 버전으로 클라이언트가 다시 빌드되고 다시 배포되도록 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="9c828-121">계약 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-121">Contract Versioning</span></span>  

 <span data-ttu-id="9c828-122">클라이언트에서 사용하는 계약과 서비스에서 사용하는 계약이 동일해야 할 필요는 없습니다. 이 둘을 호환할 수만 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="9c828-123">서비스 계약의 경우, 호환성이란 서비스에 의해 노출되는 새 작업을 추가할 수는 있지만 기존 작업을 제거하거나 의미상 변경할 수는 없다는 것을 뜻합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="9c828-124">데이터 계약의 경우, 호환성은 새 스키마 형식의 정의를 추가할 수는 있지만 기존 스키마 형식의 정의를 주요한 방법으로 변경할 수는 없다는 것을 뜻합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="9c828-125">주요 변경 내용에는 데이터 멤버를 제거하거나 데이터 형식을 호환되지 않게 변경하는 것이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="9c828-126">이 기능을 사용하면 서비스가 클라이언트를 중단시키지 않고도 해당 계약의 버전을 일부 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="9c828-127">다음 두 섹션에서는 WCF 데이터 및 서비스 계약에 적용할 수 있는 줄 바꿈하지 않는 변경 내용 및 주요 변경 내용에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="9c828-128">데이터 계약 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-128">Data Contract Versioning</span></span>  

 <span data-ttu-id="9c828-129">이 단원에서는 <xref:System.Runtime.Serialization.DataContractSerializer> 및 <xref:System.Runtime.Serialization.DataContractAttribute> 클래스를 사용할 때의 데이터 버전 관리에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="9c828-130">엄격한 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-130">Strict Versioning</span></span>  

 <span data-ttu-id="9c828-131">버전 변경이 문제가 되는 많은 시나리오에서 서비스 개발자는 클라이언트를 제어할 수 있는 권한이 없습니다. 따라서 메시지 XML 또는 스키마에서의 변경 내용에 대응하는 방법을 가정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="9c828-132">이러한 경우, 다음 두 가지 이유로 새 메시지가 기존 스키마에 대해 유효성을 검사할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="9c828-133">이전 버전의 클라이언트는 스키마가 변경되지 않는다는 가정 하에 개발되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="9c828-134">이전 버전의 클라이언트는 개발 시에 처리할 수 있도록 설정된 메시지 외에는 메시지를 처리하지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="9c828-135">이전 클라이언트는 메시지를 처리하려고 시도하기 전에 이전 스키마에 대해 스키마 유효성 검사를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="9c828-136">이러한 시나리오에서는 기존 데이터 계약을 변경할 수 없는 것으로 간주하고, 정규화된 고유 XML 이름을 가진 새 항목을 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="9c828-137">그런 다음 서비스 개발자는 기존 서비스 계약에 새 메서드를 추가하거나, 새 데이터 계약을 사용하는 메서드로 새 서비스 계약을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="9c828-138">서비스 개발자가 데이터 계약의 모든 버전에서 실행해야 하는 비즈니스 논리를 작성하고, 이와 함께 계약의 각 버전별로 실행해야 하는 비즈니스 코드를 작성해야 하는 경우에 이러한 방법이 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="9c828-139">이 항목의 끝에 있는 부록에서는 인터페이스를 사용하여 이와 같은 경우를 처리하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="9c828-140">Lax 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-140">Lax Versioning</span></span>  

 <span data-ttu-id="9c828-141">다른 여러 시나리오에서 서비스 개발자는 새 선택적 멤버를 데이터 계약에 추가해도 기존 클라이언트가 중지되지 않는다고 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="9c828-142">이를 위해서 서비스 개발자는 기존 클라이언트가 스키마 유효성 검사를 수행하지 않고 있으며, 알려지지 않은 데이터 멤버를 무시하는지를 조사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="9c828-143">이러한 시나리오에서는 주요하지 않은 변경 방법으로 새 멤버를 추가하기 위해 데이터 계약 기능을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="9c828-144">서비스 개발자는 버전 관리를 위한 데이터 계약 기능을 이미 서비스의 첫 번째 버전에 대해 사용한 경우 안전하게 이렇게 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="9c828-145">WCF, ASP.NET 웹 서비스 및 기타 많은 웹 서비스 스택은 *느슨한 버전 관리* 를 지원 합니다. 즉, 수신 된 데이터에서 알 수 없는 새 데이터 멤버에 대 한 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="9c828-146">새 멤버를 추가해도 기존 클라이언트가 중지되지 않을 것이라고 잘못 생각할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="9c828-147">모든 클라이언트가 lax 버전 관리를 처리할 수 있는지 확신할 수 없는 경우에는 엄격한 버전 관리 지침을 사용하고, 데이터 계약을 변경할 수 없는 것으로 간주하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="9c828-148">데이터 계약의 느슨한 버전과 엄격한 버전 관리에 대 한 자세한 지침은 [모범 사례: 데이터 계약 버전 관리](best-practices-data-contract-versioning.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9c828-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="9c828-149">데이터 계약과 .NET 형식 구별</span><span class="sxs-lookup"><span data-stu-id="9c828-149">Distinguishing Between Data Contract and .NET Types</span></span>  

 <span data-ttu-id="9c828-150"><xref:System.Runtime.Serialization.DataContractAttribute> 특성을 클래스에 적용해서 .NET 클래스 또는 구조를 데이터 계약으로 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="9c828-151">.NET 형식 및 해당 데이터 계약 프로젝션은 서로 다른 별개의 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="9c828-152">여러 .NET 형식에서 동일한 데이터 계약 프로젝션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="9c828-153">이러한 구분은 특히 표시된 데이터 계약을 유지 관리하여 엄밀한 의미에서 기존 클라이언트와의 호환성을 유지하기 위하여 .NET 형식을 변경할 때 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="9c828-154">.NET 형식과 데이터 계약의 이러한 구분을 유지하기 위해서는 다음 두 가지 사항을 항상 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="9c828-155"><xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> 및 <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="9c828-156">사용자의 .NET 형식 이름 및 네임스페이스가 계약에서 노출되지 않도록 하려면 데이터 계약의 이름 및 네임스페이스를 항상 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="9c828-157">이 방법으로 .NET 네임스페이스 또는 형식 이름을 나중에 변경하려는 경우 데이터 계약은 동일하게 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="9c828-158"><xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="9c828-159">사용자의 .NET 멤버 이름이 계약에서 노출되지 않도록 하려면 데이터 멤버의 이름을 항상 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="9c828-160">이 방법으로 멤버의 .NET 이름을 나중에 변경하려는 경우 데이터 계약은 동일하게 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="9c828-161">멤버 변경 또는 제거</span><span class="sxs-lookup"><span data-stu-id="9c828-161">Changing or Removing Members</span></span>  

 <span data-ttu-id="9c828-162">멤버의 이름이나 데이터 형식을 변경하거나 데이터 멤버를 제거하는 것은 lax 버전 관리가 허용되어 있더라도 주요 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="9c828-163">이러한 변경이 필요하면 새 데이터 계약을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="9c828-164">서비스 호환성이 매우 중요할 경우 사용자 코드에서 사용되지 않는 데이터 멤버를 무시하고 이를 그대로 남겨두는 것을 고려해 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="9c828-165">하나의 데이터 멤버를 여러 멤버로 분할하는 경우, 하위 수준의 클라이언트(최신 버전으로 업그레이드 되지 않는 클라이언트)에 대해 필수 분할 및 재집계를 수행할 수 있는 속성으로 기존 멤버를 그대로 남겨두는 것을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="9c828-166">마찬가지로 데이터 계약의 이름 또는 네임스페이스를 변경하는 것은 주요한 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="9c828-167">알 수 없는 데이터의 라운드트립</span><span class="sxs-lookup"><span data-stu-id="9c828-167">Round-Trips of Unknown Data</span></span>  

 <span data-ttu-id="9c828-168">일부 시나리오에서는 새 버전에 추가된 멤버의 알 수 없는 데이터를 "라운드트립"해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="9c828-169">예를 들어 "versionNew" 서비스는 일부 새로 추가된 멤버와 함께 데이터를 "versionOld" 클라이언트로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="9c828-170">클라이언트는 메시지를 처리할 때 새로 추가된 멤버를 무시하지만, 새로 추가된 멤버를 포함하여 동일한 데이터를 versionNew 서비스로 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="9c828-171">이에 대한 일반 시나리오는 데이터를 서비스에서 검색하고, 변경하고, 반환하는 데이터 업데이트입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="9c828-172">특정 형식의 라운드트립을 사용하려면 형식이 <xref:System.Runtime.Serialization.IExtensibleDataObject> 인터페이스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="9c828-173">인터페이스에는 <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> 형식을 반환하는 속성 중 하나인 <xref:System.Runtime.Serialization.ExtensionDataObject>가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="9c828-174">속성은 현재 버전에서는 알 수 없는 이후 버전 데이터 계약의 모든 데이터를 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="9c828-175">이 데이터는 클라이언트에 불분명하지만 인스턴스가 serialize될 때 <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> 속성의 콘텐츠는 데이터 계약 멤버의 나머지 데이터와 함께 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="9c828-176">사용자의 모든 형식이 이 인터페이스를 구현하여 이후의 알 수 없는 새 멤버를 수용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="9c828-177">데이터 계약 라이브러리</span><span class="sxs-lookup"><span data-stu-id="9c828-177">Data Contract Libraries</span></span>  

 <span data-ttu-id="9c828-178">계약이 중앙 리포지토리에 게시되고 서비스 및 형식 구현자가 해당 리포지토리로부터 데이터 계약을 구현하고 노출하는 데이터 계약의 라이브러리가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="9c828-179">이 경우에는 사용자가 리포지토리에 데이터 계약을 게시할 때 이를 구현하는 형식을 만드는 사람을 제어할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="9c828-180">그러므로 계약이 게시되고 나면 변경할 수 없도록 효과적으로 계약을 렌더링하므로 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="9c828-181">XmlSerializer를 사용하는 경우</span><span class="sxs-lookup"><span data-stu-id="9c828-181">When Using the XmlSerializer</span></span>  

 <span data-ttu-id="9c828-182"><xref:System.Xml.Serialization.XmlSerializer> 클래스를 사용할 때는 동일한 버전 관리 원칙이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="9c828-183">엄격한 버전 관리가 필요할 경우 데이터 계약을 변할 수 없는 것으로 간주하고, 새 버전에 대한 정규화된 고유 이름을 가진 새 데이터 계약을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="9c828-184">lax 버전 관리를 사용할 수 있는 경우 serialize할 수 있는 새 멤버를 새 버전에 추가할 수 있지만 기존 멤버를 변경하거나 제거할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9c828-185"><xref:System.Xml.Serialization.XmlSerializer>에서는 <xref:System.Xml.Serialization.XmlAnyElementAttribute> 및 <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> 특성을 사용하여 알 수 없는 데이터의 라운드트립을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="9c828-186">메시지 계약 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-186">Message Contract Versioning</span></span>  

 <span data-ttu-id="9c828-187">메시지 계약 버전 관리에 대한 지침은 데이터 계약 버전 관리와 매우 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="9c828-188">엄격한 버전 관리가 필요할 경우 메시지 본문을 변경하는 대신 정규화된 고유 이름을 가진 새 메시지 계약을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="9c828-189">lax 버전 지정을 사용할 수 있는 경우에는 새 메시지 본문 부분을 추가할 수 있지만 기존 부분을 변경하거나 제거할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="9c828-190">이 지침은 기본 메시지 계약과 래핑된 메시지 계약 둘 다에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="9c828-191">메시지 헤더는 항상 추가할 수 있습니다. 이는 엄격한 버전 관리를 사용 중인 경우에도 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="9c828-192">MustUnderstand 플래그가 버전 관리에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="9c828-193">일반적으로 WCF의 헤더에 대 한 버전 관리 모델은 SOAP 사양에 설명 된 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="9c828-194">서비스 계약 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-194">Service Contract Versioning</span></span>  

 <span data-ttu-id="9c828-195">데이터 계약 버전 관리와 마찬가지로 서비스 계약 버전 관리에는 작업 추가, 변경 및 제거가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="9c828-196">이름, 네임스페이스 및 동작 지정</span><span class="sxs-lookup"><span data-stu-id="9c828-196">Specifying Name, Namespace, and Action</span></span>  

 <span data-ttu-id="9c828-197">기본적으로 서비스 계약의 이름은 인터페이스의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="9c828-198">기본 네임 스페이스는 " http://tempuri.org "이 고 각 작업의 작업은 " http://tempuri.org/contractname/methodname "입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="9c828-199">서비스 계약에 대 한 이름 및 네임 스페이스를 명시적으로 지정 하는 것이 좋으며, ""를 사용 하지 않고 http://tempuri.org 인터페이스 및 메서드 이름이 서비스의 계약에서 노출 되지 않도록 방지 하기 위한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="9c828-200">매개 변수 및 작업 추가</span><span class="sxs-lookup"><span data-stu-id="9c828-200">Adding Parameters and Operations</span></span>  

 <span data-ttu-id="9c828-201">서비스에 의해 노출된 서비스 작업을 추가하는 것은 주요하지 않은 변경 내용입니다. 이러한 새 작업에서는 기존 클라이언트의 요구를 고려하지 않아도 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9c828-202">작업을 이중 콜백 계약에 추가하는 것은 주요 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="9c828-203">작업 매개 변수 또는 반환 형식 변경</span><span class="sxs-lookup"><span data-stu-id="9c828-203">Changing Operation Parameter or Return Types</span></span>  

 <span data-ttu-id="9c828-204">기존 형식에서 구현한 데이터 계약을 새 형식에서 동일하게 구현하지 않는 경우, 매개 변수 또는 반환 형식을 변경하는 것은 일반적으로 주요한 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="9c828-205">이러한 변경을 위해서 새 작업을 서비스 계약에 추가하거나 새 서비스 계약을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="9c828-206">제거 작업</span><span class="sxs-lookup"><span data-stu-id="9c828-206">Removing Operations</span></span>  

 <span data-ttu-id="9c828-207">제거 작업도 주요한 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="9c828-208">이러한 변경을 위해서 새 서비스 계약을 정의하고 이를 새 엔드포인트에서 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="9c828-209">오류 계약</span><span class="sxs-lookup"><span data-stu-id="9c828-209">Fault Contracts</span></span>  

 <span data-ttu-id="9c828-210">서비스 계약 개발자는 <xref:System.ServiceModel.FaultContractAttribute> 특성을 사용하여 계약 작업에서 반환될 수 있는 오류의 정보를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="9c828-211">서비스 계약에 설명된 오류 목록은 전체 목록으로 간주되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="9c828-212">어떤 경우에든 작업은 해당 계약에 설명되어 있지 않은 오류를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="9c828-213">그러므로 계약에서 설명된 오류 집합을 변경하는 것은 주요한 변경 내용으로 간주되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="9c828-214"><xref:System.ServiceModel.FaultContractAttribute>를 사용하여 새 오류를 계약에 추가하거나, 계약으로부터 기존 오류를 제거하는 것을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="9c828-215">서비스 계약 라이브러리</span><span class="sxs-lookup"><span data-stu-id="9c828-215">Service Contract Libraries</span></span>  

 <span data-ttu-id="9c828-216">조직에서는 계약 라이브러리를 가질 수 있으며, 여기서 계약은 중앙 리포지토리에 게시되고 서비스 구현자는 해당 리포지토리로부터 계약을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="9c828-217">이 경우에는 사용자가 리포지토리에 서비스 계약을 게시할 때 이를 구현하는 서비스를 만드는 사람을 제어할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="9c828-218">그러므로 서비스 계약이 게시되고 나면 변경할 수 없도록 서비스 계약이 효과적으로 렌더링되어 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="9c828-219">WCF는 기존 계약을 확장 하는 새 계약을 만드는 데 사용할 수 있는 계약 상속을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="9c828-220">이 기능을 사용하려면 이전 서비스 계약 인터페이스로부터 상속된 새 서비스 계약 인터페이스를 정의한 다음 새 인터페이스에 메서드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="9c828-221">그런 다음 이전 계약을 구현하는 서비스를 변경하여 새 계약을 구현하고, "versionOld" 엔드포인트 정의를 변경하여 새 계약을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="9c828-222">엔드포인트는 "versionOld" 클라이언트에 대해서는 "versionOld" 계약을 노출하면서 계속 표시되고, "versionNew" 클라이언트에 대해서는 "versionNew" 계약을 노출하기 위해 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="9c828-223">주소 및 바인딩 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-223">Address and Binding Versioning</span></span>  

 <span data-ttu-id="9c828-224">클라이언트에서 새 엔드포인트 주소 또는 바인딩을 동적으로 검색할 수 없는 경우, 엔드포인트 주소 및 바인딩에 대한 변경 내용은 주요 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="9c828-225">이 기능을 구현하는 메커니즘 중 하나는 UDDI(Universal Description, Discovery, and Integration) 레지스트리 및 UDDI 호출 패턴을 사용하는 것입니다. 여기서 클라이언트는 엔드포인트와 통신하려고 시도하며, 실패 시 현재 엔드포인트 메타데이터에 대해 잘 알려진 UDDI 레지스트리를 쿼리합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="9c828-226">그런 다음 클라이언트는 이 메타데이터의 주소 및 바인딩을 사용하여 엔드포인트와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="9c828-227">이 통신이 성공하면 클라이언트는 나중에 사용할 수 있도록 주소 및 바인딩 정보를 캐시합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="9c828-228">라우팅 서비스 및 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9c828-228">Routing Service and Versioning</span></span>  

 <span data-ttu-id="9c828-229">서비스 변경이 주요한 변경이고 서로 다른 버전의 서비스를 두 개 이상 동시에 실행해야 하면 WCF 라우팅 서비스를 사용하여 적절한 서비스 인스턴스에 메시지를 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="9c828-230">WCF 라우팅 서비스는 콘텐츠 기반 라우팅을 사용합니다. 즉, 메시지 내의 정보를 사용하여 메시지를 라우팅할 위치를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="9c828-231">WCF 라우팅 서비스에 대 한 자세한 내용은 [라우팅 서비스](./feature-details/routing-service.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9c828-231">For more information about the WCF Routing Service see [Routing Service](./feature-details/routing-service.md).</span></span> <span data-ttu-id="9c828-232">서비스 버전 관리를 위해 WCF 라우팅 서비스를 사용 하는 방법에 대 한 예제는 [방법: 서비스 버전 관리](./feature-details/how-to-service-versioning.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9c828-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](./feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="9c828-233">부록</span><span class="sxs-lookup"><span data-stu-id="9c828-233">Appendix</span></span>  

 <span data-ttu-id="9c828-234">엄격한 버전 관리가 필요한 경우 일반 데이터 계약 버전 관리 지침을 변경 불가능한 데이터 계약으로 간주하고, 변경이 필요한 경우 새 항목을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="9c828-235">새로운 각 데이터 계약에 대해 새 클래스를 만들어야 하므로 이전 데이터 계약 클래스의 측면에서 작성된 기존 코드를 사용하지 않고, 새 데이터 계약 클래스의 측면에서 코드를 새로 작성하기 위한 메커니즘이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="9c828-236">이러한 메커니즘 중 하나는 인터페이스를 사용하여 각 데이터 계약의 멤버를 정의하고, 해당 인터페이스를 구현하는 데이터 계약 클래스가 아닌 인터페이스 측면의 내부 구현 코드를 작성하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="9c828-237">서비스의 버전 1에 대한 다음 코드에서는 `IPurchaseOrderV1` 인터페이스와 `PurchaseOrderV1`을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```csharp  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="9c828-238">서비스 계약 작업은 `PurchaseOrderV1`의 측면에서 작성되지만, 실제 비즈니스 논리는 `IPurchaseOrderV1`의 측면에서 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="9c828-239">그런 다음, 버전 2에서는 다음 코드에서처럼 새 `IPurchaseOrderV2` 인터페이스와 새 `PurchaseOrderV2` 클래스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```csharp
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="9c828-240">서비스 계약이 업데이트되어 `PurchaseOrderV2`의 측면에서 작성되는 새 작업을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="9c828-241">`IPurchaseOrderV1`의 측면에서 작성된 기존 비즈니스 논리라도 `PurchaseOrderV2`에 대한 작업을 계속할 수 있으며, `OrderDate` 속성을 필요로 하는 새 비즈니스 논리도 `IPurchaseOrderV2`의 측면에서 작성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c828-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9c828-242">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9c828-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="9c828-243">데이터 계약 동등성</span><span class="sxs-lookup"><span data-stu-id="9c828-243">Data Contract Equivalence</span></span>](./feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="9c828-244">버전 독립적 Serialization 콜백</span><span class="sxs-lookup"><span data-stu-id="9c828-244">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
