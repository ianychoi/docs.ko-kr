---
title: 세션 사용
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- sessions [WCF]
ms.assetid: 864ba12f-3331-4359-a359-6d6d387f1035
ms.openlocfilehash: 42159b3871d974e53751468b422cbe9f72b6f908
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96273687"
---
# <a name="using-sessions"></a><span data-ttu-id="1f651-102">세션 사용</span><span class="sxs-lookup"><span data-stu-id="1f651-102">Using Sessions</span></span>

<span data-ttu-id="1f651-103">WCF (Windows Communication Foundation) 응용 프로그램에서 *세션* 은 메시지 그룹을 대화에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-103">In Windows Communication Foundation (WCF) applications, a *session* correlates a group of messages into a conversation.</span></span> <span data-ttu-id="1f651-104">WCF 세션은 ASP.NET 응용 프로그램에서 사용할 수 있는 세션 개체와 다르며, 다른 동작을 지원 하 고 다양 한 방법으로 제어 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-104">WCF sessions are different than the session object available in ASP.NET applications, support different behaviors, and are controlled in different ways.</span></span> <span data-ttu-id="1f651-105">이 항목에서는 WCF 응용 프로그램에서 세션을 사용 하는 기능과 사용 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-105">This topic describes the features that sessions enable in WCF applications and how to use them.</span></span>  
  
## <a name="sessions-in-windows-communication-foundation-applications"></a><span data-ttu-id="1f651-106">Windows Communication Foundation 애플리케이션의 세션</span><span class="sxs-lookup"><span data-stu-id="1f651-106">Sessions in Windows Communication Foundation Applications</span></span>  

 <span data-ttu-id="1f651-107">서비스 계약에서 세션이 필요하도록 지정할 경우 해당 계약은 모든 호출(즉, 호출을 지원하는 기본 메시지 교환)이 동일한 대화의 일부가 되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-107">When a service contract specifies that it requires a session, that contract is specifying that all calls (that is, the underlying message exchanges that support the calls) must be part of the same conversation.</span></span> <span data-ttu-id="1f651-108">계약이 세션을 허용하지만 특정 세션이 필요 없음을 지정하는 경우, 클라이언트는 세션을 연결하여 설정하거나 설정하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-108">If a contract specifies that it allows sessions but does not require one, clients can connect and either establish a session or not establish a session.</span></span> <span data-ttu-id="1f651-109">세션이 종료되고 메시지가 동일한 채널을 통해 전송될 경우 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-109">If the session ends and a message is sent through the same channel an exception is thrown.</span></span>  
  
 <span data-ttu-id="1f651-110">WCF 세션에는 다음과 같은 주요 개념 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-110">WCF sessions have the following main conceptual features:</span></span>  
  
- <span data-ttu-id="1f651-111">이러한 기능은 호출 애플리케이션(WCF 클라이언트)에 의해 명시적으로 시작되고 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-111">They are explicitly initiated and terminated by the calling application (the WCF client).</span></span>  
  
- <span data-ttu-id="1f651-112">한 세션 동안 배달된 메시지는 수신된 순서대로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-112">Messages delivered during a session are processed in the order in which they are received.</span></span>  
  
- <span data-ttu-id="1f651-113">세션은 메시지 그룹을 대화에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-113">Sessions correlate a group of messages into a conversation.</span></span> <span data-ttu-id="1f651-114">여러 유형의 상관 관계를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-114">Different types of correlation are possible.</span></span> <span data-ttu-id="1f651-115">예를 들어, 공유된 네트워크 연결을 기반으로 메시지와 연결될 수 있는 세션 기반 채널이 있는 반면 메시지 본문의 공유 태그를 기반으로 메시지와 연결될 수 있는 세션 기반 채널도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-115">For instance, one session-based channel may correlate messages based on a shared network connection while another session-based channel may correlate messages based on a shared tag in the message body.</span></span> <span data-ttu-id="1f651-116">세션에서 파생될 수 있는 기능은 상관 관계의 특성에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-116">The features that can be derived from the session depend on the nature of the correlation.</span></span>  
  
- <span data-ttu-id="1f651-117">WCF 세션과 연결 된 일반 데이터 저장소는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-117">There is no general data store associated with a WCF session.</span></span>  
  
 <span data-ttu-id="1f651-118"><xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType>ASP.NET 응용 프로그램의 클래스와이 클래스에서 제공 하는 기능에 대해 잘 알고 있는 경우 해당 종류의 세션과 WCF 세션 간에 다음과 같은 차이점을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-118">If you are familiar with the <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> class in ASP.NET applications and the functionality it provides, you might notice the following differences between that kind of session and WCF sessions:</span></span>  
  
- <span data-ttu-id="1f651-119">ASP.NET 세션은 항상 서버에서 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-119">ASP.NET sessions are always server-initiated.</span></span>  
  
- <span data-ttu-id="1f651-120">ASP.NET 세션은 암시적으로 순서가 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-120">ASP.NET sessions are implicitly unordered.</span></span>  
  
- <span data-ttu-id="1f651-121">ASP.NET 세션은 요청에 대해 일반 데이터 저장소 메커니즘을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-121">ASP.NET sessions provide a general data storage mechanism across requests.</span></span>  
  
 <span data-ttu-id="1f651-122">이 항목에서는 다음에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-122">This topic describes:</span></span>  
  
- <span data-ttu-id="1f651-123">서비스 모델 계층에서 세션 기반 바인딩을 사용하는 경우 기본 실행 동작</span><span class="sxs-lookup"><span data-stu-id="1f651-123">The default execution behavior when using session-based bindings in the service model layer.</span></span>  
  
- <span data-ttu-id="1f651-124">WCF 세션 기반 시스템 제공 바인딩이 제공 하는 기능 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-124">The types of features that the WCF session-based, system-provided bindings provide.</span></span>  
  
- <span data-ttu-id="1f651-125">세션 요구 사항을 선언하는 계약을 만드는 방법</span><span class="sxs-lookup"><span data-stu-id="1f651-125">How to create a contract that declares a session requirement.</span></span>  
  
- <span data-ttu-id="1f651-126">세션의 생성과 종료 및 세션과 서비스 인스턴스와의 관계를 이해하고 제어하는 방법</span><span class="sxs-lookup"><span data-stu-id="1f651-126">How to understand and control the creation and termination of the session and the relationship of the session to the service instance.</span></span>  
  
## <a name="default-execution-behavior-using-sessions"></a><span data-ttu-id="1f651-127">세션을 사용한 기본 실행 동작</span><span class="sxs-lookup"><span data-stu-id="1f651-127">Default Execution Behavior Using Sessions</span></span>  

 <span data-ttu-id="1f651-128">세션을 초기화하려는 바인딩은 *세션 기반* 바인딩에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-128">A binding that attempts to initiate a session is called a *session-based* binding.</span></span> <span data-ttu-id="1f651-129">서비스 계약에서는 서비스 계약 인터페이스(또는 클래스)의 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 속성을 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 열거형 값 중 하나로 설정하여 세션 기반 바인딩을 필요로 하거나 허용하거나 거부하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-129">Service contracts specify that they require, permit, or refuse session-based bindings by setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property on the service contract interface (or class) to one of the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> enumeration values.</span></span> <span data-ttu-id="1f651-130">기본적으로이 속성의 값은입니다 <xref:System.ServiceModel.SessionMode.Allowed> . 즉, 클라이언트가 WCF 서비스 구현과 함께 세션 기반 바인딩을 사용 하는 경우 서비스는 제공 된 세션을 설정 하 고 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-130">By default, the value of this property is <xref:System.ServiceModel.SessionMode.Allowed>, which means that if a client uses a session-based binding with a WCF service implementation, the service establishes and uses the session provided.</span></span>  
  
 <span data-ttu-id="1f651-131">WCF 서비스가 클라이언트 세션을 허용 하는 경우 기본적으로 다음 기능이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-131">When a WCF service accepts a client session, the following features are enabled by default:</span></span>  
  
1. <span data-ttu-id="1f651-132">WCF 클라이언트 개체 간의 모든 호출은 동일한 서비스 인스턴스에 의해 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-132">All calls between a WCF client object are handled by the same service instance.</span></span>  
  
2. <span data-ttu-id="1f651-133">다른 세션 기반 바인딩은 추가 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-133">Different session-based bindings provide additional features.</span></span>  
  
## <a name="system-provided-session-types"></a><span data-ttu-id="1f651-134">시스템 제공 세션 유형</span><span class="sxs-lookup"><span data-stu-id="1f651-134">System-Provided Session Types</span></span>  

 <span data-ttu-id="1f651-135">세션 기반 바인딩은 서비스 인스턴스와 특정 세션과의 기본 연결을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-135">A session-based binding supports the default association of a service instance with a particular session.</span></span> <span data-ttu-id="1f651-136">그러나 다른 세션 기반 바인딩은 앞서 설명한 세션 기반 인스턴스 만들기를 제어할 수 있는 기능 이외에 다른 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-136">However, different session-based bindings support different features in addition to enabling the session-based instancing control previously described.</span></span>  
  
 <span data-ttu-id="1f651-137">WCF는 다음과 같은 유형의 세션 기반 응용 프로그램 동작을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-137">WCF provides the following types of session-based application behavior:</span></span>  
  
- <span data-ttu-id="1f651-138"><xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> 는 통신의 양쪽 끝에서 특정 보안 대화에 동의한 보안 기반 세션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-138">The <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> supports security-based sessions, in which both ends of communication have agreed upon a specific secure conversation.</span></span> <span data-ttu-id="1f651-139">자세한 내용은 [서비스 보안](securing-services.md)설정을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="1f651-139">For more information, see [Securing Services](securing-services.md).</span></span> <span data-ttu-id="1f651-140">예를 들어, 보안 세션과 신뢰할 수 있는 세션 모두에 대한 지원이 포함된 <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> 바인딩은 기본적으로 메시지에 대해 암호화 및 디지털 서명을 수행하는 보안 세션만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-140">For example, the <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> binding, which contains support for both security sessions and reliable sessions, by default uses only a secure session that encrypts and digitally signs messages.</span></span>  
  
- <span data-ttu-id="1f651-141"><xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> 바인딩은 모든 메시지가 소켓 수준에서 연결을 통해 상호 연결되도록 TCP/IP 기반 세션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-141">The <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> binding supports TCP/IP-based sessions to ensure that all messages are correlated by the connection at the socket level.</span></span>  
  
- <span data-ttu-id="1f651-142">WS-ReliableMessaging 사양을 구현하는 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> 요소는 신뢰할 수 있는 세션에 대한 지원을 제공합니다. 신뢰할 수 있는 세션에서는 메시지를 순서대로 정확히 한 번 배달하도록 구성하여 대화 중에 여러 노드에서 메시지가 전달되는 경우에도 메시지가 수신되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-142">The <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> element, which implements the WS-ReliableMessaging specification, provides support for reliable sessions in which messages can be configured to be delivered in order and exactly once, ensuring messages are received even when messages travel across multiple nodes during the conversation.</span></span> <span data-ttu-id="1f651-143">자세한 내용은 [신뢰할 수 있는 세션](./feature-details/reliable-sessions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="1f651-143">For more information, see [Reliable Sessions](./feature-details/reliable-sessions.md).</span></span>  
  
- <span data-ttu-id="1f651-144"><xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> 바인딩은 MSMQ 데이터그램 세션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-144">The <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> binding provides MSMQ datagram sessions.</span></span> <span data-ttu-id="1f651-145">자세한 내용은 [WCF의 큐](./feature-details/queues-in-wcf.md)를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="1f651-145">For more information, see [Queues in WCF](./feature-details/queues-in-wcf.md).</span></span>  
  
 <span data-ttu-id="1f651-146"><xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> 속성을 설정하면 계약에 필요한 세션 유형을 지정하지 않고 요구만 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-146">Setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property does not specify the type of session the contract requires, only that it requires one.</span></span>  
  
## <a name="creating-a-contract-that-requires-a-session"></a><span data-ttu-id="1f651-147">세션이 필요한 계약 만들기</span><span class="sxs-lookup"><span data-stu-id="1f651-147">Creating a Contract That Requires a Session</span></span>  

 <span data-ttu-id="1f651-148">세션이 필요한 계약을 만들면 서비스 계약이 선언한 작업 그룹 모두가 같은 세션 내에서 실행되고 해당 메시지가 순서대로 배달되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-148">Creating a contract that requires a session states that the group of operations that the service contract declares must all be executed within the same session and that messages must be delivered in order.</span></span> <span data-ttu-id="1f651-149">서비스 계약이 필요한 세션 지원 수준을 어설션하려면 서비스 계약 인터페이스 또는 클래스의 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 속성을 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 열거형 값으로 설정하여 계약에서 다음을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-149">To assert the level of session support that a service contract requires, set the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property on your service contract interface or class to the value of the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> enumeration to specify whether the contract:</span></span>  
  
- <span data-ttu-id="1f651-150">세션이 필요한지 여부</span><span class="sxs-lookup"><span data-stu-id="1f651-150">Requires a session.</span></span>  
  
- <span data-ttu-id="1f651-151">클라이언트가 세션을 설정하도록 허용할지 여부</span><span class="sxs-lookup"><span data-stu-id="1f651-151">Allows a client to establish a session.</span></span>  
  
- <span data-ttu-id="1f651-152">세션을 금지할지 여부</span><span class="sxs-lookup"><span data-stu-id="1f651-152">Prohibits a session.</span></span>  
  
 <span data-ttu-id="1f651-153">그러나 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> 속성을 설정하면 계약에 필요한 세션 기반 동작 유형을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-153">Setting the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property does not, however, specify the type of session-based behavior the contract requires.</span></span> <span data-ttu-id="1f651-154">WCF는 런타임에 서비스에 대해 구성 된 바인딩 (통신 채널 생성)이 서비스를 구현할 때 세션을 수행 하는지 여부를 확인 하도록 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-154">It instructs WCF to confirm at runtime that the configured binding (which creates the communication channel) for the service does, does not, or can establish a session when implementing a service.</span></span> <span data-ttu-id="1f651-155">또한 바인딩은 보안 동작, 전송 동작, 신뢰할 수 있는 동작 또는 이러한 동작의 조합 중에서 선택한 세션 기반 동작 유형과 함께 해당 요구 사항을 충족할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-155">Again, the binding can satisfy that requirement with any type of session-based behavior it chooses—security, transport, reliable, or some combination.</span></span> <span data-ttu-id="1f651-156">정확한 동작은 선택한 <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> 값에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-156">The exact behavior depends on the <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> value selected.</span></span> <span data-ttu-id="1f651-157">서비스에 대해 구성된 바인딩이 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>의 값을 준수하지 않는 경우 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-157">If the configured binding of the service does not conform to the value of <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>, an exception is thrown.</span></span> <span data-ttu-id="1f651-158">바인딩 및 세션을 지원하도록 바인딩이 만든 채널을 세션 기반이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-158">Bindings and the channels they create that support sessions are said to be session-based.</span></span>  
  
 <span data-ttu-id="1f651-159">다음 서비스 계약은 `ICalculatorSession` 의 모든 작업이 세션 내에서 교환되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-159">The following service contract specifies that all operations in the `ICalculatorSession` must be exchanged within a session.</span></span> <span data-ttu-id="1f651-160">`Equals` 메서드를 제외하고 호출자에게 값을 반환하는 작업은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-160">None of the operations returns a value to the caller except the `Equals` method.</span></span> <span data-ttu-id="1f651-161">그러나 `Equals` 메서드는 매개 변수를 가져오지 않기 때문에 다른 작업에 데이터를 이미 전달한 세션 내에서 0이 아닌 값만 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-161">However, the `Equals` method takes no parameters and, therefore, can only return a non-zero value inside a session in which data has already been passed to the other operations.</span></span> <span data-ttu-id="1f651-162">이 계약에서 세션이 제대로 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-162">This contract requires a session to function properly.</span></span> <span data-ttu-id="1f651-163">특정 클라이언트와 연결된 세션 없이 서비스 인스턴스는 이 클라이언트가 보낸 이전 데이터를 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-163">Without a session associated with a specific client, the service instance has no way of knowing what previous data this client has sent.</span></span>  
  
 [!code-csharp[S_Service_Session#1](../../../samples/snippets/csharp/VS_Snippets_CFX/s_service_session/cs/service.cs#1)]
 [!code-vb[S_Service_Session#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_service_session/vb/service.vb#1)]  
  
 <span data-ttu-id="1f651-164">서비스에서 세션을 허용하는 경우 클라이언트가 세션을 초기화하면 세션이 설정되어 사용됩니다. 그렇지 않으면 세션이 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-164">If a service allows a session, then a session is established and used if the client initiates one; otherwise, no session is established.</span></span>  
  
## <a name="sessions-and-service-instances"></a><span data-ttu-id="1f651-165">세션 및 서비스 인스턴스</span><span class="sxs-lookup"><span data-stu-id="1f651-165">Sessions and Service Instances</span></span>  

 <span data-ttu-id="1f651-166">WCF에서 기본 인스턴스 만들기 동작을 사용 하는 경우 WCF 클라이언트 개체 간의 모든 호출은 동일한 서비스 인스턴스에 의해 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-166">If you use the default instancing behavior in WCF, all calls between a WCF client object are handled by the same service instance.</span></span> <span data-ttu-id="1f651-167">따라서 애플리케이션 수준에서 세션은 로컬 호출 동작과 비슷하게 애플리케이션 동작을 사용한다고 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-167">Therefore, at the application level, you can think of a session as enabling application behavior similar to local call behavior.</span></span> <span data-ttu-id="1f651-168">예를 들어, 로컬 개체를 만들 때 다음이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-168">For example, when you create a local object:</span></span>  
  
- <span data-ttu-id="1f651-169">생성자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-169">A constructor is called.</span></span>  
  
- <span data-ttu-id="1f651-170">WCF 클라이언트 개체 참조에 대해 수행 되는 모든 후속 호출은 동일한 개체 인스턴스에 의해 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-170">All subsequent calls made to the WCF client object reference are processed by the same object instance.</span></span>  
  
- <span data-ttu-id="1f651-171">개체 참조가 소멸되면 소멸자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-171">A destructor is called when the object reference is destroyed.</span></span>  
  
 <span data-ttu-id="1f651-172">세션에서는 기본 서비스 인스턴스 동작이 사용되는 한 클라이언트와 서비스 간의 비슷한 동작을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-172">Sessions enable a similar behavior between clients and services as long as the default service instance behavior is used.</span></span> <span data-ttu-id="1f651-173">서비스 계약에서 세션이 필요하거나 지원하는 경우 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 및 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> 속성을 설정하여 하나 이상의 계약 작업을 세션 시작 또는 세션 종료로 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-173">If a service contract requires or supports sessions, one or more contract operations can be marked as initiating or terminating a session by setting the <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> and <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> properties.</span></span>  
  
 <span data-ttu-id="1f651-174">*시작 작업* 은 새 세션의 첫 번째 작업으로 호출해야 하는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-174">*Initiating operations* are those that must be called as the first operation of a new session.</span></span> <span data-ttu-id="1f651-175">하나 이상의 작업을 호출한 후에만 시작 작업이 아닌 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-175">Non-initiating operations can be called only after at least one initiating operation has been called.</span></span> <span data-ttu-id="1f651-176">따라서 서비스 인스턴스 시작에 해당하는 클라이언트에서 입력을 가져오도록 디자인된 시작 작업을 선언하여 해당 서비스에 맞는 특정 유형의 세션 생성자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-176">You can therefore create a kind of session constructor for your service by declaring initiating operations designed to take input from clients appropriate to the beginning of the service instance.</span></span> <span data-ttu-id="1f651-177">상태는 세션과 연결되지만 서비스 개체와 연결되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-177">(The state is associated with the session, however, and not the service object.)</span></span>  
  
 <span data-ttu-id="1f651-178">반대로 *종료 작업* 은 기존 세션에서 마지막 메시지로 호출해야 하는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-178">*Terminating operations*, conversely, are those that must be called as the last message in an existing session.</span></span> <span data-ttu-id="1f651-179">기본적으로 WCF에서는 서비스와 연결된 세션이 닫힌 후에 서비스 개체 및 컨텍스트를 재활용합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-179">In the default case, WCF recycles the service object and its context after the session with which the service was associated is closed.</span></span> <span data-ttu-id="1f651-180">따라서 서비스 인스턴스의 마지막에 해당하는 기능을 수행하도록 디자인된 종료 작업을 선언하여 특정 유형의 소멸자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-180">You can, therefore, create a kind of destructor by declaring terminating operations designed to perform a function appropriate to the end of the service instance.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1f651-181">기본 동작은 로컬 생성자 및 소멸자와 비슷하지만 일치하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-181">Although the default behavior bears a resemblance to local constructors and destructors, it is only a resemblance.</span></span> <span data-ttu-id="1f651-182">모든 WCF 서비스 작업은 시작 또는 종료 작업 이거나 동시에 두 작업을 모두 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-182">Any WCF service operation can be an initiating or terminating operation, or both at the same time.</span></span> <span data-ttu-id="1f651-183">또한 기본적으로 횟수와 순서에 관계없이 시작 작업을 호출할 수 있습니다. <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> 개체를 조작하여 서비스 인스턴스의 수명을 명시적으로 지정하지 않는 한 세션이 설정되고 인스턴스와 연결되면 추가 세션이 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-183">In addition, in the default case, initiating operations can be called any number of times in any order; no additional sessions are created once the session is established and associated with an instance unless you explicitly control the lifetime of the service instance (by manipulating the <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> object).</span></span> <span data-ttu-id="1f651-184">마지막으로 상태는 세션과 연결되고 서비스 개체와는 연결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-184">Finally, the state is associated with the session and not the service object.</span></span>  
  
 <span data-ttu-id="1f651-185">예를 들어 `ICalculatorSession` 앞의 예제에서 사용 된 계약을 사용 하려면 wcf 클라이언트 개체가 먼저 `Clear` 다른 작업을 수행 하기 전에 작업을 호출 해야 하며,이 wcf 클라이언트 개체를 사용 하는 세션은 작업을 호출할 때 종료 되어야 합니다 `Equals` .</span><span class="sxs-lookup"><span data-stu-id="1f651-185">For example, the `ICalculatorSession` contract used in the preceding example requires that the WCF client object first call the `Clear` operation prior to any other operation and that the session with this WCF client object should terminate when it calls the `Equals` operation.</span></span> <span data-ttu-id="1f651-186">다음 코드 예제에서는 이러한 요구 사항을 적용하는 계약을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-186">The following code example shows a contract that enforces these requirements.</span></span> <span data-ttu-id="1f651-187">먼저`Clear` 를 호출하여 세션을 시작해야 하며, `Equals` 을 호출하면 세션이 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-187">`Clear` must be called first to initiate a session, and that session ends when `Equals` is called.</span></span>  
  
 [!code-csharp[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/csharp/VS_Snippets_CFX/sca.isinitiatingisterminating/cs/service.cs#1)]
 [!code-vb[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/sca.isinitiatingisterminating/vb/service.vb#1)]  
  
 <span data-ttu-id="1f651-188">서비스는 클라이언트와 함께 세션을 시작하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-188">Services do not start sessions with clients.</span></span> <span data-ttu-id="1f651-189">WCF 클라이언트 응용 프로그램에서 세션 기반 채널의 수명과 세션 자체의 수명 사이에 직접적인 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-189">In WCF client applications, a direct relationship exists between the lifetime of the session-based channel and the lifetime of the session itself.</span></span> <span data-ttu-id="1f651-190">예를 들어, 클라이언트는 새 세션 기반 채널을 만들어 새 세션을 만들고 세션 기반 채널을 정상적으로 닫아서 기존 세션을 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-190">As such, clients create new sessions by creating new session-based channels and tear down existing sessions by closing session-based channels gracefully.</span></span> <span data-ttu-id="1f651-191">클라이언트는 다음 중 하나를 호출하여 서비스 엔드포인트와 함께 세션을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-191">A client starts a session with a service endpoint by calling one of the following:</span></span>  
  
- <span data-ttu-id="1f651-192"><xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> 에 대한 호출을 통해 반환된 채널의 <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="1f651-192"><xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on the channel returned by a call to <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="1f651-193"><xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType>[ServiceModel Metadata 유틸리티 도구 (Svcutil.exe)](servicemodel-metadata-utility-tool-svcutil-exe.md)에서 생성 한 WCF 클라이언트 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-193"><xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType> on the WCF client object generated by the [ServiceModel Metadata Utility Tool (Svcutil.exe)](servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span>  
  
- <span data-ttu-id="1f651-194">WCF 클라이언트 개체의 각 형식에 대 한 시작 작업 (기본적으로 모든 작업이 시작 됨)</span><span class="sxs-lookup"><span data-stu-id="1f651-194">An initiating operation on either type of WCF client object (by default, all operations are initiating).</span></span> <span data-ttu-id="1f651-195">첫 번째 작업을 호출 하면 WCF 클라이언트 개체가 자동으로 채널을 열고 세션을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-195">When the first operation is called, the WCF client object automatically opens the channel and initiates a session.</span></span>  
  
 <span data-ttu-id="1f651-196">일반적으로 클라이언트는 다음 중 하나를 호출하여 서비스 엔드포인트와 함께 세션을 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-196">Typically a client ends a session with a service endpoint by calling one of the following:</span></span>  
  
- <span data-ttu-id="1f651-197"><xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 에 대한 호출을 통해 반환된 채널의 <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="1f651-197"><xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> on the channel returned by a call to <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="1f651-198"><xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> Svcutil.exe에서 생성 된 WCF 클라이언트 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-198"><xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> on the WCF client object generated by Svcutil.exe.</span></span>  
  
- <span data-ttu-id="1f651-199">WCF 클라이언트 개체의 두 형식에 대 한 종료 작업입니다. 기본적으로 작업은 종료 되지 않으며 계약은 종료 작업을 명시적으로 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-199">A terminating operation on either type of WCF client object (by default, no operations are terminating; the contract must explicitly specify a terminating operation).</span></span> <span data-ttu-id="1f651-200">첫 번째 작업을 호출 하면 WCF 클라이언트 개체가 자동으로 채널을 열고 세션을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-200">When the first operation is called, the WCF client object automatically opens the channel and initiates a session.</span></span>  
  
 <span data-ttu-id="1f651-201">예를 들어, [How to: Create a Service That Requires Sessions](./feature-details/how-to-create-a-service-that-requires-sessions.md) , [Default Service Behavior](./samples/default-service-behavior.md) 및 [Instancing](./samples/instancing.md) 샘플을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1f651-201">For examples, see [How to: Create a Service That Requires Sessions](./feature-details/how-to-create-a-service-that-requires-sessions.md) as well as the [Default Service Behavior](./samples/default-service-behavior.md) and [Instancing](./samples/instancing.md) samples.</span></span>  
  
 <span data-ttu-id="1f651-202">클라이언트 및 세션에 대 한 자세한 내용은 [WCF 클라이언트를 사용 하 여 서비스 액세스](./feature-details/accessing-services-using-a-client.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="1f651-202">For more information about clients and sessions, see [Accessing Services Using a WCF Client](./feature-details/accessing-services-using-a-client.md).</span></span>  
  
## <a name="sessions-interact-with-instancecontext-settings"></a><span data-ttu-id="1f651-203">세션이 InstanceContext 설정과 상호 작용</span><span class="sxs-lookup"><span data-stu-id="1f651-203">Sessions Interact with InstanceContext Settings</span></span>  

 <span data-ttu-id="1f651-204">계약의 <xref:System.ServiceModel.SessionMode> 열거형과 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 속성 간에 상호 작용이 있으며, 이를 통해 채널과 특정 서비스 개체 간의 연결을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-204">There is an interaction between the <xref:System.ServiceModel.SessionMode> enumeration in a contract and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property, which controls the association between channels and specific service objects.</span></span> <span data-ttu-id="1f651-205">자세한 내용은 [세션, 인스턴스 및 동시성](./feature-details/sessions-instancing-and-concurrency.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="1f651-205">For more information, see [Sessions, Instancing, and Concurrency](./feature-details/sessions-instancing-and-concurrency.md).</span></span>  
  
### <a name="sharing-instancecontext-objects"></a><span data-ttu-id="1f651-206">InstanceContext 개체 공유</span><span class="sxs-lookup"><span data-stu-id="1f651-206">Sharing InstanceContext Objects</span></span>  

 <span data-ttu-id="1f651-207">또한 해당 연결을 직접 수행하여 <xref:System.ServiceModel.InstanceContext> 개체와 연결된 세션 기반 채널 또는 호출을 제어할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-207">You can also control which session-based channel or call is associated with which <xref:System.ServiceModel.InstanceContext> object by performing that association yourself.</span></span>
  
## <a name="sessions-and-streaming"></a><span data-ttu-id="1f651-208">세션 및 스트리밍</span><span class="sxs-lookup"><span data-stu-id="1f651-208">Sessions and Streaming</span></span>  

 <span data-ttu-id="1f651-209">전송할 데이터가 많은 경우 WCF의 스트리밍 전송 모드는 메모리에서 메시지를 전체적으로 버퍼링 하 고 처리 하는 기본 동작에 대 한 적절 한 대안입니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-209">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span> <span data-ttu-id="1f651-210">세션 기반 바인딩을 통해 스트리밍 호출이 수행될 경우 예기치 못한 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="1f651-211">모든 스트리밍 호출은 사용 중인 바인딩이 세션을 사용하도록 구성된 경우에도 세션을 지원하지 않는 하나의 채널(데이터그램 채널)을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="1f651-212">여러 클라이언트에서 세션 기반 바인딩을 통해 동일한 서비스 개체에 대한 스트리밍 호출을 수행하고, 서비스 개체의 동시성 모드가 단일 모드로 설정되고, 서비스 개체의 인스턴스 컨텍스트 모드가 `PerSession`으로 설정된 경우, 모든 호출은 데이터그램 채널을 통해 수행되므로 한 번에 하나의 호출만 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-212">If multiple clients make streaming calls to the same service object over a session-based binding, and the service object's concurrency mode is set to single and its instance context mode is set to `PerSession`, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="1f651-213">하나 이상의 클라이언트에서 시간 초과가 발생할 수 있습니다. 서비스 개체의 `InstanceContextMode` 를로 설정 `PerCall` 하거나 동시성을 다중으로 설정 하 여이 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-213">One or more clients may then time out. You can work around this issue by either setting the service object's `InstanceContextMode` to `PerCall` or Concurrency to multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1f651-214">이 경우 사용할 수 있는 "세션"이 하나이기 때문에 MaxConcurrentSessions에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1f651-214">MaxConcurrentSessions have no effect in this case because there is only one "session" available.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1f651-215">참고 항목</span><span class="sxs-lookup"><span data-stu-id="1f651-215">See also</span></span>

- <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>
- <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>
