---
title: 서비스 채널 수준 프로그래밍
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 8d8dcd85-0a05-4c44-8861-4a0b3b90cca9
ms.openlocfilehash: db50d385bd396ba4de74e08fc1c6d93a67f320b7
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96290220"
---
# <a name="service-channel-level-programming"></a><span data-ttu-id="bb337-102">서비스 채널 수준 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="bb337-102">Service Channel-Level Programming</span></span>

<span data-ttu-id="bb337-103">이 항목에서는 <xref:System.ServiceModel.ServiceHost?displayProperty=nameWithType> 및 관련 개체 모델을 사용 하지 않고 WCF (Windows Communication Foundation) 서비스 응용 프로그램을 작성 하는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-103">This topic describes how to write a Windows Communication Foundation (WCF) service application without using the <xref:System.ServiceModel.ServiceHost?displayProperty=nameWithType> and its associated object model.</span></span>  
  
## <a name="receiving-messages"></a><span data-ttu-id="bb337-104">메시지 받기</span><span class="sxs-lookup"><span data-stu-id="bb337-104">Receiving Messages</span></span>  

 <span data-ttu-id="bb337-105">메시지를 받은 다음 처리할 준비를 하려면 다음 단계가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-105">To be ready to receive and process messages, the following steps are required:</span></span>  
  
1. <span data-ttu-id="bb337-106">바인딩을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-106">Create a binding.</span></span>  
  
2. <span data-ttu-id="bb337-107">채널 수신기를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-107">Build a channel listener.</span></span>  
  
3. <span data-ttu-id="bb337-108">채널 수신기를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-108">Open the channel listener.</span></span>  
  
4. <span data-ttu-id="bb337-109">요청을 읽고 회신을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-109">Read the request and send a reply.</span></span>  
  
5. <span data-ttu-id="bb337-110">모든 채널 개체를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-110">Close all channel objects.</span></span>  
  
#### <a name="creating-a-binding"></a><span data-ttu-id="bb337-111">바인딩 만들기</span><span class="sxs-lookup"><span data-stu-id="bb337-111">Creating a Binding</span></span>  

 <span data-ttu-id="bb337-112">메시지를 수신 대기하고 받는 첫 번째 단계는 바인딩을 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-112">The first step in listening for and receiving messages is creating a binding.</span></span> <span data-ttu-id="bb337-113">WCF는 하나를 인스턴스화하여 직접 사용할 수 있는 몇 가지 기본 제공 또는 시스템 제공 바인딩을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-113">WCF ships with several built-in or system-provided bindings that can be used directly by instantiating one of them.</span></span> <span data-ttu-id="bb337-114">또한 목록 1의 코드가 수행하는 작업인 CustomBinding 클래스를 인스턴스화하여 사용자 지정 바인딩을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-114">In addition, you can also create your own custom binding by instantiating a CustomBinding class which is what the code in listing 1 does.</span></span>  
  
 <span data-ttu-id="bb337-115">아래의 코드 예제에서는 <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType>의 인스턴스를 만들고 <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType>를 채널 스택을 빌드하는 데 사용되는 바인딩 요소의 컬렉션인 해당 요소 컬렉션에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-115">The code example below creates an instance of <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType> and adds an <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType> to its Elements collection which is a collection of binding elements that are used to build the channel stack.</span></span> <span data-ttu-id="bb337-116">이 예제에서는 요소 컬렉션에 <xref:System.ServiceModel.Channels.HttpTransportBindingElement>만 있으므로 결과 채널 스택에는 HTTP 전송 채널만 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-116">In this example, because the elements collection has only the <xref:System.ServiceModel.Channels.HttpTransportBindingElement>, the resulting channel stack has only the HTTP transport channel.</span></span>  
  
#### <a name="building-a-channellistener"></a><span data-ttu-id="bb337-117">ChannelListener 빌드</span><span class="sxs-lookup"><span data-stu-id="bb337-117">Building a ChannelListener</span></span>  

 <span data-ttu-id="bb337-118">바인딩을 만든 후에 <xref:System.ServiceModel.Channels.Binding.BuildChannelListener%2A?displayProperty=nameWithType>을 호출하여 형식 매개 변수가 만들 채널 셰이프인 채널 수신기를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-118">After creating a binding, we call <xref:System.ServiceModel.Channels.Binding.BuildChannelListener%2A?displayProperty=nameWithType> to build the channel listener where the type parameter is the channel shape to create.</span></span> <span data-ttu-id="bb337-119">이 예제에서는 요청/회신 메시지 교환 패턴으로 들어오는 메시지를 수신 대기하려고 하므로 <xref:System.ServiceModel.Channels.IReplyChannel?displayProperty=nameWithType>을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-119">In this example we are using <xref:System.ServiceModel.Channels.IReplyChannel?displayProperty=nameWithType> because we want to listen for incoming messages in a request/reply message exchange pattern.</span></span>  
  
 <span data-ttu-id="bb337-120"><xref:System.ServiceModel.Channels.IReplyChannel>은 요청 메시지를 받고 회신 메시지를 다시 보내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-120"><xref:System.ServiceModel.Channels.IReplyChannel> is used for receiving request messages and sending back reply messages.</span></span> <span data-ttu-id="bb337-121"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A?displayProperty=nameWithType>를 호출하면 요청 메시지를 받고 회신 메시지를 다시 보내는 데 사용할 수 있는 <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-121">Calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A?displayProperty=nameWithType> returns an <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>, which can be used to receive the request message and to send back a reply message.</span></span>  
  
 <span data-ttu-id="bb337-122">수신기를 만들 때 수신하는 네트워크 주소를 전달합니다. 이 경우는 `http://localhost:8080/channelapp`입니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-122">When creating the listener, we pass the network address on which it listens, in this case `http://localhost:8080/channelapp`.</span></span> <span data-ttu-id="bb337-123">일반적으로 각 전송 채널은 하나 또는 여러 개의 주소 스키마를 지원합니다. 예를 들면 HTTP 전송은 http와 https 스키마를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-123">In general, each transport channel supports one or possibly several address schemes, for example, the HTTP transport supports both http and https schemes.</span></span>  
  
 <span data-ttu-id="bb337-124">또한 수신기를 만들 때 빈 <xref:System.ServiceModel.Channels.BindingParameterCollection?displayProperty=nameWithType>을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-124">We also pass an empty <xref:System.ServiceModel.Channels.BindingParameterCollection?displayProperty=nameWithType> when creating the listener.</span></span> <span data-ttu-id="bb337-125">바인딩 매개 변수는 수신기가 빌드되는 방식을 제어하는 매개 변수를 전달하는 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-125">A binding parameter is a mechanism to pass parameters that control how the listener should be built.</span></span> <span data-ttu-id="bb337-126">예제에서는 그러한 매개 변수를 사용하지 않으므로 빈 컬렉션을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-126">In our example, we are not using any such parameters so we pass an empty collection.</span></span>  
  
#### <a name="listening-for-incoming-messages"></a><span data-ttu-id="bb337-127">들어오는 메시지 수신 대기</span><span class="sxs-lookup"><span data-stu-id="bb337-127">Listening for Incoming Messages</span></span>  

 <span data-ttu-id="bb337-128">수신기에서 <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType>을 호출하고 채널을 수락합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-128">We then call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on the listener and start accepting channels.</span></span> <span data-ttu-id="bb337-129"><xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>의 동작은 전송이 연결 지향인지, 연결 지양인지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-129">The behavior of <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> depends on whether the transport is connection-oriented or connection-less.</span></span> <span data-ttu-id="bb337-130">연결 지향 전송에서 <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A>은 새 연결 요청이 들어올 때까지 차단됩니다. 이 시점에서 새 연결을 나타내는 새 채널을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-130">For connection-oriented transports, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> blocks until a new connection request comes in at which point it returns a new channel that represents that new connection.</span></span> <span data-ttu-id="bb337-131">HTTP와 같은 연결 지양 전송에서 <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A>은 전송 수신기가 만드는 유일한 채널과 함께 즉시 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-131">For connection-less transports, such as HTTP, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> returns immediately with the one and only channel that the transport listener creates.</span></span>  
  
 <span data-ttu-id="bb337-132">이 예제에서 수신기는 <xref:System.ServiceModel.Channels.IReplyChannel>을 구현하는 채널을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-132">In this example, the listener returns a channel that implements <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span> <span data-ttu-id="bb337-133">이 채널에서 메시지를 받기 위해 먼저 <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType>을 호출하여 통신 준비 상태로 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-133">To receive messages on this channel we first call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on it to place it in a state ready for communication.</span></span> <span data-ttu-id="bb337-134">그런 다음 메시지가 도착할 때까지 차단되는 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-134">We then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> which blocks until a message arrives.</span></span>  
  
#### <a name="reading-the-request-and-sending-a-reply"></a><span data-ttu-id="bb337-135">요청 읽기 및 회신 보내기</span><span class="sxs-lookup"><span data-stu-id="bb337-135">Reading the Request and Sending a Reply</span></span>  

 <span data-ttu-id="bb337-136"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>가 <xref:System.ServiceModel.Channels.RequestContext>를 반환하면 <xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A> 속성을 사용하여 받은 메시지를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-136">When <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> returns a <xref:System.ServiceModel.Channels.RequestContext>, we get the received message using its <xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A> property.</span></span> <span data-ttu-id="bb337-137">메시지 동작 및 본문 내용(문자열)을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-137">We write out the message’s action and body content, (which we assume is a string).</span></span>  
  
 <span data-ttu-id="bb337-138">회신을 보내려면 이 경우 요청에서 받은 문자열 데이터를 다시 전달하는 새 회신 메시지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-138">To send a reply, we create a new reply message in this case passing back the string data we received in the request.</span></span> <span data-ttu-id="bb337-139">그런 다음 <xref:System.ServiceModel.Channels.RequestContext.Reply%2A>를 호출하여 회신 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-139">We then call <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> to send the reply message.</span></span>  
  
#### <a name="closing-objects"></a><span data-ttu-id="bb337-140">개체 닫기</span><span class="sxs-lookup"><span data-stu-id="bb337-140">Closing Objects</span></span>  

 <span data-ttu-id="bb337-141">리소스 누수를 방지하려면 통신에 사용된 개체가 더 이상 필요하지 않은 경우 그 개체를 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-141">To avoid leaking resources, it is very important to close objects used in communications when they are no longer required.</span></span> <span data-ttu-id="bb337-142">이 예제에서는 요청 메시지, 요청 컨텍스트, 채널 및 수신기를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-142">In this example we close the request message, the request context, the channel and the listener.</span></span>  
  
 <span data-ttu-id="bb337-143">다음 코드 예제에서는 채널 수신기가 한 메시지만 받는 기본 서비스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-143">The following code example shows a basic service in which a channel listener receives only one message.</span></span> <span data-ttu-id="bb337-144">실제 서비스는 서비스가 종료될 때까지 채널을 계속 수락하고 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="bb337-144">A real service keeps accepting channels and receiving messages until the service exits.</span></span>  
  
 [!code-csharp[ChannelProgrammingBasic#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/channelprogrammingbasic/cs/serviceprogram.cs#1)]
 [!code-vb[ChannelProgrammingBasic#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/channelprogrammingbasic/vb/serviceprogram.vb#1)]
