---
description: '자세히 알아보기: 상태 변경 이해'
title: 상태 변경 이해
ms.date: 03/30/2017
ms.assetid: a79ed2aa-e49a-47a8-845a-c9f436ec9987
ms.openlocfilehash: e537a7421ffa8ab924e4e9e4ab841343245534b2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99644010"
---
# <a name="understanding-state-changes"></a><span data-ttu-id="c4d7d-103">상태 변경 이해</span><span class="sxs-lookup"><span data-stu-id="c4d7d-103">Understanding State Changes</span></span>

<span data-ttu-id="c4d7d-104">이 항목에서는 채널에 있는 상태와 전이, 채널 상태의 구조 지정에 사용되는 형식, 그리고 구현 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-104">This topic discusses the states and transitions that channels have, the types used to structure channel states, and how to implement them.</span></span>  
  
## <a name="state-machines-and-channels"></a><span data-ttu-id="c4d7d-105">상태 시스템 및 채널</span><span class="sxs-lookup"><span data-stu-id="c4d7d-105">State Machines and Channels</span></span>  

 <span data-ttu-id="c4d7d-106">소켓과 같이 통신을 처리하는 개체는 보통 상태 전이와 네트워크 리소스 할당, 연결 시작 및 수락, 연결 닫기 및 통신 종료 등이 관련된 상태 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-106">Objects that deal with communication, for example sockets, usually present a state machine whose state transitions relate to allocating network resources, making or accepting connections, closing connections and terminating communication.</span></span> <span data-ttu-id="c4d7d-107">채널 상태 시스템에서는 개체의 기본 구현을 요약하는 통신 개체의 상태에 대한 균일 모델을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-107">The channel state machine provides a uniform model of the states of a communication object that abstracts the underlying implementation of that object.</span></span> <span data-ttu-id="c4d7d-108"><xref:System.ServiceModel.ICommunicationObject> 인터페이스에서는 상태 집합, 상태 전이 메서드 및 상태 전이 이벤트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-108">The <xref:System.ServiceModel.ICommunicationObject> interface provides a set of states, state transition methods and state transition events.</span></span> <span data-ttu-id="c4d7d-109">모든 채널, 채널 팩터리 및 채널 수신기는 채널 상태 시스템을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-109">All channels, channel factories and channel listeners implement the channel state machine.</span></span>  
  
 <span data-ttu-id="c4d7d-110">Closed, Closing, Faulted, Opened 및 Opening 이벤트는 상태 전이가 발생한 후에 외부의 관찰자에게 해당 사실을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-110">The events Closed, Closing, Faulted, Opened and Opening signal an external observer after a state transition occurs.</span></span>  
  
 <span data-ttu-id="c4d7d-111">Abort, Close 및 Open 메서드와 이에 해당되는 비동기 이벤트는 상태 전이를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-111">The methods Abort, Close, and Open (and their asynchronous equivalents) cause state transitions.</span></span>  
  
 <span data-ttu-id="c4d7d-112">상태 속성은 <xref:System.ServiceModel.CommunicationState>에서 정의한 현재 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-112">The state property returns the current state as defined by <xref:System.ServiceModel.CommunicationState>:</span></span>  
  
## <a name="icommunicationobject-communicationobject-and-states-and-state-transition"></a><span data-ttu-id="c4d7d-113">ICommunicationObject, CommunicationObject와 상태 및 상태 전이</span><span class="sxs-lookup"><span data-stu-id="c4d7d-113">ICommunicationObject, CommunicationObject, and States and State Transition</span></span>  

 <span data-ttu-id="c4d7d-114"><xref:System.ServiceModel.ICommunicationObject>는 다양한 속성을 구성할 수 있는 만듦 상태에서 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-114">An <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state where its various properties can be configured.</span></span> <span data-ttu-id="c4d7d-115">열림 상태가 된 개체는 메시지 보내기와 받기에 사용할 수 있지만 해당 속성은 변경할 수 없는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-115">Once in the Opened state, the object is usable for sending and receiving messages but its properties are considered immutable.</span></span> <span data-ttu-id="c4d7d-116">Closing 상태가 된 개체는 더 이상 새 보내기 또는 받기 요청을 처리할 수 없지만 기존 요청은 Close 제한 시간에 도달할 때까지 완료할 기회가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-116">Once in the Closing state, the object can no longer process new send or receive requests, but existing requests have a chance to complete until the Close timeout is reached.</span></span>  <span data-ttu-id="c4d7d-117">복구할 수 없는 오류가 발생한 경우 개체는 Faulted 상태로 전이되며, 해당 상태에서 오류에 대한 정보가 검사된 후 결국 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-117">If an unrecoverable error occurs, the object transitions to the Faulted state where it can be inspected for information about the error and ultimately closed.</span></span> <span data-ttu-id="c4d7d-118">Closed 상태에 있는 개체는 기본적으로 상태 시스템의 끝에 도달한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-118">When in the Closed state the object has essentially reached the end of the state machine.</span></span> <span data-ttu-id="c4d7d-119">개체가 한 상태에서 다음 상태로 전이되고 나면 이전 상태로 돌아가지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-119">Once an object transitions from one state to the next, it does not go back to a previous state.</span></span>  
  
 <span data-ttu-id="c4d7d-120">다음 다이어그램은 <xref:System.ServiceModel.ICommunicationObject> 상태 및 상태 전이를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-120">The following diagram shows the <xref:System.ServiceModel.ICommunicationObject> states and state transitions.</span></span> <span data-ttu-id="c4d7d-121">상태 전이는 Abort, Open 또는 Close의 세 가지 메서드 중 하나를 호출하여 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-121">State transitions can be caused by calling one of the three methods: Abort, Open, or Close.</span></span> <span data-ttu-id="c4d7d-122">다른 구현 관련 메서드를 호출하여 일으킬 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-122">They could also be caused by calling other implementation-specific methods.</span></span> <span data-ttu-id="c4d7d-123">Faulted 상태로의 전이는 통신 개체를 여는 도중이나 열고 난 후에 오류가 발생한 경우 일어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-123">Transitioning to the Faulted state could happen as a result of errors while opening or after having opened the communication object.</span></span>  
  
 <span data-ttu-id="c4d7d-124">모든 <xref:System.ServiceModel.ICommunicationObject>는 만듦 상태로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-124">Every <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state.</span></span> <span data-ttu-id="c4d7d-125">이 상태에서는 애플리케이션이 속성을 설정하여 개체를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-125">In this state, an application can configure the object by setting its properties.</span></span> <span data-ttu-id="c4d7d-126">개체가 Created 외의 상태가 되면 변경할 수 없는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-126">Once an object is in a state other than Created, it is considered immutable.</span></span>  
  
 ![채널 상태 전환의 데이터 흐름 다이어그램](./media/understanding-state-changes/channel-state-transitions.gif)  
<span data-ttu-id="c4d7d-128">그림 1.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-128">Figure 1.</span></span> <span data-ttu-id="c4d7d-129">ICommunicationObject 상태 시스템.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-129">The ICommunicationObject State Machine.</span></span>  
  
 <span data-ttu-id="c4d7d-130">WCF (Windows Communication Foundation)는 <xref:System.ServiceModel.Channels.CommunicationObject> 및 채널 상태 시스템을 구현 하는 라는 추상 기본 클래스를 제공 <xref:System.ServiceModel.ICommunicationObject> 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-130">Windows Communication Foundation (WCF) provides an abstract base class named <xref:System.ServiceModel.Channels.CommunicationObject> that implements <xref:System.ServiceModel.ICommunicationObject> and the channel state machine.</span></span> <span data-ttu-id="c4d7d-131">다음 그래픽은 <xref:System.ServiceModel.Channels.CommunicationObject>에 적용되는 수정된 상태 다이어그램입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-131">The following graphic is a modified state diagram that is specific to <xref:System.ServiceModel.Channels.CommunicationObject>.</span></span> <span data-ttu-id="c4d7d-132">여기에는 <xref:System.ServiceModel.ICommunicationObject> 상태 시스템 외에도 추가 <xref:System.ServiceModel.Channels.CommunicationObject> 메서드가 호출되는 타이밍이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-132">In addition to the <xref:System.ServiceModel.ICommunicationObject> state machine, it shows the timing when additional <xref:System.ServiceModel.Channels.CommunicationObject> methods are invoked.</span></span>  
  
 <span data-ttu-id="c4d7d-133">![CommunicationObject 구현 상태 변경 내용에 대 한 데이터 흐름 다이어그램](./media/understanding-state-changes/communicationobject-implementation-state-machine.gif)</span><span class="sxs-lookup"><span data-stu-id="c4d7d-133">![Dataflow diagram of CommunicationObject implementation state changes.](./media/understanding-state-changes/communicationobject-implementation-state-machine.gif)</span></span>
<span data-ttu-id="c4d7d-134">그림 2.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-134">Figure 2.</span></span> <span data-ttu-id="c4d7d-135">이벤트 및 보호된 메서드 호출을 포함한 ICommunicationObject 상태 시스템의 CommunicationObject 구현</span><span class="sxs-lookup"><span data-stu-id="c4d7d-135">The CommunicationObject implementation of the ICommunicationObject state machine including calls to events and protected methods.</span></span>  
  
### <a name="icommunicationobject-events"></a><span data-ttu-id="c4d7d-136">ICommunicationObject 이벤트</span><span class="sxs-lookup"><span data-stu-id="c4d7d-136">ICommunicationObject Events</span></span>  

 <span data-ttu-id="c4d7d-137"><xref:System.ServiceModel.Channels.CommunicationObject>는 <xref:System.ServiceModel.ICommunicationObject>에 정의된 5개의 이벤트를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-137"><xref:System.ServiceModel.Channels.CommunicationObject> exposes the five events defined by <xref:System.ServiceModel.ICommunicationObject>.</span></span> <span data-ttu-id="c4d7d-138">이러한 이벤트는 통신 개체를 사용하는 코드에 상태 전이를 알리는 데 사용하도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-138">These events are designed for code using the communication object to be notified of state transitions.</span></span> <span data-ttu-id="c4d7d-139">위의 그림 2에 표시된 것과 같이 각 이벤트는 이벤트에서 명명된 상태로 개체의 상태 전이가 이루어진 후에 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-139">As shown in Figure 2 above, each event is fired once after the object’s state transitions to the state named by the event.</span></span> <span data-ttu-id="c4d7d-140">5개의 이벤트는 모두 다음과 같이 정의되는 `EventHandler` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-140">All five events are of the `EventHandler` type which is defined as:</span></span>  
  
 `public delegate void EventHandler(object sender, EventArgs e);`  
  
 <span data-ttu-id="c4d7d-141"><xref:System.ServiceModel.Channels.CommunicationObject> 구현에서 발신자는 <xref:System.ServiceModel.Channels.CommunicationObject> 자체이거나 <xref:System.ServiceModel.Channels.CommunicationObject> 생성자에 발신자로 전달되는 항목입니다(해당 생성자 오버로드를 사용하는 경우).</span><span class="sxs-lookup"><span data-stu-id="c4d7d-141">In the <xref:System.ServiceModel.Channels.CommunicationObject> implementation, the sender is either the <xref:System.ServiceModel.Channels.CommunicationObject> itself or whatever was passed in as the sender to the <xref:System.ServiceModel.Channels.CommunicationObject> constructor (if that constructor overload was used).</span></span> <span data-ttu-id="c4d7d-142">EventArgs 매개 변수 `e`는 항상 `EventArgs.Empty`입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-142">The EventArgs parameter, `e`, is always `EventArgs.Empty`.</span></span>  
  
### <a name="derived-object-callbacks"></a><span data-ttu-id="c4d7d-143">파생된 개체 콜백</span><span class="sxs-lookup"><span data-stu-id="c4d7d-143">Derived Object Callbacks</span></span>  

 <span data-ttu-id="c4d7d-144"><xref:System.ServiceModel.Channels.CommunicationObject>에서는 5개의 이벤트 외에도 상태 전이가 일어나기 전후에 파생된 개체를 콜백할 수 있도록 디자인된 8개의 보호된 가상 메서드를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-144">In addition to the five events, <xref:System.ServiceModel.Channels.CommunicationObject> declares eight protected virtual methods designed to allow a derived object to be called back before and after state transitions occur.</span></span>  
  
 <span data-ttu-id="c4d7d-145"><xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> 메서드에는 이러한 3개의 콜백이 각각 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-145">The <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> methods have three such callbacks associated with each of them.</span></span> <span data-ttu-id="c4d7d-146">예를 들어, <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType>에 해당되는 것으로 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-146">For example, corresponding to <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> there is <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c4d7d-147"><xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType>에는 <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> 메서드가 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-147">Associated with <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> are the <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="c4d7d-148">마찬가지로 <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> 메서드에는 해당 <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-148">Similarly, the <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> method has a corresponding <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c4d7d-149"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>에는 기본 구현이 없지만 다른 콜백에는 상태 시스템의 정확성을 위해 필요한 기본 구현이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-149">While <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> have no default implementation, the other callbacks do have a default implementation which is necessary for state machine correctness.</span></span> <span data-ttu-id="c4d7d-150">해당 메서드를 재정의하는 경우에는 기본 구현을 호출하거나 올바르게 대체해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-150">If you override those methods be sure to call the base implementation or correctly replace it.</span></span>  
  
 <span data-ttu-id="c4d7d-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType>는 해당 <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> 이벤트를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> events.</span></span> <span data-ttu-id="c4d7d-152"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType>는 각각 개체 상태를 Opened와 Closed로 설정한 다음 해당되는 <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> 및 <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> 이벤트를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-152"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> set the object state to Opened and Closed respectively then fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> events.</span></span>  
  
### <a name="state-transition-methods"></a><span data-ttu-id="c4d7d-153">상태 전이 메서드</span><span class="sxs-lookup"><span data-stu-id="c4d7d-153">State Transition Methods</span></span>  

 <span data-ttu-id="c4d7d-154"><xref:System.ServiceModel.Channels.CommunicationObject>에서는 Abort, Close 및 Open의 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-154"><xref:System.ServiceModel.Channels.CommunicationObject> provides implementations of Abort, Close and Open.</span></span> <span data-ttu-id="c4d7d-155">또한 Faulted 상태로 상태 전이를 일으키는 Fault 메서드도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-155">It also provides a Fault method which causes a state transition to the Faulted state.</span></span> <span data-ttu-id="c4d7d-156">그림 2는 전이를 일으키는 각 메서드가 레이블로 표시된 <xref:System.ServiceModel.ICommunicationObject> 상태 시스템을 보여 줍니다. 레이블이 없는 전이는 레이블이 있는 마지막 전이를 일으킨 메서드의 구현 내에서 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-156">Figure 2 shows the <xref:System.ServiceModel.ICommunicationObject> state machine with each transition labeled by the method that causes it (unlabeled transitions happen inside the implementation of the method that caused the last labeled transition).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c4d7d-157">통신 상태 가져오기/설정의 모든 <xref:System.ServiceModel.Channels.CommunicationObject> 구현은 스레드로 동기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-157">All <xref:System.ServiceModel.Channels.CommunicationObject> implementations of communication state gets/sets are thread-synchronized.</span></span>  
  
 <span data-ttu-id="c4d7d-158">생성자</span><span class="sxs-lookup"><span data-stu-id="c4d7d-158">Constructor</span></span>  
  
 <span data-ttu-id="c4d7d-159"><xref:System.ServiceModel.Channels.CommunicationObject>에서는 3개의 생성자를 제공하며, 이들 생성자는 모두 개체를 만듦 상태로 남겨 둡니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-159"><xref:System.ServiceModel.Channels.CommunicationObject> provides three constructors, all of which leave the object in the Created state.</span></span> <span data-ttu-id="c4d7d-160">생성자는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-160">The constructors are defined as:</span></span>  
  
 <span data-ttu-id="c4d7d-161">첫 번째 생성자는 개체를 사용 하는 생성자 오버 로드에 위임 하는 매개 변수가 없는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-161">The first constructor is a parameterless constructor that delegates to the constructor overload that takes an object:</span></span>  
  
 `protected CommunicationObject() : this(new object()) { … }`  
  
 <span data-ttu-id="c4d7d-162">개체를 받는 생성자에서는 해당 매개 변수를 통신 개체 상태에 대한 액세스를 동기화할 때 잠글 개체로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-162">The constructor that takes an object uses that parameter as the object to be locked when synchronizing access to communication object state:</span></span>  
  
 `protected CommunicationObject(object mutex) { … }`  
  
 <span data-ttu-id="c4d7d-163">마지막으로 세 번째 생성자는 <xref:System.ServiceModel.ICommunicationObject> 이벤트를 시작할 때 발신자 인수로 사용되는 추가 매개 변수를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-163">Finally, a third constructor takes an additional parameter that is used as the sender argument when <xref:System.ServiceModel.ICommunicationObject> events are fired.</span></span>  
  
 `protected CommunicationObject(object mutex, object eventSender) { … }`  
  
 <span data-ttu-id="c4d7d-164">앞의 두 생성자에서 해당 발신자를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-164">The previous two constructors set the sender to this.</span></span>  
  
 <span data-ttu-id="c4d7d-165">Open 메서드</span><span class="sxs-lookup"><span data-stu-id="c4d7d-165">Open Method</span></span>  
  
 <span data-ttu-id="c4d7d-166">사전 조건: 상태는 Created.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-166">Precondition: State is Created.</span></span>  
  
 <span data-ttu-id="c4d7d-167">사후 조건: 상태는 Opened 또는 Faulted.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-167">Post-condition: State is Opened or Faulted.</span></span> <span data-ttu-id="c4d7d-168">예외가 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-168">May throw an exception.</span></span>  
  
 <span data-ttu-id="c4d7d-169">Open() 메서드에서는 통신 개체를 열고 상태를 Opened로 설정하려 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-169">The Open() method will try to open the communication object and set the state to Opened.</span></span> <span data-ttu-id="c4d7d-170">여기서 오류가 발견되면 상태를 Faulted로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-170">If it encounters an error, it will set the state to Faulted.</span></span>  
  
 <span data-ttu-id="c4d7d-171">메서드에서는 먼저 현재 상태가 Created인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-171">The method first checks that the current state is Created.</span></span> <span data-ttu-id="c4d7d-172">현재 상태가 Opening 또는 Opened이면 <xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-172">If the current state is Opening or Opened it throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="c4d7d-173">현재 상태가 Closing 또는 Closed이면 개체가 종료된 경우 <xref:System.ServiceModel.CommunicationObjectAbortedException>, 그렇지 않은 경우 <xref:System.ObjectDisposedException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-173">If the current state is Closing or Closed, it throws a <xref:System.ServiceModel.CommunicationObjectAbortedException> if the object has been terminated and <xref:System.ObjectDisposedException> otherwise.</span></span> <span data-ttu-id="c4d7d-174">현재 상태가 Faulted인 경우에는 <xref:System.ServiceModel.CommunicationObjectFaultedException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-174">If the current state is Faulted, it throws a <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span></span>  
  
 <span data-ttu-id="c4d7d-175">다음으로는 상태를 Opening으로 설정하고 Opening 이벤트를 일으키는 OnOpening()과 OnOpen() 및 OnOpened()를 차례로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-175">It then sets the state to Opening and calls OnOpening() (which raises the Opening event), OnOpen() and OnOpened() in that order.</span></span> <span data-ttu-id="c4d7d-176">OnOpened()에서는 상태를 Opened로 설정하고 Opened 이벤트를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-176">OnOpened() sets the state to Opened and raises the Opened event.</span></span> <span data-ttu-id="c4d7d-177">이 과정 중에 예외가 throw되면 Open()에서는 Fault()를 호출하고 예외를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-177">If any of these throws an exception, Open()calls Fault() and lets the exception bubble up.</span></span> <span data-ttu-id="c4d7d-178">다음 다이어그램은 Open 프로세스를 보다 자세히 나타낸 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-178">The following diagram shows the Open process in more detail.</span></span>  
  
 ![ICommunicationObject 상태 변경 내용에 대 한 데이터 흐름 다이어그램](./media/understanding-state-changes/ico-open-process-override-onopen.gif)  
<span data-ttu-id="c4d7d-180">내부 통신 개체 열기 등의 사용자 지정 열기 논리를 구현하려면 OnOpen 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-180">Override the OnOpen method to implement custom open logic such as opening an inner communication object.</span></span>  
  
 <span data-ttu-id="c4d7d-181">Close 메서드</span><span class="sxs-lookup"><span data-stu-id="c4d7d-181">Close Method</span></span>  
  
 <span data-ttu-id="c4d7d-182">사전 조건: 없음.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-182">Precondition: None.</span></span>  
  
 <span data-ttu-id="c4d7d-183">사후 조건: 상태는 Closed.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-183">Post-condition: State is Closed.</span></span> <span data-ttu-id="c4d7d-184">예외가 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-184">May throw an exception.</span></span>  
  
 <span data-ttu-id="c4d7d-185">Close() 메서드는 어느 상태에서나 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-185">The Close() method can be called at any state.</span></span> <span data-ttu-id="c4d7d-186">여기서는 개체를 정상적으로 닫으려 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-186">It tries to close the object normally.</span></span> <span data-ttu-id="c4d7d-187">오류가 발생하면 개체를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-187">If an error is encountered, it terminates the object.</span></span> <span data-ttu-id="c4d7d-188">현재 상태가 Closing 또는 Closed이면 이 메서드에서는 아무 것도 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-188">The method does nothing if the current state is Closing or Closed.</span></span> <span data-ttu-id="c4d7d-189">그렇지 않으면 상태를 Closing으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-189">Otherwise it sets the state to Closing.</span></span> <span data-ttu-id="c4d7d-190">원래 상태가 Created, Opening 또는 Faulted이면 Abort()를 호출합니다(다음 다이어그램 참조).</span><span class="sxs-lookup"><span data-stu-id="c4d7d-190">If the original state was Created, Opening or Faulted, it calls Abort() (see the following diagram).</span></span> <span data-ttu-id="c4d7d-191">원래 상태가 Opened이면 Closing 이벤트를 일으키는 OnClosing()과 OnClose() 및 OnClosed()를 순서대로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-191">If the original state was Opened, it calls OnClosing() (which raises the Closing event), OnClose() and OnClosed() in that order.</span></span> <span data-ttu-id="c4d7d-192">이 과정 중에 예외가 throw되면 Close()에서는 Abort()를 호출하고 예외를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-192">If any of these throws an exception, Close()calls Abort() and lets the exception bubble up.</span></span> <span data-ttu-id="c4d7d-193">OnClosed()에서는 상태를 Closed로 설정하고 Closed 이벤트를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-193">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="c4d7d-194">다음 다이어그램은 Close 프로세스를 보다 자세히 나타낸 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-194">The following diagram shows the Close process in more detail.</span></span>  
  
 ![ICommunicationObject 상태 변경 내용에 대 한 데이터 흐름 다이어그램](./media/understanding-state-changes/ico-close-process-override-onclose.gif)  
<span data-ttu-id="c4d7d-196">내부 통신 개체 닫기 등의 사용자 지정 닫기 논리를 구현하려면 OnClose 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-196">Override the OnClose method to implement custom close logic, such as closing an inner communication object.</span></span> <span data-ttu-id="c4d7d-197">장기적으로 차단될 수 있는 모든 정상적인 닫기 논리는(예: 다른 쪽의 응답을 기다리는 경우) 제한 시간 매개 변수를 받고 Abort()의 일부로 호출되지 않기 때문에 OnClose()에 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-197">All graceful closing logic that may block for a long time (for example, waiting for the other side to respond) should be implemented in OnClose() because it takes a timeout parameter and because it is not called as part of Abort().</span></span>  
  
 <span data-ttu-id="c4d7d-198">중단</span><span class="sxs-lookup"><span data-stu-id="c4d7d-198">Abort</span></span>  
  
 <span data-ttu-id="c4d7d-199">사전 조건: 없음.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-199">Precondition: None.</span></span>  
<span data-ttu-id="c4d7d-200">사후 조건: 상태는 Closed.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-200">Post-condition: State is Closed.</span></span> <span data-ttu-id="c4d7d-201">예외가 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-201">May throw an exception.</span></span>  
  
 <span data-ttu-id="c4d7d-202">현재 상태가 Closed이거나 이전에 개체가 다른 스레드에서 Abort()를 실행하는 등의 방법으로 종료된 경우에는 Abort() 메서드에서 아무 것도 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-202">The Abort() method does nothing if the current state is Closed or if the object has been terminated before (for example, possibly by having Abort() executing on another thread).</span></span> <span data-ttu-id="c4d7d-203">그렇지 않은 경우에는 상태를 Closing으로 설정하고 Closing 이벤트를 일으키는 OnClosing()과 OnAbort() 및 OnClosed()를 순서대로 호출합니다. 개체를 닫는 경우가 아니라 종료하는 경우이기 때문에 OnClose는 호출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-203">Otherwise it sets the state to Closing and calls OnClosing() (which raises the Closing event), OnAbort(), and OnClosed() in that order (does not call OnClose because the object is being terminated, not closed).</span></span> <span data-ttu-id="c4d7d-204">OnClosed()에서는 상태를 Closed로 설정하고 Closed 이벤트를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-204">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="c4d7d-205">이 과정에서 예외가 throw되면 Abort의 호출자에게 예외가 다시 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-205">If any of these throw an exception, it is re-thrown to the caller of Abort.</span></span> <span data-ttu-id="c4d7d-206">OnClosing(), OnClosed() 및 OnAbort()의 구현은 입력/출력 등을 차단하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-206">Implementations of OnClosing(), OnClosed() and OnAbort() should not block (for example, on input/output).</span></span> <span data-ttu-id="c4d7d-207">다음 다이어그램은 Abort 프로세스를 보다 자세히 나타낸 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-207">The following diagram shows the Abort process in more detail.</span></span>  
  
 ![ICommunicationObject 상태 변경 내용에 대 한 데이터 흐름 다이어그램](./media/understanding-state-changes/ico-abort-process-override-onabort.gif)  
<span data-ttu-id="c4d7d-209">내부 통신 개체 종료 등의 사용자 지정 종료 논리를 구현하려면 OnAbort 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-209">Override the OnAbort method to implement custom terminate logic such as terminating an inner communication object.</span></span>  
  
 <span data-ttu-id="c4d7d-210">오류</span><span class="sxs-lookup"><span data-stu-id="c4d7d-210">Fault</span></span>  
  
 <span data-ttu-id="c4d7d-211">Fault 메서드는 <xref:System.ServiceModel.Channels.CommunicationObject>에 적용되며 <xref:System.ServiceModel.ICommunicationObject> 인터페이스의 일부가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-211">The Fault method is specific to <xref:System.ServiceModel.Channels.CommunicationObject> and is not part of the <xref:System.ServiceModel.ICommunicationObject> interface.</span></span> <span data-ttu-id="c4d7d-212">여기서는 완전성을 위해 함께 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-212">It is included here for completeness.</span></span>  
  
 <span data-ttu-id="c4d7d-213">사전 조건: 없음.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-213">Precondition: None.</span></span>  
  
 <span data-ttu-id="c4d7d-214">사후 조건: 상태는 Faulted.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-214">Post-condition: State is Faulted.</span></span> <span data-ttu-id="c4d7d-215">예외가 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-215">May throw an exception.</span></span>  
  
 <span data-ttu-id="c4d7d-216">현재 상태가 Faulted 또는 Closed이면 Fault() 메서드에서 아무 것도 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-216">The Fault() method does nothing if the current state is Faulted or Closed.</span></span> <span data-ttu-id="c4d7d-217">그렇지 않은 경우에는 상태를 Faulted로 설정하고 Faulted 이벤트를 일으키는 OnFaulted()를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-217">Otherwise it sets the state to Faulted and call OnFaulted(), which raises the Faulted event.</span></span> <span data-ttu-id="c4d7d-218">OnFaulted에서 예외가 throw되면 다시 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-218">If OnFaulted throws an exception it is re-thrown.</span></span>  
  
### <a name="throwifxxx-methods"></a><span data-ttu-id="c4d7d-219">ThrowIfXxx 메서드</span><span class="sxs-lookup"><span data-stu-id="c4d7d-219">ThrowIfXxx Methods</span></span>  

 <span data-ttu-id="c4d7d-220">CommunicationObject에는 개체가 특정 상태에 있을 때 예외를 throw하는 데 사용되는 보호된 메서드가 3개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-220">CommunicationObject has three protected methods that can be used to throw exceptions if the object is in a specific state.</span></span>  
  
 <span data-ttu-id="c4d7d-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A>에서는 상태가 Closing, Closed 또는 Faulted인 경우에 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> throws an exception if the state is Closing, Closed or Faulted.</span></span>  
  
 <span data-ttu-id="c4d7d-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A>에서는 상태가 Created가 아닌 경우에 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> throws an exception if the state is not Created.</span></span>  
  
 <span data-ttu-id="c4d7d-223"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A>에서는 상태가 Opened가 아닌 경우에 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-223"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> throws an exception if the state is not Opened.</span></span>  
  
 <span data-ttu-id="c4d7d-224">throw되는 예외는 상태에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-224">The exceptions thrown depend on the state.</span></span> <span data-ttu-id="c4d7d-225">다음 표에서는 여러 상태 및 해당 상태에서 ThrowIfXxx를 호출하면 throw되는 해당 예외 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-225">The following table shows the different states and the corresponding exception type thrown by calling a ThrowIfXxx that throws on that state.</span></span>  
  
|<span data-ttu-id="c4d7d-226">시스템 상태</span><span class="sxs-lookup"><span data-stu-id="c4d7d-226">State</span></span>|<span data-ttu-id="c4d7d-227">Abort 호출 여부</span><span class="sxs-lookup"><span data-stu-id="c4d7d-227">Has Abort been called?</span></span>|<span data-ttu-id="c4d7d-228">예외</span><span class="sxs-lookup"><span data-stu-id="c4d7d-228">Exception</span></span>|  
|-----------|----------------------------|---------------|  
|<span data-ttu-id="c4d7d-229">생성일</span><span class="sxs-lookup"><span data-stu-id="c4d7d-229">Created</span></span>|<span data-ttu-id="c4d7d-230">해당 없음</span><span class="sxs-lookup"><span data-stu-id="c4d7d-230">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="c4d7d-231">열기</span><span class="sxs-lookup"><span data-stu-id="c4d7d-231">Opening</span></span>|<span data-ttu-id="c4d7d-232">해당 없음</span><span class="sxs-lookup"><span data-stu-id="c4d7d-232">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="c4d7d-233">열림</span><span class="sxs-lookup"><span data-stu-id="c4d7d-233">Opened</span></span>|<span data-ttu-id="c4d7d-234">해당 없음</span><span class="sxs-lookup"><span data-stu-id="c4d7d-234">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="c4d7d-235">닫기</span><span class="sxs-lookup"><span data-stu-id="c4d7d-235">Closing</span></span>|<span data-ttu-id="c4d7d-236">예</span><span class="sxs-lookup"><span data-stu-id="c4d7d-236">Yes</span></span>|<xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>|  
|<span data-ttu-id="c4d7d-237">닫기</span><span class="sxs-lookup"><span data-stu-id="c4d7d-237">Closing</span></span>|<span data-ttu-id="c4d7d-238">아니요</span><span class="sxs-lookup"><span data-stu-id="c4d7d-238">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="c4d7d-239">닫힘</span><span class="sxs-lookup"><span data-stu-id="c4d7d-239">Closed</span></span>|<span data-ttu-id="c4d7d-240">예</span><span class="sxs-lookup"><span data-stu-id="c4d7d-240">Yes</span></span>|<span data-ttu-id="c4d7d-241">이전에 명시적인 Abort 호출로 개체가 닫힌 경우 <xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-241"><xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType> in the case that an object was closed by a previous and explicit call of Abort.</span></span> <span data-ttu-id="c4d7d-242">개체에서 Close를 호출하면 <xref:System.ObjectDisposedException?displayProperty=nameWithType>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-242">If you call Close on the object then an <xref:System.ObjectDisposedException?displayProperty=nameWithType> is thrown.</span></span>|  
|<span data-ttu-id="c4d7d-243">닫힘</span><span class="sxs-lookup"><span data-stu-id="c4d7d-243">Closed</span></span>|<span data-ttu-id="c4d7d-244">아니요</span><span class="sxs-lookup"><span data-stu-id="c4d7d-244">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="c4d7d-245">오류</span><span class="sxs-lookup"><span data-stu-id="c4d7d-245">Faulted</span></span>|<span data-ttu-id="c4d7d-246">해당 없음</span><span class="sxs-lookup"><span data-stu-id="c4d7d-246">N/A</span></span>|<xref:System.ServiceModel.CommunicationObjectFaultedException?displayProperty=nameWithType>|  
  
### <a name="timeouts"></a><span data-ttu-id="c4d7d-247">시간 제한</span><span class="sxs-lookup"><span data-stu-id="c4d7d-247">Timeouts</span></span>  

 <span data-ttu-id="c4d7d-248">지금까지 설명한 메서드 중 일부는 시간 제한 매개 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-248">Several of the methods we discussed take timeout parameters.</span></span> <span data-ttu-id="c4d7d-249">Close, Open(일부 오버로드 및 비동기 버전), OnClose 및 OnOpen이 여기에 해당됩니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-249">These are Close, Open (certain overloads and asynchronous versions), OnClose and OnOpen.</span></span> <span data-ttu-id="c4d7d-250">이러한 메서드는 연결을 정상적으로 닫는 동안 입력/출력을 차단하는 등의 오래 걸리는 작업이 가능하도록 디자인되었기 때문에 시간 제한 매개 변수는 인터럽트되기 전에 이러한 작업에 사용할 수 있는 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-250">These methods are designed to allow for lengthy operations (for example, blocking on input/output while gracefully closing down a connection) so the timeout parameter indicates how long such operations can take before being interrupted.</span></span> <span data-ttu-id="c4d7d-251">이러한 메서드의 구현에서는 제공된 시간 제한 값을 사용하여 제한 시간 내에 호출자에게 반환되게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-251">Implementations of any of these methods should use the supplied timeout value to ensure it returns to the caller within that timeout.</span></span> <span data-ttu-id="c4d7d-252">시간 제한을 사용하지 않는 다른 메서드의 구현은 오래 걸리는 작업을 위해 디자인되어 있지 않으며 입력/출력을 차단하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-252">Implementations of other methods that do not take a timeout are not designed for lengthy operations and should not block on input/output.</span></span>  
  
 <span data-ttu-id="c4d7d-253">시간 제한을 사용하지 않는 Open() 및 Close() 오버로드는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-253">The exception are the Open() and Close() overloads that do not take a timeout.</span></span> <span data-ttu-id="c4d7d-254">파생된 클래스가 제공한 기본 시간 제한 값을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-254">These use a default timeout value supplied by the derived class.</span></span> <span data-ttu-id="c4d7d-255"><xref:System.ServiceModel.Channels.CommunicationObject>는 다음과 같이 정의된 <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A>과 <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A>이라는 두 가지 보호된 추상 속성을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-255"><xref:System.ServiceModel.Channels.CommunicationObject> exposes two protected abstract properties named <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> defined as:</span></span>  
  
 `protected abstract TimeSpan DefaultCloseTimeout { get; }`  
  
 `protected abstract TimeSpan DefaultOpenTimeout { get; }`  
  
 <span data-ttu-id="c4d7d-256">파생된 클래스에서는 이러한 속성을 구현하여 시간 제한 값을 받지 않는 Open() 및 Close() 오버로드에 기본 시간 제한 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-256">A derived class implements these properties to provide the default timeout for the Open() and Close() overloads that do not take a timeout value.</span></span> <span data-ttu-id="c4d7d-257">그러면 Open() 및 Close() 구현에서는 예를 들어 시간 제한 값을 받는 오버로드에 기본 시간 제한 값을 다음과 같이 위임합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-257">Then the Open() and Close() implementations delegate to the overload that takes a timeout passing it the default timeout value, for example:</span></span>  
  
 `public void Open()`  
  
 `{`  
  
 `this.Open(this.DefaultOpenTimeout);`  
  
 `}`  
  
#### <a name="idefaultcommunicationtimeouts"></a><span data-ttu-id="c4d7d-258">IDefaultCommunicationTimeouts</span><span class="sxs-lookup"><span data-stu-id="c4d7d-258">IDefaultCommunicationTimeouts</span></span>  

 <span data-ttu-id="c4d7d-259">이 인터페이스에는 열기, 보내기, 받기 및 닫기에 대해 기본 시간 제한 값을 제공하는 4개의 읽기 전용 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-259">This interface has four read-only properties for providing default timeout values for open, send, receive, and close.</span></span> <span data-ttu-id="c4d7d-260">각 구현은 적절한 모든 방법으로 기본값을 가져오는 일을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-260">Each implementation is responsible for obtaining the default values in whatever manner appropriate.</span></span> <span data-ttu-id="c4d7d-261">편의상 <xref:System.ServiceModel.Channels.ChannelFactoryBase> 및 <xref:System.ServiceModel.Channels.ChannelListenerBase>에서는 이 기본값을 각각 1분으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c4d7d-261">As a convenience, <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase> default these values to 1 minute each.</span></span>
