---
title: WCF 단순화 기능
ms.date: 03/30/2017
ms.assetid: 4535a511-6064-4da0-b361-80262a891663
ms.openlocfilehash: 8a818ec0852cfae20ef23fede04b55b08a7449a5
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95732920"
---
# <a name="wcf-simplification-features"></a><span data-ttu-id="5acec-102">WCF 단순화 기능</span><span class="sxs-lookup"><span data-stu-id="5acec-102">WCF Simplification Features</span></span>

<span data-ttu-id="5acec-103">이 항목에서는 WCF 애플리케이션을 더 간단하게 작성할 수 있는 새로운 기능에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-103">This topic discusses new features that make writing WCF applications simpler.</span></span>

## <a name="simplified-generated-configuration-files"></a><span data-ttu-id="5acec-104">단순화되어 생성된 구성 파일</span><span class="sxs-lookup"><span data-stu-id="5acec-104">Simplified Generated Configuration Files</span></span>

<span data-ttu-id="5acec-105">Visual Studio에 서비스 참조를 추가하거나 SvcUtil.exe 도구를 사용하면 클라이언트 구성 파일이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-105">When you add a service reference in Visual Studio or use the SvcUtil.exe tool a client configuration file is generated.</span></span> <span data-ttu-id="5acec-106">이전 버전의 WCF에서는 바인딩 속성 값이 기본값인 경우를 포함하여 모든 바인딩 속성 값이 이러한 구성 파일에 포함되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-106">In previous versions of WCF these configuration files contained the value of every binding property even if its value is the default value.</span></span> <span data-ttu-id="5acec-107">WCF 4.5에서는 생성된 구성 파일에 기본값이 아닌 값으로 설정된 바인딩 속성만 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-107">In WCF 4.5 the generated configuration files contain only those binding properties that are set to a non-default value.</span></span>

<span data-ttu-id="5acec-108">다음은 WCF 3.0에서 생성된 구성 파일의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-108">The following is an example of a configuration file generated by WCF 3.0.</span></span>

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <system.serviceModel>
        <bindings>
            <basicHttpBinding>
                <binding name="BasicHttpBinding_IService1" closeTimeout="00:01:00"
                    openTimeout="00:01:00" receiveTimeout="00:10:00" sendTimeout="00:01:00"
                    allowCookies="false" bypassProxyOnLocal="false"
                    hostNameComparisonMode="StrongWildcard" maxBufferSize="65536"
                    maxBufferPoolSize="524288" maxReceivedMessageSize="65536"
                    messageEncoding="Text" textEncoding="utf-8" transferMode="Buffered"
                    useDefaultWebProxy="true">
                    <readerQuotas maxDepth="32" maxStringContentLength="8192"
                        maxArrayLength="16384" maxBytesPerRead="4096"
                        maxNameTableCharCount="16384" />
                    <security mode="None">
                        <transport clientCredentialType="None" proxyCredentialType="None"
                            realm="" />
                        <message clientCredentialType="UserName" algorithmSuite="Default" />
                    </security>
                </binding>
            </basicHttpBinding>
        </bindings>
        <client>
            <endpoint address="http://localhost:36906/Service1.svc" binding="basicHttpBinding"
                bindingConfiguration="BasicHttpBinding_IService1" contract="IService1"
                name="BasicHttpBinding_IService1" />
        </client>
    </system.serviceModel>
</configuration>
```

<span data-ttu-id="5acec-109">다음은 WCF 4.5에서 생성된 동일한 구성 파일의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-109">The following is an example of the same configuration file generated by WCF 4.5.</span></span>

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <system.serviceModel>
        <bindings>
            <basicHttpBinding>
                <binding name="BasicHttpBinding_IService1" />
            </basicHttpBinding>
        </bindings>
        <client>
            <endpoint address="http://localhost:36906/Service1.svc" binding="basicHttpBinding"
                bindingConfiguration="BasicHttpBinding_IService1" contract="IService1"
                name="BasicHttpBinding_IService1" />
        </client>
    </system.serviceModel>
</configuration>
```

## <a name="contract-first-development"></a><span data-ttu-id="5acec-110">계약 중심 개발</span><span class="sxs-lookup"><span data-stu-id="5acec-110">Contract-First Development</span></span>

<span data-ttu-id="5acec-111">WCF는 이제 계약 중심 개발을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-111">WCF now has support for contract-first development.</span></span> <span data-ttu-id="5acec-112">svcutil.exe 도구에는 WSDL 문서에서 서비스 및 데이터 계약을 생성할 수 있는/serviceContract 스위치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-112">The svcutil.exe tool has a /serviceContract switch which allows you to generate service and data contracts from a WSDL document.</span></span>

## <a name="add-service-reference-from-a-portable-subset-project"></a><span data-ttu-id="5acec-113">이식 가능한 하위 집합 프로젝트의 서비스 참조 추가</span><span class="sxs-lookup"><span data-stu-id="5acec-113">Add Service Reference From a Portable Subset Project</span></span>

<span data-ttu-id="5acec-114">이식 가능한 하위 집합 프로젝트를 사용 하면 .NET 어셈블리 프로그래머는 여러 .NET 구현 (데스크톱, Silverlight, Windows Phone 및 Xbox)을 계속 지원 하면서 단일 소스 트리 및 빌드 시스템을 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-114">Portable subset projects enable .NET assembly programmers to maintain a single source tree and build system while still supporting multiple .NET implementations (desktop, Silverlight, Windows Phone, and Xbox).</span></span> <span data-ttu-id="5acec-115">이식 가능한 하위 집합 프로젝트는 .NET 구현에서 사용할 수 있는 어셈블리인 .NET 이식 가능한 라이브러리만 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-115">Portable subset projects only reference .NET portable libraries that are assemblies that can be used on any .NET implementation.</span></span> <span data-ttu-id="5acec-116">개발자 환경은 다른 WCF 클라이언트 애플리케이션에 서비스 참조를 추가하는 것과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-116">The developer experience is the same as adding a service reference within any other WCF client application.</span></span> <span data-ttu-id="5acec-117">자세한 내용은 [이식 가능한 하위 집합 프로젝트의 서비스 참조 추가](add-service-reference-in-a-portable-subset-project.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5acec-117">For more information, see [Add Service Reference in a Portable Subset Project](add-service-reference-in-a-portable-subset-project.md).</span></span>

## <a name="aspnet-compatibility-mode-default-changed"></a><span data-ttu-id="5acec-118">ASP.NET 호환 모드 기본값 변경</span><span class="sxs-lookup"><span data-stu-id="5acec-118">ASP.NET Compatibility Mode Default Changed</span></span>

<span data-ttu-id="5acec-119">WCF는 개발자가 WCF 서비스를 작성할 때 ASP.NET HTTP 파이프라인 기능에 완전하게 액세스할 수 있게 해 주는 ASP.NET 호환 모드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-119">WCF provides ASP.NET compatibility mode to grant developers full access to the features in the ASP.NET HTTP pipeline when writing WCF services.</span></span> <span data-ttu-id="5acec-120">이 모드를 사용 하려면 `aspNetCompatibilityEnabled` web.config의 섹션에서 특성을 true로 설정 해야 합니다 [\<serviceHostingEnvironment>](../configure-apps/file-schema/wcf/servicehostingenvironment.md) . 또한이 appDomain의 모든 서비스에는 `RequirementsMode` 속성이 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> 또는로 설정 되어 있어야 합니다 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Required> .</span><span class="sxs-lookup"><span data-stu-id="5acec-120">To use this mode, you must set the `aspNetCompatibilityEnabled` attribute to true in the [\<serviceHostingEnvironment>](../configure-apps/file-schema/wcf/servicehostingenvironment.md) section of web.config. Additionally, any service in this appDomain needs to have the `RequirementsMode` property on its <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> set to <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> or <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Required>.</span></span> <span data-ttu-id="5acec-121">기본적으로 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> 는로 설정 되 <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> 고, 기본 WCF 서비스 응용 프로그램 템플릿은 특성을로 설정 합니다 `aspNetCompatibilityEnabled` `true` .</span><span class="sxs-lookup"><span data-stu-id="5acec-121">By default <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute> is now set to <xref:System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode.Allowed> and the default WCF service application template sets the `aspNetCompatibilityEnabled` attribute to `true`.</span></span> <span data-ttu-id="5acec-122">자세한 내용은 Windows Communication Foundation 4.5 및 [WCF 서비스와 ASP.NET](./feature-details/wcf-services-and-aspnet.md) [의 새로운 기능](whats-new.md) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5acec-122">For more information, see [What's New in Windows Communication Foundation 4.5](whats-new.md) and [WCF Services and ASP.NET](./feature-details/wcf-services-and-aspnet.md).</span></span>

## <a name="streaming-improvements"></a><span data-ttu-id="5acec-123">스트리밍 향상</span><span class="sxs-lookup"><span data-stu-id="5acec-123">Streaming Improvements</span></span>

- <span data-ttu-id="5acec-124">비동기 스트리밍 지원이 WCF에 새로 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-124">New support for asynchronous streaming has been added to WCF.</span></span> <span data-ttu-id="5acec-125">비동기 스트리밍을 사용하려면 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> 엔드포인트 동작을 서비스 호스트에 추가하고 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> 속성을 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-125">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="5acec-126">따라서 서비스에서 읽는 속도가 느린 여러 클라이언트에 스트리밍된 메시지를 보낼 때 확장성이 개선될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-126">This can benefit scalability when a service is sending streamed messages to multiple clients which are reading slowly.</span></span> <span data-ttu-id="5acec-127">WCF는 더 이상 클라이언트당 하나의 스레드를 차단하지 않으며 다른 클라이언트에 서비스를 제공하기 위해 스레드를 개방합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-127">WCF does not block one thread per client anymore and will free up the thread to service another client.</span></span>

- <span data-ttu-id="5acec-128">서비스가 IIS에서 호스팅되는 경우 메시지 버퍼링과 관련된 제한이 제거되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-128">Removed limitations around buffering of messages when a service is IIS hosted.</span></span> <span data-ttu-id="5acec-129">이전 버전의 WCF에서는 스트리밍 메시지 전송을 사용한 IIS 호스팅 서비스 메시지를 수신할 때 ASP.NET에서 전체 메시지를 버퍼링한 후 WCF로 보냈습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-129">In previous versions of WCF when receiving a message for an IIS-hosted service that used streaming message transfer, ASP.NET would buffer the entire message before sending it to WCF.</span></span> <span data-ttu-id="5acec-130">이 경우 메모리 소비가 매우 커집니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-130">This would cause large memory consumption.</span></span> <span data-ttu-id="5acec-131">이 버퍼링은 .NET Framework 4.5에서 제거 되었으므로 이제 IIS에서 호스팅되는 WCF 서비스는 전체 메시지를 받기 전에 들어오는 스트림 처리를 시작할 수 있으므로 진정한 스트리밍이 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-131">This buffering has been removed in .NET Framework 4.5 and now IIS-hosted WCF services can start processing the incoming stream before the entire message has been received, thereby enabling true streaming.</span></span> <span data-ttu-id="5acec-132">이에 따라 WCF가 메시지에 즉시 응답할 수 있어 성능이 개선됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-132">This allows WCF to respond immediately to messages and allows improved performance.</span></span> <span data-ttu-id="5acec-133">또한 들어오는 요청에 대한 ASP.NET 크기 제한인 `maxRequestLength` 값을 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-133">In addition, you no longer have to specify a value for `maxRequestLength`, the ASP.NET size limit on incoming requests.</span></span> <span data-ttu-id="5acec-134">이 속성은 설정해도 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-134">If this property is set, it is ignored.</span></span> <span data-ttu-id="5acec-135">에 대 한 자세한 `maxRequestLength` 내용은 [ \<httpRuntime> 구성 요소](/previous-versions/dotnet/netframework-1.1/e1f13641(v=vs.71))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5acec-135">For more information about `maxRequestLength` see [\<httpRuntime> configuration element](/previous-versions/dotnet/netframework-1.1/e1f13641(v=vs.71)).</span></span> <span data-ttu-id="5acec-136">MaxAllowedContentLength를 구성 해야 합니다. 자세한 내용은 [IIS 요청 제한](/previous-versions/iis/settings-schema/ms689462(v=vs.90))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5acec-136">You will still need to configure the maxAllowedContentLength, For more information, see [IIS Request Limits](/previous-versions/iis/settings-schema/ms689462(v=vs.90)).</span></span>

## <a name="new-transport-default-values"></a><span data-ttu-id="5acec-137">새 전송 기본값</span><span class="sxs-lookup"><span data-stu-id="5acec-137">New Transport Default Values</span></span>

<span data-ttu-id="5acec-138">다음 표에는 변경된 설정과 추가 정보를 찾을 수 있는 위치가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-138">The following table describes the settings that have changed and where to find additional information.</span></span>

|<span data-ttu-id="5acec-139">속성</span><span class="sxs-lookup"><span data-stu-id="5acec-139">Property</span></span>|<span data-ttu-id="5acec-140">켜기</span><span class="sxs-lookup"><span data-stu-id="5acec-140">On</span></span>|<span data-ttu-id="5acec-141">새 기본값</span><span class="sxs-lookup"><span data-stu-id="5acec-141">New Default</span></span>|<span data-ttu-id="5acec-142">추가 정보</span><span class="sxs-lookup"><span data-stu-id="5acec-142">More Information</span></span>|
|--------------|--------|-----------------|----------------------|
|<span data-ttu-id="5acec-143">channelInitializationTimeout</span><span class="sxs-lookup"><span data-stu-id="5acec-143">channelInitializationTimeout</span></span>|<xref:System.ServiceModel.NetTcpBinding>|<span data-ttu-id="5acec-144">30초</span><span class="sxs-lookup"><span data-stu-id="5acec-144">30 seconds</span></span>|<span data-ttu-id="5acec-145">이 속성은 TCP 연결이 .NET 프레이밍 프로토콜을 사용 하 여 자신을 인증 하는 데 사용할 수 있는 시간을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-145">This property determines how long a TCP connection can take to authenticate itself using the .NET Framing protocol.</span></span> <span data-ttu-id="5acec-146">서버가 인증을 수행하는 데 충분한 정보를 가지려면 클라이언트가 몇 가지 초기 데이터를 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-146">A client needs to send some initial data before the server has enough information to perform authentication.</span></span> <span data-ttu-id="5acec-147">이 시간 제한은 인증되지 않은 악의적 클라이언트가 서버에 너무 오래 연결되지 않도록 ReceiveTimeout(10분)보다 일부러 작게 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-147">This timeout is intentionally made smaller than the ReceiveTimeout (10 min) so that malicious unauthenticated clients do not keep the connections tied up to the server for long.</span></span> <span data-ttu-id="5acec-148">기본값은 30초입니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-148">The default value is 30 seconds.</span></span> <span data-ttu-id="5acec-149">에 대 한 자세한 내용 <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.ChannelInitializationTimeout%2A></span><span class="sxs-lookup"><span data-stu-id="5acec-149">For more information about <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.ChannelInitializationTimeout%2A></span></span>|
|<span data-ttu-id="5acec-150">listenBacklog</span><span class="sxs-lookup"><span data-stu-id="5acec-150">listenBacklog</span></span>|<xref:System.ServiceModel.NetTcpBinding>|<span data-ttu-id="5acec-151">16 \* 프로세서 수</span><span class="sxs-lookup"><span data-stu-id="5acec-151">16 \* number of processors</span></span>|<span data-ttu-id="5acec-152">이 소켓 수준 속성은 대기될 "보류 중 승인" 요청의 수를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-152">This socket-level property describes the number of "pending accept" requests to be queued.</span></span> <span data-ttu-id="5acec-153">수신 백로그 큐가 가득 차면 새 소켓 요청이 거부 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-153">If the listen backlog queue fills up, new socket requests will be rejected.</span></span> <span data-ttu-id="5acec-154">에 대 한 자세한 내용 <xref:System.ServiceModel.NetTcpBinding.ListenBacklog%2A></span><span class="sxs-lookup"><span data-stu-id="5acec-154">For more information about <xref:System.ServiceModel.NetTcpBinding.ListenBacklog%2A></span></span>|
|<span data-ttu-id="5acec-155">maxPendingAccepts</span><span class="sxs-lookup"><span data-stu-id="5acec-155">maxPendingAccepts</span></span>|<span data-ttu-id="5acec-156">ConnectionOrientedTransportBindingElement</span><span class="sxs-lookup"><span data-stu-id="5acec-156">ConnectionOrientedTransportBindingElement</span></span><br /><br /> <span data-ttu-id="5acec-157">SMSvcHost.exe</span><span class="sxs-lookup"><span data-stu-id="5acec-157">SMSvcHost.exe</span></span>|<span data-ttu-id="5acec-158">2 \* 전송용 프로세서 수</span><span class="sxs-lookup"><span data-stu-id="5acec-158">2 \* number of processors for transport</span></span><br /><br /> <span data-ttu-id="5acec-159">4 \* SMSvcHost.exe 프로세서 수</span><span class="sxs-lookup"><span data-stu-id="5acec-159">4 \* number of processors for SMSvcHost.exe</span></span>|<span data-ttu-id="5acec-160">이 속성은 서버가 수신기에서 대기시킬 수 있는 채널 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-160">This property limits the number of channels that the server can have waiting on a listener.</span></span> <span data-ttu-id="5acec-161">MaxPendingAccepts가 너무 낮으면 모든 대기 채널이 연결 서비스를 시작한 후 새 채널이 수신을 시작하기 전까지 약간의 시간 간격이 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-161">When MaxPendingAccepts is too low, there will be a small interval of time in which all of the waiting channels have started servicing connections, but no new channels have begun listening.</span></span> <span data-ttu-id="5acec-162">이 간격 동안 연결이 도달할 수 있으며 이 경우 서버에서 연결 대기 중인 채널이 없기 때문에 연결이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-162">A connection can arrive during this interval and will fail because nothing is waiting for it on the server.</span></span> <span data-ttu-id="5acec-163">이 속성은 <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A> 속성을 큰 숫자로 설정하여 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-163">This property can be configured by setting the <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A> property to a larger number.</span></span> <span data-ttu-id="5acec-164">자세한 내용은 <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingAccepts%2A> 및 [Net.tcp 포트 공유 서비스 구성](./feature-details/configuring-the-net-tcp-port-sharing-service.md) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5acec-164">For more information, see <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingAccepts%2A> and [Configuring the Net.TCP Port Sharing Service](./feature-details/configuring-the-net-tcp-port-sharing-service.md)</span></span>|
|<span data-ttu-id="5acec-165">maxPendingConnections</span><span class="sxs-lookup"><span data-stu-id="5acec-165">maxPendingConnections</span></span>|<span data-ttu-id="5acec-166">ConnectionOrientedTransportBindingElement</span><span class="sxs-lookup"><span data-stu-id="5acec-166">ConnectionOrientedTransportBindingElement</span></span>|<span data-ttu-id="5acec-167">12 \* 프로세서 수</span><span class="sxs-lookup"><span data-stu-id="5acec-167">12 \* number of processors</span></span>|<span data-ttu-id="5acec-168">이 속성은 전송에서 승인하였지만 ServiceModel 디스패처에서 선택하지 않은 연결 수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-168">This property controls how many connections a transport has accepted but have not been picked up by the ServiceModel Dispatcher.</span></span> <span data-ttu-id="5acec-169">이 값을 설정하려면 바인딩 요소의 `MaxConnections` 또는 바인딩의 `maxOutboundConnectionsPerEndpoint`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-169">To set this value, use `MaxConnections` on the binding or `maxOutboundConnectionsPerEndpoint` on the binding element.</span></span> <span data-ttu-id="5acec-170">에 대 한 자세한 내용 <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A></span><span class="sxs-lookup"><span data-stu-id="5acec-170">For more information about <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxPendingConnections%2A></span></span>|
|<span data-ttu-id="5acec-171">receiveTimeout</span><span class="sxs-lookup"><span data-stu-id="5acec-171">receiveTimeout</span></span>|<span data-ttu-id="5acec-172">SMSvcHost.exe</span><span class="sxs-lookup"><span data-stu-id="5acec-172">SMSvcHost.exe</span></span>|<span data-ttu-id="5acec-173">30초</span><span class="sxs-lookup"><span data-stu-id="5acec-173">30 seconds</span></span>|<span data-ttu-id="5acec-174">이 속성은 TCP 프레이밍 데이터를 읽고 내부 연결에서 연결 디스패치를 수행하기 위한 시간 제한을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-174">This property specifies the timeout for reading the TCP framing data and performing connection dispatching from the underlying connections.</span></span> <span data-ttu-id="5acec-175">이는 들어오는 연결에서 프리앰블 데이터를 읽기 위해 SMSvcHost.exe 서비스를 유지할 시간의 상한을 설정하기 위해 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-175">This exists to put a cap on the amount of time SMSvcHost.exe service is kept engaged to read the preamble data from an incoming connection.</span></span> <span data-ttu-id="5acec-176">자세한 내용은 [Net.tcp Port Sharing Service 구성](./feature-details/configuring-the-net-tcp-port-sharing-service.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5acec-176">For more information, see [Configuring the Net.TCP Port Sharing Service](./feature-details/configuring-the-net-tcp-port-sharing-service.md).</span></span>|

> [!NOTE]
> <span data-ttu-id="5acec-177">이러한 새로운 기본값은 .NET Framework 4.5가 설치된 컴퓨터에 WCF 서비스를 배포할 경우에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-177">These new defaults are used only if you deploy the WCF service on a machine with .NET Framework 4.5.</span></span> <span data-ttu-id="5acec-178">동일한 서비스를 .NET Framework 4.0이 설치된 컴퓨터에 배포할 경우에는 .NET Framework 4.0 기본값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-178">If you deploy the same service on a machine with .NET Framework 4.0, then the .NET Framework 4.0 defaults are used.</span></span> <span data-ttu-id="5acec-179">이 경우에는 이러한 설정을 명시적으로 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-179">In such cases it is recommended to configure these settings explicitly.</span></span>

## <a name="xmldictionaryreaderquotas"></a><span data-ttu-id="5acec-180">XmlDictionaryReaderQuotas</span><span class="sxs-lookup"><span data-stu-id="5acec-180">XmlDictionaryReaderQuotas</span></span>

<span data-ttu-id="5acec-181"><xref:System.Xml.XmlDictionaryReaderQuotas>에는 메시지를 만드는 동안 인코더가 사용하는 메모리의 크기를 제한하는 XML 사전 판독기에 대한 구성 가능 할당량 값이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-181"><xref:System.Xml.XmlDictionaryReaderQuotas> contains configurable quota values for XML dictionary readers which limit the amount of memory utilized by an encoder while creating a message.</span></span> <span data-ttu-id="5acec-182">이러한 할당량은 구성 가능하지만, 개발자가 이를 명시적으로 설정해야 할 가능성을 줄이기 위해 기본값이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-182">While these quotas are configurable, the default values have changed to lessen the possibility that a developer will need to set them explicitly.</span></span> <span data-ttu-id="5acec-183">메모리 소비를 제한해서 복잡한 `MaxReceivedMessageSize`를 처리하지 않아도 되도록 <xref:System.Xml.XmlDictionaryReaderQuotas> 할당량은 변경되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-183">`MaxReceivedMessageSize` quota has not been changed so that it can still limit memory consumption preventing the need for you to deal with the complexity of the <xref:System.Xml.XmlDictionaryReaderQuotas>.</span></span> <span data-ttu-id="5acec-184">다음 표에는 할당량, 새 기본값 및 각 할당량의 용도에 대한 간략한 설명이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-184">The following table shows the quotas, their new default values and a brief explanation of what each quota is used for.</span></span>

|<span data-ttu-id="5acec-185">할당량 이름</span><span class="sxs-lookup"><span data-stu-id="5acec-185">Quota Name</span></span>|<span data-ttu-id="5acec-186">기본값</span><span class="sxs-lookup"><span data-stu-id="5acec-186">Default Value</span></span>|<span data-ttu-id="5acec-187">설명</span><span class="sxs-lookup"><span data-stu-id="5acec-187">Description</span></span>|
|----------------|-------------------|-----------------|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>|<span data-ttu-id="5acec-188">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="5acec-188">Int32.MaxValue</span></span>|<span data-ttu-id="5acec-189">허용 되는 최대 배열 길이를 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-189">Gets and sets the maximum allowed array length.</span></span> <span data-ttu-id="5acec-190">이 할당량은 바이트 배열을 포함하여 XML 판독기가 반환하는 기본 형식 배열의 최대 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-190">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="5acec-191">이 할당량은 XML 판독기 자체의 메모리 소비량은 제한하지 않지만 판독기를 사용하는 모든 구성 요소의 메모리 소비량을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-191">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="5acec-192">예를 들어, <xref:System.Runtime.Serialization.DataContractSerializer> 가 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>로 보안이 설정된 판독기를 사용하는 경우에는 이 할당량보다 큰 바이트 배열을 역직렬화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-192">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A>|<span data-ttu-id="5acec-193">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="5acec-193">Int32.MaxValue</span></span>|<span data-ttu-id="5acec-194">각 읽기에 대해 반환 되는 최대 허용 바이트를 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-194">Gets and sets the maximum allowed bytes returned for each read.</span></span> <span data-ttu-id="5acec-195">이 할당량은 요소 시작 태그와 해당 특성을 읽을 때 단일 읽기 작업에서 읽는 바이트 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-195">This quota limits the number of bytes that are read in a single Read operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="5acec-196">비스트리밍 작업의 경우 요소 이름 자체는 할당량 계산에서 제외됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-196">(In non-streamed cases, the element name itself is not counted against the quota).</span></span> <span data-ttu-id="5acec-197">XML 특성이 너무 많으면 특성 이름의 고유성을 확인해야 하기 때문에 처리 시간이 과도하게 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-197">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="5acec-198"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> 는 이 위협을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-198"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> mitigates this threat.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>|<span data-ttu-id="5acec-199">128 노드 수준</span><span class="sxs-lookup"><span data-stu-id="5acec-199">128 nodes deep</span></span>|<span data-ttu-id="5acec-200">이 할당량은 XML 요소의 최대 중첩 깊이를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-200">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="5acec-201"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> 는 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A>와 상호 작용합니다. 판독기는 항상 현재 요소와 모든 상위 요소의 데이터를 메모리에 유지하기 때문에 판독기의 최대 메모리 소비량은 이 두 설정을 곱한 값에 비례합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-201"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> interacts with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A>: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span> <span data-ttu-id="5acec-202">여러 층으로 중첩된 개체 그래프를 역직렬화할 때 역직렬 변환기가 전체 스택에 액세스하여 복구할 수 없는 <xref:System.StackOverflowException>이 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-202">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="5acec-203">XML 중첩과 <xref:System.Runtime.Serialization.DataContractSerializer> 및 <xref:System.Xml.Serialization.XmlSerializer>모두의 개체 중첩 사이에는 직접적인 상관 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-203">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="5acec-204">이 위협을 완화하기 위해 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-204"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is used to mitigate this threat.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>|<span data-ttu-id="5acec-205">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="5acec-205">Int32.MaxValue</span></span>|<span data-ttu-id="5acec-206">이 할당량은 nametable에 허용되는 최대 문자 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-206">This quota limits the maximum number of characters allowed in a nametable.</span></span> <span data-ttu-id="5acec-207">nametable에는 XML 문서를 처리할 때 표시되는 특정 문자열(예: 네임스페이스 및 접두사)이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-207">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="5acec-208">이러한 문자열은 메모리에 버퍼링되기 때문에 스트리밍이 예상되는 경우 과도한 버퍼링을 방지하기 위해 이 할당량이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-208">As these strings are buffered in memory, this quota is used to prevent excessive buffering when streaming is expected.</span></span>|
|<xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>|<span data-ttu-id="5acec-209">Int32.MaxValue</span><span class="sxs-lookup"><span data-stu-id="5acec-209">Int32.MaxValue</span></span>|<span data-ttu-id="5acec-210">이 할당량은 XML 판독기에서 반환하는 최대 문자열 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-210">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="5acec-211">이 할당량은 XML 판독기 자체에서는 메모리 소비량을 제한하지 않지만 판독기를 사용하는 구성 요소의 메모리 소비량을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-211">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="5acec-212">예를 들어, <xref:System.Runtime.Serialization.DataContractSerializer> 가 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>로 보안이 설정된 판독기를 사용하는 경우에는 이 할당량보다 큰 문자열을 역직렬화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-212">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="5acec-213">데이터 보안 유지에 대 한 자세한 내용은 [데이터의 보안 고려 사항](./feature-details/security-considerations-for-data.md) 에서 "XML을 안전 하 게 사용"을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5acec-213">Refer to "Using XML Safely" under [Security Considerations for Data](./feature-details/security-considerations-for-data.md) for more information about securing your data.</span></span>

> [!NOTE]
> <span data-ttu-id="5acec-214">이러한 새로운 기본값은 .NET Framework 4.5가 설치된 컴퓨터에 WCF 서비스를 배포할 경우에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-214">These new defaults are used only if you deploy the WCF service on a machine with .NET Framework 4.5.</span></span> <span data-ttu-id="5acec-215">동일한 서비스를 .NET Framework 4.0이 설치된 컴퓨터에 배포할 경우에는 .NET Framework 4.0 기본값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-215">If you deploy the same service on a machine with .NET Framework 4.0, then the .NET Framework 4.0 defaults are used.</span></span> <span data-ttu-id="5acec-216">이 경우에는 이러한 설정을 명시적으로 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-216">In such cases it is recommended to configure these settings explicitly.</span></span>

## <a name="wcf-configuration-validation"></a><span data-ttu-id="5acec-217">WCF 구성 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="5acec-217">WCF Configuration Validation</span></span>

<span data-ttu-id="5acec-218">이제 Visual Studio 내에서 빌드 프로세스의 일부로 WCF 구성 파일의 유효성이 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-218">As part of the build process within Visual Studio, WCF configuration files are now validated.</span></span> <span data-ttu-id="5acec-219">유효성 검사가 실패할 경우 유효성 검사 오류 또는 경고의 목록이 Visual Studio에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-219">A list of validation errors or warnings are displayed in Visual Studio if the validation fails.</span></span>

## <a name="xml-editor-tooltips"></a><span data-ttu-id="5acec-220">XML 편집기 도구 설명</span><span class="sxs-lookup"><span data-stu-id="5acec-220">XML Editor Tooltips</span></span>

<span data-ttu-id="5acec-221">WCF 서비스의 기존 및 새 개발자들이 서비스를 구성하는 데 도움이 되도록 이제 Visual Studio XML 편집기에서 서비스 구성 파일에 포함된 모든 구성 요소 및 해당 속성에 대한 도구 설명을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-221">In order to help new and existing WCF service developers to configure their services, the Visual Studio XML editor now provides tooltips for every configuration element and its properties that is part of the service configuration file.</span></span>

## <a name="basichttpbinding-improvements"></a><span data-ttu-id="5acec-222">BasicHttpBinding 기능 향상</span><span class="sxs-lookup"><span data-stu-id="5acec-222">BasicHttpBinding Improvements</span></span>

1. <span data-ttu-id="5acec-223">단일 WCF 엔드포인트에서 서로 다른 여러 인증 모드에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-223">Enables a single WCF endpoint to respond to different authentication modes.</span></span>

2. <span data-ttu-id="5acec-224">IIS에서 WCF 서비스의 보안 설정을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5acec-224">Enables a WCF service’s security settings to be controlled by IIS</span></span>
