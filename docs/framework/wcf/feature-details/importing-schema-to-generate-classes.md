---
description: '자세히 알아보기: 스키마를 가져와 클래스 생성'
title: 스키마를 가져와 클래스 생성
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- WCF, schema import and export
- XsdDataContractImporter class
ms.assetid: b9170583-8c34-43bd-97bb-6c0c8dddeee0
ms.openlocfilehash: 787d2a40db6de8181c7e4d27df72fbc4ac032da2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99802868"
---
# <a name="importing-schema-to-generate-classes"></a><span data-ttu-id="5ca62-103">스키마를 가져와 클래스 생성</span><span class="sxs-lookup"><span data-stu-id="5ca62-103">Importing Schema to Generate Classes</span></span>

<span data-ttu-id="5ca62-104">WCF (Windows Communication Foundation)에서 사용할 수 있는 스키마에서 클래스를 생성 하려면 클래스를 사용 <xref:System.Runtime.Serialization.XsdDataContractImporter> 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-104">To generate classes from schemas that are usable with Windows Communication Foundation (WCF), use the <xref:System.Runtime.Serialization.XsdDataContractImporter> class.</span></span> <span data-ttu-id="5ca62-105">이 항목에서는 프로세스와 변형에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-105">This topic describes the process and variations.</span></span>  
  
## <a name="the-import-process"></a><span data-ttu-id="5ca62-106">가져오기 프로세스</span><span class="sxs-lookup"><span data-stu-id="5ca62-106">The Import Process</span></span>

 <span data-ttu-id="5ca62-107">스키마 가져오기 프로세스는 <xref:System.Xml.Schema.XmlSchemaSet>로 시작되고 <xref:System.CodeDom.CodeCompileUnit>을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-107">The schema import process starts with an <xref:System.Xml.Schema.XmlSchemaSet> and produces a <xref:System.CodeDom.CodeCompileUnit>.</span></span>  
  
 <span data-ttu-id="5ca62-108">는 `XmlSchemaSet` XSD (XML 스키마 정의 언어) 스키마 문서 집합을 나타내는 .NET FRAMEWORK SOM (스키마 개체 모델)의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-108">The `XmlSchemaSet` is a part of the .NET Framework’s Schema Object Model (SOM) that represents a set of XML Schema definition language (XSD) schema documents.</span></span> <span data-ttu-id="5ca62-109">XSD 문서 집합에서 `XmlSchemaSet` 개체를 만들려면 <xref:System.Xml.Schema.XmlSchema>를 사용하여 각 문서를 <xref:System.Xml.Serialization.XmlSerializer> 개체로 역직렬화하고 이러한 개체를 새 `XmlSchemaSet`에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-109">To create an `XmlSchemaSet` object from a set of XSD documents, deserialize each document into an <xref:System.Xml.Schema.XmlSchema> object (using the <xref:System.Xml.Serialization.XmlSerializer>) and add these objects to a new `XmlSchemaSet`.</span></span>  
  
 <span data-ttu-id="5ca62-110">는 `CodeCompileUnit` 추상 방식으로 .NET Framework 코드를 나타내는 CodeDOM (.NET Framework 코드 문서 개체 모델)의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-110">The `CodeCompileUnit` is part of the .NET Framework’s Code Document Object Model (CodeDOM) that represents .NET Framework code in an abstract way.</span></span> <span data-ttu-id="5ca62-111">`CodeCompileUnit`에서 실제 코드를 생성하려면 <xref:System.CodeDom.Compiler.CodeDomProvider> 또는 <xref:Microsoft.CSharp.CSharpCodeProvider> 클래스 같은 <xref:Microsoft.VisualBasic.VBCodeProvider> 클래스의 하위 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-111">To generate the actual code from a `CodeCompileUnit`, use a subclass of the <xref:System.CodeDom.Compiler.CodeDomProvider> class, such as the <xref:Microsoft.CSharp.CSharpCodeProvider> or <xref:Microsoft.VisualBasic.VBCodeProvider> class.</span></span>  
  
### <a name="to-import-a-schema"></a><span data-ttu-id="5ca62-112">스키마를 가져오려면</span><span class="sxs-lookup"><span data-stu-id="5ca62-112">To import a schema</span></span>  
  
1. <span data-ttu-id="5ca62-113"><xref:System.Runtime.Serialization.XsdDataContractImporter> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-113">Create an instance of the <xref:System.Runtime.Serialization.XsdDataContractImporter>.</span></span>  
  
2. <span data-ttu-id="5ca62-114">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-114">Optional.</span></span> <span data-ttu-id="5ca62-115">생성자의 `CodeCompileUnit`를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-115">Pass a `CodeCompileUnit` in the constructor.</span></span> <span data-ttu-id="5ca62-116">스키마를 가져오는 중 생성된 형식은 빈 `CodeCompileUnit`로 시작하지 않고 이 `CodeCompileUnit` 인스턴스에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-116">The types generated during schema import are added to this `CodeCompileUnit` instance instead of starting with a blank `CodeCompileUnit`.</span></span>  
  
3. <span data-ttu-id="5ca62-117">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-117">Optional.</span></span> <span data-ttu-id="5ca62-118"><xref:System.Runtime.Serialization.XsdDataContractImporter.CanImport%2A> 메서드 중 하나를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-118">Call one of the <xref:System.Runtime.Serialization.XsdDataContractImporter.CanImport%2A> methods.</span></span> <span data-ttu-id="5ca62-119">메서드는 지정된 스키마가 올바른 데이터 계약 스키마이고 가져올 수 있는지 여부를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-119">The method determines whether the given schema is a valid data contract schema and can be imported.</span></span> <span data-ttu-id="5ca62-120">`CanImport` 메서드는 `Import`(다음 단계)와 동일한 오버로드를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-120">The `CanImport` method has the same overloads as `Import` (the next step).</span></span>  
  
4. <span data-ttu-id="5ca62-121">오버로드된 `Import` 메서드 중 하나(예: <xref:System.Runtime.Serialization.XsdDataContractImporter.Import%28System.Xml.Schema.XmlSchemaSet%29> 메서드)를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-121">Call one of the overloaded `Import` methods, for example, the <xref:System.Runtime.Serialization.XsdDataContractImporter.Import%28System.Xml.Schema.XmlSchemaSet%29> method.</span></span>  
  
     <span data-ttu-id="5ca62-122">가장 간단한 오버로드는 `XmlSchemaSet`를 사용하고 익명 형식을 포함하여 해당 스키마 집합에 있는 모든 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-122">The simplest overload takes an `XmlSchemaSet` and imports all types, including anonymous types, found in that schema set.</span></span> <span data-ttu-id="5ca62-123">기타 오버로드를 사용하면 XSD 형식이나 가져올 형식 목록을 <xref:System.Xml.XmlQualifiedName> 또는 `XmlQualifiedName` 개체 컬렉션 형태로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-123">Other overloads allow you to specify the XSD type or a list of types to import (in the form of an <xref:System.Xml.XmlQualifiedName> or a collection of `XmlQualifiedName` objects).</span></span> <span data-ttu-id="5ca62-124">이 경우 지정된 형식만 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-124">In this case, only the specified types are imported.</span></span> <span data-ttu-id="5ca62-125">오버로드는 <xref:System.Xml.Schema.XmlSchemaElement>에서 특정 요소를 가져오는 `XmlSchemaSet` 및 연결된 형식(익명 형식인지 여부에 관계없이)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-125">An overload takes an <xref:System.Xml.Schema.XmlSchemaElement> that imports a particular element out of the `XmlSchemaSet`, as well as its associated type (whether it is anonymous or not).</span></span> <span data-ttu-id="5ca62-126">이 오버로드는 이 요소에 대해 생성된 형식의 데이터 계약 이름을 나타내는 `XmlQualifiedName`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-126">This overload returns an `XmlQualifiedName`, which represents the data contract name of the type generated for this element.</span></span>  
  
     <span data-ttu-id="5ca62-127">`Import` 메서드를 여러 번 호출하면 동일한 `CodeCompileUnit`에 여러 항목이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-127">Multiple calls of the `Import` method result in multiple items being added to the same `CodeCompileUnit`.</span></span> <span data-ttu-id="5ca62-128">형식이 이미 있으면 `CodeCompileUnit` 에 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-128">A type is not generated into the `CodeCompileUnit` if it already exists there.</span></span> <span data-ttu-id="5ca62-129">`Import` 개체를 여러 개 사용하는 대신 동일한 `XsdDataContractImporter`에서 `XsdDataContractImporter`를 여러 번 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-129">Call `Import` multiple times on the same `XsdDataContractImporter` instead of using multiple `XsdDataContractImporter` objects.</span></span> <span data-ttu-id="5ca62-130">중복 형식이 생성되지 않도록 하려면 이 방법을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-130">This is the recommended way to avoid duplicate types being generated.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="5ca62-131">가져오기 중 오류가 발생하면 `CodeCompileUnit`는 예기치 않은 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-131">If there is a failure during import, the `CodeCompileUnit` will be in an unpredictable state.</span></span> <span data-ttu-id="5ca62-132">실패한 가져오기에서 생성된 `CodeCompileUnit`를 사용하면 보안상 취약해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-132">Using a `CodeCompileUnit` resulting from a failed import could expose you to security vulnerabilities.</span></span>  
  
5. <span data-ttu-id="5ca62-133">`CodeCompileUnit` 속성을 통해 <xref:System.Runtime.Serialization.XsdDataContractImporter.CodeCompileUnit%2A> 에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-133">Access the `CodeCompileUnit` through the <xref:System.Runtime.Serialization.XsdDataContractImporter.CodeCompileUnit%2A> property.</span></span>  
  
### <a name="import-options-customizing-the-generated-types"></a><span data-ttu-id="5ca62-134">가져오기 옵션: 생성된 형식 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="5ca62-134">Import Options: Customizing the Generated Types</span></span>  

 <span data-ttu-id="5ca62-135"><xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A>의 <xref:System.Runtime.Serialization.XsdDataContractImporter> 속성을 <xref:System.Runtime.Serialization.ImportOptions> 클래스의 인스턴스로 설정하여 가져오기 프로세스의 다양한 측면을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-135">You can set the <xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A> property of the <xref:System.Runtime.Serialization.XsdDataContractImporter> to an instance of the <xref:System.Runtime.Serialization.ImportOptions> class to control various aspects of the import process.</span></span> <span data-ttu-id="5ca62-136">여러 가지 옵션은 생성되는 형식에 직접 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-136">A number of options directly influence the types that are generated.</span></span>  
  
#### <a name="controlling-the-access-level-generateinternal-or-the-internal-switch"></a><span data-ttu-id="5ca62-137">액세스 수준 제어(GenerateInternal 또는 /internal 스위치)</span><span class="sxs-lookup"><span data-stu-id="5ca62-137">Controlling the Access Level (GenerateInternal or the /internal switch)</span></span>  

 <span data-ttu-id="5ca62-138">이는 [ServiceModel Metadata 유틸리티 도구 (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)의 **/sinternal** 스위치에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-138">This corresponds to the **/internal** switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span>  
  
 <span data-ttu-id="5ca62-139">일반적으로 public 형식은 private 필드 및 일치하는 공용 데이터 멤버 속성을 사용하여 스키마에서 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-139">Normally, public types are generated from schema, with private fields and matching public data member properties.</span></span> <span data-ttu-id="5ca62-140">대신 내부 형식을 생성하려면 <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> 속성을 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-140">To generate internal types instead, set the <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> property to `true`.</span></span>  
  
 <span data-ttu-id="5ca62-141">다음 예제에서는 <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> 속성이 `true.`로 설정된 경우 내부 클래스로 변환되는 스키마를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-141">The following example shows a schema transformed into an internal class when the <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> property is set to `true.`</span></span>  
  
 [!code-csharp[c_SchemaImportExport#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#2)]
 [!code-vb[c_SchemaImportExport#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#2)]  
  
#### <a name="controlling-namespaces-namespaces-or-the-namespace-switch"></a><span data-ttu-id="5ca62-142">네임스페이스 제어(Namespaces 또는 /namespace 스위치)</span><span class="sxs-lookup"><span data-stu-id="5ca62-142">Controlling Namespaces (Namespaces or the /namespace switch)</span></span>  

 <span data-ttu-id="5ca62-143">이는 도구의 **/namespace** 스위치에 해당 `Svcutil.exe` 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-143">This corresponds to the **/namespace** switch on the `Svcutil.exe` tool.</span></span>  
  
 <span data-ttu-id="5ca62-144">일반적으로 스키마에서 생성 된 형식은 [데이터 계약 스키마 참조](data-contract-schema-reference.md)에 설명 된 매핑에 따라 특정 .NET Framework 네임 스페이스에 해당 하는 각 XSD 네임 스페이스와 함께 .NET Framework 네임 스페이스로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-144">Normally, types generated from schema are generated into .NET Framework namespaces, with each XSD namespace corresponding to a particular .NET Framework namespace according to a mapping described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="5ca62-145"><xref:System.Runtime.Serialization.ImportOptions.Namespaces%2A>에 대한 <xref:System.Collections.Generic.Dictionary%602> 속성으로 이 매핑을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-145">You can customize this mapping by the <xref:System.Runtime.Serialization.ImportOptions.Namespaces%2A> property to a <xref:System.Collections.Generic.Dictionary%602>.</span></span> <span data-ttu-id="5ca62-146">사전에서 지정 된 XSD 네임 스페이스를 찾은 경우 일치 하는 .NET Framework 네임 스페이스도 사전에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-146">If a given XSD namespace is found in the dictionary, the matching .NET Framework namespace is also taken from your dictionary.</span></span>  
  
 <span data-ttu-id="5ca62-147">예를 들어 다음 스키마를 생각해 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-147">For example, consider the following schema.</span></span>  
  
 [!code-xml[c_SchemaImportExport#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#10)]  
  
 <span data-ttu-id="5ca62-148">다음 예제에서는 속성을 사용 하 여 `Namespaces` `http://schemas.contoso.com/carSchema` 네임 스페이스를 "Contoso. 자동차"에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-148">The following example uses the `Namespaces` property to map the `http://schemas.contoso.com/carSchema` namespace to "Contoso.Cars".</span></span>  
  
 [!code-csharp[c_SchemaImportExport#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#8)]
 [!code-vb[c_SchemaImportExport#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#8)]  
  
#### <a name="adding-the-serializableattribute-generateserializable-or-the-serializable-switch"></a><span data-ttu-id="5ca62-149">SerializableAttribute 추가(GenerateSerializable 또는 /serializable 스위치)</span><span class="sxs-lookup"><span data-stu-id="5ca62-149">Adding the SerializableAttribute (GenerateSerializable or the /serializable switch)</span></span>  

 <span data-ttu-id="5ca62-150">이는 도구의 **도구의/serializable** 스위치에 해당 `Svcutil.exe` 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-150">This corresponds to the **/serializable** switch on the `Svcutil.exe` tool.</span></span>  
  
 <span data-ttu-id="5ca62-151">경우에 따라 스키마에서 생성 된 형식을 .NET Framework 런타임 serialization 엔진 (예: 및 클래스)과 함께 사용할 수 있도록 하는 것이 중요 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=nameWithType> <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-151">Sometimes it is important for the types generated from the schema to be usable with .NET Framework runtime serialization engines (for example, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=nameWithType> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> classes).</span></span> <span data-ttu-id="5ca62-152">.NET Framework 원격 기능에 형식을 사용 하는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-152">This is useful when using types for .NET Framework remoting.</span></span> <span data-ttu-id="5ca62-153">이 기능을 사용하려면 일반적인 <xref:System.SerializableAttribute> 특성 외에도 <xref:System.Runtime.Serialization.DataContractAttribute> 특성을 생성된 형식에 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-153">To enable this, you must apply the <xref:System.SerializableAttribute> attribute to the generated types in addition to the regular <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="5ca62-154">`GenerateSerializable` 가져오기 옵션이 `true`로 설정되어 있으면 이 특성이 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-154">The attribute is generated automatically if the `GenerateSerializable` import option is set to `true`.</span></span>  
  
 <span data-ttu-id="5ca62-155">다음 예제에서는 `Vehicle` 가져오기 옵션을 `GenerateSerializable`로 설정하여 생성된 `true` 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-155">The following example shows the `Vehicle` class generated with the `GenerateSerializable` import option set to `true`.</span></span>  
  
 [!code-csharp[c_SchemaImportExport#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#4)]
 [!code-vb[c_SchemaImportExport#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#4)]  
  
#### <a name="adding-data-binding-support-enabledatabinding-or-the-enabledatabinding-switch"></a><span data-ttu-id="5ca62-156">데이터 바인딩 지원 추가(EnableDataBinding 또는 /enableDataBinding 스위치)</span><span class="sxs-lookup"><span data-stu-id="5ca62-156">Adding Data Binding Support (EnableDataBinding or the /enableDataBinding switch)</span></span>  

 <span data-ttu-id="5ca62-157">이는 Svcutil.exe 도구의 **/enableDataBinding** 스위치에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-157">This corresponds to the **/enableDataBinding** switch on the Svcutil.exe tool.</span></span>  
  
 <span data-ttu-id="5ca62-158">경우에 따라 스키마에서 생성된 형식을 그래픽 사용자 인터페이스 구성 요소에 바인딩하여 이러한 형식의 인스턴스를 업데이트할 경우 자동으로 UI가 업데이트되도록 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-158">Sometimes, you may want to bind the types generated from the schema to graphical user interface components so that any update to instances of these types will automatically update the UI.</span></span> <span data-ttu-id="5ca62-159">`XsdDataContractImporter`는 속성을 변경할 경우 이벤트가 트리거되는 방식으로 <xref:System.ComponentModel.INotifyPropertyChanged> 인터페이스를 구현하는 형식을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-159">The `XsdDataContractImporter` can generate types that implement the <xref:System.ComponentModel.INotifyPropertyChanged> interface in such a way that any property change triggers an event.</span></span> <span data-ttu-id="5ca62-160">Windows Presentation Foundation (WPF)와 같이이 인터페이스를 지 원하는 클라이언트 UI 프로그래밍 환경에서 사용할 형식을 생성 하는 경우 <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> 이 기능을 사용 하려면 속성을로 설정 합니다 `true` .</span><span class="sxs-lookup"><span data-stu-id="5ca62-160">If you are generating types for use with a client UI programming environment that supports this interface (such as Windows Presentation Foundation (WPF)), set the <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> property to `true` to enable this feature.</span></span>  
  
 <span data-ttu-id="5ca62-161">다음 예제에서는 `Vehicle`을 <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A>로 설정하여 생성된 `true` 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-161">The following example shows the `Vehicle` class generated with the <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> set to `true`.</span></span>  
  
 [!code-csharp[C_SchemaImportExport#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#5)]
 [!code-vb[C_SchemaImportExport#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#5)]  
  
### <a name="import-options-choosing-collection-types"></a><span data-ttu-id="5ca62-162">가져오기 옵션: 컬렉션 형식 선택</span><span class="sxs-lookup"><span data-stu-id="5ca62-162">Import Options: Choosing Collection Types</span></span>  

 <span data-ttu-id="5ca62-163">XML의 두 가지 특수 패턴은 항목 컬렉션, 즉 항목 목록 및 한 항목과 다른 항목 간의 연결을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-163">Two special patterns in XML represent collections of items: lists of items and associations between one item and another.</span></span> <span data-ttu-id="5ca62-164">다음은 문자열 목록의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-164">The following is an example of a list of strings.</span></span>  
  
 [!code-xml[C_SchemaImportExport#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#11)]  
  
 <span data-ttu-id="5ca62-165">다음은 문자열과 정수(`city name` 및 `population`) 간의 연결 예입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-165">The following is an example of an association between a string and an integer (`city name` and `population`).</span></span>  
  
 [!code-xml[C_SchemaImportExport#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#12)]  
  
> [!NOTE]
> <span data-ttu-id="5ca62-166">모든 연결을 목록으로 간주할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-166">Any association could also be considered a list.</span></span> <span data-ttu-id="5ca62-167">예를 들어 앞의 연결을 두 개의 필드(문자열 필드 및 정수 필드)가 있는 복잡한 `city` 개체 목록으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-167">For example, you can view the preceding association as a list of complex `city` objects that happen to have two fields (a string field and an integer field).</span></span> <span data-ttu-id="5ca62-168">두 패턴은 모두 XSD 스키마에서 하나로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-168">Both patterns have a representation in the XSD Schema.</span></span> <span data-ttu-id="5ca62-169">목록과 연결을 구분할 수 있는 방법이 없으므로 WCF와 관련 된 특별 한 주석이 스키마에 존재 하지 않는 한 이러한 패턴은 항상 목록으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-169">There is no way to differentiate between a list and an association, so such patterns are always treated as lists unless a special annotation specific to WCF is present in the schema.</span></span> <span data-ttu-id="5ca62-170">주석은 지정된 패턴이 연결을 나타냄을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-170">The annotation indicates that a given pattern represents an association.</span></span> <span data-ttu-id="5ca62-171">자세한 내용은 [데이터 계약 스키마 참조](data-contract-schema-reference.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5ca62-171">For more information, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="5ca62-172">일반적으로 목록은 컬렉션에 대 한 표준 명명 패턴을 따르는지 여부에 따라 제네릭 목록에서 또는 .NET Framework 배열로 파생 되는 컬렉션 데이터 계약으로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-172">Normally, a list is imported as a collection data contract that derives from a Generic List or as a .NET Framework array, depending on whether or not the schema follows the standard naming pattern for collections.</span></span> <span data-ttu-id="5ca62-173">이에 대해서는 [데이터 계약의 컬렉션 형식](collection-types-in-data-contracts.md)에 자세히 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-173">This is described in more detail in [Collection Types in Data Contracts](collection-types-in-data-contracts.md).</span></span> <span data-ttu-id="5ca62-174">연결은 일반적으로 <xref:System.Collections.Generic.Dictionary%602> 또는 사전 개체에서 파생된 컬렉션 데이터 계약으로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-174">Associations are normally imported as either a <xref:System.Collections.Generic.Dictionary%602> or a collection data contract that derives from the dictionary object.</span></span> <span data-ttu-id="5ca62-175">예를 들어 다음 스키마를 생각해 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-175">For example, consider the following schema.</span></span>  
  
 [!code-xml[c_SchemaImportExport#13](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#13)]  
  
 <span data-ttu-id="5ca62-176">이 스키마는 다음과 같이 가져옵니다(읽기 쉽도록 속성 대신 필드가 표시됨).</span><span class="sxs-lookup"><span data-stu-id="5ca62-176">This would be imported as follows (fields are shown instead of properties for readability).</span></span>  
  
 [!code-csharp[c_SchemaImportExport#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#6)]
 [!code-vb[c_SchemaImportExport#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#6)]  
  
 <span data-ttu-id="5ca62-177">이러한 스키마 패턴에 대해 생성된 컬렉션 형식을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-177">It is possible to customize the collection types that are generated for such schema patterns.</span></span> <span data-ttu-id="5ca62-178">예를 들어 형식을 목록 상자에 바인딩하고 컬렉션 콘텐츠를 변경할 때 자동으로 업데이트되도록 <xref:System.ComponentModel.BindingList%601> 클래스 대신 <xref:System.Collections.Generic.List%601>에서 파생된 컬렉션을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-178">For example, you may want to generate collections deriving from the <xref:System.ComponentModel.BindingList%601> instead of the <xref:System.Collections.Generic.List%601> class in order to bind the type to a list box and have it be automatically updated when the contents of the collection change.</span></span> <span data-ttu-id="5ca62-179">이렇게 하려면 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 클래스의 <xref:System.Runtime.Serialization.ImportOptions> 속성을 사용할 컬렉션 형식(이후부터는 참조된 형식) 목록으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-179">To do this, set the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> class to a list of collection types to be used (hereafter known as the referenced types).</span></span> <span data-ttu-id="5ca62-180">컬렉션을 가져올 때는 이 참조된 컬렉션 형식 목록이 검색되고, 가장 일치하는 컬렉션이 있으면 해당 컬렉션이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-180">When importing any collection, this list of referenced collection types is scanned and the best-matching collection is used if one is found.</span></span> <span data-ttu-id="5ca62-181">목록은 지원되는 모든 컬렉션 형식에 대해 일치되지만 연결은 제네릭 또는 비제네릭 <xref:System.Collections.IDictionary> 인터페이스를 구현하는 형식에 대해서만 일치됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-181">Associations are matched only against types that implement either the generic or the nongeneric <xref:System.Collections.IDictionary> interface, while lists are matched against any supported collection type.</span></span>  
  
 <span data-ttu-id="5ca62-182">예를 들어 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 속성을 <xref:System.ComponentModel.BindingList%601>로 설정하면 앞의 예에서 `people` 형식은 다음과 같이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-182">For example, if the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property is set to a <xref:System.ComponentModel.BindingList%601>, the `people` type in the preceding example is generated as follows.</span></span>  
  
 [!code-csharp[C_SchemaImportExport#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#7)]
 [!code-vb[C_SchemaImportExport#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#7)]  
  
 <span data-ttu-id="5ca62-183">폐쇄형 제네릭이 가장 일치하는 항목으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-183">A closed generic is considered the best match.</span></span> <span data-ttu-id="5ca62-184">예를 들어 `BindingList(Of Integer)` 및 <xref:System.Collections.ArrayList> 형식이 참조된 형식의 컬렉션으로 전달되는 경우 스키마에 있는 모든 정수 목록을 `BindingList(Of Integer)`로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-184">For example, if the types `BindingList(Of Integer)` and <xref:System.Collections.ArrayList> are passed to the collection of referenced types, any lists of integers found in schema are imported as a `BindingList(Of Integer)`.</span></span> <span data-ttu-id="5ca62-185">예를 들어 다른 모든 목록 `List(Of String)`는 `ArrayList`로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-185">Any other lists, for example, a `List(Of String)`, are imported as an `ArrayList`.</span></span>  
  
 <span data-ttu-id="5ca62-186">제네릭 `IDictionary` 인터페이스를 구현하는 형식이 참조된 형식 컬렉션에 추가되는 경우 형식 매개 변수를 완전히 열거나 완전히 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-186">If a type that implements the generic `IDictionary` interface is added to the collection of referenced types, its type parameters must either be fully open or fully closed.</span></span>  
  
 <span data-ttu-id="5ca62-187">복제는 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-187">Duplicates are not allowed.</span></span> <span data-ttu-id="5ca62-188">예를 들어 `List(Of Integer)` 및 `Collection(Of Integer)`을 모두 참조된 형식에 추가할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-188">For example, you cannot add both a `List(Of Integer)` and a `Collection(Of Integer)` to the referenced types.</span></span> <span data-ttu-id="5ca62-189">이렇게 하면 스키마에 정수 목록이 있을 때 사용할 항목을 결정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-189">That would make it impossible to determine which should be used when a list of integers is found in schema.</span></span> <span data-ttu-id="5ca62-190">중복 문제를 노출하는 형식이 스키마에 있는 경우에만 중복이 감지됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-190">Duplicates will be detected only if there is a type in schema that exposes the duplicates problem.</span></span> <span data-ttu-id="5ca62-191">예를 들어 가져온 스키마에 정수 목록이 없는 경우 `List(Of Integer)` 및 `Collection(Of Integer)`을 참조된 형식 컬렉션에 모두 포함할 수 있지만 둘 다 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-191">For example, if the imported schema does not contain lists of integers, it is allowed to have both the `List(Of Integer)` and the `Collection(Of Integer)` in the referenced types collection, but neither will have any effect.</span></span>  
  
 <span data-ttu-id="5ca62-192">참조된 컬렉션 형식 메커니즘은 기본 형식의 컬렉션뿐만 아니라 다른 컬렉션의 컬렉션을 비롯한 복합 형식의 컬렉션에서도 효과적으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-192">The referenced collection types mechanism works equally well for collections of complex types (including collections of other collections), and not just for collections of primitives.</span></span>  
  
 <span data-ttu-id="5ca62-193">`ReferencedCollectionTypes`속성은 SvcUtil.exe 도구의 **/collectiontype** 스위치에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-193">The `ReferencedCollectionTypes` property corresponds to the **/collectionType** switch on the SvcUtil.exe tool.</span></span> <span data-ttu-id="5ca62-194">여러 컬렉션 형식을 참조 하려면 **/Collectiontype** 스위치를 여러 번 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-194">Note that to reference multiple collection types, the **/collectionType** switch must be specified multiple times.</span></span> <span data-ttu-id="5ca62-195">형식이 MsCorLib.dll에 없는 경우 **/reference** 스위치를 사용 하 여 해당 어셈블리도 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-195">If the type is not in the MsCorLib.dll, its assembly must also be referenced using the **/reference** switch.</span></span>  
  
#### <a name="import-options-referencing-existing-types"></a><span data-ttu-id="5ca62-196">가져오기 옵션: 기존 형식 참조</span><span class="sxs-lookup"><span data-stu-id="5ca62-196">Import Options: Referencing Existing Types</span></span>  

 <span data-ttu-id="5ca62-197">경우에 따라 스키마의 형식은 기존 .NET Framework 형식에 해당 하며 이러한 형식을 처음부터 생성 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-197">Occasionally, types in schema correspond to existing .NET Framework types, and there is no need to generate these types from scratch.</span></span> <span data-ttu-id="5ca62-198">이 단원의 내용은 비컬렉션 형식에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-198">(This section applies only to noncollection types.</span></span> <span data-ttu-id="5ca62-199">컬렉션 형식에 대해서는 이전 단원을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5ca62-199">For collection types, see the preceding section.)</span></span>  
  
 <span data-ttu-id="5ca62-200">예를 들어 개인을 나타낼 때 항상 사용할 회사 수준의 표준 "Person" 데이터 계약 형식이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-200">For example, you may have a standard company-wide "Person" data contract type that you always want used when representing a person.</span></span> <span data-ttu-id="5ca62-201">일부 서비스에서 이 형식을 사용하고 서비스 메타데이터에 해당 스키마가 나타날 때마다 각 서비스에 대해 새 형식을 생성하는 대신 이 스키마를 가져올 때 기존 `Person` 형식을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-201">Whenever some service makes use of this type, and its schema appears in the service metadata, you may want to reuse the existing `Person` type when importing this schema instead of generating a new one for every service.</span></span>  
  
 <span data-ttu-id="5ca62-202">이렇게 하려면 다시 사용할 .NET Framework 형식의 목록을 <xref:System.Runtime.Serialization.ImportOptions.ReferencedTypes%2A> 속성이 클래스에서 반환 하는 컬렉션에 전달 합니다 <xref:System.Runtime.Serialization.ImportOptions> .</span><span class="sxs-lookup"><span data-stu-id="5ca62-202">To do this, pass a list of .NET Framework types that you want to reuse into the collection the <xref:System.Runtime.Serialization.ImportOptions.ReferencedTypes%2A> property returns on the <xref:System.Runtime.Serialization.ImportOptions> class.</span></span> <span data-ttu-id="5ca62-203">이러한 형식에 스키마 형식의 이름 및 네임스페이스와 일치하는 데이터 계약 이름 및 네임스페이스가 있으면 구조 비교가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-203">If any of these types have a data contract name and namespace that matches the name and namespace of a schema type, a structural comparison is performed.</span></span> <span data-ttu-id="5ca62-204">형식에 일치 하는 이름과 일치 하는 구조가 모두 있는 것으로 확인 되 면 기존 .NET Framework 형식이 새 형식을 생성 하는 대신 다시 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-204">If it is determined that the types have both matching names and matching structures, the existing .NET Framework type is reused instead of generating a new one.</span></span> <span data-ttu-id="5ca62-205">이름만 일치하고 구조가 일치하지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-205">If only the name matches but not the structure, an exception is thrown.</span></span> <span data-ttu-id="5ca62-206">형식을 참조할 때(예: 새 선택적 데이터 멤버를 추가할 때) 버전 관리는 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-206">Note that there is no allowance for versioning when referencing types (for example, adding new optional data members).</span></span> <span data-ttu-id="5ca62-207">구조는 정확하게 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-207">The structures must match exactly.</span></span>  
  
 <span data-ttu-id="5ca62-208">해당 이름과 네임스페이스를 가진 스키마 형식을 가져오지 않는 한 동일한 데이터 계약 이름과 네임스페이스를 가진 여러 형식을 참조된 형식 컬렉션에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-208">It is legal to add multiple types with the same data contract name and namespace to the referenced types collection, as long as no schema types are imported with that name and namespace.</span></span> <span data-ttu-id="5ca62-209">이렇게 하면 실제로 스키마에서 발생하지 않는 형식의 중복에 대해 염려하지 않고 어셈블리의 모든 형식을 쉽게 컬렉션에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-209">This allows you to easily add all the types in an assembly to the collection without worrying about duplicates for types that do not actually occur in schema.</span></span>  
  
 <span data-ttu-id="5ca62-210">`ReferencedTypes`속성은 Svcutil.exe 도구의 특정 작업 모드에서 **/reference** 스위치에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-210">The `ReferencedTypes` property corresponds to the **/reference** switch in certain modes of operation of the Svcutil.exe tool.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5ca62-211">Svcutil.exe 또는 (Visual Studio) **서비스 참조 추가** 도구를 사용 하는 경우 MsCorLib.dll의 모든 형식이 자동으로 참조 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-211">When using the Svcutil.exe or (in Visual Studio) the **Add Service Reference** tools, all of the types in MsCorLib.dll are automatically referenced.</span></span>  
  
#### <a name="import-options-importing-non-datacontract-schema-as-ixmlserializable-types"></a><span data-ttu-id="5ca62-212">가져오기 옵션: DataContract가 아닌 스키마를 IXmlSerializable 형식으로 가져오기</span><span class="sxs-lookup"><span data-stu-id="5ca62-212">Import Options: Importing Non-DataContract Schema as IXmlSerializable types</span></span>  

 <span data-ttu-id="5ca62-213"><xref:System.Runtime.Serialization.XsdDataContractImporter>는 스키마의 제한된 하위 집합을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-213">The <xref:System.Runtime.Serialization.XsdDataContractImporter> supports a limited subset of the schema.</span></span> <span data-ttu-id="5ca62-214">지원되지 않는 스키마 구문이 있으면(예: XML 특성) 예외와 함께 가져오기 시도가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-214">If unsupported schema constructs are present (for example, XML attributes), the import attempt fails with an exception.</span></span> <span data-ttu-id="5ca62-215">그러나 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 속성을 `true`로 설정하면 지원되는 스키마 범위가 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-215">However, setting the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> property to `true` extends the range of schema supported.</span></span> <span data-ttu-id="5ca62-216">`true`는 <xref:System.Runtime.Serialization.XsdDataContractImporter>로 설정된 경우 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스를 구현하는 형식을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-216">When set to `true`, the <xref:System.Runtime.Serialization.XsdDataContractImporter> generates types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span> <span data-ttu-id="5ca62-217">이 경우 이러한 형식의 XML 표현에 직접 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-217">This enables direct access to the XML representation of these types.</span></span>  
  
##### <a name="design-considerations"></a><span data-ttu-id="5ca62-218">디자인 고려 사항</span><span class="sxs-lookup"><span data-stu-id="5ca62-218">Design Considerations</span></span>  
  
- <span data-ttu-id="5ca62-219">약한 형식의 XML 표현을 직접 사용하기 어려울 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-219">It may be difficult to work with the weakly typed XML representation directly.</span></span> <span data-ttu-id="5ca62-220"><xref:System.Xml.Serialization.XmlSerializer> 같은 대체 serialization 엔진을 사용하여 강력한 형식의 데이터 계약과 호환되지 않는 스키마 작업을 수행해 보세요.</span><span class="sxs-lookup"><span data-stu-id="5ca62-220">Consider using an alternative serialization engine, such as the <xref:System.Xml.Serialization.XmlSerializer>, to work with schema not compatible with data contracts in a strongly typed way.</span></span> <span data-ttu-id="5ca62-221">자세한 내용은 [XmlSerializer 클래스 사용](using-the-xmlserializer-class.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5ca62-221">For more information, see [Using the XmlSerializer Class](using-the-xmlserializer-class.md).</span></span>  
  
- <span data-ttu-id="5ca62-222"><xref:System.Runtime.Serialization.XsdDataContractImporter> 속성이 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A>로 설정되어 있어도 일부 스키마 구문은 `true`로 가져올 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-222">Some schema constructs cannot be imported by the <xref:System.Runtime.Serialization.XsdDataContractImporter> even when the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> property is set to `true`.</span></span> <span data-ttu-id="5ca62-223">이 경우에도 <xref:System.Xml.Serialization.XmlSerializer>를 사용해 보세요.</span><span class="sxs-lookup"><span data-stu-id="5ca62-223">Again, consider using the <xref:System.Xml.Serialization.XmlSerializer> for such cases.</span></span>  
  
- <span data-ttu-id="5ca62-224">가 또는 일 때 모두 지원 되는 정확한 스키마 구문은 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> `true` `false` [데이터 계약 스키마 참조](data-contract-schema-reference.md)에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-224">The exact schema constructs that are supported both when <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> is `true` or `false` are described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>  
  
- <span data-ttu-id="5ca62-225">생성된 <xref:System.Xml.Serialization.IXmlSerializable> 형식의 스키마는 가져오고 내보낼 때 충실도를 유지하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-225">Schema for generated <xref:System.Xml.Serialization.IXmlSerializable> types do not retain fidelity when imported and exported.</span></span> <span data-ttu-id="5ca62-226">즉, 생성된 형식에서 스키마를 내보내고 클래스로 가져오면 원래 스키마가 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-226">That is, exporting the schema from the generated types and importing as classes does not return the original schema.</span></span>  
  
 <span data-ttu-id="5ca62-227"><xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 옵션을 앞에서 설명한 <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> 옵션과 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-227">It is possible to combine the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> option with the <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> option previously described.</span></span> <span data-ttu-id="5ca62-228"><xref:System.Xml.Serialization.IXmlSerializable> 구현으로 생성해야 하는 형식의 경우 <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> 기능을 사용할 때 구조적 검사를 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-228">For types that have to be generated as <xref:System.Xml.Serialization.IXmlSerializable> implementations, the structural check is skipped when using the <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> feature.</span></span>  
  
 <span data-ttu-id="5ca62-229"><xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A>옵션은 Svcutil.exe 도구의 **/Importxmltypes** 스위치에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-229">The <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> option corresponds to the **/importXmlTypes** switch on the Svcutil.exe tool.</span></span>  
  
##### <a name="working-with-generated-ixmlserializable-types"></a><span data-ttu-id="5ca62-230">생성된 IXmlSerializable 형식 작업</span><span class="sxs-lookup"><span data-stu-id="5ca62-230">Working with Generated IXmlSerializable Types</span></span>  

 <span data-ttu-id="5ca62-231">생성된 `IXmlSerializable` 형식에는 <xref:System.Xml.XmlNode> 개체 배열을 반환하는 "nodesField"라는 private 필드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-231">The generated `IXmlSerializable` types contain a private field, named "nodesField," that returns an array of <xref:System.Xml.XmlNode> objects.</span></span> <span data-ttu-id="5ca62-232">이러한 형식의 인스턴스를 역직렬화하는 경우 XML 문서 개체 모델을 사용하여 이 필드를 통해 직접 XML 데이터에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-232">When deserializing an instance of such a type, you can access the XML data directly through this field by using the XML Document Object Model.</span></span> <span data-ttu-id="5ca62-233">이 형식의 인스턴스를 serialize하는 경우 이 필드를 원하는 XML 데이터로 설정하면 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-233">When serializing an instance of this type, you can set this field to the desired XML data and it will be serialized.</span></span>  
  
 <span data-ttu-id="5ca62-234">이 작업은 `IXmlSerializable` 구현을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-234">This is accomplished through the `IXmlSerializable` implementation.</span></span> <span data-ttu-id="5ca62-235">생성된 `IXmlSerializable` 형식에서 <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 구현은 <xref:System.Runtime.Serialization.XmlSerializableServices.ReadNodes%2A> 클래스의 <xref:System.Runtime.Serialization.XmlSerializableServices> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-235">In the generated `IXmlSerializable` type, the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> implementation calls the <xref:System.Runtime.Serialization.XmlSerializableServices.ReadNodes%2A> method of the <xref:System.Runtime.Serialization.XmlSerializableServices> class.</span></span> <span data-ttu-id="5ca62-236">메서드는 <xref:System.Xml.XmlReader>를 통해 제공된 XML을 <xref:System.Xml.XmlNode> 개체 배열로 변환하는 도우미 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-236">The method is a helper method that converts XML provided through an <xref:System.Xml.XmlReader> to an array of <xref:System.Xml.XmlNode> objects.</span></span> <span data-ttu-id="5ca62-237"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 구현은 반대 작업을 수행하고 `XmlNode` 개체 배열을 <xref:System.Xml.XmlWriter> 호출 시퀀스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-237">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation does the opposite and converts the array of `XmlNode` objects to a sequence of <xref:System.Xml.XmlWriter> calls.</span></span> <span data-ttu-id="5ca62-238">이 작업은 <xref:System.Runtime.Serialization.XmlSerializableServices.WriteNodes%2A> 메서드를 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-238">This is accomplished using the <xref:System.Runtime.Serialization.XmlSerializableServices.WriteNodes%2A> method.</span></span>  
  
 <span data-ttu-id="5ca62-239">생성된 `IXmlSerializable` 클래스에서 스키마 내보내기 프로세스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-239">It is possible to run the schema export process on the generated `IXmlSerializable` classes.</span></span> <span data-ttu-id="5ca62-240">앞에서 설명했듯이 원래 스키마가 반환되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-240">As previously stated, you will not get the original schema back.</span></span> <span data-ttu-id="5ca62-241">대신 XSD 형식에 대 한 와일드 카드인 "anyType" 표준 XSD 형식이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-241">Instead, you will get the "anyType" standard XSD type, which is a wildcard for any XSD type.</span></span>  
  
 <span data-ttu-id="5ca62-242">이는 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 생성 된 클래스에 특성을 적용 하 `IXmlSerializable` 고 메서드를 호출 하 여 <xref:System.Runtime.Serialization.XmlSerializableServices.AddDefaultSchema%2A> "anyType" 형식을 생성 하는 메서드를 지정 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-242">This is accomplished by applying the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to the generated `IXmlSerializable` classes and specifying a method that calls the <xref:System.Runtime.Serialization.XmlSerializableServices.AddDefaultSchema%2A> method to generate the "anyType" type.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5ca62-243"><xref:System.Runtime.Serialization.XmlSerializableServices> 형식은 이 특정 기능을 지원하기 위한 용도로만 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-243">The <xref:System.Runtime.Serialization.XmlSerializableServices> type exists solely to support this particular feature.</span></span> <span data-ttu-id="5ca62-244">다른 용도로는 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-244">It is not recommended for use for any other purpose.</span></span>  
  
#### <a name="import-options-advanced-options"></a><span data-ttu-id="5ca62-245">가져오기 옵션: 고급 옵션</span><span class="sxs-lookup"><span data-stu-id="5ca62-245">Import Options: Advanced Options</span></span>  

 <span data-ttu-id="5ca62-246">다음은 고급 가져오기 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-246">The following are advanced import options:</span></span>  
  
- <span data-ttu-id="5ca62-247"><xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="5ca62-247"><xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> property.</span></span> <span data-ttu-id="5ca62-248">생성된 클래스에 대한 코드를 생성하는 데 사용할 <xref:System.CodeDom.Compiler.CodeDomProvider>를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-248">Specify the <xref:System.CodeDom.Compiler.CodeDomProvider> to use to generate the code for the generated classes.</span></span> <span data-ttu-id="5ca62-249">가져오기 메커니즘은 <xref:System.CodeDom.Compiler.CodeDomProvider>에서 지원하지 않는 기능을 피하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-249">The import mechanism attempts to avoid features that the <xref:System.CodeDom.Compiler.CodeDomProvider> does not support.</span></span> <span data-ttu-id="5ca62-250"><xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A>가 설정 되지 않은 경우 .NET Framework 기능의 전체 집합이 제한 없이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-250">If the <xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> is not set, the full set of .NET Framework features is used with no restrictions.</span></span>  
  
- <span data-ttu-id="5ca62-251"><xref:System.Runtime.Serialization.ImportOptions.DataContractSurrogate%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="5ca62-251"><xref:System.Runtime.Serialization.ImportOptions.DataContractSurrogate%2A> property.</span></span> <span data-ttu-id="5ca62-252">이 속성을 사용하여 <xref:System.Runtime.Serialization.IDataContractSurrogate> 구현을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-252">An <xref:System.Runtime.Serialization.IDataContractSurrogate> implementation can be specified with this property.</span></span> <span data-ttu-id="5ca62-253"><xref:System.Runtime.Serialization.IDataContractSurrogate>는 가져오기 프로세스를 사용자 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-253">The <xref:System.Runtime.Serialization.IDataContractSurrogate> customizes the import process.</span></span> <span data-ttu-id="5ca62-254">자세한 내용은 [데이터 계약 서로게이트](../extending/data-contract-surrogates.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5ca62-254">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span> <span data-ttu-id="5ca62-255">기본적으로 서로게이트는 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ca62-255">By default, no surrogate is used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5ca62-256">참고 항목</span><span class="sxs-lookup"><span data-stu-id="5ca62-256">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.XsdDataContractImporter>
- <xref:System.Runtime.Serialization.XsdDataContractExporter>
- <xref:System.Runtime.Serialization.ImportOptions>
- [<span data-ttu-id="5ca62-257">데이터 계약 스키마 참조</span><span class="sxs-lookup"><span data-stu-id="5ca62-257">Data Contract Schema Reference</span></span>](data-contract-schema-reference.md)
- [<span data-ttu-id="5ca62-258">데이터 계약 서로게이트</span><span class="sxs-lookup"><span data-stu-id="5ca62-258">Data Contract Surrogates</span></span>](../extending/data-contract-surrogates.md)
- [<span data-ttu-id="5ca62-259">스키마 가져오기 및 내보내기</span><span class="sxs-lookup"><span data-stu-id="5ca62-259">Schema Import and Export</span></span>](schema-import-and-export.md)
- [<span data-ttu-id="5ca62-260">클래스에서 스키마 내보내기</span><span class="sxs-lookup"><span data-stu-id="5ca62-260">Exporting Schemas from Classes</span></span>](exporting-schemas-from-classes.md)
- [<span data-ttu-id="5ca62-261">데이터 계약 스키마 참조</span><span class="sxs-lookup"><span data-stu-id="5ca62-261">Data Contract Schema Reference</span></span>](data-contract-schema-reference.md)
