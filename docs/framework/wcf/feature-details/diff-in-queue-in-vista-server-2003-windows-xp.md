---
title: Windows Vista, Windows Server 2003 및 Windows XP의 큐 기능 차이점
ms.date: 03/30/2017
helpviewer_keywords:
- queues [WCF], differences in operating systems
ms.assetid: aa809d93-d0a3-4ae6-a726-d015cca37c04
ms.openlocfilehash: 6ec20a0d9512b1f80da1fd423282fc1538c750ef
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96254274"
---
# <a name="differences-in-queuing-features-in-windows-vista-windows-server-2003-and-windows-xp"></a><span data-ttu-id="203c1-102">Windows Vista, Windows Server 2003 및 Windows XP의 큐 기능 차이점</span><span class="sxs-lookup"><span data-stu-id="203c1-102">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>

<span data-ttu-id="203c1-103">이 항목에서는 Windows Vista, Windows Server 2003 및 Windows XP 간에 WCF (Windows Communication Foundation) 큐 기능의 차이점에 대해 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-103">This topic summarizes the differences in the Windows Communication Foundation (WCF) queues feature between Windows Vista, Windows Server 2003, and Windows XP.</span></span>  
  
## <a name="application-specific-dead-letter-queue"></a><span data-ttu-id="203c1-104">애플리케이션별 배달 못한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="203c1-104">Application-Specific Dead-Letter Queue</span></span>  

 <span data-ttu-id="203c1-105">대기 중인 메시지는 수신 애플리케이션이 적절한 시간 내에 메시지를 읽지 못하는 경우 무기한 큐에 남을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-105">Queued messages can remain in the queue indefinitely if the receiving application does not read them in a timely fashion.</span></span> <span data-ttu-id="203c1-106">시간이 중요한 메시지인 경우에는 이 동작이 별로 좋지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-106">This behavior is not advisable if the messages are time-sensitive.</span></span> <span data-ttu-id="203c1-107">시간이 중요한 메시지는 대기 중인 바인딩에서 `TimeToLive` 속성이 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-107">Time-sensitive messages have a `TimeToLive` property set in the queued binding.</span></span> <span data-ttu-id="203c1-108">이 속성은 메시지가 만료될 때까지 큐에 머물 수 있는 기간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-108">This property indicates how long the messages can be in the queue before they expire.</span></span> <span data-ttu-id="203c1-109">만료된 메시지는 배달 못한 편지 큐라는 특수 큐로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-109">Expired messages are sent to a special queue called the dead-letter queue.</span></span> <span data-ttu-id="203c1-110">또한 큐 할당량 초과 또는 인증 오류 등 다른 이유로 메시지가 배달 못한 편지 큐에 놓일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-110">A message can also end up in a dead-letter queue for other reasons, such as exceeding a queue quota or experiencing an authentication failure.</span></span>  
  
 <span data-ttu-id="203c1-111">일반적으로 큐 관리자를 공유하는 모든 대기 중인 애플리케이션에 대해 시스템 전체 수준의 배달 못한 편지 큐 하나가 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-111">Typically, a single system-wide dead-letter queue exists for all queued applications that share a queue manager.</span></span> <span data-ttu-id="203c1-112">각 애플리케이션에 대해 배달 못한 편지 큐를 사용하면 이러한 애플리케이션에서 해당 애플리케이션별 배달 못한 편지 큐를 직접 지정하여 큐 관리자를 공유하는 대기 중인 애플리케이션을 서로 격리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-112">A dead-letter queue for each application enables better isolation between queued applications that share a queue manager by allowing these applications to specify their own application-specific dead-letter queue.</span></span> <span data-ttu-id="203c1-113">다른 애플리케이션과 배달 못한 편지 큐를 공유하는 애플리케이션에서는 큐에서 해당되는 메시지를 찾아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-113">An application that shares a dead-letter queue with other applications has to browse the queue to find messages that are applicable to it.</span></span> <span data-ttu-id="203c1-114">애플리케이션별 배달 못한 편지 큐를 사용하면 애플리케이션에서는 배달 못한 편지 큐에 있는 모든 메시지가 자신에 해당되는 것임을 확신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-114">With an application-specific dead-letter queue, the application can be assured that all messages in its dead-letter queue are applicable to it.</span></span>  
  
 <span data-ttu-id="203c1-115">Windows Vista는 응용 프로그램별 배달 못 한 편지 큐를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-115">Windows Vista provides for application-specific dead-letter queues.</span></span> <span data-ttu-id="203c1-116">응용 프로그램별 배달 못 한 편지 큐는 Windows Server 2003 및 Windows XP에서 사용할 수 없으며 응용 프로그램은 시스템 차원의 배달 못 한 편지 큐를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-116">Application-specific dead-letter queues are not available in Windows Server 2003 and Windows XP, and applications must use the system-wide dead-letter queue.</span></span>  
  
## <a name="poison-message-handling"></a><span data-ttu-id="203c1-117">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="203c1-117">Poison-Message Handling</span></span>  

 <span data-ttu-id="203c1-118">포이즌 메시지는 받는 애플리케이션에 전달하는 최대 배달 시도 횟수를 초과한 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-118">A poison message is a message that has exceeded the maximum number of delivery attempts to the receiving application.</span></span> <span data-ttu-id="203c1-119">이 상황은 트랜잭션 큐에서 메시지를 읽는 애플리케이션이 오류 때문에 메시지를 즉시 처리할 수 없는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-119">This situation can arise when an application that reads a message from a transactional queue cannot process the message immediately because of errors.</span></span> <span data-ttu-id="203c1-120">애플리케이션에서 대기 중인 메시지를 받은 트랜잭션이 중단되면 메시지가 큐에 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-120">If the application aborts the transaction in which the queued message was received, it returns the message to the queue.</span></span> <span data-ttu-id="203c1-121">그러면 애플리케이션에서 새 트랜잭션으로 메시지를 다시 검색하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-121">The application then tries to retrieve the message again in a new transaction.</span></span> <span data-ttu-id="203c1-122">오류를 일으킨 문제가 해결되지 않은 경우 받는 애플리케이션은 최대 배달 시도 횟수를 초과할 때까지 같은 메시지를 받고 중단하는 루프에 갇힐 수 있으며, 포이즌 메시지가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-122">If the problem that causes the error is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until it exceeds the maximum number of delivery attempts, and a poison message results.</span></span>  
  
 <span data-ttu-id="203c1-123">Windows Vista, Windows Server 2003 및 Windows XP의 MSMQ (메시지 큐)에서 포이즌 처리와 관련 된 주요 차이점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-123">The key differences between Message Queuing (MSMQ) on Windows Vista, Windows Server 2003, and Windows XP that are relevant to poison handling include the following:</span></span>  
  
- <span data-ttu-id="203c1-124">Windows Vista의 MSMQ는 하위 큐를 지원 하지만 Windows Server 2003 및 Windows XP에서는 하위 큐를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-124">MSMQ in Windows Vista supports subqueues, while Windows Server 2003 and Windows XP do not support subqueues.</span></span> <span data-ttu-id="203c1-125">하위 큐는 포이즌 메시지 처리에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-125">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="203c1-126">재시도 큐와 포이즌 큐는 포이즌 메시지 처리 설정에 따라 만들어지는 애플리케이션 큐의 하위 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-126">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="203c1-127">`MaxRetryCycles`는 만들 재시도 하위 큐의 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-127">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="203c1-128">따라서 Windows Server 2003 또는 Windows XP에서 실행 되는 경우는 `MaxRetryCycles` 무시 되 고 `ReceiveErrorHandling.Move` 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-128">Therefore, when running on Windows Server 2003 or Windows XP, `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
- <span data-ttu-id="203c1-129">Windows Vista의 MSMQ는 부정 승인을 지원 하 고 windows Server 2003 및 Windows XP는 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-129">MSMQ in Windows Vista supports negative acknowledgment, while Windows Server 2003 and Windows XP do not.</span></span> <span data-ttu-id="203c1-130">받는 큐 관리자에서 네거티브 승인을 사용하면 거부된 메시지가 보내는 큐 관리자의 배달 못한 편지 큐에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-130">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="203c1-131">따라서 `ReceiveErrorHandling.Reject` Windows Server 2003 및 WINDOWS XP에서는이 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-131">As such, `ReceiveErrorHandling.Reject` is not allowed with Windows Server 2003 and Windows XP.</span></span>  
  
- <span data-ttu-id="203c1-132">Windows Vista의 MSMQ는 메시지 배달을 시도 하는 횟수를 유지 하는 메시지 속성을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-132">MSMQ in Windows Vista supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="203c1-133">이 abort count 속성은 Windows Server 2003 및 Windows XP에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-133">This abort count property is not available on Windows Server 2003 and Windows XP.</span></span> <span data-ttu-id="203c1-134">WCF는 메모리에서 중단 횟수를 유지 하므로 웹 팜에 있는 둘 이상의 WCF 서비스에서 같은 메시지를 읽을 경우이 속성에 정확한 값이 포함 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-134">WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a Web farm.</span></span>  
  
## <a name="remote-transactional-read"></a><span data-ttu-id="203c1-135">원격 트랜잭션 읽기</span><span class="sxs-lookup"><span data-stu-id="203c1-135">Remote Transactional Read</span></span>  

 <span data-ttu-id="203c1-136">Windows Vista의 MSMQ는 원격 트랜잭션 읽기를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-136">MSMQ on Windows Vista supports remote transactional reads.</span></span> <span data-ttu-id="203c1-137">이를 통해 큐에서 읽기를 수행하는 애플리케이션을 큐가 호스팅된 컴퓨터와 다른 컴퓨터에 호스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-137">This allows an application that is reading from a queue to be hosted on a computer that is different from the computer on which the queue is hosted.</span></span> <span data-ttu-id="203c1-138">이 기능을 사용하면 중앙의 큐에서 읽기를 수행하는 서비스 팜을 구성하여 시스템의 전체적인 처리량을 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-138">This ensures the ability to have a farm of services reading from a central queue, which increases the overall throughput of the system.</span></span> <span data-ttu-id="203c1-139">또한 메시지를 읽거나 처리하는 동안 오류가 발생하면 트랜잭션을 롤백하여 나중에 처리할 수 있도록 메시지를 큐에 남길 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="203c1-139">It also ensures that if a failure occurs when reading and processing the message, the transaction rolls back and the message remains in the queue for later processing.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="203c1-140">참고 항목</span><span class="sxs-lookup"><span data-stu-id="203c1-140">See also</span></span>

- [<span data-ttu-id="203c1-141">배달 못 한 편지 큐를 사용하여 메시지 전송 오류 처리</span><span class="sxs-lookup"><span data-stu-id="203c1-141">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>](using-dead-letter-queues-to-handle-message-transfer-failures.md)
- [<span data-ttu-id="203c1-142">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="203c1-142">Poison Message Handling</span></span>](poison-message-handling.md)
