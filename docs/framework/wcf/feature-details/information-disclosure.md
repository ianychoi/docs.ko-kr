---
description: '자세히 알아보기: 정보 공개'
title: 정보 공개
ms.date: 03/30/2017
ms.assetid: 4064c89f-afa6-444a-aa7e-807ef072131c
ms.openlocfilehash: 420437703fab883698cdd7217efb14c214a1f529
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99802855"
---
# <a name="information-disclosure"></a><span data-ttu-id="16030-103">정보 공개</span><span class="sxs-lookup"><span data-stu-id="16030-103">Information Disclosure</span></span>

<span data-ttu-id="16030-104">정보 공개를 사용하여 공격자가 시스템에 대해 유용한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-104">Information disclosure enables an attacker to gain valuable information about a system.</span></span> <span data-ttu-id="16030-105">따라서 항상 노출하려는 정보의 내용과 악의가 있는 사용자가 사용해도 되는지 여부를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-105">Therefore, always consider what information you are revealing and whether it can be used by a malicious user.</span></span> <span data-ttu-id="16030-106">다음은 가능한 정보 공개 공격을 나열하고 각 공격에 대한 완화 방안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-106">The following lists possible information disclosure attacks and provides mitigations for each.</span></span>

## <a name="message-security-and-http"></a><span data-ttu-id="16030-107">메시지 보안 및 HTTP</span><span class="sxs-lookup"><span data-stu-id="16030-107">Message Security and HTTP</span></span>

<span data-ttu-id="16030-108">HTTP 전송 계층을 통해 메시지 수준 보안을 사용하는 경우 메시지 수준 보안이 HTTP 헤더를 보호하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-108">If you are using message-level security over an HTTP transport layer, be aware that message-level security does not protect HTTP headers.</span></span> <span data-ttu-id="16030-109">HTTP 헤더를 보호하기 위한 유일한 방법은 HTTP 대신 HTTPS 전송을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="16030-109">The only way to protect HTTP headers is to use HTTPS transport instead of HTTP.</span></span> <span data-ttu-id="16030-110">HTTPS 전송은 HTTP 헤더를 포함한 전체 메시지를 SSL(Secure Sockets Layer) 프로토콜을 사용하여 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-110">HTTPS transport causes the entire message, including the HTTP headers, to be encrypted using the Secure Sockets Layer (SSL) protocol.</span></span>

## <a name="policy-information"></a><span data-ttu-id="16030-111">정책 정보</span><span class="sxs-lookup"><span data-stu-id="16030-111">Policy Information</span></span>

<span data-ttu-id="16030-112">민감한 발급된 토큰 요구 사항 또는 토큰 발급자 정보가 정책에 노출되는 페더레이션 시나리오의 경우 특히 정책 보안 유지가 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-112">Keeping policy secure is important, especially in federation scenarios where sensitive issued-token requirements or token-issuer information is exposed in policy.</span></span> <span data-ttu-id="16030-113">이러한 경우 페더레이션 서비스 정책 엔드포인트의 보안을 유지하여 발급된 토큰에 삽입할 클레임 형식 또는 악의적인 토큰 발급자에게 클라이언트 리디렉션과 같이 공격자가 서비스에 대한 정보를 가져오지 못하도록 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-113">In these cases, the recommendation is to secure the federated service's policy endpoint to prevent attackers from obtaining information about the service, such as the type of claims to put in the issued token, or redirecting clients to malicious token issuers.</span></span> <span data-ttu-id="16030-114">예를 들어, 공격자가 메시지 가로채기(man-in-the-middle) 공격을 실행한 발급자로 끝나도록 페더레이션 신뢰 체인을 다시 구성하여 사용자 이름/암호 쌍을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-114">For example, an attacker could discover user name/password pairs by reconfiguring the federated trust chain to terminate in an issuer that executed a man-in-the-middle attack.</span></span> <span data-ttu-id="16030-115">또한 정책 검색을 통해 바인딩을 가져오는 페더레이션 클라이언트가 가져온 페더레이션 신뢰 체인의 발급자를 신뢰하는지 확인하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-115">It is also recommended that federated clients who obtain their bindings through policy retrieval verify that they trust the issuers in the obtained federated trust chain.</span></span> <span data-ttu-id="16030-116">페더레이션 시나리오에 대 한 자세한 내용은 [페더레이션](federation.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="16030-116">For more information about federation scenarios, see [Federation](federation.md).</span></span>

## <a name="memory-dumps-can-reveal-claim-information"></a><span data-ttu-id="16030-117">메모리 덤프가 클레임 정보를 노출할 수 있음</span><span class="sxs-lookup"><span data-stu-id="16030-117">Memory Dumps Can Reveal Claim Information</span></span>

<span data-ttu-id="16030-118">애플리케이션이 실패할 경우 예를 들어 Dr. Watson씨가 작성한 파일과 같이 로그 파일에 클레임 정보를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-118">When an application fails, log files, such as those produced by Dr. Watson, can contain the claim information.</span></span> <span data-ttu-id="16030-119">이 정보는 지원 팀과 같은 다른 엔터티에 내보내지 않아야 합니다. 그렇지 않을 경우 개인 데이터가 포함된 클레임 정보도 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="16030-119">This information should not be exported to other entities, such as support teams; otherwise, the claim information that contains private data is also exported.</span></span> <span data-ttu-id="16030-120">로그 파일을 알 수 없는 엔터티에 보내지 않으면 이러한 문제를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-120">You can mitigate this by not sending the log files to unknown entities.</span></span>

## <a name="endpoint-addresses"></a><span data-ttu-id="16030-121">엔드포인트 주소</span><span class="sxs-lookup"><span data-stu-id="16030-121">Endpoint Addresses</span></span>

<span data-ttu-id="16030-122">엔드포인트 주소에는 엔드포인트와 통신하는 데 필요한 정보가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-122">An endpoint address contains the information needed to communicate with an endpoint.</span></span> <span data-ttu-id="16030-123">SOAP 보안에서는 클라이언트와 서버 간의 대칭 키를 협상하기 위해 교환되는 보안 협상 메시지에 전체 주소가 포함되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-123">SOAP security must include the address in full in the security negotiation messages that are exchanged in order to negotiate a symmetric key between a client and a server.</span></span> <span data-ttu-id="16030-124">보안 협상은 부트스트랩 프로세스이기 때문에 이 프로세스 동안 주소 헤더를 암호화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-124">Because security negotiation is a bootstrap process, the address headers cannot be encrypted during this process.</span></span> <span data-ttu-id="16030-125">따라서 주소에 어떠한 기밀 데이터도 포함하지 않아야 합니다. 포함할 경우 정보 공개 공격을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-125">Therefore, the address should not contain any confidential data; otherwise, it leads to information disclosure attacks.</span></span>

## <a name="certificates-transferred-unencrypted"></a><span data-ttu-id="16030-126">암호화되지 않은 상태로 전송된 인증서</span><span class="sxs-lookup"><span data-stu-id="16030-126">Certificates Transferred Unencrypted</span></span>

<span data-ttu-id="16030-127">X.509 인증서를 사용하여 클라이언트를 인증하는 경우 인증서는 SOAP 헤더 내에서 보안되지 않은 상태로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="16030-127">When you use an X.509 certificate to authenticate a client, the certificate is transferred in the clear, inside the SOAP header.</span></span> <span data-ttu-id="16030-128">이것은 잠재적인 PII(개인적으로 식별할 수 있는 정보) 공개로 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-128">Be aware of this as a potential personally identifiable information (PII) disclosure.</span></span> <span data-ttu-id="16030-129">이는 전체 메시지가 전송 수준 보안으로 암호화되는 `TransportWithMessageCredential` 모드에는 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-129">This is not an issue for `TransportWithMessageCredential` mode, where the entire message is encrypted with transport-level security.</span></span>

## <a name="service-references"></a><span data-ttu-id="16030-130">서비스 참조</span><span class="sxs-lookup"><span data-stu-id="16030-130">Service References</span></span>

<span data-ttu-id="16030-131">서비스 참조는 다른 서비스에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="16030-131">A service reference is a reference to another service.</span></span> <span data-ttu-id="16030-132">예를 들어, 서비스가 작업 과정에서 서비스 참조를 클라이언트에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-132">For example, a service may pass a service reference to a client in the course of an operation.</span></span> <span data-ttu-id="16030-133">서비스 참조는 응용 프로그램 데이터 또는 자격 증명과 같은 정보를 대상에 공개 하기 전에 대상 주체의 id를 확인 하는 내부 구성 요소인 *트러스트 id 검증 도구* 와 함께 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="16030-133">The service reference is also used with a *trust identity verifier*, an internal component that ensures the identity of the target principal before disclosing information such as application data or credentials to the target.</span></span> <span data-ttu-id="16030-134">원격 트러스트 ID를 검증할 수 없거나 잘못된 경우 보낸 사람이 데이터 자체, 애플리케이션 또는 사용자를 손상시킬 수 있는 공개된 데이터가 없는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-134">If the remote trust identity cannot be verified or is incorrect, the sender should ensure that no data was disclosed that could compromise itself, the application, or the user.</span></span>

<span data-ttu-id="16030-135">완화 방안에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="16030-135">Mitigations include the following:</span></span>

- <span data-ttu-id="16030-136">서비스 참조는 신뢰할 수 있는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-136">Service references are assumed to be trustworthy.</span></span> <span data-ttu-id="16030-137">서비스 참조 인스턴스를 전송할 때마다 손상되지 않았는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-137">Take care whenever transferring service reference instances to ensure that they have not been tampered with.</span></span>

- <span data-ttu-id="16030-138">일부 애플리케이션에서 서비스 참조의 데이터 및 원격 호스트에서 제공하는 신뢰 데이터를 기반으로 신뢰를 대화형으로 구축하는 사용자 경험을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-138">Some applications can present a user experience that allows interactive establishment of trust based on data in the service reference and trust data proven by the remote host.</span></span> <span data-ttu-id="16030-139">WCF는 이러한 기능을 위한 확장 지점도 제공 하지만 사용자는 이러한 기능을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-139">WCF provides extensibility points for such a facility, but the user must implemented them.</span></span>

## <a name="ntlm"></a><span data-ttu-id="16030-140">NTLM</span><span class="sxs-lookup"><span data-stu-id="16030-140">NTLM</span></span>

<span data-ttu-id="16030-141">기본적으로 Windows 도메인 환경의 경우 Windows 인증은 Kerberos 프로토콜을 사용하여 사용자를 인증하고 권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-141">By default, in the Windows domain environment, Windows authentication uses the Kerberos protocol to authenticate and authorize users.</span></span> <span data-ttu-id="16030-142">일부 이유로 인해 Kerberos 프로토콜을 사용할 수 없는 경우 NTLM(NT LAN Manager)을 대신 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-142">If the Kerberos protocol cannot be used for some reason, NT LAN Manager (NTLM) is used as a fallback.</span></span> <span data-ttu-id="16030-143"><xref:System.ServiceModel.Security.WindowsClientCredential.AllowNtlm%2A> 속성을 `false`로 설정하면 이 동작을 비활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-143">You can disable this behavior by setting the <xref:System.ServiceModel.Security.WindowsClientCredential.AllowNtlm%2A> property to `false`.</span></span> <span data-ttu-id="16030-144">NTLM을 사용하는 경우 고려해야 할 문제는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-144">Issues to be aware of when allowing NTLM include:</span></span>

- <span data-ttu-id="16030-145">NTLM은 클라이언트 사용자 이름을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-145">NTLM exposes the client user name.</span></span> <span data-ttu-id="16030-146">사용자 이름을 기밀로 유지해야 하는 경우 바인딩의 `AllowNTLM` 속성을 `false`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="16030-146">If the user name needs to be kept confidential, then set the `AllowNTLM` property on the binding to `false`.</span></span>

- <span data-ttu-id="16030-147">NTLM은 서버 인증을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-147">NTLM does not provide server authentication.</span></span> <span data-ttu-id="16030-148">따라서 NTLM을 인증 프로토콜로 사용하는 경우 클라이언트가 올바른 서비스와 통신하는지 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-148">Therefore, the client cannot ensure that it is communicating with the right service when you use NTLM as an authentication protocol.</span></span>

### <a name="specifying-client-credentials-or-invalid-identity-forces-ntlm-usage"></a><span data-ttu-id="16030-149">클라이언트 자격 증명 또는 잘못된 ID를 지정하면 강제로 NTLM 사용</span><span class="sxs-lookup"><span data-stu-id="16030-149">Specifying Client Credentials or Invalid Identity Forces NTLM Usage</span></span>

<span data-ttu-id="16030-150">클라이언트를 만들 때 도메인 이름 없이 클라이언트 자격 증명을 지정하거나 잘못된 서버 ID를 지정하면 NTLM이 Kerberos 프로토콜 대신 사용됩니다(`AllowNtlm` 속성을 `true`로 설정한 경우).</span><span class="sxs-lookup"><span data-stu-id="16030-150">When creating a client, specifying client credentials without a domain name, or specifying an invalid server identity, causes NTLM to be used instead of the Kerberos protocol (if the `AllowNtlm` property is set to `true`).</span></span> <span data-ttu-id="16030-151">NTLM이 서버 인증을 수행하지 않기 때문에 정보가 잠재적으로 공개될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-151">Because  NTLM does not do server authentication, information can potentially be disclosed.</span></span>

<span data-ttu-id="16030-152">예를 들어 다음 Visual c # 코드에 표시 된 것 처럼 도메인 이름이 없는 Windows 클라이언트 자격 증명을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16030-152">For example, it is possible to specify Windows client credentials without a domain name, as shown in the following Visual C# code.</span></span>

```csharp
MyChannelFactory.Credentials.Windows.ClientCredential = new System.Net.NetworkCredential("username", "password");
```

<span data-ttu-id="16030-153">코드가 도메인 이름을 지정하지 않기 때문에 NTLM이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="16030-153">The code does not specify a domain name, and therefore NTLM will be used.</span></span>

<span data-ttu-id="16030-154">도메인을 지정했지만 엔드포인트 ID 기능을 사용하여 잘못된 서비스 사용자 이름을 지정하는 경우 NTLM이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="16030-154">If the domain is specified, but an invalid service principal name is specified using the endpoint identity feature, then NTLM is used.</span></span> <span data-ttu-id="16030-155">끝점 id를 지정 하는 방법에 대 한 자세한 내용은 [서비스 id 및 인증](service-identity-and-authentication.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="16030-155">For more information about how endpoint identity is specified, see [Service Identity and Authentication](service-identity-and-authentication.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="16030-156">참고 항목</span><span class="sxs-lookup"><span data-stu-id="16030-156">See also</span></span>

- [<span data-ttu-id="16030-157">Security Considerations</span><span class="sxs-lookup"><span data-stu-id="16030-157">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="16030-158">권한 상승</span><span class="sxs-lookup"><span data-stu-id="16030-158">Elevation of Privilege</span></span>](elevation-of-privilege.md)
- [<span data-ttu-id="16030-159">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="16030-159">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="16030-160">변조</span><span class="sxs-lookup"><span data-stu-id="16030-160">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="16030-161">지원 되지 않는 시나리오</span><span class="sxs-lookup"><span data-stu-id="16030-161">Unsupported Scenarios</span></span>](unsupported-scenarios.md)
- [<span data-ttu-id="16030-162">재생 공격</span><span class="sxs-lookup"><span data-stu-id="16030-162">Replay Attacks</span></span>](replay-attacks.md)
