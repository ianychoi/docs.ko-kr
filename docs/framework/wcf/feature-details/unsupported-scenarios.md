---
description: '자세한 정보: 지원 되지 않는 시나리오'
title: 지원되지 않는 시나리오
ms.date: 03/30/2017
ms.assetid: 72027d0f-146d-40c5-9d72-e94392c8bb40
ms.openlocfilehash: 7547a1acc060a6611a4750e512501cd314bed702
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99726756"
---
# <a name="unsupported-scenarios"></a><span data-ttu-id="e5310-103">지원되지 않는 시나리오</span><span class="sxs-lookup"><span data-stu-id="e5310-103">Unsupported scenarios</span></span>

<span data-ttu-id="e5310-104">다양 한 이유로 WCF (Windows Communication Foundation)는 특정 보안 시나리오를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-104">For various reasons, Windows Communication Foundation (WCF) does not support some specific security scenarios.</span></span> <span data-ttu-id="e5310-105">예를 들어 Windows XP Home Edition은 SSPI 또는 Kerberos 인증 프로토콜을 구현 하지 않으므로 WCF는 해당 플랫폼에서 Windows 인증을 사용 하는 서비스 실행을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-105">For example, Windows XP Home Edition does not implement the SSPI or Kerberos authentication protocols, and therefore WCF does not support running a service with Windows authentication on that platform.</span></span> <span data-ttu-id="e5310-106">Windows XP Home Edition에서 WCF를 실행 하는 경우 사용자 이름/암호 및 HTTP/HTTPS 통합 인증과 같은 다른 인증 메커니즘을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-106">Other authentication mechanisms, such as username/password and HTTP/HTTPS integrated authentication are supported when running WCF under Windows XP Home Edition.</span></span>

## <a name="impersonation-scenarios"></a><span data-ttu-id="e5310-107">가장 시나리오</span><span class="sxs-lookup"><span data-stu-id="e5310-107">Impersonation scenarios</span></span>

### <a name="impersonated-identity-might-not-flow-when-clients-make-asynchronous-calls"></a><span data-ttu-id="e5310-108">클라이언트에서 비동기 호출을 수행할 때 가장 id가 전달 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-108">Impersonated identity might not flow when clients make asynchronous calls</span></span>

 <span data-ttu-id="e5310-109">WCF 클라이언트가 가장을 사용하여 Windows 인증을 통해 WCF 서비스로 비동기 호출을 수행할 때 가장 ID 대신 클라이언트 프로세스 ID로 인증이 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-109">When a WCF client makes asynchronous calls to a WCF service using Windows authentication under impersonation, authentication might occur with the identity of the client process instead of the impersonated identity.</span></span>

### <a name="windows-xp-and-secure-context-token-cookie-enabled"></a><span data-ttu-id="e5310-110">Windows XP 및 보안 컨텍스트 토큰 쿠키 사용</span><span class="sxs-lookup"><span data-stu-id="e5310-110">Windows XP and secure context token cookie enabled</span></span>

<span data-ttu-id="e5310-111">WCF는 가장을 지원 하지 않으며 <xref:System.InvalidOperationException> 다음 조건에 해당할 경우이 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-111">WCF does not support impersonation and an <xref:System.InvalidOperationException> is thrown when the following conditions exist:</span></span>

- <span data-ttu-id="e5310-112">운영 체제가 Windows XP입니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-112">The operating system is Windows XP.</span></span>

- <span data-ttu-id="e5310-113">인증 모드에서 Windows ID를 생성하는 경우</span><span class="sxs-lookup"><span data-stu-id="e5310-113">The authentication mode results in a Windows identity.</span></span>

- <span data-ttu-id="e5310-114"><xref:System.ServiceModel.OperationBehaviorAttribute>의 <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> 속성이 <xref:System.ServiceModel.ImpersonationOption.Required>로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-114">The <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property of the <xref:System.ServiceModel.OperationBehaviorAttribute> is set to <xref:System.ServiceModel.ImpersonationOption.Required>.</span></span>

- <span data-ttu-id="e5310-115">상태 기반 SCT(보안 컨텍스트 토큰)가 만들어지는 경우(기본값: 만들기 사용 안 함)</span><span class="sxs-lookup"><span data-stu-id="e5310-115">A state-based security context token (SCT) is created (by default, creation is disabled).</span></span>

 <span data-ttu-id="e5310-116">상태 기반 SCT는 사용자 지정 바인딩을 통해서만 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-116">The state-based SCT can only be created using a custom binding.</span></span> <span data-ttu-id="e5310-117">자세한 내용은 [방법: 보안 세션에 대 한 보안 컨텍스트 토큰 만들기](how-to-create-a-security-context-token-for-a-secure-session.md)를 참조 하세요. 코드에서 <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> 또는 메서드를 사용 하 여 보안 바인딩 요소 (또는)를 만들고 <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement%28System.Boolean%29?displayProperty=nameWithType> <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%28System.ServiceModel.Channels.SecurityBindingElement%2CSystem.Boolean%29?displayProperty=nameWithType> `requireCancellation` 매개 변수를로 설정 `false` 하 여 토큰을 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-117">For more information, see [How to: Create a Security Context Token for a Secure Session](how-to-create-a-security-context-token-for-a-secure-session.md).) In code, the token is enabled by creating a security binding element (either <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> or <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement>) using the <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement%28System.Boolean%29?displayProperty=nameWithType> or the <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%28System.ServiceModel.Channels.SecurityBindingElement%2CSystem.Boolean%29?displayProperty=nameWithType> method and setting the `requireCancellation` parameter to `false`.</span></span> <span data-ttu-id="e5310-118">매개 변수는 SCT 캐싱을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-118">The parameter refers to the caching of the SCT.</span></span> <span data-ttu-id="e5310-119">값을 `false`로 설정하면 상태 기반 SCT 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-119">Setting the value to `false` enables the state-based SCT feature.</span></span>

 <span data-ttu-id="e5310-120">또는 구성에서는 <`customBinding`> 만든 다음 <> 요소를 추가 하 `security` 고 특성을 ws-secureconversation로 설정 하 고 특성을로 설정 하 여 토큰을 사용 하도록 설정 합니다 `authenticationMode` `requireSecurityContextCancellation` `true` .</span><span class="sxs-lookup"><span data-stu-id="e5310-120">Alternatively, in configuration, the token is enabled by creating a <`customBinding`>, then adding a <`security`> element, and setting the `authenticationMode` attribute to SecureConversation and the `requireSecurityContextCancellation` attribute to `true`.</span></span>

> [!NOTE]
> <span data-ttu-id="e5310-121">앞의 요구 사항은 각기 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-121">The preceding requirements are specific.</span></span> <span data-ttu-id="e5310-122">예를 들어, <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement%2A>는 Windows ID를 생성하는 바인딩 요소를 만들지만 SCT를 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-122">For example, the <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement%2A> creates a binding element that results in a Windows identity, but does not establish an SCT.</span></span> <span data-ttu-id="e5310-123">따라서 `Required` WINDOWS XP의 옵션과 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-123">Therefore, you can use it with the `Required` option on Windows XP.</span></span>

### <a name="possible-aspnet-conflict"></a><span data-ttu-id="e5310-124">가능한 ASP.NET 충돌</span><span class="sxs-lookup"><span data-stu-id="e5310-124">Possible ASP.NET conflict</span></span>

<span data-ttu-id="e5310-125">WCF 및 ASP.NET는 모두 가장을 사용 하거나 사용 하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-125">WCF and ASP.NET can both enable or disable impersonation.</span></span> <span data-ttu-id="e5310-126">ASP.NET가 WCF 응용 프로그램을 호스트 하는 경우 WCF와 ASP.NET 구성 설정 사이에 충돌이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-126">When ASP.NET hosts a WCF application, a conflict may exist between the WCF and ASP.NET configuration settings.</span></span> <span data-ttu-id="e5310-127">충돌이 발생 하는 경우 속성이로 설정 되지 않은 경우 WCF 설정이 우선적으로 적용 됩니다 <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> <xref:System.ServiceModel.ImpersonationOption.NotAllowed> .이 경우 ASP.NET 가장 설정이 우선적으로 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-127">In case of conflict, the WCF setting takes precedence, unless the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property is set to <xref:System.ServiceModel.ImpersonationOption.NotAllowed>, in which case the ASP.NET impersonation setting takes precedence.</span></span>

### <a name="assembly-loads-may-fail-under-impersonation"></a><span data-ttu-id="e5310-128">가장 하는 동안 어셈블리 로드가 실패할 수 있음</span><span class="sxs-lookup"><span data-stu-id="e5310-128">Assembly loads may fail under impersonation</span></span>

<span data-ttu-id="e5310-129">가장 컨텍스트에 어셈블리 로드 액세스 권한이 없고 CLR(공용 언어 런타임)에서 AppDomain에 대한 어셈블리 로드를 처음으로 시도하는 경우 <xref:System.AppDomain>은 오류를 캐시합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-129">If the impersonated context does not have access rights to load an assembly and if it is the first time the common language runtime (CLR) is attempting to load the assembly for that AppDomain, the <xref:System.AppDomain> caches the failure.</span></span> <span data-ttu-id="e5310-130">가장을 변환한 이후 변환된 컨텍스트에 어셈블리 로드 액세스 권한이 있더라도 후속 어셈블리 로드 시도는 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-130">Subsequent attempts to load that assembly (or assemblies) fail, even after reverting the impersonation, and even if the reverted context has access rights to load the assembly.</span></span> <span data-ttu-id="e5310-131">이는 사용자 컨텍스트가 변경 된 후 CLR에서 로드를 다시 시도 하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-131">This is because the CLR does not reattempt the load after the user context is changed.</span></span> <span data-ttu-id="e5310-132">오류를 복구하려면 애플리케이션 도메인을 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-132">You must restart the application domain to recover from the failure.</span></span>

> [!NOTE]
> <span data-ttu-id="e5310-133"><xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> 클래스의 <xref:System.ServiceModel.Security.WindowsClientCredential> 속성 기본값은 <xref:System.Security.Principal.TokenImpersonationLevel.Identification>입니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-133">The default value for the <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> property of the <xref:System.ServiceModel.Security.WindowsClientCredential> class is <xref:System.Security.Principal.TokenImpersonationLevel.Identification>.</span></span> <span data-ttu-id="e5310-134">대부분의 경우 확인 수준 가장 컨텍스트에는 추가 어셈블리 로드 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-134">In most cases, an identification-level impersonation context has no rights to load any additional assemblies.</span></span> <span data-ttu-id="e5310-135">이는 기본값이므로 일반적인 조건으로 알아 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-135">This is the default value, so this is a very common condition to be aware of.</span></span> <span data-ttu-id="e5310-136">확인 수준 가장은 가장 프로세스에 `SeImpersonate` 권한이 없는 경우에도 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-136">Identification-level impersonation also occurs when the impersonating process does not have the `SeImpersonate` privilege.</span></span> <span data-ttu-id="e5310-137">자세한 내용은 [위임 및 가장](delegation-and-impersonation-with-wcf.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e5310-137">For more information, see [Delegation and Impersonation](delegation-and-impersonation-with-wcf.md).</span></span>

### <a name="delegation-requires-credential-negotiation"></a><span data-ttu-id="e5310-138">위임에 자격 증명 협상이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-138">Delegation requires credential negotiation</span></span>

<span data-ttu-id="e5310-139">Kerberos 인증 프로토콜을 위임과 함께 사용하려면 자격 증명 협상이 포함된 Kerberos 프로토콜(multi-leg 또는 multi-step Kerberos라고도 함)을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-139">To use the Kerberos authentication protocol with delegation, you must implement the Kerberos protocol with credential negotiation (sometimes called multi-leg or multi-step Kerberos).</span></span> <span data-ttu-id="e5310-140">자격 증명 협상이 포함되지 않은 Kerberos 프로토콜(one-shot 또는 single-leg Kerberos라고도 함)을 구현하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-140">If you implement Kerberos authentication without credential negotiation (sometimes called one-shot or single-leg Kerberos), an exception is thrown.</span></span> <span data-ttu-id="e5310-141">자격 증명 협상을 구현 하는 방법에 대 한 자세한 내용은 [Windows 인증 오류 디버깅](debugging-windows-authentication-errors.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e5310-141">For more information about how to implement credential negotiation, see [Debugging Windows Authentication Errors](debugging-windows-authentication-errors.md).</span></span>

## <a name="cryptography"></a><span data-ttu-id="e5310-142">암호화</span><span class="sxs-lookup"><span data-stu-id="e5310-142">Cryptography</span></span>

### <a name="sha-256-supported-only-for-symmetric-key-usages"></a><span data-ttu-id="e5310-143">SHA-256은 대칭 키 사용에만 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-143">SHA-256 supported only for symmetric key usages</span></span>

<span data-ttu-id="e5310-144">WCF는 시스템에서 제공 하는 바인딩에 알고리즘 모음을 사용 하 여 지정할 수 있는 다양 한 암호화 및 서명 다이제스트 만들기 알고리즘을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-144">WCF supports a variety of encryption and signature digest creation algorithms that you can specify using the algorithm suite in the system-provided bindings.</span></span> <span data-ttu-id="e5310-145">보안 향상을 위해 WCF는 서명 다이제스트 해시를 만들기 위한 SHA (Secure Hash Algorithm) 2 알고리즘, 특히 SHA-256을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-145">For improved security, WCF supports Secure Hash Algorithm (SHA) 2 algorithms, specifically SHA-256, for creating signature digest hashes.</span></span> <span data-ttu-id="e5310-146">이 릴리스는 Kerberos 키와 같은 대칭 키를 사용하는 경우와 메시지 서명에 X.509 인증서를 사용하지 않는 경우에 SHA-256을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-146">This release supports SHA-256 only for symmetric key usages, such as Kerberos keys, and where an X.509 certificate is not used to sign the message.</span></span> <span data-ttu-id="e5310-147">WCF는 WinFX에서 현재 RSA-SHA256에 대 한 지원이 부족 하기 때문에 SHA-256 해시를 사용 하 여 RSA 서명 (x.509 인증서에 사용 됨)을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-147">WCF does not support RSA signatures (used in X.509 certificates) using SHA-256 hash due to the current lack of support for RSA-SHA256 in the WinFX.</span></span>

### <a name="fips-compliant-sha-256-hashes-not-supported"></a><span data-ttu-id="e5310-148">FIPS 규격 SHA-256 해시가 지원 되지 않음</span><span class="sxs-lookup"><span data-stu-id="e5310-148">FIPS-compliant SHA-256 hashes not supported</span></span>

<span data-ttu-id="e5310-149">WCF는 SHA-256 FIPS 규격 해시를 지원 하지 않으므로, s h a-256를 사용 하는 알고리즘 도구는 FIPS 규격 알고리즘을 사용 해야 하는 시스템의 WCF에서 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-149">WCF does not support SHA-256 FIPS-compliant hashes, so algorithm suites that use SHA-256 are not supported by WCF on systems where use of FIPS-compliant algorithms is required.</span></span>

### <a name="fips-compliant-algorithms-may-fail-if-registry-is-edited"></a><span data-ttu-id="e5310-150">레지스트리를 편집할 경우 FIPS 규격 알고리즘이 실패할 수 있음</span><span class="sxs-lookup"><span data-stu-id="e5310-150">FIPS-compliant algorithms may fail if registry is edited</span></span>

<span data-ttu-id="e5310-151">로컬 보안 설정 MMC(Microsoft Management Console) 스냅인을 사용하여 FIPS(Federal Information Processing Standards) 규격 알고리즘을 사용하거나 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-151">You can enable and disable Federal Information Processing Standards (FIPS)-compliant algorithms by using the Local Security Settings Microsoft Management Console (MMC) snap-in.</span></span> <span data-ttu-id="e5310-152">레지스트리에서 설정에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-152">You can also access the setting in the registry.</span></span> <span data-ttu-id="e5310-153">그러나 WCF는 레지스트리를 사용 하 여 설정을 다시 설정 하는 것을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-153">Note, however, that WCF does not support using the registry to reset the setting.</span></span> <span data-ttu-id="e5310-154">1 또는 0 이외의 값을 설정하면 CLR과 운영 체제 간에 일치하지 않는 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-154">If the value is set to anything other than 1 or 0, inconsistent results can occur between the CLR and the operating system.</span></span>

### <a name="fips-compliant-aes-encryption-limitation"></a><span data-ttu-id="e5310-155">FIPS 규격 AES 암호화 제한</span><span class="sxs-lookup"><span data-stu-id="e5310-155">FIPS-compliant AES encryption limitation</span></span>

<span data-ttu-id="e5310-156">FIPS 규격 AES 암호화는 id 수준 가장의 이중 콜백에서 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-156">FIPS-compliant AES encryption does not work in duplex callbacks under identification level impersonation.</span></span>

### <a name="cngksp-certificates"></a><span data-ttu-id="e5310-157">CNG/KSP 인증서</span><span class="sxs-lookup"><span data-stu-id="e5310-157">CNG/KSP certificates</span></span>

<span data-ttu-id="e5310-158">*암호화 API: 차세대 (CNG)* 는 CryptoAPI의 장기 대체 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-158">*Cryptography API: Next Generation (CNG)* is the long-term replacement for the CryptoAPI.</span></span> <span data-ttu-id="e5310-159">이 API는 Windows Vista, Windows Server 2008 이상 버전의 비관리 코드에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-159">This API is available in unmanaged code on Windows Vista, Windows Server 2008, and later Windows versions.</span></span>

 <span data-ttu-id="e5310-160">.NET Framework 4.6.1 및 이전 버전은 레거시 CryptoAPI를 사용 하 여 CNG/KSP 인증서를 처리 하기 때문에 이러한 인증서를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-160">.NET Framework 4.6.1 and earlier versions do not support these certificates because they use the legacy CryptoAPI to handle CNG/KSP certificates.</span></span> <span data-ttu-id="e5310-161">.NET Framework 4.6.1 이전 버전에서 이러한 인증서를 사용 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-161">The use of these certificates with   .NET Framework 4.6.1 and earlier versions will cause an exception.</span></span>

 <span data-ttu-id="e5310-162">인증서에서 KSP를 사용하는지 여부를 파악하는 방법은 다음 두 가지입니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-162">There are two possible ways to tell if a certificate uses KSP:</span></span>

- <span data-ttu-id="e5310-163">`p/invoke`에 대해 `CertGetCertificateContextProperty`를 실행하고 반환되는 `dwProvType`에서 `CertGetCertificateContextProperty`이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-163">Do a `p/invoke` of `CertGetCertificateContextProperty`, and inspect `dwProvType` on the returned `CertGetCertificateContextProperty`.</span></span>

- <span data-ttu-id="e5310-164">명령줄에서 명령을 사용 하 여  `certutil` 인증서를 쿼리 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-164">Use the  `certutil` command from the command line for querying certificates.</span></span> <span data-ttu-id="e5310-165">자세한 내용은 [인증서 문제 해결을 위한 Certutil 작업](/previous-versions/orphan-topics/ws.10/cc772619(v=ws.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e5310-165">For more information, see [Certutil tasks for troubleshooting certificates](/previous-versions/orphan-topics/ws.10/cc772619(v=ws.10)).</span></span>

## <a name="message-security-fails-if-using-aspnet-impersonation-and-aspnet-compatibility-is-required"></a><span data-ttu-id="e5310-166">ASP.NET 가장 및 ASP.NET 호환성을 사용 해야 하는 경우 메시지 보안 실패</span><span class="sxs-lookup"><span data-stu-id="e5310-166">Message security fails if using ASP.NET impersonation and ASP.NET compatibility is required</span></span>

<span data-ttu-id="e5310-167">WCF는 클라이언트 인증이 발생 하는 것을 방지할 수 있기 때문에 다음과 같은 설정 조합을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-167">WCF does not support the following combination of settings because they can prevent client authentication from occurring:</span></span>

- <span data-ttu-id="e5310-168">ASP.NET 가장을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-168">ASP.NET Impersonation is enabled.</span></span> <span data-ttu-id="e5310-169">Web.config 파일에서 `impersonate` <> 요소의 특성을로 설정 하 여이 작업을 수행 `identity` `true` 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-169">This is done in the Web.config file by setting the `impersonate` attribute of the <`identity`> element to `true`.</span></span>

- <span data-ttu-id="e5310-170">ASP.NET 호환성 모드는의 특성을로 설정 하 여 사용할 수 `aspNetCompatibilityEnabled` [\<serviceHostingEnvironment>](../../configure-apps/file-schema/wcf/servicehostingenvironment.md) `true` 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-170">ASP.NET compatibility mode is enabled by setting the `aspNetCompatibilityEnabled` attribute of the [\<serviceHostingEnvironment>](../../configure-apps/file-schema/wcf/servicehostingenvironment.md) to `true`.</span></span>

- <span data-ttu-id="e5310-171">메시지 모드 보안이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-171">Message mode security is used.</span></span>

<span data-ttu-id="e5310-172">해결 방법은 ASP.NET 호환 모드를 해제 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-172">The work-around is to turn off the ASP.NET compatibility mode.</span></span> <span data-ttu-id="e5310-173">또는 ASP.NET 호환 모드가 필요한 경우 ASP.NET 가장 기능을 사용 하지 않도록 설정 하 고 WCF에서 제공 하는 가장을 대신 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-173">Or, if the ASP.NET compatibility mode is required, disable the ASP.NET impersonation feature and use WCF-provided impersonation instead.</span></span> <span data-ttu-id="e5310-174">자세한 내용은 [위임 및 가장](delegation-and-impersonation-with-wcf.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e5310-174">For more information, see [Delegation and Impersonation](delegation-and-impersonation-with-wcf.md).</span></span>

## <a name="ipv6-literal-address-failure"></a><span data-ttu-id="e5310-175">IPv6 리터럴 주소 오류</span><span class="sxs-lookup"><span data-stu-id="e5310-175">IPv6 literal address failure</span></span>

<span data-ttu-id="e5310-176">클라이언트와 서비스가 동일한 컴퓨터에 있고 IPv6 리터럴 주소가 서비스에 사용되는 경우 보안 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-176">Security requests fail when the client and service are on the same machine, and IPv6 literal addresses are used for the service.</span></span>

 <span data-ttu-id="e5310-177">리터럴 IPv6 주소는 서비스와 클라이언트가 서로 다른 컴퓨터에 있는 경우에 작동됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-177">Literal IPv6 addresses work if the service and client are on different machines.</span></span>

## <a name="wsdl-retrieval-failures-with-federated-trust"></a><span data-ttu-id="e5310-178">페더레이션된 트러스트를 사용 하는 WSDL 검색 오류</span><span class="sxs-lookup"><span data-stu-id="e5310-178">WSDL retrieval failures with federated trust</span></span>

<span data-ttu-id="e5310-179">WCF에는 페더레이션된 트러스트 체인의 각 노드에 대해 정확히 하나의 WSDL 문서가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-179">WCF requires exactly one WSDL document for each node in the federated trust chain.</span></span> <span data-ttu-id="e5310-180">엔드포인트를 지정할 때 루프를 설정하지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-180">Be careful not to set up a loop when specifying endpoints.</span></span> <span data-ttu-id="e5310-181">루프를 발생시킬 수 있는 한 가지 방법은 같은 WSDL 문서에 두 개 이상의 링크가 포함된 페더레이션 신뢰 체인에 대해 WSDL 다운로드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-181">One way in which loops can arise is using a WSDL download of federated trust chains with two or more links in the same WSDL document.</span></span> <span data-ttu-id="e5310-182">이 문제를 일으킬 수 있는 일반적인 시나리오로 보안 토큰 서버와 서비스가 동일한 ServiceHost 내에 포함된 페더레이션 서비스를 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-182">A common scenario that can produce this problem is a federated service where the Security Token Server and the service are contained inside the same ServiceHost.</span></span>

 <span data-ttu-id="e5310-183">다음과 같은 세 엔드포인트 주소가 있는 서비스를 이러한 상황의 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-183">An example of this situation is a service with the following three endpoint addresses:</span></span>

- <span data-ttu-id="e5310-184">`http://localhost/CalculatorService/service` (서비스)</span><span class="sxs-lookup"><span data-stu-id="e5310-184">`http://localhost/CalculatorService/service` (the service)</span></span>

- <span data-ttu-id="e5310-185">`http://localhost/CalculatorService/issue_ticket` (STS)</span><span class="sxs-lookup"><span data-stu-id="e5310-185">`http://localhost/CalculatorService/issue_ticket` (the STS)</span></span>

- <span data-ttu-id="e5310-186">`http://localhost/CalculatorService/mex` (메타 데이터 끝점)</span><span class="sxs-lookup"><span data-stu-id="e5310-186">`http://localhost/CalculatorService/mex` (the metadata endpoint)</span></span>

 <span data-ttu-id="e5310-187">이 경우 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-187">This throws an exception.</span></span>

 <span data-ttu-id="e5310-188">ph x="1" /&gt; 엔드포인트를 다른 곳에 넣어 이 시나리오가 작동하게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-188">You can make this scenario work by putting the `issue_ticket` endpoint elsewhere.</span></span>

## <a name="wsdl-import-attributes-can-be-lost"></a><span data-ttu-id="e5310-189">WSDL 가져오기 특성이 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-189">WSDL import attributes can be lost</span></span>

<span data-ttu-id="e5310-190">WSDL 가져오기를 실행할 때는 WCF에서 `<wst:Claims>` 템플릿의 `RST` 요소에 대한 특성을 추적하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-190">WCF loses track of the attributes on a `<wst:Claims>` element in an `RST` template when doing a WSDL import.</span></span> <span data-ttu-id="e5310-191">WSDL 가져오기 중에 클레임 형식 컬렉션을 직접 사용하지 않고 `<Claims>` 또는 `WSFederationHttpBinding.Security.Message.TokenRequestParameters`에서 직접 `IssuedSecurityTokenRequestParameters.AdditionalRequestParameters`를 지정하는 경우에 이 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-191">This happens during a WSDL import if you specify `<Claims>` directly in `WSFederationHttpBinding.Security.Message.TokenRequestParameters` or `IssuedSecurityTokenRequestParameters.AdditionalRequestParameters` instead of using the claim type collections directly.</span></span>  <span data-ttu-id="e5310-192">가져오기 중에 특성이 손실되므로 바인딩이 WSDL을 통해 제대로 라운드트립되지 않고 클라이언트측에서 잘못됩니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-192">Since the import loses the attributes, the binding does not round trip properly through WSDL and hence is incorrect on the client side.</span></span>

 <span data-ttu-id="e5310-193">문제를 해결하려면 가져오기를 실행한 후 클라이언트에서 직접 바인딩을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="e5310-193">The fix is to modify the binding directly on the client after doing the import.</span></span>

## <a name="see-also"></a><span data-ttu-id="e5310-194">참고 항목</span><span class="sxs-lookup"><span data-stu-id="e5310-194">See also</span></span>

- [<span data-ttu-id="e5310-195">Security Considerations</span><span class="sxs-lookup"><span data-stu-id="e5310-195">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="e5310-196">정보 공개</span><span class="sxs-lookup"><span data-stu-id="e5310-196">Information Disclosure</span></span>](information-disclosure.md)
- [<span data-ttu-id="e5310-197">권한 상승</span><span class="sxs-lookup"><span data-stu-id="e5310-197">Elevation of Privilege</span></span>](elevation-of-privilege.md)
- [<span data-ttu-id="e5310-198">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="e5310-198">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="e5310-199">변조</span><span class="sxs-lookup"><span data-stu-id="e5310-199">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="e5310-200">재생 공격</span><span class="sxs-lookup"><span data-stu-id="e5310-200">Replay Attacks</span></span>](replay-attacks.md)
