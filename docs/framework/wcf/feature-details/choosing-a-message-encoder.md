---
description: '자세한 정보: 메시지 인코더 선택'
title: 메시지 인코더 선택
ms.date: 03/30/2017
ms.assetid: 2204d82d-d962-4922-a79e-c9a231604f19
ms.openlocfilehash: 16f58dd0510584fa94363f63e1a2e56a9de83b52
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99734999"
---
# <a name="choose-a-message-encoder"></a><span data-ttu-id="f9370-103">메시지 인코더 선택</span><span class="sxs-lookup"><span data-stu-id="f9370-103">Choose a Message Encoder</span></span>

<span data-ttu-id="f9370-104">이 문서에서는 Windows Communication Foundation (WCF)에 포함 된 메시지 인코더 중 이진, 텍스트 및 MTOM (메시지 전송 최적화 메커니즘) 중에서 선택 하는 조건을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-104">This article discusses criteria for choosing among the message encoders that are included in Windows Communication Foundation (WCF): binary, text, and Message Transmission Optimization Mechanism (MTOM).</span></span>  
  
 <span data-ttu-id="f9370-105">WCF에서는 바인딩을 사용 하 여 네트워크를 통해 끝점 간에 데이터를 전송 하는 방법을 지정 합니다 *. 바인딩은* *바인딩 요소로* 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-105">In WCF, you specify how to transfer data across a network between endpoints by means of a *binding*, which is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="f9370-106">메시지 인코더는 바인딩 스택에서 바인딩 요소를 인코딩하는 메시지로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-106">A message encoder is represented by a message encoding binding element in the binding stack.</span></span> <span data-ttu-id="f9370-107">바인딩에는 보안 바인딩 요소 또는 신뢰할 수 있는 메시징 바인딩 요소, 필수 메시지 인코딩 바인딩 요소, 필수 전송 바인딩 요소와 같은 선택적 프로토콜 바인딩 요소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-107">A binding includes optional protocol binding elements, such as a security binding element or reliable messaging binding element, a required message encoding binding element, and a required transport binding element.</span></span>  
  
 <span data-ttu-id="f9370-108">메시지 인코딩 바인딩 요소는 선택적 프로토콜 바인딩 요소보다는 아래에, 필수 전송 바인딩 요소보다는 위에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-108">The message encoding binding element sits below the optional protocol binding elements and above the required transport binding element.</span></span> <span data-ttu-id="f9370-109">나가는 쪽에서는 메시지 인코더가 나가는 <xref:System.ServiceModel.Channels.Message>를 serialize하고 이를 전송에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-109">On the outgoing side, a message encoder serializes the outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport.</span></span> <span data-ttu-id="f9370-110">들어오는 쪽에서는 메시지 인코더가 전송으로부터 <xref:System.ServiceModel.Channels.Message>의 serialize된 형식을 받고, 더 높은 프로토콜 계층이 있으면 해당 계층으로 이를 전달하며, 더 높은 계층이 없으면 이를 애플리케이션으로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-110">On the incoming side, a message encoder receives the serialized form of a <xref:System.ServiceModel.Channels.Message> from the transport and passes it to the higher protocol layer, if present, or to the application, if not.</span></span>  
  
 <span data-ttu-id="f9370-111">기존 클라이언트 또는 서버에 연결할 때는 다른 쪽에서 원하는 방식으로 메시지를 인코딩해야 하므로 특정 메시지의 인코딩 사용을 선택하지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-111">When connecting to a pre-existing client or server, you may not have a choice about using a particular message encoding since you need to encode your messages in a way that the other side is expecting.</span></span> <span data-ttu-id="f9370-112">그러나 WCF 서비스를 작성 하는 경우에는 각각 서로 다른 메시지 인코딩을 사용 하 여 여러 끝점을 통해 서비스를 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-112">However, if you are writing a WCF service, you can expose your service through multiple endpoints, each using a different message encoding.</span></span> <span data-ttu-id="f9370-113">이를 통해 클라이언트는 가장 적합한 인코딩을 선택할 수 있는 유연성을 가질 뿐만 아니라 가장 적합한 엔드포인트를 통해 서비스와 통신하기 위한 최적의 인코딩을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-113">This allows clients to choose the best encoding for talking to your service over the endpoint that is best for them, as well as giving your clients the flexibility to choose the encoding that is best for them.</span></span> <span data-ttu-id="f9370-114">여러 엔드포인트를 사용하면 여러 메시지 인코딩의 이점을 다른 바인딩 요소와 결합할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-114">Using multiple endpoints also allows you to combine the advantages of different message encodings with other binding elements.</span></span>  
  
## <a name="system-provided-encoders"></a><span data-ttu-id="f9370-115">시스템 제공 인코더</span><span class="sxs-lookup"><span data-stu-id="f9370-115">System-Provided Encoders</span></span>  

 <span data-ttu-id="f9370-116">WCF에는 다음 세 가지 클래스로 표시 되는 세 가지 메시지 인코더가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-116">WCF includes three message encoders, which are represented by the following three classes:</span></span>  
  
- <span data-ttu-id="f9370-117"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: 텍스트 메시지 인코더로, 일반 XML 인코딩 및 SOAP 인코딩을 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-117"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>, the text message encoder, supports both plain XML encoding and SOAP encoding.</span></span> <span data-ttu-id="f9370-118">텍스트 메시지 인코더의 일반 XML 인코딩 모드는 텍스트 기반 SOAP 인코딩과 구별하기 위해 POX("Plain Old Xml")라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-118">The plain XML encoding mode of the text message encoder is called "plain old XML" (POX) to distinguish it from text-based SOAP encoding.</span></span> <span data-ttu-id="f9370-119">POX를 사용하도록 설정하려면 <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement.MessageVersion%2A> 속성을 <xref:System.ServiceModel.Channels.MessageVersion.None%2A>으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-119">To enable POX, set the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement.MessageVersion%2A> property to <xref:System.ServiceModel.Channels.MessageVersion.None%2A>.</span></span> <span data-ttu-id="f9370-120">텍스트 메시지 인코더를 사용 하 여 비 WCF 끝점과 상호 운용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-120">Use the text message encoder to interoperate with non-WCF endpoints.</span></span>  
  
- <span data-ttu-id="f9370-121"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>이진 메시지 인코더는 컴팩트 이진 형식을 사용 하며 WCF에서 WCF로의 통신에 최적화 되어 있으므로 상호 운용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-121"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>, the binary message encoder, uses a compact binary format and is optimized for WCF to WCF communication, and hence is not interoperable.</span></span> <span data-ttu-id="f9370-122">이는 WCF에서 제공 하는 모든 인코더의 가장 성능이 뛰어난 인코더 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-122">This is also the most performant encoder of all the encoders WCF provides.</span></span>  
  
- <span data-ttu-id="f9370-123"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>: 바인딩 요소로, MTOM 인코딩을 사용하여 메시지에 대해 메시지 버전 및 문자 인코딩을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-123"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>, the binding element, specifies the character encoding and message versioning for messages using MTOM encoding.</span></span> <span data-ttu-id="f9370-124">MTOM은 WCF 메시지의 이진 데이터를 전송하기 위한 효율적인 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-124">MTOM is an efficient technology for transmitting binary data in WCF messages.</span></span> <span data-ttu-id="f9370-125">MTOM 인코더는 효율성과 상호 운용성 간의 균형을 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-125">The MTOM encoder attempts to create a balance between efficiency and interoperability.</span></span> <span data-ttu-id="f9370-126">MTOM 인코딩은 대부분의 XML을 텍스트 형식으로 전송하지만, 큰 이진 데이터 블록의 경우에는 텍스트로 변환하지 않고 있는 그대로 전송하여 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-126">The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.</span></span> <span data-ttu-id="f9370-127">WCF에서 제공 하는 인코더 사이에서 효율성 측면에서 MTOM은 텍스트 (가장 느림)와 이진 (가장 빠름) 사이에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-127">In terms of efficiency, among the encoders WCF provides, MTOM is in-between text (the slowest) and binary (the fastest).</span></span>  
  
## <a name="how-to-choose-a-message-encoder"></a><span data-ttu-id="f9370-128">메시지 인코더를 선택하는 방법</span><span class="sxs-lookup"><span data-stu-id="f9370-128">How to Choose a Message Encoder</span></span>  

 <span data-ttu-id="f9370-129">다음 표에서는 메시지 인코더를 선택하는 데 사용하는 일반 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-129">The following table describes common factors used to choose a message encoder.</span></span> <span data-ttu-id="f9370-130">애플리케이션의 중요한 요소에 우선 순위를 지정한 다음 이러한 요소에 가장 적합한 메시지 인코더를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-130">Prioritize the factors that are important for your application, and then choose the message encoders that work best with these factors.</span></span> <span data-ttu-id="f9370-131">이 표에 나열되지 않은 모든 추가 요소 및 애플리케이션에 필요할 수 있는 모든 사용자 지정 메시지 인코더를 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-131">Be sure to consider any additional factors not listed in this table and any custom message encoders that may be required in your application.</span></span>  
  
|<span data-ttu-id="f9370-132">요인</span><span class="sxs-lookup"><span data-stu-id="f9370-132">Factor</span></span>|<span data-ttu-id="f9370-133">설명</span><span class="sxs-lookup"><span data-stu-id="f9370-133">Description</span></span>|<span data-ttu-id="f9370-134">이 요소를 지원하는 인코더</span><span class="sxs-lookup"><span data-stu-id="f9370-134">Encoders that support this factor</span></span>|  
|------------|-----------------|---------------------------------------|  
|<span data-ttu-id="f9370-135">지원되는 문자 집합</span><span class="sxs-lookup"><span data-stu-id="f9370-135">Supported Character Sets</span></span>|<span data-ttu-id="f9370-136"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> 및 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> 은 UTF8 및 UTF16 Unicode (*빅 endian* 및 *작은 endian*) 인코딩만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-136"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> and <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> support only the UTF8 and UTF16 Unicode (*big-endian* and *little-endian*) encodings.</span></span> <span data-ttu-id="f9370-137">UTF7 또는 ASCII와 같은 다른 인코딩이 필요한 경우 사용자 지정 인코더를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-137">If other encodings are required, such as UTF7 or ASCII, a custom encoder must be used.</span></span> <span data-ttu-id="f9370-138">샘플 사용자 지정 인코더는 [사용자 지정 메시지 인코더](../samples/custom-message-encoder-custom-text-encoder.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="f9370-138">For a sample custom encoder, see [Custom Message Encoder](../samples/custom-message-encoder-custom-text-encoder.md).</span></span>|<span data-ttu-id="f9370-139">텍스트</span><span class="sxs-lookup"><span data-stu-id="f9370-139">Text</span></span>|  
|<span data-ttu-id="f9370-140">검사</span><span class="sxs-lookup"><span data-stu-id="f9370-140">Inspection</span></span>|<span data-ttu-id="f9370-141">검사는 전송을 하는 동안 메시지를 검사하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-141">Inspection is the ability to examine messages during transmission.</span></span> <span data-ttu-id="f9370-142">SOAP의 사용 여부에 관계없이 특수화된 도구를 사용하지 않고도 텍스트 인코딩을 통해 많은 애플리케이션에서 메시지를 검사 및 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-142">Text encodings, either with or without the use of SOAP, allow messages to be inspected and analyzed by many applications without the use of specialized tools.</span></span> <span data-ttu-id="f9370-143">메시지 또는 전송 수준에서 전송 보안을 사용 하는 것은 메시지를 검사할 수 있는 기능에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-143">The use of transfer security, at either the message or transport level, affects your ability to inspect messages.</span></span> <span data-ttu-id="f9370-144">기밀성은 메시지를 검사하지 않도록 보호해주며 무결성은 메시지를 수정하지 않도록 보호해줍니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-144">Confidentiality protects a message from being examined and integrity protects a message from being modified.</span></span>|<span data-ttu-id="f9370-145">텍스트</span><span class="sxs-lookup"><span data-stu-id="f9370-145">Text</span></span>|  
|<span data-ttu-id="f9370-146">안정성</span><span class="sxs-lookup"><span data-stu-id="f9370-146">Reliability</span></span>|<span data-ttu-id="f9370-147">안정성은 전송 오류에 대한 인코더의 유연성을 말합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-147">Reliability is the resiliency of an encoder to transmission errors.</span></span> <span data-ttu-id="f9370-148">안정성을 메시지, 전송 또는 애플리케이션 계층에서 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-148">Reliability can also be provided at the message, transport, or application layer.</span></span> <span data-ttu-id="f9370-149">모든 표준 WCF 인코더는 다른 계층에서 안정성을 제공 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-149">All of the standard WCF encoders assume that another layer is providing reliability.</span></span> <span data-ttu-id="f9370-150">인코더에는 전송 오류를 복구하는 기능이 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-150">The encoder has little ability to recover from a transmission error.</span></span>|<span data-ttu-id="f9370-151">없음</span><span class="sxs-lookup"><span data-stu-id="f9370-151">None</span></span>|  
|<span data-ttu-id="f9370-152">단순함</span><span class="sxs-lookup"><span data-stu-id="f9370-152">Simplicity</span></span>|<span data-ttu-id="f9370-153">단순성은 인코딩 사양에 대해 인코더 및 디코더를 쉽게 만들 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-153">Simplicity represents the ease with which you can create encoders and decoders for an encoding specification.</span></span> <span data-ttu-id="f9370-154">텍스트 인코딩은 특히 단순성을 위해 도움이 되며, POX 텍스트 인코딩은 SOAP 처리에 대한 지원을 필요로 하지 않는다는 추가 이점도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-154">Text encodings are particularly advantageous for simplicity, and the POX text encoding has the additional advantage of not requiring support for processing SOAP.</span></span>|<span data-ttu-id="f9370-155">텍스트(POX)</span><span class="sxs-lookup"><span data-stu-id="f9370-155">Text (POX)</span></span>|  
|<span data-ttu-id="f9370-156">크기</span><span class="sxs-lookup"><span data-stu-id="f9370-156">Size</span></span>|<span data-ttu-id="f9370-157">인코딩은 콘텐츠에 적용되는 오버헤드의 양을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-157">The encoding determines the amount of overhead imposed on content.</span></span> <span data-ttu-id="f9370-158">인코딩된 메시지의 크기는 서비스 작업의 최대 처리량과 직접적으로 연관됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-158">The size of encoded messages is directly related to the maximum throughput of service operations.</span></span> <span data-ttu-id="f9370-159">일반적으로 이진 인코딩이 텍스트 인코딩보다 간결합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-159">Binary encodings are generally more compact than text encodings.</span></span> <span data-ttu-id="f9370-160">메시지 크기가 최상일 경우 인코딩을 하는 동안 메시지 내용을 압축하는 것도 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="f9370-160">When message size is at a premium, consider also compressing the message contents during encoding.</span></span> <span data-ttu-id="f9370-161">그러나 압축을 하면 메시지 발신자와 수신자 둘 다의 처리 공간이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-161">However, compression adds processing costs for both the message sender and receiver.</span></span>|<span data-ttu-id="f9370-162">이진</span><span class="sxs-lookup"><span data-stu-id="f9370-162">Binary</span></span>|  
|<span data-ttu-id="f9370-163">스트리밍</span><span class="sxs-lookup"><span data-stu-id="f9370-163">Streaming</span></span>|<span data-ttu-id="f9370-164">스트리밍을 통해 전체 메시지가 도착하기 전에 애플리케이션에서 메시지 처리를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-164">Streaming allows applications to begin processing a message before the entire message has arrived.</span></span> <span data-ttu-id="f9370-165">스트리밍을 효과적으로 사용하려면 수신 애플리케이션에서 메시지가 전부 도착할 때까지 기다리지 않아도 되도록 메시지의 시작 부분에서 메시지의 중요 데이터를 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-165">Effectively using streaming requires that the important data for a message be available at the beginning of the message so that the receiving application is not required to wait for it to arrive.</span></span> <span data-ttu-id="f9370-166">또한 스트리밍 전송을 사용하는 애플리케이션은 해당 콘텐츠가 정방향 종속성을 가지지 않도록 메시지의 데이터를 점증적으로 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-166">Moreover, applications that use streamed transfer must organize data in the message incrementally so that the content does not have forward dependencies.</span></span> <span data-ttu-id="f9370-167">대부분의 경우 콘텐츠를 스트리밍하는 것과 해당 콘텐츠의 가능한 최소 전송 크기를 갖는 것 중에 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-167">In many cases, you must compromise between streaming content and having the smallest possible transfer size for that content.</span></span>|<span data-ttu-id="f9370-168">없음</span><span class="sxs-lookup"><span data-stu-id="f9370-168">None</span></span>|  
|<span data-ttu-id="f9370-169">타사 도구 지원</span><span class="sxs-lookup"><span data-stu-id="f9370-169">Third-Party Tool Support</span></span>|<span data-ttu-id="f9370-170">인코딩에 대한 지원 영역에는 개발 및 진단이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-170">Support areas for an encoding include development and diagnosis.</span></span> <span data-ttu-id="f9370-171">타사 개발자는 POX 형식으로 인코딩된 메시지를 처리하기 위해 라이브러리 및 도구 키트에 대규모 투자를 해왔습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-171">Third-party developers have made a large investment in libraries and toolkits for handling messages encoded in the POX format.</span></span>|<span data-ttu-id="f9370-172">텍스트(POX)</span><span class="sxs-lookup"><span data-stu-id="f9370-172">Text (POX)</span></span>|  
|<span data-ttu-id="f9370-173">상호 운용성</span><span class="sxs-lookup"><span data-stu-id="f9370-173">Interoperability</span></span>|<span data-ttu-id="f9370-174">이 요소는 wcf 인코더를 사용 하 여 WCF가 아닌 서비스와 상호 운용할 수 있는 기능을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-174">This factor refers to the ability of a WCF encoder to interoperate with non-WCF services.</span></span>|<span data-ttu-id="f9370-175">텍스트</span><span class="sxs-lookup"><span data-stu-id="f9370-175">Text</span></span><br /><br /> <span data-ttu-id="f9370-176">MTOM(부분)</span><span class="sxs-lookup"><span data-stu-id="f9370-176">MTOM (partial)</span></span>|  
  
<span data-ttu-id="f9370-177">참고: 이진 인코더를 사용할 경우 XMLReader를 만들 때 IgnoreWhitespace 설정을 사용해도 아무 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-177">Note: When using the Binary Encoder, using the IgnoreWhitespace setting when creating a XMLReader will have no effect.</span></span>  <span data-ttu-id="f9370-178">예를 들어, 서비스 작업 안에서 다음을 수행하는 경우를 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-178">For example, if you do the following inside a service operation:</span></span>  

```csharp
public void OperationContract(XElement input)
{
    Console.WriteLine("{0}", input.Value);
    int counter = 0;
    var xreader = input.CreateReader();
    var reader = XmlReader.Create(xreader, new XmlReaderSettings() { IgnoreWhitespace = true });
    while (reader.Read())
    {
        counter++;
    }

    Console.WriteLine("Read {0} lines with reader", counter);
}
```  
  
<span data-ttu-id="f9370-179">IgnoreWhitespace 설정이 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-179">The IgnoreWhitespace setting is ignored.</span></span>  
  
## <a name="compression-and-the-binary-encoder"></a><span data-ttu-id="f9370-180">압축 및 이진 인코더</span><span class="sxs-lookup"><span data-stu-id="f9370-180">Compression and the Binary Encoder</span></span>

<span data-ttu-id="f9370-181">WCF 4.5부터는 WCF 이진 인코더에서 압축을 추가 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-181">Beginning with WCF 4.5 the WCF binary encoder adds support for compression.</span></span> <span data-ttu-id="f9370-182">그러면 WCF 클라이언트에서 압축 메시지를 보낼 때 gzip/deflate 알고리즘을 사용하고 자체 호스팅된 WCF 서비스의 압축 메시지에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-182">This enables you to use the gzip/deflate algorithm for sending compressed messages from a WCF client and also respond with compressed messages from a self-hosted WCF service.</span></span> <span data-ttu-id="f9370-183">이 기능을 사용하면 HTTP 및 TCP 전송 모두에서 압축이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-183">This feature enables compression on both the HTTP and TCP transports.</span></span> <span data-ttu-id="f9370-184">IIS 호스트 서버를 구성하면 IIS에서 호스팅된 WCF 서비스에서 언제나 압축된 응답을 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-184">An IIS hosted WCF service can always be enabled for sending compressed responses by configuring the IIS host server.</span></span> <span data-ttu-id="f9370-185">압축 형식은 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.CompressionFormat%2A?displayProperty=nameWithType> 속성에서 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-185">The type of compression is configured with the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.CompressionFormat%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f9370-186">이 속성은 <xref:System.ServiceModel.Channels.CompressionFormat?displayProperty=nameWithType> 열거형의 값 중 하나로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-186">This property is set to one of the <xref:System.ServiceModel.Channels.CompressionFormat?displayProperty=nameWithType> enum values:</span></span>

- <xref:System.ServiceModel.Channels.CompressionFormat.Deflate>
- <xref:System.ServiceModel.Channels.CompressionFormat.GZip>
- <xref:System.ServiceModel.Channels.CompressionFormat.None>
  
<span data-ttu-id="f9370-187">이 속성은 binaryMessageEncodingBindingElement에만 노출 되므로이 기능을 사용 하려면 다음과 같은 사용자 지정 바인딩을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-187">Since this property is only exposed on the binaryMessageEncodingBindingElement, you will need to create a custom binding like the following to use this feature:</span></span>

 ```xml
 <customBinding>
   <binding name="BinaryCompressionBinding">
     <binaryMessageEncoding compressionFormat ="GZip" />
     <httpTransport />
  </binding>
</customBinding>
 ```

<span data-ttu-id="f9370-188">클라이언트와 서비스는 모두 압축 된 메시지를 보내고 받는 데 동의 해야 하므로 compressionFormat 속성은 클라이언트와 서비스 모두의 binaryMessageEncoding 요소에 구성 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-188">Both the client and the service need to agree to send and receive compressed messages and therefore the compressionFormat property must be configured on the binaryMessageEncoding element on both client and service.</span></span> <span data-ttu-id="f9370-189">서비스 또는 클라이언트에 압축이 구성 되어 있지 않지만 다른 쪽은 인 경우 ProtocolException이 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-189">A ProtocolException is thrown if either the service or client is not configured for compression, but the other side is.</span></span> <span data-ttu-id="f9370-190">압축 사용은 신중 하 게 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-190">Enabling compression should be carefully considered.</span></span> <span data-ttu-id="f9370-191">네트워크 대역폭이 병목인 경우 압축이 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-191">Compression is mostly useful if network bandwidth is a bottleneck.</span></span> <span data-ttu-id="f9370-192">CPU가 병목인 경우 압축을 수행하면 처리량이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-192">In the case where the CPU is the bottleneck, compression will decrease throughput.</span></span> <span data-ttu-id="f9370-193">이렇게 하는 것이 애플리케이션에 좋은지 알아 보려면 시뮬레이션 환경에서 적절한 테스트를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f9370-193">Appropriate testing must be done in a simulated environment to find out if this benefits the application</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f9370-194">참고 항목</span><span class="sxs-lookup"><span data-stu-id="f9370-194">See also</span></span>

- [<span data-ttu-id="f9370-195">바인딩</span><span class="sxs-lookup"><span data-stu-id="f9370-195">Bindings</span></span>](bindings.md)
