---
description: '자세한 정보: 포이즌 메시지 처리'
title: 포이즌 메시지 처리
ms.date: 03/30/2017
ms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595
ms.openlocfilehash: 1d6c8027d44da4d79562e4e427654a3d85df3e88
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793625"
---
# <a name="poison-message-handling"></a><span data-ttu-id="1744a-103">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="1744a-103">Poison Message Handling</span></span>

<span data-ttu-id="1744a-104">*포이즌 메시지* 는 응용 프로그램에 대 한 최대 배달 시도 횟수를 초과한 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-104">A *poison message* is a message that has exceeded the maximum number of delivery attempts to the application.</span></span> <span data-ttu-id="1744a-105">큐 기반 애플리케이션에서 오류로 인해 메시지를 처리할 수 없는 경우 이러한 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-105">This situation can arise when a queue-based application cannot process a message because of errors.</span></span> <span data-ttu-id="1744a-106">안정성 요청을 충족하려면 대기 중인 애플리케이션이 트랜잭션에서 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-106">To meet reliability demands, a queued application receives messages under a transaction.</span></span> <span data-ttu-id="1744a-107">대기 중인 메시지를 받은 트랜잭션을 중단하면 메시지가 큐에 남으므로 새 트랜잭션에서 해당 메시지가 다시 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-107">Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction.</span></span> <span data-ttu-id="1744a-108">트랜잭션의 중단 문제가 해결되지 않은 경우에는 수신 애플리케이션이 최대 전달 시도 횟수를 초과할 때까지 같은 메시지를 받고 중단하는 루프에 갇히고, 포이즌 메시지가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-108">If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.</span></span>  
  
 <span data-ttu-id="1744a-109">메시지는 여러 가지 이유로 포이즌 메시지가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-109">A message can become a poison message for many reasons.</span></span> <span data-ttu-id="1744a-110">가장 일반적인 이유는 응용 프로그램 마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-110">The most common reasons are application-specific.</span></span> <span data-ttu-id="1744a-111">예를 들어 애플리케이션이 큐에서 메시지를 읽고 일부 데이터베이스 처리를 수행하면 애플리케이션이 데이터베이스에 대한 잠금을 얻지 못해 트랜잭션이 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-111">For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction.</span></span> <span data-ttu-id="1744a-112">데이터베이스 트랜잭션이 중단되었기 때문에 메시지가 큐에 남아 있으며 이로 인해 두 번째에서는 애플리케이션이 메시지를 다시 읽고 데이터베이스에 대한 잠금을 얻도록 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-112">Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database.</span></span> <span data-ttu-id="1744a-113">메시지에 잘못된 정보가 들어 있는 경우 해당 메시지는 포이즌 메시지가 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-113">Messages can also become poison if they contain invalid information.</span></span> <span data-ttu-id="1744a-114">예를 들면, 구매 주문서에 잘못된 고객 번호가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-114">For example, a purchase order may contain an invalid customer number.</span></span> <span data-ttu-id="1744a-115">이 경우 애플리케이션이 트랜잭션을 중단하고 메시지가 포이즌 메시지가 되도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-115">In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.</span></span>  
  
 <span data-ttu-id="1744a-116">경우에 따라 메시지가 애플리케이션에 디스패치되지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-116">On rare occasions, messages can fail to get dispatched to the application.</span></span> <span data-ttu-id="1744a-117">WCF (Windows Communication Foundation) 계층에서는 메시지에 잘못 된 프레임이 있거나, 잘못 된 메시지 자격 증명이 연결 되었거나, 잘못 된 작업 헤더가 있는 경우와 같이 메시지 문제를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-117">The Windows Communication Foundation (WCF) layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header.</span></span> <span data-ttu-id="1744a-118">이러한 경우 애플리케이션이 메시지를 받지는 않지만 메시지가 포이즌 메시지가 될 수 있으며 그러한 메시지는 수동으로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-118">In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.</span></span>  
  
## <a name="handling-poison-messages"></a><span data-ttu-id="1744a-119">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="1744a-119">Handling Poison Messages</span></span>  

 <span data-ttu-id="1744a-120">WCF에서 포이즌 메시지 처리는 응용 프로그램에 디스패치할 수 없는 메시지를 처리 하는 수신 응용 프로그램이 나 응용 프로그램에 디스패치 되었지만 응용 프로그램 관련 이유로 인해 처리 되지 않는 메시지를 처리 하는 메커니즘을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-120">In WCF, poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application or messages that are dispatched to the application but that fail to be processed because of application-specific reasons.</span></span> <span data-ttu-id="1744a-121">사용 가능한 각 대기 중인 바인딩에서 다음 속성을 사용 하 여 포이즌 메시지 처리를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-121">Configure poison message handling with the following properties in each of the available queued bindings:</span></span>  
  
- <span data-ttu-id="1744a-122">`ReceiveRetryCount`.</span><span class="sxs-lookup"><span data-stu-id="1744a-122">`ReceiveRetryCount`.</span></span> <span data-ttu-id="1744a-123">애플리케이션 큐에서 애플리케이션으로 메시지 전달을 다시 시도하는 최대 횟수를 나타내는 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-123">An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application.</span></span> <span data-ttu-id="1744a-124">기본값은 5입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-124">The default value is 5.</span></span> <span data-ttu-id="1744a-125">이 값은 데이터베이스의 임시 교착 상태처럼 문제 해결을 즉시 다시 시도하는 경우 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-125">This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.</span></span>  
  
- <span data-ttu-id="1744a-126">`MaxRetryCycles`.</span><span class="sxs-lookup"><span data-stu-id="1744a-126">`MaxRetryCycles`.</span></span> <span data-ttu-id="1744a-127">최대 재시도 주기 수를 나타내는 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-127">An integer value that indicates the maximum number of retry cycles.</span></span> <span data-ttu-id="1744a-128">재시도 주기는 애플리케이션 큐에서 재시도 하위 큐로 메시지를 전송하고, 구성 가능한 지연 시간 이후 재시도 하위 큐에서 전달을 다시 시도할 애플리케이션 큐로 메시지를 다시 전송하는 것으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-128">A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery.</span></span> <span data-ttu-id="1744a-129">기본값은 2입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-129">The default value is 2.</span></span> <span data-ttu-id="1744a-130">Windows Vista에서는 메시지가 최대 ( `ReceiveRetryCount` + 1) \* ( `MaxRetryCycles` + 1) 번 시도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-130">On Windows Vista, the message is tried a maximum of (`ReceiveRetryCount` +1) \* (`MaxRetryCycles` + 1) times.</span></span> <span data-ttu-id="1744a-131">`MaxRetryCycles` 는 Windows Server 2003 및 Windows XP에서 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-131">`MaxRetryCycles` is ignored on Windows Server 2003 and Windows XP.</span></span>  
  
- <span data-ttu-id="1744a-132">`RetryCycleDelay`.</span><span class="sxs-lookup"><span data-stu-id="1744a-132">`RetryCycleDelay`.</span></span> <span data-ttu-id="1744a-133">재시도 주기 사이의 지연 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-133">The time delay between retry cycles.</span></span> <span data-ttu-id="1744a-134">기본값은 30분입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-134">The default value is 30 minutes.</span></span> <span data-ttu-id="1744a-135">`MaxRetryCycles` 및 `RetryCycleDelay`는 함께 정기적인 지연 시간 이후 재시도로 문제를 해결하는 문제 해결 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-135">`MaxRetryCycles` and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem.</span></span> <span data-ttu-id="1744a-136">예를 들면, 이 핸들은 SQL Server의 보류 중인 트랜잭션 커밋에 설정된 잠긴 행을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-136">For example, this handles a locked row set in SQL Server pending transaction commit.</span></span>  
  
- <span data-ttu-id="1744a-137">`ReceiveErrorHandling`.</span><span class="sxs-lookup"><span data-stu-id="1744a-137">`ReceiveErrorHandling`.</span></span> <span data-ttu-id="1744a-138">최대 재시도 횟수만큼 시도한 후에 전달하지 못한 메시지에 대해 수행할 작업을 나타내는 열거입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-138">An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted.</span></span> <span data-ttu-id="1744a-139">이 값은 Fault, Drop, Reject 및 Move일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-139">The values can be Fault, Drop, Reject, and Move.</span></span> <span data-ttu-id="1744a-140">기본 옵션은 Fault입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-140">The default option is Fault.</span></span>  
  
- <span data-ttu-id="1744a-141">Fault.</span><span class="sxs-lookup"><span data-stu-id="1744a-141">Fault.</span></span> <span data-ttu-id="1744a-142">이 옵션은 `ServiceHost`에 오류를 일으키는 수신기에 오류를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-142">This option sends a fault to the listener that caused the `ServiceHost` to fault.</span></span> <span data-ttu-id="1744a-143">애플리케이션이 큐의 메시지를 계속 처리하려면 외부 메커니즘을 통해 애플리케이션 큐에서 메시지를 제거해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-143">The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.</span></span>  
  
- <span data-ttu-id="1744a-144">Drop.</span><span class="sxs-lookup"><span data-stu-id="1744a-144">Drop.</span></span> <span data-ttu-id="1744a-145">이 옵션은 포이즌 메시지를 삭제하므로 메시지가 애플리케이션에 전달되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-145">This option drops the poison message and the message is never delivered to the application.</span></span> <span data-ttu-id="1744a-146">메시지의 `TimeToLive` 속성이 이 시점에서 만료되면 메시지가 보낸 사람의 배달 못 한 큐에 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-146">If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue.</span></span> <span data-ttu-id="1744a-147">그렇지 않으면 메시지는 아무 곳에서도 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-147">If not, the message does not appear anywhere.</span></span> <span data-ttu-id="1744a-148">이 옵션은 메시지가 손실된 경우 사용자가 수행할 작업을 지정하지 않았음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-148">This option indicates that the user has not specified what to do if the message is lost.</span></span>  
  
- <span data-ttu-id="1744a-149">Reject.</span><span class="sxs-lookup"><span data-stu-id="1744a-149">Reject.</span></span> <span data-ttu-id="1744a-150">이 옵션은 Windows Vista 에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-150">This option is available only on Windows Vista.</span></span> <span data-ttu-id="1744a-151">이렇게 하면 응용 프로그램에서 메시지를 받을 수 없다는 메시지 큐 (MSMQ)가 전송 큐 관리자에 게 부정 승인을 다시 보내도록 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-151">This instructs Message Queuing (MSMQ) to send a negative acknowledgment back to the sending queue manager that the application cannot receive the message.</span></span> <span data-ttu-id="1744a-152">이 메시지는 전송 큐 관리자의 배달 못한 편지 큐에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-152">The message is placed in the sending queue manager's dead-letter queue.</span></span>  
  
- <span data-ttu-id="1744a-153">Move.</span><span class="sxs-lookup"><span data-stu-id="1744a-153">Move.</span></span> <span data-ttu-id="1744a-154">이 옵션은 Windows Vista 에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-154">This option is available only on Windows Vista.</span></span> <span data-ttu-id="1744a-155">이 옵션은 포이즌 메시지 처리 애플리케이션이 나중에 처리할 수 있도록 포이즌 메시지를 포이즌 메시지 큐로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-155">This moves the poison message to a poison-message queue for later processing by a poison-message handling application.</span></span> <span data-ttu-id="1744a-156">포이즌 메시지 큐는 애플리케이션 큐의 하위 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-156">The poison-message queue is a subqueue of the application queue.</span></span> <span data-ttu-id="1744a-157">포이즌 메시지 처리 응용 프로그램은 포이즌 큐에서 메시지를 읽는 WCF 서비스 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-157">A poison-message handling application can be a WCF service that reads messages out of the poison queue.</span></span> <span data-ttu-id="1744a-158">포이즌 큐는 응용 프로그램 큐의 하위 큐로 주소를 지정할 수 있습니다. \<*machine-name*> / oison;p. 여기서 *컴퓨터 이름* 은 큐가 있는 컴퓨터의 이름이 고 *applicationqueue* 는 응용 프로그램별 큐의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-158">The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue.</span></span>  
  
<span data-ttu-id="1744a-159">다음은 메시지에 대한 최대 전달 시도 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-159">The following are the maximum number of delivery attempts made for a message:</span></span>  
  
- <span data-ttu-id="1744a-160">Windows Vista의 ((ReceiveRetryCount + 1) \* (MaxRetryCycles + 1)).</span><span class="sxs-lookup"><span data-stu-id="1744a-160">((ReceiveRetryCount+1) \* (MaxRetryCycles + 1)) on Windows Vista.</span></span>  
  
- <span data-ttu-id="1744a-161">(ReceiveRetryCount + 1) Windows Server 2003 및 Windows XP</span><span class="sxs-lookup"><span data-stu-id="1744a-161">(ReceiveRetryCount + 1) on Windows Server 2003 and Windows XP.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1744a-162">전달된 메시지에 대해서는 다시 시도하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-162">No retries are made for a message that is delivered successfully.</span></span>  
  
 <span data-ttu-id="1744a-163">메시지 읽기를 시도 하는 횟수를 추적 하기 위해 Windows Vista는 중단 횟수를 계산 하는 지 속성 메시지 속성을 유지 하 고, 응용 프로그램 큐와 하위 큐 간에 메시지가 이동 하는 횟수를 계산 하는 이동 횟수 속성을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-163">To keep track of the number of times a message read is attempted, Windows Vista maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues.</span></span> <span data-ttu-id="1744a-164">WCF 채널은이를 사용 하 여 수신 다시 시도 횟수 및 재시도 주기 수를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-164">The WCF channel uses these to compute the receive retry count and the retry cycles count.</span></span> <span data-ttu-id="1744a-165">Windows Server 2003 및 Windows XP에서 중단 횟수는 WCF 채널에 의해 메모리에 유지 되며 응용 프로그램에 오류가 발생 하면 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-165">On Windows Server 2003 and Windows XP, the abort count is maintained in memory by the WCF channel and is reset if the application fails.</span></span> <span data-ttu-id="1744a-166">또한 WCF 채널은 언제 든 지 메모리에 최대 256 메시지의 중단 횟수를 보유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-166">Also, the WCF channel can hold the abort counts for up to 256 messages in memory at any time.</span></span> <span data-ttu-id="1744a-167">257번째 메시지를 읽으면 가장 오래된 메시지의 중단 횟수가 재설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-167">If a 257th message is read, then the oldest message's abort count is reset.</span></span>  
  
 <span data-ttu-id="1744a-168">중단 횟수와 이동 횟수 속성은 작업 컨텍스트를 통해 서비스 작업에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-168">The abort count and move count properties are available to the service operation through the operation context.</span></span> <span data-ttu-id="1744a-169">다음 코드 예제에서는 이러한 속성에 액세스하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-169">The following code example shows how to access them.</span></span>  
  
 [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  
  
 <span data-ttu-id="1744a-170">WCF는 다음과 같은 두 개의 표준 대기 중인 바인딩을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-170">WCF provides two standard queued bindings:</span></span>  
  
- <span data-ttu-id="1744a-171"><xref:System.ServiceModel.NetMsmqBinding>.</span><span class="sxs-lookup"><span data-stu-id="1744a-171"><xref:System.ServiceModel.NetMsmqBinding>.</span></span> <span data-ttu-id="1744a-172">다른 WCF 끝점과의 큐 기반 통신을 수행 하는 데 적합 한 .NET Framework 바인딩입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-172">A .NET Framework binding suitable for performing queue-based communication with other WCF endpoints.</span></span>  
  
- <span data-ttu-id="1744a-173"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="1744a-173"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span></span> <span data-ttu-id="1744a-174">기존 메시지 큐 애플리케이션과 통신하는 데 적합한 바인딩입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-174">A binding suitable for communicating with existing Message Queuing applications.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1744a-175">WCF 서비스의 요구 사항에 따라 이러한 바인딩에서 속성을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-175">You can alter properties in these bindings based on the requirements of your WCF service.</span></span> <span data-ttu-id="1744a-176">전체 포이즌 메시지 처리 메커니즘은 수신 애플리케이션에 로컬입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-176">The entire poison message handling mechanism is local to the receiving application.</span></span> <span data-ttu-id="1744a-177">프로세스는 수신 애플리케이션이 최종적으로 부정 승인을 중지하고 발신자에게 다시 보내지 않으면 송신 애플리케이션에 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-177">The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender.</span></span> <span data-ttu-id="1744a-178">이 경우 메시지가 발신자의 배달 못 한 큐로 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-178">In that case, the message is moved to the sender's dead-letter queue.</span></span>  
  
## <a name="best-practice-handling-msmqpoisonmessageexception"></a><span data-ttu-id="1744a-179">최선의 방법: MsmqPoisonMessageException 처리</span><span class="sxs-lookup"><span data-stu-id="1744a-179">Best Practice: Handling MsmqPoisonMessageException</span></span>  

 <span data-ttu-id="1744a-180">서비스에서 메시지가 포이즌임을 확인하면 대기 중인 전송이 포이즌 메시지의 <xref:System.ServiceModel.MsmqPoisonMessageException>를 포함하는 `LookupId`을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-180">When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message.</span></span>  
  
 <span data-ttu-id="1744a-181">수신 애플리케이션이 <xref:System.ServiceModel.Dispatcher.IErrorHandler> 인터페이스를 구현하여 애플리케이션에서 요청하는 모든 오류를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-181">A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires.</span></span> <span data-ttu-id="1744a-182">자세한 내용은 [오류 처리 및 보고에 대 한 제어 확장](../samples/extending-control-over-error-handling-and-reporting.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="1744a-182">For more information, see [Extending Control Over Error Handling and Reporting](../samples/extending-control-over-error-handling-and-reporting.md).</span></span>  
  
 <span data-ttu-id="1744a-183">애플리케이션에서 서비스가 큐의 남은 메시지에 액세스할 수 있도록 포이즌 메시지를 포이즌 메시지 큐로 이동하는 몇 가지 포이즌 메시지 자동 처리 작업이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-183">The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue.</span></span> <span data-ttu-id="1744a-184"><xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> 설정이 <xref:System.ServiceModel.ReceiveErrorHandling.Fault>로 설정된 경우에만 오류 처리 메커니즘을 사용하여 포이즌 메시지 예외를 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-184">The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>.</span></span> <span data-ttu-id="1744a-185">메시지 큐 3.0의 포이즌 메시지 샘플은 이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-185">The poison-message sample for Message Queuing 3.0 demonstrates this behavior.</span></span> <span data-ttu-id="1744a-186">다음에서는 최선의 방법을 포함하여 포이즌 메시지를 처리하는 단계를 간략히 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-186">The following outlines the steps to take to handle poison messages, including best practices:</span></span>  
  
1. <span data-ttu-id="1744a-187">포이즌 설정이 애플리케이션의 요구 사항을 반영하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-187">Ensure your poison settings reflect the requirements of your application.</span></span> <span data-ttu-id="1744a-188">설정을 사용 하 여 작업할 때 Windows Vista, Windows Server 2003 및 Windows XP에서 메시지 큐의 기능 간의 차이점을 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-188">When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on Windows Vista, Windows Server 2003, and Windows XP.</span></span>  
  
2. <span data-ttu-id="1744a-189">필요한 경우를 구현 `IErrorHandler` 하 여 포이즌 메시지 오류를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-189">If necessary, implement the `IErrorHandler` to handle poison-message errors.</span></span> <span data-ttu-id="1744a-190">`ReceiveErrorHandling`을 `Fault`로 설정하려면 큐에서 포이즌 메시지를 제거하거나 외부 종속 문제를 해결하는 수동 메커니즘이 필요하므로 일반적인 사용법은 다음 코드처럼 `IErrorHandler`이 `ReceiveErrorHandling`로 설정된 경우 `Fault`를 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-190">Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  
  
3. <span data-ttu-id="1744a-191">서비스 동작에서 사용할 수 있는 `PoisonBehaviorAttribute`를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-191">Create a `PoisonBehaviorAttribute` that the service behavior can use.</span></span> <span data-ttu-id="1744a-192">이렇게 하면 디스패처에 `IErrorHandler`가 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-192">The behavior installs the `IErrorHandler` on the dispatcher.</span></span> <span data-ttu-id="1744a-193">다음 코드 예제를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="1744a-193">See the following code example.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  
  
4. <span data-ttu-id="1744a-194">서비스에 포이즌 동작 특성으로 주석이 달려 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-194">Ensure that your service is annotated with the poison behavior attribute.</span></span>  

 <span data-ttu-id="1744a-195">또한 `ReceiveErrorHandling`이 `Fault`로 설정된 경우 `ServiceHost`에서 포이즌 메시지를 발생하는 데 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-195">In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message.</span></span> <span data-ttu-id="1744a-196">오류가 발생한 이벤트에 후크하고 서비스를 종료하며 정정 작업을 수행한 다음 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-196">You can hook up to the faulted event and shut down the service, take corrective actions, and restart.</span></span> <span data-ttu-id="1744a-197">예를 들어 `LookupId`로 전파된 <xref:System.ServiceModel.MsmqPoisonMessageException>의 `IErrorHandler`를 기록해 둔 다음, 서비스 호스트에 오류가 발생하는 경우 `System.Messaging` API를 사용하면 `LookupId`를 사용하여 큐에서 메시지를 받고, 큐에서 메시지를 제거하고, 외부 저장소 또는 다른 큐에 메시지를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-197">For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue.</span></span> <span data-ttu-id="1744a-198">그런 다음 `ServiceHost`를 다시 시작하여 일반적인 처리를 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-198">You can then restart `ServiceHost` to resume normal processing.</span></span> <span data-ttu-id="1744a-199">[MSMQ 4.0의 포이즌 메시지 처리](../samples/poison-message-handling-in-msmq-4-0.md) 에서는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-199">The [Poison Message Handling in MSMQ 4.0](../samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior.</span></span>  
  
## <a name="transaction-time-out-and-poison-messages"></a><span data-ttu-id="1744a-200">트랜잭션 제한 시간 및 포이즌 메시지</span><span class="sxs-lookup"><span data-stu-id="1744a-200">Transaction Time-Out and Poison Messages</span></span>  

 <span data-ttu-id="1744a-201">대기 중인 전송 채널과 사용자 코드 사이에 오류 클래스가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-201">A class of errors can occur between the queued transport channel and the user code.</span></span> <span data-ttu-id="1744a-202">이러한 오류는 메시지 보안 계층이나 서비스 디스패치 논리와 같은 사이 계층에서 검색될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-202">These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic.</span></span> <span data-ttu-id="1744a-203">예를 들어 메시지가 애플리케이션으로 디스패치되는 경우는 SOAP 보안 계층에서 검색되는 X.509 인증서가 없고 동작이 누락된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-203">For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application.</span></span> <span data-ttu-id="1744a-204">이 경우 서비스 모델이 메시지를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-204">When this happens, the service model drops the message.</span></span> <span data-ttu-id="1744a-205">메시지를 트랜잭션에서 읽고 해당 트랜잭션에 대한 결과를 제공할 수 없으므로 트랜잭션이 시간 초과되고 중단되며 메시지가 큐에 다시 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-205">Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue.</span></span> <span data-ttu-id="1744a-206">즉, 특정 오류 클래스에 대해 트랜잭션은 즉시 중단 되지 않지만 트랜잭션이 시간 초과 될 때까지 대기 합니다. 을 사용 하 여 서비스에 대 한 트랜잭션 제한 시간을 수정할 수 있습니다 <xref:System.ServiceModel.ServiceBehaviorAttribute> .</span><span class="sxs-lookup"><span data-stu-id="1744a-206">In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>.</span></span>  
  
 <span data-ttu-id="1744a-207">컴퓨터 전체에서 트랜잭션 시간 초과를 변경 하려면 machine.config 파일을 수정 하 고 적절 한 트랜잭션 제한 시간을 설정 합니다. 트랜잭션의 제한 시간 설정에 따라 트랜잭션이 결국 중단 되 고 큐로 돌아가서 중단 횟수가 증가 한다는 점에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-207">To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented.</span></span> <span data-ttu-id="1744a-208">결국 메시지는 포이즌이 되고 사용자 설정에 따라 적절히 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-208">Eventually, the message becomes poison and the right disposition is made according to the user settings.</span></span>  
  
## <a name="sessions-and-poison-messages"></a><span data-ttu-id="1744a-209">세션 및 포이즌 메시지</span><span class="sxs-lookup"><span data-stu-id="1744a-209">Sessions and Poison Messages</span></span>  

 <span data-ttu-id="1744a-210">세션에서는 단일 메시지와 같은 재시도와 포이즌 메시지 처리 프로시저를 거칩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-210">A session undergoes the same retry and poison-message handling procedures as a single message.</span></span> <span data-ttu-id="1744a-211">포이즌 메시지에 대해 위에 나열된 속성은 전체 세션에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-211">The properties previously listed for poison messages apply to the entire session.</span></span> <span data-ttu-id="1744a-212">즉, 메시지가 거부되면 전체 세션이 다시 시도되고 최종 포이즌 메시지 큐나 발신자의 배달 못한 편지 큐로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-212">This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.</span></span>  
  
## <a name="batching-and-poison-messages"></a><span data-ttu-id="1744a-213">일괄 처리 및 포이즌 메시지</span><span class="sxs-lookup"><span data-stu-id="1744a-213">Batching and Poison Messages</span></span>  

 <span data-ttu-id="1744a-214">메시지가 포이즌 메시지가 되고 일괄 처리에 포함되면 전체 일괄 처리가 롤백되고 채널이 한 번에 하나의 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-214">If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time.</span></span> <span data-ttu-id="1744a-215">일괄 처리에 대 한 자세한 내용은 [트랜잭션에서 메시지 일괄 처리](batching-messages-in-a-transaction.md) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="1744a-215">For more information about batching, see [Batching Messages in a Transaction](batching-messages-in-a-transaction.md)</span></span>  
  
## <a name="poison-message-handling-for-messages-in-a-poison-queue"></a><span data-ttu-id="1744a-216">포이즌 큐의 메시지에 대한 포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="1744a-216">Poison-message Handling for Messages in a Poison Queue</span></span>  

 <span data-ttu-id="1744a-217">메시지가 포이즌 메시지 큐에 놓이면 포이즌 메시지 처리가 종료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-217">Poison-message handling does not end when a message is placed in the poison-message queue.</span></span> <span data-ttu-id="1744a-218">포이즌 메시지 큐의 메시지를 읽고 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-218">Messages in the poison-message queue must still be read and handled.</span></span> <span data-ttu-id="1744a-219">최종 포이즌 하위 큐에서 메시지를 읽을 때 포이즌 메시지 처리 설정의 하위 집합을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-219">You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue.</span></span> <span data-ttu-id="1744a-220">`ReceiveRetryCount` 및 `ReceiveErrorHandling` 설정을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-220">The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`.</span></span> <span data-ttu-id="1744a-221">`ReceiveErrorHandling`은 Drop, Reject 또는 Fault로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-221">You can set `ReceiveErrorHandling` to Drop, Reject, or Fault.</span></span> <span data-ttu-id="1744a-222">`MaxRetryCycles`이 Move로 설정되면 `ReceiveErrorHandling`가 무시되고 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-222">`MaxRetryCycles` is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move.</span></span>  
  
## <a name="windows-vista-windows-server-2003-and-windows-xp-differences"></a><span data-ttu-id="1744a-223">Windows Vista, Windows Server 2003 및 Windows XP의 차이점</span><span class="sxs-lookup"><span data-stu-id="1744a-223">Windows Vista, Windows Server 2003, and Windows XP Differences</span></span>  

 <span data-ttu-id="1744a-224">앞에서 설명한 것 처럼 일부 포이즌 메시지 처리 설정은 Windows Server 2003 및 Windows XP에 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-224">As noted earlier, not all poison-message handling settings apply to Windows Server 2003 and Windows XP.</span></span> <span data-ttu-id="1744a-225">Windows Server 2003, Windows XP 및 Windows Vista에서 메시지 큐의 다음과 같은 주요 차이점은 포이즌 메시지 처리와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-225">The following key differences between Message Queuing on Windows Server 2003, Windows XP, and Windows Vista are relevant to poison-message handling:</span></span>  
  
- <span data-ttu-id="1744a-226">Windows Vista의 메시지 큐는 하위 큐를 지원 하지만 Windows Server 2003 및 Windows XP에서는 하위 큐를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-226">Message Queuing in Windows Vista supports subqueues, while Windows Server 2003 and Windows XP do not support subqueues.</span></span> <span data-ttu-id="1744a-227">하위 큐는 포이즌 메시지 처리에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-227">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="1744a-228">재시도 큐와 포이즌 큐는 포이즌 메시지 처리 설정에 따라 만들어지는 애플리케이션 큐의 하위 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-228">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="1744a-229">`MaxRetryCycles`는 만들 재시도 하위 큐의 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-229">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="1744a-230">따라서 Windows Server 2003 또는 Windows XP에서 실행 되는 경우는 `MaxRetryCycles` 무시 되 고 `ReceiveErrorHandling.Move` 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-230">Therefore, when running on Windows Server 2003 or Windows XP, `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
- <span data-ttu-id="1744a-231">Windows Vista의 메시지 큐는 부정 승인을 지원 하지만 Windows Server 2003 및 Windows XP는 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-231">Message Queuing in Windows Vista supports negative acknowledgment, while Windows Server 2003 and Windows XP do not.</span></span> <span data-ttu-id="1744a-232">받는 큐 관리자에서 네거티브 승인을 사용하면 거부된 메시지가 보내는 큐 관리자의 배달 못한 편지 큐에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-232">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="1744a-233">따라서 `ReceiveErrorHandling.Reject` Windows Server 2003 및 WINDOWS XP에서는이 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-233">As such, `ReceiveErrorHandling.Reject` is not allowed with Windows Server 2003 and Windows XP.</span></span>  
  
- <span data-ttu-id="1744a-234">Windows Vista의 메시지 큐는 메시지 배달을 시도 하는 횟수를 유지 하는 메시지 속성을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-234">Message Queuing in Windows Vista supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="1744a-235">이 abort count 속성은 Windows Server 2003 및 Windows XP에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-235">This abort count property is not available on Windows Server 2003 and Windows XP.</span></span> <span data-ttu-id="1744a-236">WCF는 메모리에서 중단 횟수를 유지 하므로 팜의 둘 이상의 WCF 서비스에서 같은 메시지를 읽을 경우이 속성에 정확한 값이 포함 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1744a-236">WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a farm.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1744a-237">참고 항목</span><span class="sxs-lookup"><span data-stu-id="1744a-237">See also</span></span>

- [<span data-ttu-id="1744a-238">큐 개요</span><span class="sxs-lookup"><span data-stu-id="1744a-238">Queues Overview</span></span>](queues-overview.md)
- [<span data-ttu-id="1744a-239">Windows Vista, Windows Server 2003 및 Windows XP의 큐 기능 차이점</span><span class="sxs-lookup"><span data-stu-id="1744a-239">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](diff-in-queue-in-vista-server-2003-windows-xp.md)
- [<span data-ttu-id="1744a-240">계약 및 서비스에서 오류 지정 및 처리</span><span class="sxs-lookup"><span data-stu-id="1744a-240">Specifying and Handling Faults in Contracts and Services</span></span>](../specifying-and-handling-faults-in-contracts-and-services.md)
