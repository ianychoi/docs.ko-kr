---
title: 서비스 거부
ms.date: 03/30/2017
helpviewer_keywords:
- denial of service [WCF]
ms.assetid: dfb150f3-d598-4697-a5e6-6779e4f9b600
ms.openlocfilehash: 6bf0dd8af32f50164138092684c4b82f12134718
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96291598"
---
# <a name="denial-of-service"></a><span data-ttu-id="41a26-102">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="41a26-102">Denial of Service</span></span>

<span data-ttu-id="41a26-103">서비스 거부는 시스템을 가득 채워 메시지를 처리할 수 없거나 메시지가 매우 느리게 처리되는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-103">Denial of service occurs when a system is overwhelmed in such a way that messages cannot be processed, or they are processed extremely slowly.</span></span>  
  
## <a name="excess-memory-consumption"></a><span data-ttu-id="41a26-104">과도한 메모리 사용</span><span class="sxs-lookup"><span data-stu-id="41a26-104">Excess Memory Consumption</span></span>  

 <span data-ttu-id="41a26-105">고유 로컬 이름, 네임스페이스 또는 접두사를 많이 포함하는 XML 문서를 읽을 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-105">A problem can occur when reading an XML document with a large number of unique local names, namespaces, or prefixes.</span></span> <span data-ttu-id="41a26-106"><xref:System.Xml.XmlReader>에서 파생되는 클래스를 사용할 경우 각 항목에 대해 <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A> 또는 <xref:System.Xml.XmlReader.NamespaceURI%2A> 속성을 호출하면 반환된 문자열이 <xref:System.Xml.NameTable>에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-106">If you are using a class that derives from <xref:System.Xml.XmlReader>, and you call either the <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A> or <xref:System.Xml.XmlReader.NamespaceURI%2A> property for each item, the returned string is added to a <xref:System.Xml.NameTable>.</span></span> <span data-ttu-id="41a26-107"><xref:System.Xml.NameTable>에 포함된 컬렉션은 크기가 줄지 않아 문자열 핸들의 가상 "메모리 누수"를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-107">The collection held by the <xref:System.Xml.NameTable> never decreases in size, creating a virtual "memory leak" of the string handles.</span></span>  
  
 <span data-ttu-id="41a26-108">완화 방안은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-108">Mitigations include:</span></span>  
  
- <span data-ttu-id="41a26-109"><xref:System.Xml.NameTable> 클래스에서 파생되고 최대 크기 할당량을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-109">Derive from the <xref:System.Xml.NameTable> class and enforce a maximum size quota.</span></span> <span data-ttu-id="41a26-110">가득 찼을 때 <xref:System.Xml.NameTable> 사용을 금지하거나 <xref:System.Xml.NameTable>을 전환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-110">(You cannot prevent the use of a <xref:System.Xml.NameTable> or switch the <xref:System.Xml.NameTable> when it is full.)</span></span>  
  
- <span data-ttu-id="41a26-111">가능한 경우 위에서 설명한 속성 대신 <xref:System.Xml.XmlReader.MoveToAttribute%2A> 메서드와 함께 <xref:System.Xml.XmlReader.IsStartElement%2A> 메서드를 사용합니다. 이러한 메서드는 문자열을 반환하지 않으므로 <xref:System.Xml.NameTable> 컬렉션이 과도하게 채워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-111">Avoid using the properties mentioned and instead use the <xref:System.Xml.XmlReader.MoveToAttribute%2A> method with the <xref:System.Xml.XmlReader.IsStartElement%2A> method where possible; those methods do not return strings and thus avoid the problem of overfilling the <xref:System.Xml.NameTable> collection.</span></span>  
  
## <a name="malicious-client-sends-excessive-license-requests-to-service"></a><span data-ttu-id="41a26-112">악의적인 클라이언트가 과도한 라이선스 요청을 서비스로 전송</span><span class="sxs-lookup"><span data-stu-id="41a26-112">Malicious Client Sends Excessive License Requests to Service</span></span>  

 <span data-ttu-id="41a26-113">악의적인 클라이언트가 과도한 라이선스 요청으로 서비스를 채우면 서버가 메모리를 지나치게 많이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-113">If a malicious client bombards a service with excessive license requests, it can cause the server to use excessive memory.</span></span>  
  
 <span data-ttu-id="41a26-114">완화 방법: <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> 클래스의 다음 속성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-114">Mitigation: Use the following properties of the <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> class:</span></span>  
  
- <span data-ttu-id="41a26-115"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A>: `SecurityContextToken` 또는 `SPNego` 협상 후에 서버에서 캐시하는 시간이 제한된 `SSL`의 최대 개수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-115"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A>: controls the maximum number of time-bounded `SecurityContextToken`s that the server caches after `SPNego` or `SSL` negotiation.</span></span>  
  
- <span data-ttu-id="41a26-116"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A>: `SecurityContextTokens` 또는 `SPNego` 협상 후에 서버에서 발급하는 `SSL`의 수명을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-116"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A>: controls the lifetime of the `SecurityContextTokens` that the server issues following `SPNego` or `SSL` negotiation.</span></span> <span data-ttu-id="41a26-117">서버는 `SecurityContextToken` 이 기간 동안를 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-117">The server caches the `SecurityContextToken`s for this period of time.</span></span>  
  
- <span data-ttu-id="41a26-118"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A>: 서버에서 설정되었지만 애플리케이션 메시지가 처리되지 않은 보안 대화의 최대 개수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-118"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A>: controls the maximum number of secure conversations that are established at the server but for which no application messages have been processed.</span></span> <span data-ttu-id="41a26-119">이 할당량은 클라이언트가 서비스에서 보안 대화를 설정할 수 없도록 하여 서비스가 클라이언트별 상태를 유지 관리하게 하지만 사용하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-119">This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.</span></span>  
  
- <span data-ttu-id="41a26-120"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A>: 서비스가 대화를 위해 클라이언트로부터 애플리케이션 메시지를 받지 않고 보안 대화를 활성 상태로 유지하는 최대 시간을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-120"><xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A>:  controls the maximum time the service keeps a secure conversation alive without receiving an application message from the client for the conversation.</span></span> <span data-ttu-id="41a26-121">이 할당량은 클라이언트가 서비스에서 보안 대화를 설정할 수 없도록 하여 서비스가 클라이언트별 상태를 유지 관리하게 하지만 사용하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-121">This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.</span></span>  
  
## <a name="wsdualhttpbinding-or-dual-custom-bindings-require-client-authentication"></a><span data-ttu-id="41a26-122">WSDualHttpBinding 또는 이중 사용자 지정 바인딩에 클라이언트 인증이 필요함</span><span class="sxs-lookup"><span data-stu-id="41a26-122">WSDualHttpBinding or Dual Custom Bindings Require Client Authentication</span></span>  

 <span data-ttu-id="41a26-123">기본적으로 <xref:System.ServiceModel.WSDualHttpBinding>은 보안을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-123">By default, the <xref:System.ServiceModel.WSDualHttpBinding> has security enabled.</span></span> <span data-ttu-id="41a26-124">그러나 <xref:System.ServiceModel.MessageSecurityOverHttp.ClientCredentialType%2A> 속성을 <xref:System.ServiceModel.MessageCredentialType.None>으로 설정하여 클라이언트 인증을 비활성화한 경우 악의적인 사용자가 제 3의 서비스에 대해 서비스 거부 공격을 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-124">It is possible, however, that if the client authentication is disabled by setting the <xref:System.ServiceModel.MessageSecurityOverHttp.ClientCredentialType%2A> property to <xref:System.ServiceModel.MessageCredentialType.None>, a malicious user can cause a denial of service attack on a third service.</span></span> <span data-ttu-id="41a26-125">이는 악의적인 클라이언트가 메시지 스트림을 제 3의 서비스로 보내도록 서비스에 지시할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-125">This can occur because a malicious client can direct the service to send a stream of messages to a third service.</span></span>  
  
 <span data-ttu-id="41a26-126">이 문제를 완화하려면 속성을 `None`으로 설정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="41a26-126">To mitigate this, do not set the property to `None`.</span></span> <span data-ttu-id="41a26-127">또한 이중 메시지 패턴이 있는 사용자 지정 바인딩을 만들 때 이러한 가능성에 주의합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-127">Also be aware of this possibility when creating a custom binding that has a dual message pattern.</span></span>  
  
## <a name="auditing-event-log-can-be-filled"></a><span data-ttu-id="41a26-128">감사 이벤트 로그가 채워질 수 있음</span><span class="sxs-lookup"><span data-stu-id="41a26-128">Auditing Event Log Can Be Filled</span></span>  

 <span data-ttu-id="41a26-129">악의적인 사용자가 감사가 설정된 사실을 알고 있다면 잘못된 메시지를 보내 감사 항목이 기록되게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-129">If a malicious user understands that auditing is enabled, that attacker can send invalid messages that cause audit entries to be written.</span></span> <span data-ttu-id="41a26-130">이런 식으로 감사 로그가 채워지면 감사 시스템이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-130">If the audit log is filled in this manner, the auditing system fails.</span></span>  
  
 <span data-ttu-id="41a26-131">이 문제를 완화하려면 <xref:System.ServiceModel.Description.ServiceSecurityAuditBehavior.SuppressAuditFailure%2A> 속성을 `true`로 설정하고 이벤트 뷰어의 속성을 사용하여 감사 동작을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-131">To mitigate this, set the <xref:System.ServiceModel.Description.ServiceSecurityAuditBehavior.SuppressAuditFailure%2A> property to `true` and use the properties of the Event Viewer to control the auditing behavior.</span></span> <span data-ttu-id="41a26-132">이벤트 뷰어를 사용 하 여 이벤트 로그를 보고 관리 하는 방법에 대 한 자세한 내용은 [이벤트 뷰어](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc766042(v=ws.11))을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="41a26-132">For more information about using the Event Viewer to view and manage event logs, see [Event Viewer](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc766042(v=ws.11)).</span></span> <span data-ttu-id="41a26-133">자세한 내용은 [감사](auditing-security-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-133">For more information, see [Auditing](auditing-security-events.md).</span></span>  
  
## <a name="invalid-implementations-of-iauthorizationpolicy-can-cause-service-to-become-unresponsive"></a><span data-ttu-id="41a26-134">IAuthorizationPolicy의 구현이 잘못 된 경우 서비스가 응답 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-134">Invalid Implementations of IAuthorizationPolicy Can Cause Service to Become Unresponsive</span></span>  

 <span data-ttu-id="41a26-135"><xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%2A>인터페이스의 잘못 된 구현에서 메서드를 호출 하면 <xref:System.IdentityModel.Policy.IAuthorizationPolicy> 서비스가 응답 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-135">Calling the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%2A> method on a faulty implementation of the <xref:System.IdentityModel.Policy.IAuthorizationPolicy> interface can cause the service to become unresponsive.</span></span>  
  
 <span data-ttu-id="41a26-136">완화 방법: 신뢰할 수 있는 코드만 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="41a26-136">Mitigation: Use only trusted code.</span></span> <span data-ttu-id="41a26-137">즉, 직접 작성하고 테스트한 코드나 신뢰할 수 있는 공급자가 제공한 코드만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-137">That is, use only code that you have written and tested, or that comes from a trusted provider.</span></span> <span data-ttu-id="41a26-138">신뢰할 수 없는 <xref:System.IdentityModel.Policy.IAuthorizationPolicy> 확장이 적절한 고려 없이 코드에 연결할 수 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-138">Do not allow untrusted extensions of <xref:System.IdentityModel.Policy.IAuthorizationPolicy> to be plugged into your code without due consideration.</span></span> <span data-ttu-id="41a26-139">이 내용은 서비스 구현에 사용되는 모든 확장에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-139">This applies to all extensions used in a service implementation.</span></span> <span data-ttu-id="41a26-140">WCF는 확장성 위치를 사용 하 여 연결 된 응용 프로그램 코드와 외부 코드를 구분 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-140">WCF does not make any distinction between application code and foreign code that is plugged in using extensibility points.</span></span>  
  
## <a name="kerberos-maximum-token-size-may-need-resizing"></a><span data-ttu-id="41a26-141">Kerberos 최대 토큰 크기를 조정해야 할 수 있음</span><span class="sxs-lookup"><span data-stu-id="41a26-141">Kerberos Maximum Token Size May Need Resizing</span></span>  

 <span data-ttu-id="41a26-142">클라이언트는 다수의 그룹(실제 개수는 그룹에 따라 다를 수 있지만 대략 900개)에 속해 있지만 메시지 헤더의 블록이 64KB를 초과할 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-142">If a client belongs to a large number of groups (approximately 900, although the actual number varies depending on the groups), a problem may occur when a message header's block exceeds 64 kilobytes.</span></span> <span data-ttu-id="41a26-143">이 경우 최대 Kerberos 토큰 크기를 늘릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-143">In that case, you can increase the maximum Kerberos token size.</span></span> <span data-ttu-id="41a26-144">큰 Kerberos 토큰을 수용 하기 위해 최대 WCF 메시지 크기를 늘려야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-144">You may also need to increase the maximum WCF message size to accommodate the larger Kerberos token.</span></span>  
  
## <a name="autoenrollment-results-in-multiple-certificates-with-same-subject-name-for-machine"></a><span data-ttu-id="41a26-145">자동 등록으로 인해 한 컴퓨터에 대해 동일한 주체 이름을 가진 여러 인증서가 발생함</span><span class="sxs-lookup"><span data-stu-id="41a26-145">Autoenrollment Results in Multiple Certificates with Same Subject Name for Machine</span></span>  

 <span data-ttu-id="41a26-146">자동 *등록* 은 Windows Server 2003에서 인증서에 대 한 사용자 및 컴퓨터를 자동으로 등록 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-146">*Autoenrollment* is the capability of Windows Server 2003 to automatically enroll users and computers for certificates.</span></span> <span data-ttu-id="41a26-147">이 기능을 사용하는 도메인에 컴퓨터가 있으면 새 컴퓨터가 네트워크에 참가할 때마다 용도가 클라이언트 인증인 X.509 인증서가 자동으로 만들어지고 로컬 컴퓨터의 개인 인증서 저장소에 삽입됩니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-147">When a machine is on a domain with the feature enabled, an X.509 certificate with the intended purpose of client authentication is automatically created and inserted into the local computer's Personal certificates store whenever a new machine is joined to the network.</span></span> <span data-ttu-id="41a26-148">그러나 자동 등록은 캐시에 만드는 모든 인증서에 대해 동일한 주체 이름을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-148">However, autoenrollment uses the same subject name for all certificates it creates in the cache.</span></span>  
  
 <span data-ttu-id="41a26-149">이 경우 WCF 서비스는 자동 등록을 사용 하 여 도메인에서 열지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-149">The impact is that WCF services may fail to open on domains with autoenrollment.</span></span> <span data-ttu-id="41a26-150">이 문제는 컴퓨터의 정규화된 DNS(Domain Name System) 이름을 포함하는 여러 인증서가 있어서 기본 서비스 X.509 자격 증명 검색 조건이 모호할 수 있기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-150">This occurs because the default service X.509 credential search criteria might be ambiguous because multiple certificates with the machine's fully qualified Domain Name System (DNS) name exist.</span></span> <span data-ttu-id="41a26-151">한 인증서는 자동 등록에서 시작되고 다른 인증서는 자체 서명된 인증서일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-151">One certificate originates from autoenrollment; the other might be a self-issued certificate.</span></span>  
  
 <span data-ttu-id="41a26-152">이를 완화 하려면에서 보다 정확한 검색 기준을 사용 하 여 사용할 정확한 인증서를 참조 합니다 [\<serviceCredentials>](../../configure-apps/file-schema/wcf/servicecredentials.md) .</span><span class="sxs-lookup"><span data-stu-id="41a26-152">To mitigate this, reference the exact certificate to use by using a more precise search criterion on the [\<serviceCredentials>](../../configure-apps/file-schema/wcf/servicecredentials.md).</span></span> <span data-ttu-id="41a26-153">예를 들어 <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint> 옵션을 사용하고 고유한 지문(해시)으로 인증서를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-153">For example, use the <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint> option, and specify the certificate by its unique thumbprint (hash).</span></span>  
  
 <span data-ttu-id="41a26-154">자동 등록 기능에 대 한 자세한 내용은 [Windows Server 2003의 인증서 자동 등록](/previous-versions/windows/it-pro/windows-server-2003/cc778954(v=ws.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="41a26-154">For more information about the autoenrollment feature, see [Certificate Autoenrollment in Windows Server 2003](/previous-versions/windows/it-pro/windows-server-2003/cc778954(v=ws.10)).</span></span>  
  
## <a name="last-of-multiple-alternative-subject-names-used-for-authorization"></a><span data-ttu-id="41a26-155">권한 부여에 사용되는 여러 개의 대체 주체 이름 중 마지막</span><span class="sxs-lookup"><span data-stu-id="41a26-155">Last of Multiple Alternative Subject Names Used for Authorization</span></span>  

 <span data-ttu-id="41a26-156">드물지만 X.509 인증서에 여러 개의 대체 주체 이름이 포함된 경우 대체 주체 이름을 사용하여 권한을 부여하면 권한 부여가 실패할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-156">In the rare case when an X.509 certificate contains multiple alternative subject names, and you authorize using the alternative subject name, authorization may fail.</span></span>  
  
## <a name="protect-configuration-files-with-acls"></a><span data-ttu-id="41a26-157">ACL을 사용하여 구성 파일 보호</span><span class="sxs-lookup"><span data-stu-id="41a26-157">Protect Configuration Files with ACLs</span></span>  

 <span data-ttu-id="41a26-158">코드 및 CardSpace 발급 된 토큰에 대 한 구성 파일에서 필수 및 선택적 클레임을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-158">You can specify required and optional claims in code and configuration files for CardSpace issued tokens.</span></span> <span data-ttu-id="41a26-159">이로 인해 보안 토큰 서비스로 전송되는 `RequestSecurityToken` 메시지에 해당 요소가 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-159">This results in corresponding elements being emitted in `RequestSecurityToken` messages that are sent to the security token service.</span></span> <span data-ttu-id="41a26-160">공격자는 코드나 구성을 수정하여 필수 또는 선택적 클레임을 제거하고 보안 토큰 서비스가 대상 서비스에 대한 액세스를 허용하지 않는 토큰을 발급하게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-160">An attacker can modify code or configuration to remove required or optional claims, potentially getting the security token service to issue a token that does not allow access to the target service.</span></span>  
  
 <span data-ttu-id="41a26-161">완화 방법: 구성 파일을 수정하려면 컴퓨터에 대한 액세스 권한이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-161">To mitigate: Require access to the computer to modify the configuration file.</span></span> <span data-ttu-id="41a26-162">파일 ACL(액세스 제어 목록)을 사용하여 구성 파일에 보안을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-162">Use file access control lists (ACLs) to secure configuration files.</span></span> <span data-ttu-id="41a26-163">WCF를 사용 하려면 코드가 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에 있어야 해당 코드를 구성에서 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-163">WCF requires that code be in the application directory or the global assembly cache before it will allow such code to be loaded from configuration.</span></span> <span data-ttu-id="41a26-164">디렉터리 ACL을 사용하여 디렉터리에 보안을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-164">Use directory ACLs to secure directories.</span></span>  
  
## <a name="maximum-number-of-secure-sessions-for-a-service-is-reached"></a><span data-ttu-id="41a26-165">서비스에 허용되는 보안 세션의 최대 개수</span><span class="sxs-lookup"><span data-stu-id="41a26-165">Maximum Number of Secure Sessions for a Service Is Reached</span></span>  

 <span data-ttu-id="41a26-166">서비스에서 성공적으로 클라이언트를 인증하고 서비스와의 보안 세션이 설정된 경우 서비스는 클라이언트가 세션을 취소하거나 세션이 만료될 때까지 세션을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-166">When a client is successfully authenticated by a service and a secure session is established with the service, the service keeps track of the session until the client cancels it or the session expires.</span></span> <span data-ttu-id="41a26-167">설정된 각 세션은 서비스에 대해 허용되는 동시 활성 세션의 최대 개수 제한에 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-167">Every established session counts against the limit for the maximum number of active simultaneous sessions with a service.</span></span> <span data-ttu-id="41a26-168">이 제한에 도달하면 하나 이상의 활성 세션이 만료되거나 클라이언트에 의해 취소될 때까지 해당 서비스와 새 세션을 만들려고 시도하는 클라이언트가 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-168">When this limit is reached, clients that attempt to create a new session with that service are rejected until one or more active sessions expire or are canceled by a client.</span></span> <span data-ttu-id="41a26-169">클라이언트는 서비스와 여러 세션을 만들 수 있으며, 이러한 세션의 각각이 제한에 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-169">A client can have multiple sessions with a service, and each one of those sessions counts toward the limit.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="41a26-170">상태 저장 세션을 사용하는 경우 이전 단락의 내용이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-170">When you use stateful sessions, the previous paragraph does not apply.</span></span> <span data-ttu-id="41a26-171">상태 저장 세션에 대 한 자세한 내용은 [방법: 보안 세션에 대 한 보안 컨텍스트 토큰 만들기](how-to-create-a-security-context-token-for-a-secure-session.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="41a26-171">For more information about stateful sessions, see [How to: Create a Security Context Token for a Secure Session](how-to-create-a-security-context-token-for-a-secure-session.md).</span></span>  
  
 <span data-ttu-id="41a26-172">이 문제를 완화하려면 <xref:System.ServiceModel.Channels.SecurityBindingElement> 클래스의 <xref:System.ServiceModel.Channels.SecurityBindingElement> 속성을 설정하여 활성 세션의 최대 개수와 세션의 최대 수명에 대해 제한을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="41a26-172">To mitigate this, set the limit for the maximum number of active sessions and the maximum lifetime for a session by setting the <xref:System.ServiceModel.Channels.SecurityBindingElement> property of the <xref:System.ServiceModel.Channels.SecurityBindingElement> class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="41a26-173">참고 항목</span><span class="sxs-lookup"><span data-stu-id="41a26-173">See also</span></span>

- [<span data-ttu-id="41a26-174">Security Considerations</span><span class="sxs-lookup"><span data-stu-id="41a26-174">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="41a26-175">정보 공개</span><span class="sxs-lookup"><span data-stu-id="41a26-175">Information Disclosure</span></span>](information-disclosure.md)
- [<span data-ttu-id="41a26-176">권한 상승</span><span class="sxs-lookup"><span data-stu-id="41a26-176">Elevation of Privilege</span></span>](elevation-of-privilege.md)
- [<span data-ttu-id="41a26-177">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="41a26-177">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="41a26-178">재생 공격</span><span class="sxs-lookup"><span data-stu-id="41a26-178">Replay Attacks</span></span>](replay-attacks.md)
- [<span data-ttu-id="41a26-179">변조</span><span class="sxs-lookup"><span data-stu-id="41a26-179">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="41a26-180">지원되지 않는 시나리오</span><span class="sxs-lookup"><span data-stu-id="41a26-180">Unsupported Scenarios</span></span>](unsupported-scenarios.md)
