---
title: Message 클래스 사용
description: WCF의 기본 인 메시지 클래스에 대해 알아봅니다. 일부 고급 시나리오 에서만 메시지 클래스를 직접 사용 하 여 프로그래밍 해야 합니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
ms.openlocfilehash: fd19256b571727883dd877f0094f180ec47c6d63
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96289388"
---
# <a name="using-the-message-class"></a><span data-ttu-id="e3178-104">Message 클래스 사용</span><span class="sxs-lookup"><span data-stu-id="e3178-104">Using the Message Class</span></span>

<span data-ttu-id="e3178-105"><xref:System.ServiceModel.Channels.Message>클래스는 WCF (Windows Communication Foundation)의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-105">The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="e3178-106">클라이언트와 서비스 간의 모든 통신에서 결국 <xref:System.ServiceModel.Channels.Message> 인스턴스의 전송과 수신이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-106">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="e3178-107">일반적으로 <xref:System.ServiceModel.Channels.Message> 클래스와 직접 상호 작용하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-107">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="e3178-108">대신 WCF 서비스 모델 구문 (예: 데이터 계약, 메시지 계약 및 작업 계약)은 들어오고 나가는 메시지를 설명 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-108">Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="e3178-109">그러나 일부 고급 시나리오에서는 <xref:System.ServiceModel.Channels.Message> 클래스를 직접 사용하여 프로그래밍할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-109">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="e3178-110">예를 들어 다음과 같은 경우 <xref:System.ServiceModel.Channels.Message> 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-110">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
- <span data-ttu-id="e3178-111">보내는 메시지 콘텐츠를 만드는 다른 방법이 필요한 경우 (예: 디스크의 파일에서 직접 메시지를 만드는 경우) .NET Framework 개체를 serialize 하는 대신</span><span class="sxs-lookup"><span data-stu-id="e3178-111">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing .NET Framework objects.</span></span>  
  
- <span data-ttu-id="e3178-112">들어오는 메시지 내용을 사용 하는 대체 방법이 필요한 경우 (예: 원시 XML 콘텐츠에 XSLT 변환을 적용 하려는 경우) .NET Framework 개체로 deserialize 하는 대신</span><span class="sxs-lookup"><span data-stu-id="e3178-112">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into .NET Framework objects.</span></span>  
  
- <span data-ttu-id="e3178-113">메시지 내용에 관계없이 일반적인 방법으로 메시지를 처리해야 하는 경우(예: 라우터, 부하 분산 장치 또는 게시-구독 시스템을 구축할 때 메시지를 라우팅 또는 전달하는 경우)</span><span class="sxs-lookup"><span data-stu-id="e3178-113">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="e3178-114">클래스를 사용 하기 전에 <xref:System.ServiceModel.Channels.Message> [데이터 전송 아키텍처 개요](data-transfer-architectural-overview.md)의 WCF 데이터 전송 아키텍처를 숙지 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-114">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="e3178-115"><xref:System.ServiceModel.Channels.Message>는 데이터의 범용 컨테이너이지만 그 디자인은 SOAP 프로토콜의 메시지 디자인과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-115">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="e3178-116">SOAP와 마찬가지로 메시지에는 메시지 본문과 헤더가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-116">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="e3178-117">메시지 본문에는 실제 페이로드 데이터가 들어 있고 헤더에는 명명된 추가 데이터 컨테이너가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-117">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="e3178-118">본문과 헤더를 읽고 쓰는 규칙은 서로 다릅니다. 예를 들어 헤더는 항상 메모리에 버퍼링되고 순서와 횟수에 관계없이 액세스할 수 있지만 본문은 한 번만 읽을 수 있고 스트리밍할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-118">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="e3178-119">일반적으로 SOAP를 사용하는 경우 메시지 본문은 SOAP 본문에 매핑되고 메시지 헤더는 SOAP 헤더에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-119">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="e3178-120">작업에서 메시지 클래스 사용</span><span class="sxs-lookup"><span data-stu-id="e3178-120">Using the Message Class in Operations</span></span>  

 <span data-ttu-id="e3178-121"><xref:System.ServiceModel.Channels.Message> 클래스를 작업의 입력 매개 변수, 작업의 반환 값 또는 둘 다로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-121">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="e3178-122">작업에서 <xref:System.ServiceModel.Channels.Message>를 사용하는 경우 다음 제한 사항이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-122">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
- <span data-ttu-id="e3178-123">작업에 `out` 또는 `ref` 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-123">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
- <span data-ttu-id="e3178-124">`input` 매개 변수를 둘 이상 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-124">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="e3178-125">매개 변수가 있는 경우 메시지 또는 메시지 계약 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-125">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
- <span data-ttu-id="e3178-126">반환 형식은 `void`, `Message` 또는 메시지 계약 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-126">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="e3178-127">다음 코드 예제에는 올바른 작업 계약이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-127">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="e3178-128">기본 메시지 만들기</span><span class="sxs-lookup"><span data-stu-id="e3178-128">Creating Basic Messages</span></span>  

 <span data-ttu-id="e3178-129"><xref:System.ServiceModel.Channels.Message> 클래스는 기본 메시지를 만드는 데 사용할 수 있는 정적 `CreateMessage` 팩터리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-129">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="e3178-130">모든 `CreateMessage` 오버로드는 메시지에 사용할 SOAP 및 WS-Addressing 버전을 나타내는 <xref:System.ServiceModel.Channels.MessageVersion> 형식의 버전 매개 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-130">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="e3178-131">들어오는 메시지와 동일한 프로토콜 버전을 사용하려면 <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> 속성에서 가져온 <xref:System.ServiceModel.OperationContext> 인스턴스의 <xref:System.ServiceModel.OperationContext.Current%2A> 속성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-131">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="e3178-132">대부분의 `CreateMessage` 오버로드에는 메시지에 사용할 SOAP 동작을 나타내는 문자열 매개 변수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-132">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="e3178-133">버전을 `None`으로 설정하여 SOAP 봉투 생성을 비활성화할 수 있습니다. 메시지가 본문으로만 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-133">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="e3178-134">개체에서 메시지 만들기</span><span class="sxs-lookup"><span data-stu-id="e3178-134">Creating Messages from Objects</span></span>  

 <span data-ttu-id="e3178-135">버전과 동작만 사용하는 가장 기본적인 `CreateMessage` 오버로드는 빈 본문이 있는 메시지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-135">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="e3178-136">다른 오버로드는 추가 <xref:System.Object> 매개 변수를 사용하며, 본문이 지정된 개체의 serialize된 표현인 메시지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-136">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="e3178-137">기본 serialization 설정으로 <xref:System.Runtime.Serialization.DataContractSerializer>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-137">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="e3178-138">다른 serializer를 사용하거나 `DataContractSerializer`를 다르게 구성하려면 `CreateMessage` 매개 변수도 받아들이는 `XmlObjectSerializer` 오버로드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-138">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="e3178-139">예를 들어 메시지에 개체를 반환하려면 다음 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-139">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="e3178-140">XML 판독기에서 메시지 만들기</span><span class="sxs-lookup"><span data-stu-id="e3178-140">Creating Messages from XML Readers</span></span>  

 <span data-ttu-id="e3178-141">개체 대신 본문으로 `CreateMessage` 또는 <xref:System.Xml.XmlReader>를 사용하는 <xref:System.Xml.XmlDictionaryReader> 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-141">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="e3178-142">이 경우 메시지의 본문에는 통과한 XML 판독기 읽기에서 발생한 XML이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-142">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="e3178-143">예를 들어 다음 코드는 XML 파일에서 읽은 본문 내용이 포함된 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-143">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="e3178-144">또한 본문뿐 아니라 전체 메시지를 나타내는 `CreateMessage` 또는 <xref:System.Xml.XmlReader>를 사용하는 <xref:System.Xml.XmlDictionaryReader> 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-144">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="e3178-145">이 오버로드는 정수 `maxSizeOfHeaders` 매개 변수도 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-145">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="e3178-146">헤더는 메시지를 만드는 즉시 항상 메모리에 버퍼링되며, 이 매개 변수는 발생하는 버퍼링 양을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-146">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="e3178-147">서비스 거부 공격의 가능성을 줄이기 위해 XML이 신뢰할 수 없는 소스에서 제공되는 경우 이 매개 변수를 안전한 값으로 설정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-147">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="e3178-148">XML 판독기에서 나타내는 메시지의 SOAP 및 WS-Addressing 버전은 버전 매개 변수를 사용하여 표시된 버전과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-148">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="e3178-149">BodyWriter를 사용하여 메시지 만들기</span><span class="sxs-lookup"><span data-stu-id="e3178-149">Creating Messages with BodyWriter</span></span>  

 <span data-ttu-id="e3178-150">`CreateMessage` 오버로드는 `BodyWriter` 인스턴스를 사용하여 메시지 본문을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-150">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="e3178-151">`BodyWriter`는 메시지 본문을 만드는 방법을 사용자 지정하기 위해 파생될 수 있는 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-151">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="e3178-152">고유한 `BodyWriter` 파생 클래스를 만들어 사용자 지정 방식으로 메시지 본문을 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-152">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="e3178-153">`BodyWriter.OnWriteBodyContents`를 사용하는 <xref:System.Xml.XmlDictionaryWriter> 메서드를 재정의해야 합니다. 이 메서드는 본문을 쓰는 작업을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-153">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="e3178-154">본문 작성기를 버퍼링하거나 버퍼링하지 않을(스트리밍) 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-154">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="e3178-155">버퍼링된 본문 작성기는 횟수에 관계없이 콘텐츠를 쓸 수 있지만 스트리밍된 본문 작성기는 한 번만 콘텐츠를 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-155">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="e3178-156">`IsBuffered` 속성은 본문 작성기의 버퍼링 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-156">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="e3178-157">`BodyWriter` 부울 매개 변수를 사용하는 보호된 `isBuffered` 생성자를 호출하여 본문 작성기에 대해 이 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-157">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="e3178-158">본문 작성기는 버퍼링되지 않은 본문 작성기에서 버퍼링된 본문 작성기를 만드는 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-158">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="e3178-159">`OnCreateBufferedCopy` 메서드를 재정의하여 이 프로세스를 사용자 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-159">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="e3178-160">기본적으로, `OnWriteBodyContents`에서 반환한 XML이 들어 있는 메모리 내 버퍼가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-160">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="e3178-161">`OnCreateBufferedCopy`는 `maxBufferSize` 정수 매개 변수를 사용합니다. 이 메서드를 재정의할 경우 이 최대 크기보다 큰 버퍼를 만들면 안됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-161">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="e3178-162">`BodyWriter` 클래스는 기본적으로 각각 `WriteBodyContents` 및 `CreateBufferedCopy` 메서드를 둘러싼 가는 래퍼인 `OnWriteBodyContents` 및 `OnCreateBufferedCopy` 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-162">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="e3178-163">이 메서드는 상태를 확인하여 버퍼링되지 않은 본문 작성기를 두 번 이상 액세스하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-163">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="e3178-164">이 메서드는 `Message`에 기초한 사용자 지정 `BodyWriters` 파생 클래스를 만들 때만 직접 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-164">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="e3178-165">오류 메시지 만들기</span><span class="sxs-lookup"><span data-stu-id="e3178-165">Creating Fault Messages</span></span>  

 <span data-ttu-id="e3178-166">특정 `CreateMessage` 오버로드를 사용하여 SOAP 오류 메시지를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-166">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="e3178-167">이 중에서 가장 기본적인 오버로드는 오류를 설명하는 <xref:System.ServiceModel.Channels.MessageFault> 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-167">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="e3178-168">다른 오버로드는 편의상 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-168">Other overloads are provided for convenience.</span></span> <span data-ttu-id="e3178-169">첫 번째 오버로드는 `FaultCode` 및 원인 문자열을 사용하고 이 정보를 통해 `MessageFault`를 사용하여 `MessageFault.CreateFault`를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-169">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="e3178-170">다른 오버로드는 세부 개체를 사용하고 오류 코드 및 원인과 함께 이 개체를 `CreateFault`로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-170">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="e3178-171">예를 들어 다음 작업은 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-171">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="e3178-172">메시지 본문 데이터 추출</span><span class="sxs-lookup"><span data-stu-id="e3178-172">Extracting Message Body Data</span></span>  

 <span data-ttu-id="e3178-173">`Message` 클래스는 본문에서 정보를 추출하는 여러 방법을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-173">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="e3178-174">이러한 방법을 다음 범주로 분류할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-174">These can be classified into the following categories:</span></span>  
  
- <span data-ttu-id="e3178-175">한 번에 전체 메시지 본문을 XML 작성기에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-175">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="e3178-176">이를 *메시지 작성* 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-176">This is referred to as *writing a message*.</span></span>  
  
- <span data-ttu-id="e3178-177">메시지 본문에 XML 판독기를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-177">Getting an XML reader over the message body.</span></span> <span data-ttu-id="e3178-178">이렇게 하면 필요할 경우 나중에 부분별로 메시지 본문에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-178">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="e3178-179">이를 *메시지 읽기* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-179">This is referred to as *reading a message*.</span></span>  
  
- <span data-ttu-id="e3178-180">본문을 비롯한 전체 메시지를 <xref:System.ServiceModel.Channels.MessageBuffer> 형식의 메모리 내 버퍼로 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-180">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="e3178-181">이를 *메시지 복사* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-181">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="e3178-182">액세스 방법에 관계없이 `Message` 본문에는 한 번만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-182">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="e3178-183">메시지 개체에는 처음에 Created로 설정되는 `State` 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-183">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="e3178-184">앞의 목록에서 설명한 세 가지 액세스 방법은 상태를 각각 Written, Read 및 Copied로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-184">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="e3178-185">또한 `Close` 메서드는 메시지 본문 내용이 더 이상 필요하지 않을 경우 상태를 Closed로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-185">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="e3178-186">메시지 본문은 만듦 상태에서만 액세스할 수 있으며 상태가 변경된 후에는 만듦 상태로 돌아갈 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-186">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="e3178-187">메시지 쓰기</span><span class="sxs-lookup"><span data-stu-id="e3178-187">Writing Messages</span></span>  

 <span data-ttu-id="e3178-188"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 메서드는 지정된 `Message` 인스턴스의 본문 내용을 지정된 XML 작성기에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-188">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="e3178-189"><xref:System.ServiceModel.Channels.Message.WriteBody%2A>메서드는 본문 내용을 적절 한 래퍼 요소에 포함 (예:> <) 한다는 점을 제외 하 고 동일 하 게 수행 합니다 `soap:body` .</span><span class="sxs-lookup"><span data-stu-id="e3178-189">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="e3178-190">마지막으로 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>는 래핑 SOAP 봉투와 헤더를 비롯한 전체 메시지를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-190">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="e3178-191">SOAP가 해제 되어 있는 경우 ( <xref:System.ServiceModel.Channels.Message.Version> 가 인 경우 <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> ) 세 가지 메서드는 모두 동일한 작업을 수행 합니다. 즉, 메시지 본문 내용을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-191">If SOAP is turned off (<xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="e3178-192">예를 들어 다음 코드는 들어오는 메시지의 본문을 파일에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-192">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="e3178-193">두 개의 추가 도우미 메서드는 특정 SOAP 시작 요소 태그를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-193">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="e3178-194">이 메서드는 메시지 본문에 액세스하지 않으므로 메시지 상태를 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-194">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="e3178-195">여기에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-195">These include:</span></span>  
  
- <span data-ttu-id="e3178-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A>는 시작 본문 요소(예: `<soap:Body>`)를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
- <span data-ttu-id="e3178-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A>는 시작 봉투 요소(예: `<soap:Envelope>`)를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="e3178-198">해당하는 끝 요소 태그를 쓰려면 해당 XML 작성기에서 `WriteEndElement`를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-198">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="e3178-199">이 메서드는 직접 호출되는 경우가 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-199">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="e3178-200">메시지 읽기</span><span class="sxs-lookup"><span data-stu-id="e3178-200">Reading Messages</span></span>  

 <span data-ttu-id="e3178-201">메시지 본문을 읽는 기본 방법은 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>를 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-201">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="e3178-202">메시지 본문을 읽는 데 사용할 수 있는 <xref:System.Xml.XmlDictionaryReader>가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-202">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="e3178-203"><xref:System.ServiceModel.Channels.Message>는 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>를 호출하는 즉시 Read 상태로 전환되며, 반환된 XML 판독기를 사용하는 경우에는 전환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-203">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="e3178-204"><xref:System.ServiceModel.Channels.Message.GetBody%2A> 메서드를 사용하여 형식화된 개체로 메시지 본문에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-204">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="e3178-205">내부적으로 이 메서드는 `GetReaderAtBodyContents`를 사용하므로 메시지 상태를 <xref:System.ServiceModel.Channels.MessageState.Read> 상태로 전환합니다(<xref:System.ServiceModel.Channels.Message.State%2A> 속성 참조).</span><span class="sxs-lookup"><span data-stu-id="e3178-205">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="e3178-206"><xref:System.ServiceModel.Channels.Message.IsEmpty%2A> 속성을 확인하는 것이 좋습니다. 이 경우 메시지 본문이 비어 있으며 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>에서 <xref:System.InvalidOperationException>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-206">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="e3178-207">받은 메시지(예: 회신)인 경우 메시지에 오류가 있는지 여부를 나타내는 <xref:System.ServiceModel.Channels.Message.IsFault%2A>를 확인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-207">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="e3178-208"><xref:System.ServiceModel.Channels.Message.GetBody%2A>의 가장 기본적인 오버로드는 기본 설정으로 구성되고 <xref:System.Runtime.Serialization.DataContractSerializer> 할당량이 비활성화된 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A>를 사용하여 제네릭 매개 변수가 나타내는 형식의 인스턴스로 메시지 본문을 역직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-208">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="e3178-209">다른 serialization 엔진을 사용하거나 기본값이 아닌 방식으로 `DataContractSerializer`를 구성하려면 <xref:System.ServiceModel.Channels.Message.GetBody%2A>를 받아들이는 <xref:System.Runtime.Serialization.XmlObjectSerializer> 오버로드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-209">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="e3178-210">예를 들어 다음 코드는 serialize된 `Person` 개체를 포함하는 메시지 본문에서 데이터를 추출하고 개인의 이름을 인쇄합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-210">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="e3178-211">메시지를 버퍼에 복사</span><span class="sxs-lookup"><span data-stu-id="e3178-211">Copying a Message into a Buffer</span></span>  

 <span data-ttu-id="e3178-212">경우에 따라 메시지 본문을 두 번 이상 액세스해야 할 수 있습니다. 예를 들어 게시자-구독자 시스템의 일부로 동일한 메시지를 여러 대상에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-212">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="e3178-213">이 경우 본문을 비롯한 전체 메시지를 메모리에 버퍼링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-213">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="e3178-214">이렇게 하려면 <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-214">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="e3178-215">이 메서드는 최대 버퍼 크기를 나타내는 정수 매개 변수를 사용하며 이 크기보다 크지 않은 버퍼를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-215">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="e3178-216">메시지가 신뢰할 수 없는 소스에서 제공되는 경우 이 메서드를 안전한 값으로 설정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-216">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="e3178-217">버퍼는 <xref:System.ServiceModel.Channels.MessageBuffer> 인스턴스로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-217">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="e3178-218">여러 방법으로 버퍼의 데이터에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-218">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="e3178-219">기본 방법은 <xref:System.ServiceModel.Channels.Message.CreateMessage%2A>를 호출하여 버퍼에서 `Message` 인스턴스를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-219">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="e3178-220">버퍼의 데이터에 액세스하는 다른 방법은 <xref:System.Xml.XPath.IXPathNavigable> 클래스가 내부 XML에 직접 액세스하기 위해 구현하는 <xref:System.ServiceModel.Channels.MessageBuffer> 인터페이스를 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-220">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="e3178-221">일부 <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> 오버로드를 사용하면 방문할 수 있는 XML 노드 수를 제한하여 노드 할당량으로 보호되는 <xref:System.Xml.XPath> 탐색기를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-221">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="e3178-222">이 탐색기는 긴 처리 시간을 기반으로 서비스 거부 공격을 방지하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-222">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="e3178-223">이 할당량은 기본적으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-223">This quote is disabled by default.</span></span> <span data-ttu-id="e3178-224">일부 `CreateNavigator` 오버로드를 사용하면 기본값이 <xref:System.Xml.XmlSpace>인 `XmlSpace.None` 열거를 사용하여 XML에서 공백을 처리하는 방법을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-224">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="e3178-225">메시지 버퍼의 내용에 액세스하는 마지막 방법은 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>를 사용하여 버퍼 내용을 스트림에 쓰는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-225">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="e3178-226">다음 예제에서는 `MessageBuffer` 작업 프로세스를 보여 줍니다. 들어오는 메시지가 여러 수신자에게 전달된 다음 파일에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-226">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="e3178-227">버퍼링 기능이 없으면 메시지 본문에 한 번만 액세스할 수 있으므로 이 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-227">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="e3178-228">`MessageBuffer` 클래스에는 주목할 만한 다른 멤버가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-228">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="e3178-229">버퍼 내용이 더 이상 필요하지 않으면 <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> 메서드를 호출하여 리소스를 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-229">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="e3178-230"><xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> 속성은 할당된 버퍼의 크기를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-230">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="e3178-231"><xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> 속성은 메시지의 MIME 콘텐츠 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-231">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="e3178-232">디버깅을 위해 메시지 본문에 액세스</span><span class="sxs-lookup"><span data-stu-id="e3178-232">Accessing the Message Body for Debugging</span></span>  

 <span data-ttu-id="e3178-233">디버깅 목적으로 <xref:System.ServiceModel.Channels.Message.ToString%2A> 메서드를 호출하여 문자열로 메시지 표현을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-233">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="e3178-234">이 표현은 일반적으로 XML 형식이 사람이 인식하는 데 더 적합하다는 점을 제외하고 텍스트 인코더로 인코딩된 경우 통신 중에 메시지가 표시되는 방식과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-234">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="e3178-235">단, 메시지 본문은 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-235">The one exception to this is the message body.</span></span> <span data-ttu-id="e3178-236">본문은 한 번만 읽을 수 있으며 `ToString`에서 메시지 상태를 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-236">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="e3178-237">따라서 메서드는 `ToString` 본문에 액세스 하지 못할 수 있으며 자리 표시자 (예: "...")를 대체할 수 있습니다. 또는 세 개의 점)을 메시지 본문 대신</span><span class="sxs-lookup"><span data-stu-id="e3178-237">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="e3178-238">메시지의 본문 내용이 중요한 경우 `ToString`을 사용하여 메시지를 기록하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="e3178-238">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="e3178-239">다른 메시지 부분에 액세스</span><span class="sxs-lookup"><span data-stu-id="e3178-239">Accessing Other Message Parts</span></span>  

 <span data-ttu-id="e3178-240">본문 내용 이외의 메시지 정보에 액세스할 수 있도록 다양한 속성이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-240">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="e3178-241">그러나 메시지가 닫힌 후에는 이러한 속성을 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-241">However, these cannot be called once the message has been closed:</span></span>  
  
- <span data-ttu-id="e3178-242"><xref:System.ServiceModel.Channels.Message.Headers%2A> 속성은 메시지 헤더를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-242">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="e3178-243">이 항목의 뒷부분에 나오는 "헤더 작업" 섹션을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="e3178-243">See the section on "Working with Headers" later in this topic.</span></span>  
  
- <span data-ttu-id="e3178-244"><xref:System.ServiceModel.Channels.Message.Properties%2A> 속성은 일반적으로 메시지가 전송될 때 내보내지 않는 메시지에 첨부된 명명된 데이터 부분인 메시지 속성을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-244">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="e3178-245">이 항목의 뒷부분에 있는 "속성 작업" 단원을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e3178-245">See the section on "Working with Properties" later in this topic.</span></span>  
  
- <span data-ttu-id="e3178-246"><xref:System.ServiceModel.Channels.Message.Version%2A> 속성은 메시지와 연결된 SOAP 및 WS-Addressing 버전을 나타내거나 SOAP를 사용하지 않는 경우 `None`을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-246">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
- <span data-ttu-id="e3178-247">메시지가 SOAP 오류 메시지인 경우 <xref:System.ServiceModel.Channels.Message.IsFault%2A> 속성에서 `true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-247">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
- <span data-ttu-id="e3178-248">메시지가 비어 있으면 <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> 속성에서 `true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-248">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="e3178-249"><xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> 메서드를 사용하여 특정 이름과 네임스페이스로 식별된 본문 래퍼 요소(예: `<soap:Body>`)의 특정 특성에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-249">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="e3178-250">이러한 특성이 없으면 `null`이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-250">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="e3178-251">이 메서드는 `Message`가 만듦 상태인 경우(메시지 본문에 아직 액세스하지 않은 경우)에만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-251">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="e3178-252">헤더 작업</span><span class="sxs-lookup"><span data-stu-id="e3178-252">Working with Headers</span></span>  

 <span data-ttu-id="e3178-253">에는 `Message` *헤더* 라는 명명 된 XML 조각이 개수에 제한 없이 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-253">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="e3178-254">각 조각은 일반적으로 SOAP 헤더에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-254">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="e3178-255">`Headers` 형식의 <xref:System.ServiceModel.Channels.MessageHeaders> 속성을 통해 헤더에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-255">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="e3178-256"><xref:System.ServiceModel.Channels.MessageHeaders>는 <xref:System.ServiceModel.Channels.MessageHeaderInfo> 개체의 컬렉션이고 개별 헤더는 해당 <xref:System.Collections.IEnumerable> 인터페이스나 인덱서를 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-256"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="e3178-257">예를 들어 다음 코드는 `Message`의 모든 헤더 이름을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-257">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="e3178-258">헤더 추가, 제거, 찾기</span><span class="sxs-lookup"><span data-stu-id="e3178-258">Adding, Removing, Finding Headers</span></span>  

 <span data-ttu-id="e3178-259"><xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> 메서드를 사용하여 모든 기존 헤더의 끝에 새 헤더를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-259">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="e3178-260"><xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> 메서드를 사용하여 특정 인덱스에 헤더를 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-260">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="e3178-261">기존 헤더는 삽입된 항목에 대해 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-261">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="e3178-262">헤더는 인덱스에 따라 순서가 지정되며 사용 가능한 첫 번째 인덱스는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-262">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="e3178-263">다양한 <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> 메서드 오버로드를 사용하여 다른 `Message` 또는 `MessageHeaders` 인스턴스에서 헤더를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-263">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="e3178-264">일부 오버로드는 개별 헤더를 복사하고 다른 오버로드는 모든 헤더를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-264">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="e3178-265"><xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> 메서드는 모든 헤더를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-265">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="e3178-266"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> 메서드는 특정 인덱스의 헤더를 제거하고 뒤에 있는 모든 헤더를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-266">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="e3178-267"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> 메서드는 특정 이름과 네임스페이스를 가진 모든 헤더를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-267">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="e3178-268"><xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> 메서드를 사용하여 특정 헤더를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-268">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="e3178-269">이 메서드는 찾을 헤더의 이름과 네임스페이스를 사용하고 해당 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-269">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="e3178-270">헤더가 여러 번 발생하는 경우 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-270">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="e3178-271">헤더가 없으면 -1을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-271">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="e3178-272">SOAP 헤더 모델에서는 헤더의 의도된 수신자를 지정하는 `Actor` 값이 헤더에 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-272">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="e3178-273">가장 기본적인 `FindHeader` 오버로드는 메시지의 최종 수신자에 대한 헤더만 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-273">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="e3178-274">그러나 다른 오버로드를 사용하여 검색에 포함할 `Actor` 값을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-274">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> <span data-ttu-id="e3178-275">자세한 내용은 SOAP 사양을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="e3178-275">For more information, see the SOAP specification.</span></span>  
  
 <span data-ttu-id="e3178-276"><xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> 메서드는 <xref:System.ServiceModel.Channels.MessageHeaders> 컬렉션의 헤더를 <xref:System.ServiceModel.Channels.MessageHeaderInfo> 개체의 배열로 복사하기 위해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-276">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="e3178-277">헤더의 XML 데이터에 액세스하려면 <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A>를 호출하고 특정 헤더 인덱스에 대한 XML 판독기를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-277">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="e3178-278">헤더 내용을 개체로 역직렬화하려면 <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> 또는 다른 오버로드 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-278">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="e3178-279">가장 기본적인 오버로드는 기본 방식으로 구성된 <xref:System.Runtime.Serialization.DataContractSerializer>를 사용하여 헤더를 역직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-279">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="e3178-280">다른 serializer나 `DataContractSerializer`의 다른 구성을 사용하려면 `XmlObjectSerializer`를 받아들이는 오버로드 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-280">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="e3178-281">인덱스 대신 헤더 이름, 네임스페이스 및 선택적으로 `Actor` 값의 목록을 사용하는 오버로드도 있습니다. 이 오버로드는 `FindHeader` 및 `GetHeader`의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-281">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="e3178-282">속성 작업</span><span class="sxs-lookup"><span data-stu-id="e3178-282">Working with Properties</span></span>  

 <span data-ttu-id="e3178-283">`Message` 인스턴스는 임의 형식과 개수의 명명된 개체를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-283">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="e3178-284">`Properties` 형식의 `MessageProperties` 속성을 통해 이 컬렉션에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-284">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="e3178-285">이 컬렉션은 <xref:System.Collections.Generic.IDictionary%602> 인터페이스를 구현하며 <xref:System.String>에서 <xref:System.Object>로의 매핑으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-285">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="e3178-286">일반적으로 속성 값은 통신 하는 메시지의 일부에 직접 매핑되지 않지만 WCF 채널 스택의 다양 한 채널 또는 서비스 프레임 워크에 다양 한 메시지 처리 힌트를 제공 <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-286">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="e3178-287">예제는 [데이터 전송 아키텍처 개요](data-transfer-architectural-overview.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e3178-287">For an example, see [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="e3178-288">Message 클래스에서 상속</span><span class="sxs-lookup"><span data-stu-id="e3178-288">Inheriting from the Message Class</span></span>  

 <span data-ttu-id="e3178-289">`CreateMessage`를 사용하여 만든 기본 제공 메시지 형식이 요구 사항에 맞지 않을 경우 `Message` 클래스에서 파생된 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-289">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="e3178-290">메시지 본문 내용 정의</span><span class="sxs-lookup"><span data-stu-id="e3178-290">Defining the Message Body Contents</span></span>  

 <span data-ttu-id="e3178-291">메시지 본문 내의 데이터에 액세스하는 세 가지 기본 방법은 쓰기, 읽기 및 버퍼에 복사입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-291">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="e3178-292">이러한 작업을 수행하면 결국 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>의 파생 클래스에서 각각 <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 및 `Message` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-292">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="e3178-293">기본 `Message` 클래스는 각 `Message` 인스턴스에 대해 이 메서드 중 하나만 호출되며 여러 번 호출되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-293">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="e3178-294">또한 기본 클래스는 닫힌 메시지에 대해 메서드가 호출되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-294">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="e3178-295">구현에서 메시지 상태를 추적할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-295">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="e3178-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>는 추상 메서드이며 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="e3178-297">메시지의 본문 내용을 정의하는 가장 기본적인 방법은 이 메서드를 사용하여 쓰는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-297">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="e3178-298">예를 들어 다음 메시지에는 1에서 20까지 100,000개의 난수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-298">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="e3178-299"><xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> 및 <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 메서드에는 대부분의 경우에서 작동하는 기본 구현이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-299">The <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods have default implementations that work for most cases.</span></span> <span data-ttu-id="e3178-300">기본 구현에서는 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>를 호출하고 그 결과를 버퍼링한 다음 결과 버퍼로 작업합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-300">The default implementations call <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="e3178-301">그러나 일부 경우에서는 이 기능만으로 충분하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-301">However, in some cases this may not be enough.</span></span> <span data-ttu-id="e3178-302">앞의 예제에서 메시지를 읽으면 100,000개의 XML 요소가 버퍼링되며 이는 바람직하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-302">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="e3178-303"><xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents>를 재정의하여 난수를 제공하는 사용자 지정 <xref:System.Xml.XmlDictionaryReader> 파생 클래스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-303">You might want to override <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> to return a custom <xref:System.Xml.XmlDictionaryReader> derived class that serves up random numbers.</span></span> <span data-ttu-id="e3178-304">그런 다음 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> , 다음 예제와 같이 메서드가 반환 하는 판독기를 사용 하도록를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-304">You can then override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> to use the reader that the <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> method returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="e3178-305">마찬가지로 `OnCreateBufferedCopy`를 재정의하여 고유한 `MessageBuffer` 파생 클래스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-305">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="e3178-306">메시지 본문 내용 제공 외에도 메시지 파생 클래스는 `Version`, `Headers` 및 `Properties` 속성을 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-306">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="e3178-307">메시지 복사본을 만드는 경우 복사본은 원본의 메시지 헤더를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-307">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="e3178-308">재정의할 수 있는 기타 멤버</span><span class="sxs-lookup"><span data-stu-id="e3178-308">Other Members that Can Be Overridden</span></span>  

 <span data-ttu-id="e3178-309"><xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, 및 메서드를 재정의 <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> 하 여 <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> SOAP 봉투, SOAP 헤더 및 soap 본문 요소 시작 태그를 작성 하는 방법을 지정할 수 있습니다. 이러한 구문은 일반적으로 `<soap:Envelope>` , `<soap:Header>` 및에 해당 `<soap:Body>` 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-309">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="e3178-310"><xref:System.ServiceModel.Channels.Message.Version> 속성에서 <xref:System.ServiceModel.Channels.MessageVersion.None>을 반환할 경우 아무 내용도 쓰면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-310">These methods should normally not write anything out if the <xref:System.ServiceModel.Channels.Message.Version> property returns <xref:System.ServiceModel.Channels.MessageVersion.None>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e3178-311">`OnGetReaderAtBodyContents`의 기본 구현에서는 `OnWriteStartEnvelope`를 호출하고 결과를 버퍼링하기 전에 `OnWriteStartBody` 및 `OnWriteBodyContents`를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-311">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="e3178-312">헤더는 쓰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-312">Headers are not written out.</span></span>  
  
 <span data-ttu-id="e3178-313"><xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> 메서드를 재정의하여 다양한 부분에서 전체 메시지가 생성되는 방법을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-313">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="e3178-314">`OnWriteMessage` 메서드는 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 및 기본 <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 구현에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-314">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="e3178-315"><xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 재정의는 최선의 방법이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-315">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="e3178-316">적절한 `On` 메서드(예: <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> 및 <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>)를 재정의하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-316">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="e3178-317"><xref:System.ServiceModel.Channels.Message.OnBodyToString%2A>을 재정의하여 디버깅 중에 메시지 본문을 나타내는 방법을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-317">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="e3178-318">기본값은 메시지 본문을 세 개의 점("…")으로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-318">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="e3178-319">메시지 상태가 Closed가 아니면 이 메서드는 여러 번 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-319">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="e3178-320">이 메서드의 구현에서는 한 번만 수행해야 하는 작업(예: 정방향 전용 스트림에서 읽기)을 발생시키면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-320">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="e3178-321"><xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> 메서드를 재정의하여 SOAP 본문 요소의 특성에 대한 액세스를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-321">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="e3178-322">이 메서드는 횟수에 관계없이 호출할 수 있지만 `Message` 기본 형식에서 메시지가 만듦 상태인 경우에만 메서드가 호출되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-322">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="e3178-323">구현에서 상태를 확인할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-323">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="e3178-324">기본 구현에서는 항상 본문 요소의 특성이 없음을 나타내는 `null`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-324">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="e3178-325">메시지 본문이 더 이상 필요하지 않을 때 `Message` 개체에서 특별한 정리 작업을 수행해야 하는 경우 <xref:System.ServiceModel.Channels.Message.OnClose%2A>를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-325">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="e3178-326">기본 구현은 아무 작업도 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-326">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="e3178-327">`IsEmpty` 및 `IsFault` 속성을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-327">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="e3178-328">기본적으로 두 메서드는 모두 `false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e3178-328">By default, both return `false`.</span></span>
