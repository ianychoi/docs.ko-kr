---
title: 페더레이션 및 트러스트
ms.date: 03/30/2017
helpviewer_keywords:
- federation [WCF], and trust
ms.assetid: 4bdec4f2-f8a2-4512-bdcf-14ef54b5877a
ms.openlocfilehash: 6baa336f96f2349315cab2ed51bfb67c4745a110
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96255483"
---
# <a name="federation-and-trust"></a><span data-ttu-id="0c5a1-102">페더레이션 및 트러스트</span><span class="sxs-lookup"><span data-stu-id="0c5a1-102">Federation and Trust</span></span>

<span data-ttu-id="0c5a1-103">이 항목에서는 페더레이션 응용 프로그램, 트러스트 경계 및 구성, Windows Communication Foundation (WCF)에서 발급 된 토큰 사용과 관련 된 다양 한 측면에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-103">This topic covers various aspects related to federated applications, trust boundaries and configuration, and use of issued tokens in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="services-security-token-services-and-trust"></a><span data-ttu-id="0c5a1-104">서비스, 보안 토큰 서비스 및 트러스트</span><span class="sxs-lookup"><span data-stu-id="0c5a1-104">Services, Security Token Services, and Trust</span></span>  

 <span data-ttu-id="0c5a1-105">일반적으로 페더레이션 엔드포인트를 노출하는 서비스에서는 클라이언트가 특정 발급자에 의해 제공되는 토큰을 사용하여 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-105">Services that expose federated endpoints typically expect clients to authenticate using a token provided by a specific issuer.</span></span> <span data-ttu-id="0c5a1-106">서비스는 발급자에 대해 올바른 자격 증명으로 구성되는 것이 중요합니다. 그렇지 않을 경우 발급된 토큰을 통해 서명을 확인할 수 없고 클라이언트는 서비스와 통신할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-106">It is important that the service is configured with the correct credentials for the issuer; otherwise, it will not be able to verify signatures over the issued tokens, and the client will be unable to communicate with the service.</span></span> <span data-ttu-id="0c5a1-107">서비스에서 발급자 자격 증명을 구성 하는 방법에 대 한 자세한 내용은 [방법: 페더레이션 서비스에서 자격 증명 구성](how-to-configure-credentials-on-a-federation-service.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-107">For more information about configuring issuer credentials on the service, see [How to: Configure Credentials on a Federation Service](how-to-configure-credentials-on-a-federation-service.md).</span></span>  
  
 <span data-ttu-id="0c5a1-108">마찬가지로 대칭 키를 사용하는 경우 해당 키는 대상 서비스에 대해 암호화되기 때문에 대상 서비스에 대해 올바른 자격 증명으로 보안 토큰 서비스를 구성해야 합니다. 그렇지 않을 경우 대상 서비스에 대해 키를 암호화할 수 없고 클라이언트도 서비스와 통신할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-108">Similarly, when using symmetric keys, the keys are encrypted for the target service, so you must configure the security token service with the correct credentials for the target service; otherwise, it will be unable to encrypt the key for the target service, and again, the client will be unable to communicate with the service.</span></span>  
  
 <span data-ttu-id="0c5a1-109">WCF 서비스는 SecurityBindingElement의 속성 값을 사용 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxClockSkew%2A> 하 [SecurityBindingElement](../diagnostics/wmi/securitybindingelement.md) 여 클라이언트와 서비스 간의 클록 기울이기를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-109">WCF services use the value of the <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxClockSkew%2A> property on the [SecurityBindingElement](../diagnostics/wmi/securitybindingelement.md) to allow for clock skew between the client and service.</span></span> <span data-ttu-id="0c5a1-110">페더레이션에서 `MaxClockSkew` 설정은 클라이언트가 발급된 토큰을 가져온 클라이언트 및 보안 토큰 서비스 사이에 모두 클럭 오차를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-110">In federation, the `MaxClockSkew` setting applies to clock skews between both the client and the security token service from where the client obtained the issued token.</span></span> <span data-ttu-id="0c5a1-111">따라서 보안 토큰 서비스는 발급된 토큰의 유효 시간 및 만료 시간을 설정할 때 클럭 오차를 허용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-111">Therefore, security token services need not make clock-skew allowances when setting the issued token's effective and expiration times.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0c5a1-112">발급된 토큰 수명이 단축될수록 클럭 오차의 중요성이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-112">The importance of clock skew increases as the lifetime of the issued token shortens.</span></span> <span data-ttu-id="0c5a1-113">대부분의 경우 토큰 수명이 30분 이상이면 클럭 오차가 중요한 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-113">In most cases, clock skew is not a significant issue if the token lifetime is 30 minutes or more.</span></span> <span data-ttu-id="0c5a1-114">수명이 짧거나 토큰의 정확한 유효 시간이 중요한 경우 클럭 오차를 고려하도록 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-114">Scenarios with shorter lifetimes or where the exact validity time of the token is important should be designed to take clock skew into account.</span></span>  
  
## <a name="federated-endpoints-and-time-outs"></a><span data-ttu-id="0c5a1-115">페더레이션 엔드포인트 및 시간 제한</span><span class="sxs-lookup"><span data-stu-id="0c5a1-115">Federated Endpoints and Time-Outs</span></span>  

 <span data-ttu-id="0c5a1-116">클라이언트가 페더레이션 엔드포인트와 통신하는 경우 먼저 보안 토큰 서비스에서 적절한 토큰을 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-116">When a client communicates with a federated endpoint, it must first acquire an appropriate token from a security token service.</span></span> <span data-ttu-id="0c5a1-117">보안 토큰 서비스가 페더레이션 엔드포인트를 노출하는 경우 클라이언트는 먼저 해당 엔드포인트에 대한 발급자로부터 토큰을 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-117">If the security token service exposes a federated endpoint, the client must first obtain a token from the issuer for that endpoint.</span></span> <span data-ttu-id="0c5a1-118">토큰을 가져올 때마다 시간이 걸리며 이 시간은 실제 메시지를 최종 엔드포인트에 보내기 위한 전체 시간 제한에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-118">Each token acquisition takes time, and that time is subject to the overall time-out for sending the actual message to the final endpoint.</span></span>  
  
 <span data-ttu-id="0c5a1-119">예를 들어 클라이언트측 채널에 대한 시간 제한은 30초로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-119">For example, the time-out on the client-side channel is set to 30 seconds.</span></span> <span data-ttu-id="0c5a1-120">두 토큰 발급자는 메시지를 최종 엔드포인트에 보내기 전에 토큰 검색을 위해 호출되어야 하며 각 발급자가 토큰을 발급하는 데 15초 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-120">Two token issuers need to be called to retrieve tokens before sending the message to the final endpoint, and each takes 15 seconds to issue a token.</span></span> <span data-ttu-id="0c5a1-121">이 경우 시도가 실패하고 <xref:System.TimeoutException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-121">In this case, the attempt will fail and a <xref:System.TimeoutException> is thrown.</span></span> <span data-ttu-id="0c5a1-122">따라서 클라이언트 채널의 <xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> 값을 모든 발급된 토큰을 검색하는 데 걸리는 시간을 충분히 포함하도록 큰 값으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-122">Thus, you need to set the <xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> value on the client channel to a value large enough to include the time taken to retrieve all issued tokens.</span></span> <span data-ttu-id="0c5a1-123"><xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> 속성에 대해 값을 지정하지 않은 경우 <xref:System.ServiceModel.Channels.Binding.OpenTimeout%2A> 속성 또는 <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A> 속성(또는 둘 다)은 모든 발급된 토큰을 검색하는 데 걸리는 시간을 충분히 포함하도록 큰 값으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-123">In the case where a value is not specified for the <xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> property, the <xref:System.ServiceModel.Channels.Binding.OpenTimeout%2A> property or the <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A> property (or both) need to be set to a value large enough to include the time taken to retrieve all issued tokens.</span></span>  
  
## <a name="token-lifetime-and-renewal"></a><span data-ttu-id="0c5a1-124">토큰 수명 및 갱신</span><span class="sxs-lookup"><span data-stu-id="0c5a1-124">Token Lifetime and Renewal</span></span>  

 <span data-ttu-id="0c5a1-125">WCF 클라이언트는 서비스에 대 한 초기 요청을 만들 때 발급 된 토큰을 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-125">WCF clients do not check the issued token when making an initial request to a service.</span></span>  <span data-ttu-id="0c5a1-126">대신 WCF는 보안 토큰 서비스를 신뢰 하 여 적절 한 유효 기간 및 만료 시간으로 토큰을 발급 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-126">Rather, WCF trusts the security token service to issue a token with appropriate effective and expiration times.</span></span> <span data-ttu-id="0c5a1-127">토큰이 클라이언트에 의해 캐시되고 다시 사용하는 경우 토큰 수명은 후속 요청 시 검사되고 클라이언트는 필요한 경우 토큰을 자동으로 갱신합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-127">If the token is cached by the client and reused, the token lifetime is checked on subsequent requests and the client automatically renews the token if necessary.</span></span> <span data-ttu-id="0c5a1-128">토큰 캐싱에 대 한 자세한 내용은 [방법: 페더레이션된 클라이언트 만들기](how-to-create-a-federated-client.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-128">For more information about token caching, see [How to: Create a Federated Client](how-to-create-a-federated-client.md).</span></span>  
  
 <span data-ttu-id="0c5a1-129">발급 된 토큰 또는 보안 컨텍스트 토큰에 대해 30 초 이내에 짧은 수명을 지정 하면 발급 된 토큰을 요청할 때 또는 보안 컨텍스트 토큰을 협상 또는 갱신할 때 WCF 클라이언트에서 협상 시간 제한이 발생 하거나 다른 예외가 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-129">Specifying short lifetimes, on the order of 30 seconds or less for issued tokens or security context tokens, may result in negotiation time-outs or other exceptions being thrown by WCF clients when requesting issued tokens or when negotiating or renewing security context tokens.</span></span>  
  
## <a name="issued-tokens-and-inclusionmode"></a><span data-ttu-id="0c5a1-130">발급된 토큰 및 InclusionMode</span><span class="sxs-lookup"><span data-stu-id="0c5a1-130">Issued Tokens and InclusionMode</span></span>  

 <span data-ttu-id="0c5a1-131">발급된 토큰이 클라이언트에서 페더레이션 엔드포인트로 보낸 메시지에서 serialize되었는지 여부는 <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A> 클래스의 <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters> 속성을 설정하여 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-131">Whether an issued token is serialized in a message sent from a client to a federated endpoint or not is controlled by setting the <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A> property of the <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters> class.</span></span> <span data-ttu-id="0c5a1-132">이 속성은 <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode> 열거형 값 중 하나로 설정할 수 있지만 대부분의 페더레이션 시나리오에서 유용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-132">This property can be set to one of the <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode> enumeration values, but it is not useful in most federated scenarios.</span></span> <span data-ttu-id="0c5a1-133">`SecurityTokenInclusionMode.Never` 및 `SecurityTokenInclusionMode.AlwaysToInitiator` 값은 클라이언트가 보안 토큰 서비스에 의해 발급된 토큰에 대한 참조를 신뢰하는 상대에게 보내도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-133">The `SecurityTokenInclusionMode.Never` and `SecurityTokenInclusionMode.AlwaysToInitiator` values cause the client to send a reference to the token issued by the security token service to the relying party.</span></span> <span data-ttu-id="0c5a1-134">신뢰하는 상대가 발급된 토큰 복사본을 가지고 있지 않은 한 토큰 참조를 확인할 수 없기 때문에 인증이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-134">Unless the relying party possesses a copy of the issued token, authentication will fail because the token reference is not resolvable.</span></span> <span data-ttu-id="0c5a1-135">WCF `SecurityTokenInclusionMode.Once` 는와 동일 하 게 처리 `SecurityTokenInclusionMode.AlwaysToRecipient` 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0c5a1-135">WCF treats `SecurityTokenInclusionMode.Once` as equivalent to `SecurityTokenInclusionMode.AlwaysToRecipient`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0c5a1-136">참고 항목</span><span class="sxs-lookup"><span data-stu-id="0c5a1-136">See also</span></span>

- <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode>
- [<span data-ttu-id="0c5a1-137">방법: 페더레이션 클라이언트 만들기</span><span class="sxs-lookup"><span data-stu-id="0c5a1-137">How to: Create a Federated Client</span></span>](how-to-create-a-federated-client.md)
- [<span data-ttu-id="0c5a1-138">방법: 페더레이션 서비스에서 자격 증명 구성</span><span class="sxs-lookup"><span data-stu-id="0c5a1-138">How to: Configure Credentials on a Federation Service</span></span>](how-to-configure-credentials-on-a-federation-service.md)
- [<span data-ttu-id="0c5a1-139">방법: WSFederationHttpBinding 만들기</span><span class="sxs-lookup"><span data-stu-id="0c5a1-139">How to: Create a WSFederationHttpBinding</span></span>](how-to-create-a-wsfederationhttpbinding.md)
