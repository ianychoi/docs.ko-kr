---
description: '자세한 정보: Dead-Letter 큐를 사용 하 여 메시지 전송 오류 처리'
title: 배달 못 한 편지 큐를 사용하여 메시지 전송 오류 처리
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 9e891c6a-d960-45ea-904f-1a00e202d61a
ms.openlocfilehash: 497da84d37cf7c82a2da09e4303b8e53e7e0b46c
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99704448"
---
# <a name="using-dead-letter-queues-to-handle-message-transfer-failures"></a><span data-ttu-id="83bf5-103">배달 못 한 편지 큐를 사용하여 메시지 전송 오류 처리</span><span class="sxs-lookup"><span data-stu-id="83bf5-103">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>

<span data-ttu-id="83bf5-104">대기 중인 메시지를 배달하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-104">Queued messages can fail delivery.</span></span> <span data-ttu-id="83bf5-105">이러한 실패 메시지는 배달 못 한 편지 큐에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-105">These failed messages are recorded in a dead-letter queue.</span></span> <span data-ttu-id="83bf5-106">네트워크 오류, 삭제된 큐, 꽉 찬 큐, 인증 오류 또는 정시 배달 실패와 같은 이유로 인해 배달 실패가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-106">The failed delivery can be caused by reasons such as network failures, a deleted queue, a full queue, authentication failure, or a failure to deliver on time.</span></span>  
  
 <span data-ttu-id="83bf5-107">대기 중인 메시지는 수신 애플리케이션이 적절한 시간 내에 큐에서 메시지를 읽지 못하는 경우 오랫동안 큐에 남을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-107">Queued messages can remain in the queue for a long time if the receiving application does not read them from the queue in a timely fashion.</span></span> <span data-ttu-id="83bf5-108">이러한 동작은 시간이 중요한 메시지에 적합하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-108">This behavior may not be appropriate for time-sensitive messages.</span></span> <span data-ttu-id="83bf5-109">시간이 중요한 메시지에는 대기 중인 바인딩에 설정되어 있는 TTL(Time to Live) 속성이 있으며, 이 속성은 메시지가 만료되기 전에 큐에 있을 수 있는 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-109">Time-sensitive messages have a Time to Live (TTL) property set in the queued binding, which indicates how long the messages can be in the queue before they must expire.</span></span> <span data-ttu-id="83bf5-110">만료된 메시지는 배달 못한 편지 큐라는 특수 큐로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-110">Expired messages are sent to a special queue called the dead-letter queue.</span></span> <span data-ttu-id="83bf5-111">또한 큐 할당량 초과 또는 인증 오류 등 다른 이유로 메시지가 배달 못 한 편지 큐에 배치될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-111">Messages can also be put in a dead-letter queue for other reasons, such as exceeding a queue quota or because of authentication failure.</span></span>  
  
 <span data-ttu-id="83bf5-112">일반적으로 애플리케이션에서는 배달 못 한 편지 큐에서 메시지를 읽는 보정 논리 및 실패 이유를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-112">Generally, applications write compensation logic to read messages from the dead-letter queue and failure reasons.</span></span> <span data-ttu-id="83bf5-113">보정 논리는 실패의 원인에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-113">The compensation logic depends on the cause of the failure.</span></span> <span data-ttu-id="83bf5-114">예를 들어, 인증 오류의 경우 메시지에 첨부된 인증서를 수정하여 메시지를 다시 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-114">For example, in the case of authentication failure, you can correct the certificate attached with the message and resend the message.</span></span> <span data-ttu-id="83bf5-115">대상 큐 할당량을 초과하여 배달에 실패한 경우 할당량 문제가 해결되었기를 기대하며 배달을 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-115">If delivery failed because the target queue quota was reached, you can reattempt delivery in the hope that the quota problem was resolved.</span></span>  
  
 <span data-ttu-id="83bf5-116">대부분의 큐 시스템에는 해당 시스템에서 실패한 모든 메시지가 저장되는 시스템 차원의 배달 못 한 편지 큐가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-116">Most queuing systems have a system-wide dead-letter queue where all failed messages from that system are stored.</span></span> <span data-ttu-id="83bf5-117">메시지 큐(MSMQ)에서는 두 개의 시스템 차원의 배달 못 한 편지 큐를 제공합니다. 하나는 트랜잭션 큐에 배달하지 못한 메시지를 저장하는 시스템 차원의 배달 못 한 트랜잭션 큐이고 다른 하나는 비트랜잭션 큐에 배달하지 못한 메시지를 저장하는 시스템 차원의 배달 못 한 비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-117">Message Queuing (MSMQ) provides two system-wide dead-letter queues: a transactional system-wide dead-letter queue that stores messages that failed delivery to the transactional queue and a non-transactional system-wide dead-letter queue that stores messages that failed delivery to the non-transactional queue.</span></span> <span data-ttu-id="83bf5-118">두 클라이언트가 서로 다른 두 서비스에 메시지를 보내는 경우 WCF의 서로 다른 큐에서 보낼 동일한 MSMQ 서비스를 공유 하는 경우 시스템 배달 못 한 편지 큐에 메시지를 혼합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-118">If two clients are sending messages to two different services, and therefore different queues in WCF are sharing the same MSMQ service to send, then it is possible to have a mix of messages in the system dead-letter queue.</span></span> <span data-ttu-id="83bf5-119">이 방법이 항상 최상은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-119">This is not always optimal.</span></span> <span data-ttu-id="83bf5-120">예를 들어 보안과 같이 경우에 따라 한 클라이언트가 배달 못 한 편지 큐에서 다른 클라이언트의 메시지를 읽을 수 없도록 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-120">In several cases (security, for example), you may not want one client to read another client's messages from a dead-letter queue.</span></span> <span data-ttu-id="83bf5-121">또한 공유된 배달 못 한 편지 큐에서는 클라이언트가 큐를 탐색하여 보낸 메시지를 찾도록 합니다. 이런 경우 배달 못 한 편지 큐에 있는 메시지의 수에 따라 지나치게 많은 비용이 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-121">A shared dead-letter queue also requires clients to browse through the queue to find a message that they sent, which can be prohibitively expensive based on the number of messages in the dead-letter queue.</span></span> <span data-ttu-id="83bf5-122">따라서 WCF에서 `NetMsmqBinding` `MsmqIntegrationBinding,` Windows VISTA의 MSMQ는 사용자 지정 배달 못 한 편지 큐를 제공 합니다 (경우에 따라 응용 프로그램 특정 배달 못 한 큐 라고도 함).</span><span class="sxs-lookup"><span data-stu-id="83bf5-122">Therefore, in WCF`NetMsmqBinding`, `MsmqIntegrationBinding,` and MSMQ on Windows Vista provide a custom dead-letter queue (sometimes referred to as an application-specific dead-letter queue).</span></span>  
  
 <span data-ttu-id="83bf5-123">사용자 지정 배달 못 한 편지 큐에서는 메시지를 보내는 동일한 MSMQ 서비스를 공유하는 클라이언트를 격리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-123">The custom dead-letter queue provides isolation between clients that share the same MSMQ service to send messages.</span></span>  
  
 <span data-ttu-id="83bf5-124">Windows Server 2003 및 Windows XP Windows Communication Foundation (WCF)는 대기 중인 모든 클라이언트 응용 프로그램에 대해 시스템 차원의 배달 못 한 편지 큐를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-124">On Windows Server 2003 and Windows XP, Windows Communication Foundation (WCF) provides a system-wide dead-letter queue for all queued client applications.</span></span> <span data-ttu-id="83bf5-125">Windows Vista에서 WCF는 대기 중인 각 클라이언트 응용 프로그램에 대해 배달 못 한 편지 큐를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-125">On Windows Vista, WCF provides a dead-letter queue for each queued client application.</span></span>  
  
## <a name="specifying-use-of-the-dead-letter-queue"></a><span data-ttu-id="83bf5-126">배달 못 한 편지 큐의 사용 지정</span><span class="sxs-lookup"><span data-stu-id="83bf5-126">Specifying Use of the Dead-Letter Queue</span></span>  

 <span data-ttu-id="83bf5-127">배달 못 한 편지 큐는 송신 애플리케이션의 큐 관리자에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-127">A dead-letter queue is in the queue manager of the sending application.</span></span> <span data-ttu-id="83bf5-128">이 관리자는 만료되었거나 전송 또는 배달하지 못한 메시지를 보관합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-128">It stores messages that have expired or that have failed transfer or delivery.</span></span>  
  
 <span data-ttu-id="83bf5-129">바인딩에는 다음과 같은 배달 못 한 편지 큐 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-129">The binding has the following dead-letter queue properties:</span></span>  
  
- <xref:System.ServiceModel.MsmqBindingBase.DeadLetterQueue%2A>  
  
- <xref:System.ServiceModel.MsmqBindingBase.CustomDeadLetterQueue%2A>  
  
## <a name="reading-messages-from-the-dead-letter-queue"></a><span data-ttu-id="83bf5-130">배달 못 한 편지 큐에서 메시지 읽기</span><span class="sxs-lookup"><span data-stu-id="83bf5-130">Reading Messages from the Dead-Letter Queue</span></span>  

 <span data-ttu-id="83bf5-131">배달 못 한 편지 큐에서 메시지를 읽는 응용 프로그램은 다음과 같은 사소한 차이점을 제외 하 고 응용 프로그램 큐에서 읽는 WCF 서비스와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-131">An application that reads messages out of a dead-letter queue is similar to a WCF service that reads from an application queue, except for the following minor differences:</span></span>  
  
- <span data-ttu-id="83bf5-132">시스템 트랜잭션 배달 못 한 편지 큐에서 메시지를 읽으려면 URI(Uniform Resource Identifier)가 net.msmq://localhost/system$;DeadXact 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-132">To read messages from a system transactional dead-letter queue, the Uniform Resource Identifier (URI) must be of the form: net.msmq://localhost/system$;DeadXact.</span></span>  
  
- <span data-ttu-id="83bf5-133">배달 못 한 시스템 비트랜잭션 큐에서 메시지를 읽으려면 URI가 net.msmq://localhost/system$;DeadLetter 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-133">To read messages from a system non-transactional dead-letter queue, the URI must be of the form: net.msmq://localhost/system$;DeadLetter.</span></span>  
  
- <span data-ttu-id="83bf5-134">사용자 지정 배달 못 한 편지 큐에서 메시지를 읽으려면 URI는 net.tcp://localhost/private/형식 이어야 합니다. \<*custom-dlq-name*> 여기서 *custom-dlq-name* 은 사용자 지정 배달 못 한 편지 큐의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-134">To read messages from a custom dead-letter queue, the URI must be of the form:net.msmq://localhost/private/\<*custom-dlq-name*> where *custom-dlq-name* is the name of the custom dead-letter queue.</span></span>  
  
 <span data-ttu-id="83bf5-135">큐에 주소를 지정 하는 방법에 대 한 자세한 내용은 [서비스 끝점 및 큐 주소 지정](service-endpoints-and-queue-addressing.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="83bf5-135">For more information about how to address queues, see [Service Endpoints and Queue Addressing](service-endpoints-and-queue-addressing.md).</span></span>  
  
 <span data-ttu-id="83bf5-136">수신기의 WCF 스택은 서비스가 수신 대기 하는 주소와 메시지의 주소를 일치 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-136">The WCF stack on the receiver matches addresses that the service is listening on with the address on the message.</span></span> <span data-ttu-id="83bf5-137">주소가 일치하면 메시지가 디스패치되고, 그렇지 않으면 메시지가 디스패치되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-137">If the addresses match, the message is dispatched; if not, the message is not dispatched.</span></span> <span data-ttu-id="83bf5-138">일반적으로 배달 못 한 편지 큐에 있는 메시지는 배달 못 한 편지 큐 서비스가 아닌 서비스에 주소가 지정되기 때문에 배달 못 한 편지 큐에서 메시지를 읽을 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-138">This can cause problems when reading from the dead-letter queue, because messages in the dead-letter queue are typically addressed to the service and not the dead-letter queue service.</span></span> <span data-ttu-id="83bf5-139">따라서 배달 못 한 편지 큐에서 메시지를 읽는 서비스는 수신자와 관계없이 큐의 모든 메시지를 일치시키도록 스택에 지시하는 주소 필터 `ServiceBehavior`를 설치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-139">Therefore, the service reading from the dead-letter queue must install an address filter `ServiceBehavior` that instructs the stack to match all messages in the queue independently of the addressee.</span></span> <span data-ttu-id="83bf5-140">특히 `ServiceBehavior`를 <xref:System.ServiceModel.AddressFilterMode.Any> 매개 변수와 함께 배달 못 한 편지 큐에서 메시지를 읽는 서비스에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-140">Specifically, you must add a `ServiceBehavior` with the <xref:System.ServiceModel.AddressFilterMode.Any> parameter to the service reading messages from the dead-letter queue.</span></span>  
  
## <a name="poison-message-handling-from-the-dead-letter-queue"></a><span data-ttu-id="83bf5-141">배달 못 한 편지 큐에서 포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="83bf5-141">Poison Message Handling from the Dead-Letter Queue</span></span>  

 <span data-ttu-id="83bf5-142">경우에 따라 배달 못 한 편지 큐에서 포이즌 메시지 처리가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-142">Poison message handling is available on dead-letter queues, with some conditions.</span></span> <span data-ttu-id="83bf5-143">시스템 큐에서 하위 큐를 만들 수 없기 때문에 배달 못 한 시스템 큐에서 메시지를 읽는 경우 `ReceiveErrorHandling`을 `Move`로 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-143">Because you cannot create sub-queues from system queues, when reading from the system dead-letter queue, the `ReceiveErrorHandling` cannot be set to `Move`.</span></span> <span data-ttu-id="83bf5-144">사용자 지정 배달 못 한 편지 큐에서 메시지를 읽는 경우 하위 큐를 사용할 수 있으므로 `Move`는 포이즌 메시지의 유효한 처리 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-144">Note that if you are reading from a custom dead-letter queue, you can have sub-queues and, therefore, `Move` is a valid disposition for the poison message.</span></span>  
  
 <span data-ttu-id="83bf5-145">`ReceiveErrorHandling`이 `Reject`로 설정된 경우 사용자 지정 배달 못 한 편지 큐에서 메시지를 읽으면 포이즌 메시지가 배달 못 한 시스템 큐에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-145">When `ReceiveErrorHandling` is set to `Reject`, when reading from the custom dead letter queue, the poison message is put in the system dead-letter queue.</span></span> <span data-ttu-id="83bf5-146">배달 못 한 시스템 큐에서 메시지를 읽는 경우 메시지가 손실/삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-146">If reading from the system dead-letter queue, the message is dropped (purged).</span></span> <span data-ttu-id="83bf5-147">MSMQ에서 배달 못 한 시스템 큐의 거부로 인해 메시지가 손실/삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-147">A reject from a system dead-letter queue in MSMQ drops (purges) the message.</span></span>  
  
## <a name="example"></a><span data-ttu-id="83bf5-148">예제</span><span class="sxs-lookup"><span data-stu-id="83bf5-148">Example</span></span>  

 <span data-ttu-id="83bf5-149">다음 예제에서는 배달 못 한 편지 큐를 만드는 방법 및 이를 사용하여 만료된 메시지를 처리하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-149">The following example shows how to create a dead-letter queue and how to use it to process expired messages.</span></span> <span data-ttu-id="83bf5-150">예제는 [방법: 대기 중인 메시지를 WCF 끝점과 교환](how-to-exchange-queued-messages-with-wcf-endpoints.md)의 예제를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-150">The example is based on the example in [How to: Exchange Queued Messages with WCF Endpoints](how-to-exchange-queued-messages-with-wcf-endpoints.md).</span></span> <span data-ttu-id="83bf5-151">다음 예제에서는 각 애플리케이션의 배달 못 한 편지 큐를 사용하는 주문 처리 서비스에 클라이언트 코드를 작성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-151">The following example shows how to write the client code to the order processing service that uses a dead-letter queue for each application.</span></span> <span data-ttu-id="83bf5-152">또한 예제에서는 배달 못 한 편지 큐에서 메시지를 처리하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-152">The example also shows how to process messages from the dead-letter queue.</span></span>  
  
 <span data-ttu-id="83bf5-153">다음은 각 애플리케이션의 배달 못 한 편지 큐를 지정하는 클라이언트의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-153">The following is code for a client that specifies a dead-letter queue for each application.</span></span>  
  
 [!code-csharp[S_DeadLetter#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/client.cs#1)]
 [!code-vb[S_DeadLetter#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/client.vb#1)]  
  
 <span data-ttu-id="83bf5-154">다음은 클라이언트 구성 파일의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-154">The following is code for the client configuration file.</span></span>  

 <span data-ttu-id="83bf5-155">다음은 배달 못 한 편지 큐의 메시지를 처리하는 서비스의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-155">The following is code for a service processing messages from a dead-letter queue.</span></span>  
  
 [!code-csharp[S_DeadLetter#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_deadletter/cs/dlservice.cs#3)]
 [!code-vb[S_DeadLetter#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_deadletter/vb/dlservice.vb#3)]  
  
 <span data-ttu-id="83bf5-156">다음은 배달 못 한 편지 큐 서비스 구성 파일의 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="83bf5-156">The following is code for the dead-letter queue service configuration file.</span></span>  

## <a name="see-also"></a><span data-ttu-id="83bf5-157">참고 항목</span><span class="sxs-lookup"><span data-stu-id="83bf5-157">See also</span></span>

- [<span data-ttu-id="83bf5-158">큐 개요</span><span class="sxs-lookup"><span data-stu-id="83bf5-158">Queues Overview</span></span>](queues-overview.md)
- [<span data-ttu-id="83bf5-159">방법: WCF 엔드포인트와 대기 중인 메시지 교환</span><span class="sxs-lookup"><span data-stu-id="83bf5-159">How to: Exchange Queued Messages with WCF Endpoints</span></span>](how-to-exchange-queued-messages-with-wcf-endpoints.md)
- [<span data-ttu-id="83bf5-160">포이즌 메시지 처리</span><span class="sxs-lookup"><span data-stu-id="83bf5-160">Poison Message Handling</span></span>](poison-message-handling.md)
