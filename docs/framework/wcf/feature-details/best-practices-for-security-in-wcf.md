---
description: '자세한 정보: WCF의 보안에 대 한 모범 사례'
title: WCF 보안을 위한 최선의 방법
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- best practices [WCF], security
ms.assetid: 3639de41-1fa7-4875-a1d7-f393e4c8bd69
ms.openlocfilehash: 67c3f3054011ea5727d5713c1eabf810a4c39b42
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99643646"
---
# <a name="best-practices-for-security-in-wcf"></a><span data-ttu-id="80d87-103">WCF 보안을 위한 최선의 방법</span><span class="sxs-lookup"><span data-stu-id="80d87-103">Best Practices for Security in WCF</span></span>

<span data-ttu-id="80d87-104">다음 섹션에는 WCF(Windows Communication Foundation)를 사용하여 보안 애플리케이션을 만들 때 고려할 최선의 방법이 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-104">The following sections list the best practices to consider when creating secure applications using Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="80d87-105">보안에 대한 자세한 내용은 [보안 관련 고려 사항](security-considerations-in-wcf.md), [데이터에 대한 보안 고려 사항](security-considerations-for-data.md) 및 [메타데이터 관련 보안 고려 사항](security-considerations-with-metadata.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="80d87-105">For more information about security, see [Security Considerations](security-considerations-in-wcf.md), [Security Considerations for Data](security-considerations-for-data.md), and [Security Considerations with Metadata](security-considerations-with-metadata.md).</span></span>  
  
## <a name="identify-services-performing-windows-authentication-with-spns"></a><span data-ttu-id="80d87-106">SPN을 사용하여 Windows 인증을 수행하는 서비스 식별</span><span class="sxs-lookup"><span data-stu-id="80d87-106">Identify Services Performing Windows Authentication with SPNs</span></span>  

 <span data-ttu-id="80d87-107">UPN(User Principal Name) 또는 SPN(서비스 사용자 이름)을 사용하여 서비스를 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-107">Services can be identified with either user principal names (UPNs) or service principal names (SPNs).</span></span> <span data-ttu-id="80d87-108">네트워크 서비스와 같은 컴퓨터 계정으로 실행되는 서비스에는 실행 중인 컴퓨터에 해당하는 SPN ID가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-108">Services running under machine accounts such as network service have an SPN identity corresponding to the machine they're running.</span></span> <span data-ttu-id="80d87-109">사용자 계정으로 실행되는 서비스에는 실행 중인 사용자에 해당하는 UPN ID가 있지만 `setspn` 도구를 사용하여 사용자 계정에 SPN을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-109">Services running under user accounts have a UPN identity corresponding to the user they're running as, although the `setspn` tool can be used to assign an SPN to the user account.</span></span> <span data-ttu-id="80d87-110">SPN을 통해 식별될 수 있도록 서비스를 구성하고 서비스에 연결하는 클라이언트가 SPN을 사용하도록 구성하면 특정 공격이 발생할 가능성이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-110">Configuring a service so it can be identified via SPN and configuring the clients connecting to the service to use that SPN can make certain attacks more difficult.</span></span> <span data-ttu-id="80d87-111">이 지침은 Kerberos 또는 SSPI 협상을 사용하는 바인딩에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-111">This guidance applies to bindings using Kerberos or SSPI negotiation.</span></span>  <span data-ttu-id="80d87-112">클라이언트는 SSPI가 NTLM으로 대체되는 경우에 대비해 SPN을 계속 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-112">Clients should still specify an SPN in the case where SSPI falls back to NTLM.</span></span>  
  
## <a name="verify-service-identities-in-wsdl"></a><span data-ttu-id="80d87-113">WSDL에서 서비스 ID 확인</span><span class="sxs-lookup"><span data-stu-id="80d87-113">Verify Service Identities in WSDL</span></span>  

 <span data-ttu-id="80d87-114">WS-SecurityPolicy를 사용하면 서비스가 자체 ID에 대한 정보를 메타데이터로 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-114">WS-SecurityPolicy allows services to publish information about their own identities in metadata.</span></span> <span data-ttu-id="80d87-115">`svcutil` 또는 <xref:System.ServiceModel.Description.WsdlImporter>와 같은 다른 메서드를 통해 가져오면 이러한 ID 정보는 WCF 서비스 엔드포인트 주소의 ID 속성으로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-115">When retrieved via `svcutil` or other methods such as <xref:System.ServiceModel.Description.WsdlImporter>, this identity information is translated to the identity properties of the WCF service endpoint addresses.</span></span> <span data-ttu-id="80d87-116">이러한 서비스 ID가 정확하며 유효한지 확인하지 않는 클라이언트는 사실상 서비스 인증을 건너뛰게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-116">Clients which do not verify that these service identities are correct and valid effectively bypass service authentication.</span></span> <span data-ttu-id="80d87-117">이러한 클라이언트를 악의적인 서비스가 악용하여 WSDL의 클레임 ID를 변경하는 방법으로 자격 증명 전달 및 기타 "메시지 가로채기(man-in-the-middle)" 공격을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-117">A malicious service can exploit such clients to execute credential forwarding and other "man in the middle" attacks by changing the identity claimed in its WSDL.</span></span>  
  
## <a name="use-x509-certificates-instead-of-ntlm"></a><span data-ttu-id="80d87-118">NTLM 대신 X509 인증서 사용</span><span class="sxs-lookup"><span data-stu-id="80d87-118">Use X509 Certificates Instead of NTLM</span></span>  

 <span data-ttu-id="80d87-119">WCF는 피어 투 피어 인증을 위해 X509 인증서(피어 채널에 사용됨)와 Windows 인증(SSPI 협상이 Kerberos에서 NTLM으로 다운그레이드됨)이라는 두 가지 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-119">WCF offers two mechanisms for peer-to-peer authentication: X509 certificates (used by peer channel) and Windows authentication where an SSPI negotiation downgrades from Kerberos to NTLM.</span></span>  <span data-ttu-id="80d87-120">다음과 같은 여러 가지 이유로 인해 NTLM 대신 1024비트 이상의 키를 사용하는 인증서 기반 인증을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-120">Certificate-based authentication using key sizes of 1024 bits or more is preferred to NTLM for several reasons:</span></span>  
  
- <span data-ttu-id="80d87-121">상호 인증의 사용 가능성</span><span class="sxs-lookup"><span data-stu-id="80d87-121">the availability of mutual authentication,</span></span>  
  
- <span data-ttu-id="80d87-122">보다 강력한 암호화 알고리즘의 사용</span><span class="sxs-lookup"><span data-stu-id="80d87-122">the use of stronger cryptographic algorithms, and</span></span>  
  
- <span data-ttu-id="80d87-123">전달된 X509 자격 증명을 활용하는 작업의 어려움</span><span class="sxs-lookup"><span data-stu-id="80d87-123">the greater difficulty of utilizing forwarded X509 credentials.</span></span>  

## <a name="always-revert-after-impersonation"></a><span data-ttu-id="80d87-124">가장 후 항상 되돌리기</span><span class="sxs-lookup"><span data-stu-id="80d87-124">Always Revert After Impersonation</span></span>  

 <span data-ttu-id="80d87-125">클라이언트의 가장을 사용하도록 설정한 API를 사용하는 경우, 원래 ID로 되돌려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-125">When using APIs that enable impersonation of a client, be sure to revert to the original identity.</span></span> <span data-ttu-id="80d87-126">예를 들어 <xref:System.Security.Principal.WindowsIdentity> 및 <xref:System.Security.Principal.WindowsImpersonationContext>를 사용하는 경우에는 다음 코드에서처럼 C# `using` 문 또는 Visual Basic`Using` 문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-126">For example, when using the <xref:System.Security.Principal.WindowsIdentity> and <xref:System.Security.Principal.WindowsImpersonationContext>, use the C# `using` statement or the Visual Basic`Using` statement, as shown in the following code.</span></span> <span data-ttu-id="80d87-127"><xref:System.Security.Principal.WindowsImpersonationContext> 클래스는 <xref:System.IDisposable> 인터페이스를 구현하므로 코드가 `using` 블록을 벗어나면 CLR(공용 언어 런타임)은 원래 ID로 자동으로 되돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-127">The <xref:System.Security.Principal.WindowsImpersonationContext> class implements the <xref:System.IDisposable> interface, and therefore the common language runtime (CLR) automatically reverts to the original identity once the code leaves the `using` block.</span></span>  
  
 [!code-csharp[c_SecurityBestPractices#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_securitybestpractices/cs/source.cs#1)]
 [!code-vb[c_SecurityBestPractices#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_securitybestpractices/vb/source.vb#1)]  
  
## <a name="impersonate-only-as-needed"></a><span data-ttu-id="80d87-128">필요할 때만 가장</span><span class="sxs-lookup"><span data-stu-id="80d87-128">Impersonate Only as Needed</span></span>  

 <span data-ttu-id="80d87-129"><xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> 클래스의 <xref:System.Security.Principal.WindowsIdentity> 메서드를 사용하면 매우 제어된 범위에서 가장을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-129">Using the <xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> method of the <xref:System.Security.Principal.WindowsIdentity> class, it is possible to use impersonation in a very controlled scope.</span></span> <span data-ttu-id="80d87-130">이는 전체 작업의 범위에 대해 가장을 허용하는 <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A>의 <xref:System.ServiceModel.OperationBehaviorAttribute> 속성을 사용하는 것과 대조됩니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-130">This is in contrast to using the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property of the <xref:System.ServiceModel.OperationBehaviorAttribute>, which allows impersonation for the scope of the entire operation.</span></span> <span data-ttu-id="80d87-131">가능하면 보다 정확한 <xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> 메서드를 사용하여 가장 범위를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-131">Whenever possible, control the scope of impersonation by using the more precise <xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> method.</span></span>  
  
## <a name="obtain-metadata-from-trusted-sources"></a><span data-ttu-id="80d87-132">신뢰할 수 있는 소스에서 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="80d87-132">Obtain Metadata from Trusted Sources</span></span>  

 <span data-ttu-id="80d87-133">메타데이터의 원본을 신뢰할 수 있는지, 다른 사람이 메타데이터를 훼손하지는 않았는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-133">Be sure you trust the source of your metadata and make sure that no one has tampered with the metadata.</span></span> <span data-ttu-id="80d87-134">HTTP 프로토콜을 사용하여 검색한 메타데이터는 일반 텍스트로 전송되며 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-134">Metadata retrieved using the HTTP protocol is sent in clear text and can be tampered with.</span></span> <span data-ttu-id="80d87-135">서비스가 <xref:System.ServiceModel.Description.ServiceMetadataBehavior.HttpsGetEnabled%2A> 및 <xref:System.ServiceModel.Description.ServiceMetadataBehavior.HttpsGetUrl%2A> 속성을 사용하는 경우 서비스 작성자가 제공하는 URL을 통해 HTTPS 프로토콜을 사용하여 데이터를 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-135">If the service uses the <xref:System.ServiceModel.Description.ServiceMetadataBehavior.HttpsGetEnabled%2A> and <xref:System.ServiceModel.Description.ServiceMetadataBehavior.HttpsGetUrl%2A> properties, use the URL supplied by the service creator to download the data using the HTTPS protocol.</span></span>  
  
## <a name="publish-metadata-using-security"></a><span data-ttu-id="80d87-136">보안을 사용하여 메타데이터 게시</span><span class="sxs-lookup"><span data-stu-id="80d87-136">Publish Metadata Using Security</span></span>  

 <span data-ttu-id="80d87-137">서비스의 게시된 메타데이터가 훼손되지 않게 하려면 전송 또는 메시지 수준 보안을 사용하여 메타데이터 교환 엔드포인트의 보안을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-137">To prevent tampering with a service's published metadata, secure the metadata exchange endpoint with transport or message-level security.</span></span> <span data-ttu-id="80d87-138">자세한 내용은 [메타데이터 엔드포인트 게시](../publishing-metadata-endpoints.md) 및 [방법: 방법: 코드를 사용하여 서비스에 대한 메타데이터 게시](how-to-publish-metadata-for-a-service-using-code.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="80d87-138">For more information, see [Publishing Metadata Endpoints](../publishing-metadata-endpoints.md) and [How to: Publish Metadata for a Service Using Code](how-to-publish-metadata-for-a-service-using-code.md).</span></span>  
  
## <a name="ensure-use-of-local-issuer"></a><span data-ttu-id="80d87-139">로컬 발급자 사용</span><span class="sxs-lookup"><span data-stu-id="80d87-139">Ensure Use of Local Issuer</span></span>  

 <span data-ttu-id="80d87-140">지정된 바인딩에 발급자 주소와 바인딩을 지정하면 해당 바인딩을 사용하는 엔드포인트에는 로컬 발급자가 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-140">If an issuer address and binding are specified for a given binding, the local issuer is not used for endpoints that use that binding.</span></span> <span data-ttu-id="80d87-141">로컬 발급자를 항상 사용해야 하는 클라이언트는 이러한 바인딩을 사용하지 않도록 하거나 발급자 주소가 null이 되도록 바인딩을 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-141">Clients who expect to always use the local issuer should ensure that they do not use such a binding or that they modify the binding such that the issuer address is null.</span></span>  
  
## <a name="saml-token-size-quotas"></a><span data-ttu-id="80d87-142">SAML 토큰 크기 할당량</span><span class="sxs-lookup"><span data-stu-id="80d87-142">SAML Token Size Quotas</span></span>  

 <span data-ttu-id="80d87-143">SAML(Security Assertions Markup Language) 토큰이 메시지에 serialize될 때 STS(보안 토큰 서비스)에서 해당 토큰을 발급하거나 클라이언트에서 인증의 일부로 해당 토큰을 서비스에 제공하는 경우, 최대 메시지 크기 할당량은 SAML 토큰 및 다른 메시지 부분을 수용할 수 있도록 충분히 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-143">When Security Assertions Markup Language (SAML) tokens are serialized in messages, either when they are issued by a Security Token Service (STS) or when clients present them to services as part of authentication, the maximum message size quota must be sufficiently large to accommodate the SAML token and the other message parts.</span></span> <span data-ttu-id="80d87-144">일반적으로 기본 메시지 크기 할당량이면 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-144">In normal cases, the default message size quotas are sufficient.</span></span> <span data-ttu-id="80d87-145">그러나 SAML 토큰에 수백 개의 클레임이 포함되어 있어 SAML 토큰이 큰 경우에는 serialize된 토큰을 수용할 수 있도록 할당량을 늘려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-145">However, in cases where a SAML token is large because it contains hundreds of claims, the quotas should be increased to accommodate the serialized token.</span></span> <span data-ttu-id="80d87-146">할당량에 대한 자세한 내용은 [데이터에 대한 보안 고려 사항](security-considerations-for-data.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="80d87-146">For more information about quotas, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
## <a name="set-securitybindingelementincludetimestamp-to-true-on-custom-bindings"></a><span data-ttu-id="80d87-147">사용자 지정 바인딩에서 SecurityBindingElement.IncludeTimestamp를 True로 설정</span><span class="sxs-lookup"><span data-stu-id="80d87-147">Set SecurityBindingElement.IncludeTimestamp to True on Custom Bindings</span></span>  

 <span data-ttu-id="80d87-148">사용자 지정 바인딩을 만들 때는 <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A>를 `true`로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-148">When you create a custom binding, you must set <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> to `true`.</span></span> <span data-ttu-id="80d87-149">그렇지 않을 경우 <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A>가 `false`로 설정되어 있고 클라이언트가 X509 인증서와 같은 비동기 키 기반 토큰을 사용하는 경우 메시지가 서명되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="80d87-149">Otherwise, if <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> is set to `false`, and the client is using an asymmetric key-based token such as an X509 certificate, the message will not be signed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="80d87-150">참고 항목</span><span class="sxs-lookup"><span data-stu-id="80d87-150">See also</span></span>

- [<span data-ttu-id="80d87-151">Security Considerations</span><span class="sxs-lookup"><span data-stu-id="80d87-151">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="80d87-152">데이터에 대한 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="80d87-152">Security Considerations for Data</span></span>](security-considerations-for-data.md)
- [<span data-ttu-id="80d87-153">메타데이터 관련 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="80d87-153">Security Considerations with Metadata</span></span>](security-considerations-with-metadata.md)
