---
title: HTTP 전송 보안
ms.date: 03/30/2017
ms.assetid: d3439262-c58e-4d30-9f2b-a160170582bb
ms.openlocfilehash: 1af9913ac977b0e1c112ca818a04842af9f1307c
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96280561"
---
# <a name="http-transport-security"></a><span data-ttu-id="e81d8-102">HTTP 전송 보안</span><span class="sxs-lookup"><span data-stu-id="e81d8-102">HTTP Transport Security</span></span>

<span data-ttu-id="e81d8-103">HTTP를 전송으로 사용하는 경우 SSL(Secure Sockets Layer) 구현에서 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-103">When using HTTP as the transport, security is provided by a Secure Sockets Layer (SSL) implementation.</span></span> <span data-ttu-id="e81d8-104">SSL은 서비스를 클라이언트에 인증한 다음 채널에 기밀성(암호화)을 제공하기 위해 인터넷에서 널리 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-104">SSL is widely used on the Internet to authenticate a service to a client, and then to provide confidentiality (encryption) to the channel.</span></span> <span data-ttu-id="e81d8-105">이 항목에서는 SSL이 작동 하는 방법 및이를 WCF (Windows Communication Foundation)에서 구현 하는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-105">This topic explains how SSL works and how it is implemented in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="basic-ssl"></a><span data-ttu-id="e81d8-106">기본 SSL</span><span class="sxs-lookup"><span data-stu-id="e81d8-106">Basic SSL</span></span>  

 <span data-ttu-id="e81d8-107">SSL 작동 방식은 일반적인 시나리오, 이 경우 은행 웹 사이트를 통해 가장 효과적으로 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-107">How SSL works is best explained through a typical scenario, in this case, a bank's Web site.</span></span> <span data-ttu-id="e81d8-108">이 사이트에서는 고객이 사용자 이름과 암호를 사용하여 로그온할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-108">The site allows a customer to log on with a user name and password.</span></span> <span data-ttu-id="e81d8-109">인증된 후 사용자는 계좌 잔고 보기, 청구서 지급, 다른 계좌로 자금 이체 등의 트랜잭션을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-109">After being authenticated, the user can perform transactions, such as view account balances, pay bills, and move money from one account to another.</span></span>  
  
 <span data-ttu-id="e81d8-110">사용자가 사이트를 처음 방문 하면 SSL 메커니즘은 사용자의 클라이언트 (이 경우 Internet Explorer)를 사용 하 여 *핸드셰이크* 라는 일련의 협상을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-110">When a user first visits the site, the SSL mechanism begins a series of negotiations, called a *handshake*, with the user's client (in this case, Internet Explorer).</span></span> <span data-ttu-id="e81d8-111">SSL은 먼저 은행 사이트를 고객에게 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-111">SSL first authenticates the bank site to the customer.</span></span> <span data-ttu-id="e81d8-112">고객이 먼저 사용자 이름과 암호를 입력하도록 부추기는 스푸프가 아니라 실제 사이트와 통신하고 있음을 알아야 하므로 이는 필수적인 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-112">This is an essential step because customers must first know that they are communicating with the actual site, and not a spoof that tries to lure them into typing in their user name and password.</span></span> <span data-ttu-id="e81d8-113">SSL은 VeriSign 등의 신뢰할 수 있는 기관에서 제공한 SSL 인증서를 사용하여 이 인증을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-113">SSL does this authentication by using an SSL certificate provided by a trusted authority, such as VeriSign.</span></span> <span data-ttu-id="e81d8-114">논리는 다음과 같습니다. VeriSign이 은행 사이트의 ID를 보증합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-114">The logic goes like this: VeriSign vouches for the identity of the bank site.</span></span> <span data-ttu-id="e81d8-115">Internet Explorer에서 VeriSign을 신뢰하므로 사이트가 신뢰됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-115">Because Internet Explorer trusts VeriSign, the site is trusted.</span></span> <span data-ttu-id="e81d8-116">VeriSign에서 확인하려면 VeriSign 로고를 클릭하여 이 작업을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-116">If you want to check with VeriSign, you can do so as well by clicking on the VeriSign logo.</span></span> <span data-ttu-id="e81d8-117">만료 날짜와 발급된 대상(은행 사이트)이 포함된 인증서가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-117">That presents a statement of authenticity with its expiration date and who it is issued to (the bank site).</span></span>  
  
 <span data-ttu-id="e81d8-118">보안 세션을 시작하기 위해 클라이언트는 서명, 해시 생성, 암호화 및 해독에 사용할 수 있는 암호화 알고리즘 목록과 함께 "hello"에 해당하는 내용을 서버로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-118">To initiate a secure session, the client sends the equivalent of a "hello" to the server along with a list of cryptographic algorithms it can use to sign, generate hashes, and encrypt and decrypt with.</span></span> <span data-ttu-id="e81d8-119">이에 응답하여 사이트에서 승인 및 선택한 알고리즘 모음 중 하나를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-119">In response, the site sends back an acknowledgment and its choice of one of the algorithms suites.</span></span> <span data-ttu-id="e81d8-120">이 초기 핸드셰이크 중에 양쪽이 모두 nonce를 보내고 받습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-120">During this initial handshake, both parties send and receive nonces.</span></span> <span data-ttu-id="e81d8-121">*Nonce* 는 사이트의 공개 키와 함께 해시를 만들기 위해 임의로 생성 되는 데이터의 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-121">A *nonce* is a randomly generated piece of data that is used, in combination with the site's public key, to create a hash.</span></span> <span data-ttu-id="e81d8-122">*해시* 는 SHA1과 같은 표준 알고리즘을 사용 하 여 두 숫자에서 파생 되는 새 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-122">A *hash* is a new number that is derived from the two numbers using a standard algorithm, such as SHA1.</span></span> <span data-ttu-id="e81d8-123">클라이언트와 사이트는 또한 사용할 해시 알고리즘에 동의 하도록 메시지를 교환 합니다. 해시는 고유 하며, 메시지를 암호화 하 고 해독 하기 위해 클라이언트와 사이트 간의 세션에만 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-123">(The client and the site also exchange messages to agree which hash algorithm to use.) The hash is unique and is used only for the session between the client and the site to encrypt and decrypt messages.</span></span> <span data-ttu-id="e81d8-124">클라이언트와 서비스 둘 다에 원래 nonce와 인증서의 공개 키가 있으므로 양쪽이 모두 동일한 해시를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-124">Both client and service have the original nonce and the certificate's public key, so both sides can generate the same hash.</span></span> <span data-ttu-id="e81d8-125">따라서 클라이언트는 (a) 합의된 알고리즘을 사용하여 데이터를 통해 해시를 계산하고 (b) 이 해시를 서비스에서 전송한 해시와 비교하여 서비스에서 전송한 해시의 유효성을 검사합니다. 두 해시가 일치하면 클라이언트에서 해시가 조작되지 않았음을 확신합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-125">Therefore, the client validates the hash sent by the service by (a) using the agreed upon algorithm to calculate the hash from the data, and (b) comparing it to the hash sent by the service; if the two match, then the client has assurance that the hash has not been tampered with.</span></span> <span data-ttu-id="e81d8-126">클라이언트는 이 해시를 키로 사용하여 다른 새 해시가 포함된 메시지를 암호화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-126">The client can then use this hash as a key to encrypt a message that contains yet another new hash.</span></span> <span data-ttu-id="e81d8-127">서비스는 해시를 사용하여 메시지를 해독하고 최종 해시에서 두 번째 해시를 복구합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-127">The service can decrypt the message using the hash, and recover this second-to-final hash.</span></span> <span data-ttu-id="e81d8-128">이제 누적 정보(nonce, 공개 키 및 기타 데이터)가 양쪽에 알려지며 최종 해시(또는 마스터 키)를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-128">The accumulated information (nonces, public key, and other data) is now known to both sides, and a final hash (or master key) can be created.</span></span> <span data-ttu-id="e81d8-129">이 최종 키는 맨 마지막에서 두 번째 해시를 사용하여 암호화된 상태로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-129">This final key is sent encrypted using the next-to-last hash.</span></span> <span data-ttu-id="e81d8-130">그런 다음 세션의 나머지 부분에 대 한 메시지를 암호화 하 고 암호 해독 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-130">The master key is then used to encrypt and decrypt messages for the rest of the session.</span></span> <span data-ttu-id="e81d8-131">클라이언트와 서비스는 모두 동일한 키를 사용 하므로 *세션 키* 라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-131">Because both client and service use the same key, this is also called a *session key*.</span></span>  
  
 <span data-ttu-id="e81d8-132">세션 키는 대칭 키 또는 "공유 암호"로 간주되기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-132">The session key is also characterized as a symmetric key, or a "shared secret."</span></span> <span data-ttu-id="e81d8-133">대칭 키가 있으면 트랜잭션의 양쪽에 필요한 계산이 감소하므로 이는 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-133">Having a symmetric key is important because it reduces the computation required by both sides of the transaction.</span></span> <span data-ttu-id="e81d8-134">모든 메시지가 nonce와 해시의 새 교환을 요구하면 성능이 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-134">If every message demanded a new exchange of nonces and hashes, performance would deteriorate.</span></span> <span data-ttu-id="e81d8-135">따라서 SSL의 최종 목적은 대칭 키를 사용하여 보안과 효율성을 높이면서 메시지가 양쪽 간에 자유롭게 이동할 수 있게 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-135">Therefore, the ultimate goal of SSL is to use a symmetric key that allows messages to flow freely between the two sides with a greater degree of security and efficiency.</span></span>  
  
 <span data-ttu-id="e81d8-136">프로토콜이 사이트마다 다를 수 있으므로 이전 설명은 수행되는 작업의 단순한 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-136">The previous description is a simplified version of what happens, because the protocol may vary from site to site.</span></span> <span data-ttu-id="e81d8-137">또한 클라이언트와 사이트가 모두 핸드셰이크 중에 알고리즘 방식으로 결합되어 데이터 교환 프로세스에 복잡성과 보호 기능을 추가하는 nonce를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-137">It is also possible that both the client and the site both generate nonces that are algorithmically combined during the handshake to add more complexity, and therefore protection, to the process of exchanging data.</span></span>  
  
### <a name="certificates-and-public-key-infrastructure"></a><span data-ttu-id="e81d8-138">인증서 및 공개 키 인프라</span><span class="sxs-lookup"><span data-stu-id="e81d8-138">Certificates and Public Key Infrastructure</span></span>  

 <span data-ttu-id="e81d8-139">핸드셰이크 중에 서비스는 해당 SSL 인증서를 클라이언트로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-139">During the handshake, the service also sends its SSL certificate to the client.</span></span> <span data-ttu-id="e81d8-140">인증서에는 만료 날짜, 발급 기관, 사이트의 URI(Uniform Resource Identifier) 같은 정보가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-140">The certificate contains information, such as its expiration date, issuing authority, and the site's Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="e81d8-141">클라이언트는 원래 연결한 URI와 이 URI를 비교하여 일치하는지 확인하고 날짜 및 발급 기관도 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-141">The client compares the URI to the URI it had originally contacted to ensure a match, and also checks the date and issuing authority.</span></span>  
  
 <span data-ttu-id="e81d8-142">모든 인증서에는 개인 키와 공개 키 라는 두 개의 키가 있으며 두 키를 *교환 키 쌍* 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-142">Every certificate has two keys, a private key and a public key, and the two are known as an *exchange key pair*.</span></span> <span data-ttu-id="e81d8-143">간단히 말해서 프라이빗 키는 인증서의 소유자에게만 알려지고 퍼블릭 키는 인증서에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-143">In brief, the private key is known only to the owner of the certificate while the public key is readable from the certificate.</span></span> <span data-ttu-id="e81d8-144">한 키를 사용하여 다이제스트, 해시 또는 다른 키를 암호화하거나 해독할 수 있지만 반대 작업으로만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-144">Either key can be used to encrypt or decrypt a digest, hash, or other key, but only as contrary operations.</span></span> <span data-ttu-id="e81d8-145">예를 들어 클라이언트가 퍼블릭 키로 암호화되는 경우에만 사이트에서 프라이빗 키를 사용하여 메시지를 해독할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-145">For example, if the client encrypts with the public key, only the site can decrypt the message using the private key.</span></span> <span data-ttu-id="e81d8-146">마찬가지로 사이트가 프라이빗 키로 암호화되는 경우 클라이언트는 퍼블릭 키를 사용하여 해독할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-146">Similarly, if the site encrypts with the private key, the client can decrypt with the public key.</span></span> <span data-ttu-id="e81d8-147">이 경우 프라이빗 키로 암호화된 메시지만 퍼블릭 키로 해독할 수 있으므로 프라이빗 키의 소유자하고만 메시지가 교환된다는 것을 클라이언트에 보증할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-147">This provides assurance to the client that the messages are being exchanged only with the possessor of the private key because only messages encrypted with the private key can be decrypted with the public key.</span></span> <span data-ttu-id="e81d8-148">사이트는 공개 키를 사용하여 암호화한 클라이언트와 메시지를 교환합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-148">The site is assured that it is exchanging messages with a client that has encrypted using the public key.</span></span> <span data-ttu-id="e81d8-149">그러나 이 교환은 초기 핸드셰이크에 대해서만 보안이 유지되며, 이 때문에 실제 대칭 키를 만들기 위해 훨씬 더 많은 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-149">This exchange is secure only for an initial handshake, however, which is why much more is done to create the actual symmetric key.</span></span> <span data-ttu-id="e81d8-150">그렇지만 모든 통신을 수행하려면 서비스에 올바른 SSL 인증서가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-150">Nevertheless, all communications depend on the service having a valid SSL certificate.</span></span>  
  
## <a name="implementing-ssl-with-wcf"></a><span data-ttu-id="e81d8-151">WCF를 사용하여 SSL 구현</span><span class="sxs-lookup"><span data-stu-id="e81d8-151">Implementing SSL with WCF</span></span>  

 <span data-ttu-id="e81d8-152">HTTP 전송 보안 (또는 SSL)은 WCF 외부에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-152">HTTP transport security (or SSL) is provided externally to WCF.</span></span> <span data-ttu-id="e81d8-153">다음 두 가지 방법 중 하나로 SSL을 구현할 수 있습니다. 결정 요인은 애플리케이션 호스팅 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-153">You can implement SSL in one of two ways; the deciding factor is how your application is hosted:</span></span>  
  
- <span data-ttu-id="e81d8-154">WCF 호스트로 인터넷 정보 서비스 (IIS)를 사용 하는 경우 IIS 인프라를 사용 하 여 SSL 서비스를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-154">If you are using Internet Information Services (IIS) as your WCF host, use the IIS infrastructure to set up an SSL service.</span></span>  
  
- <span data-ttu-id="e81d8-155">자체 호스팅 WCF 응용 프로그램을 만드는 경우 HttpCfg.exe 도구를 사용 하 여 SSL 인증서를 주소에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-155">If you are creating a self-hosted WCF application, you can bind an SSL certificate to the address using the HttpCfg.exe tool.</span></span>  
  
### <a name="using-iis-for-transport-security"></a><span data-ttu-id="e81d8-156">전송 보안에 IIS 사용</span><span class="sxs-lookup"><span data-stu-id="e81d8-156">Using IIS for Transport Security</span></span>  
  
#### <a name="iis-70"></a><span data-ttu-id="e81d8-157">IIS 7.0</span><span class="sxs-lookup"><span data-stu-id="e81d8-157">IIS 7.0</span></span>  

 <span data-ttu-id="e81d8-158">SSL을 사용 하 여 IIS 7.0을 보안 호스트로 설정 하려면 [iis 7.0에서 SSL(Secure Sockets Layer) 구성](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc771438(v=ws.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e81d8-158">To set up IIS 7.0 as a secure host (using SSL), see [Configuring Secure Sockets Layer in IIS 7.0](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc771438(v=ws.10)).</span></span>  
  
<span data-ttu-id="e81d8-159">IIS 7.0에서 사용할 인증서를 구성 하려면 [iis 7.0에서 서버 인증서 구성](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732230(v=ws.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e81d8-159">To configure certificates for use with IIS 7.0, see [Configuring Server Certificates in IIS 7.0](/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732230(v=ws.10)).</span></span>  
  
#### <a name="iis-60"></a><span data-ttu-id="e81d8-160">IIS 6.0</span><span class="sxs-lookup"><span data-stu-id="e81d8-160">IIS 6.0</span></span>  

 <span data-ttu-id="e81d8-161">SSL을 사용 하 여 IIS 6.0을 보안 호스트로 설정 하려면 [SSL(Secure Sockets Layer) 구성](/previous-versions/windows/it-pro/windows-server-2003/cc736992(v=ws.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e81d8-161">To set up IIS 6.0 as a secure host (using SSL), see [Configuring Secure Sockets Layer](/previous-versions/windows/it-pro/windows-server-2003/cc736992(v=ws.10)).</span></span>  
  
 <span data-ttu-id="e81d8-162">IIS 6.0에서 사용할 인증서를 구성 하려면 [Certificates_IIS_SP1_Ops](/previous-versions/windows/it-pro/windows-server-2003/cc757474(v=ws.10))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e81d8-162">To configure certificates for use with IIS 6.0, see [Certificates_IIS_SP1_Ops](/previous-versions/windows/it-pro/windows-server-2003/cc757474(v=ws.10)).</span></span>  
  
### <a name="using-httpcfg-for-ssl"></a><span data-ttu-id="e81d8-163">SSL에 HttpCfg 사용</span><span class="sxs-lookup"><span data-stu-id="e81d8-163">Using HttpCfg for SSL</span></span>  

 <span data-ttu-id="e81d8-164">자체 호스팅 WCF 응용 프로그램을 만드는 경우 [HttpCfg.exe](/windows/win32/http/httpcfg-exe) 도구를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e81d8-164">If you're creating a self-hosted WCF application, use the [HttpCfg.exe](/windows/win32/http/httpcfg-exe) tool.</span></span>
  
 <span data-ttu-id="e81d8-165">HttpCfg.exe 도구를 사용 하 여 x.509 인증서로 포트를 설정 하는 방법에 대 한 자세한 내용은 [방법: SSL 인증서로 포트 구성](how-to-configure-a-port-with-an-ssl-certificate.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e81d8-165">For more information about using the HttpCfg.exe tool to set up a port with an X.509 certificate, see [How to: Configure a Port with an SSL Certificate](how-to-configure-a-port-with-an-ssl-certificate.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e81d8-166">참고 항목</span><span class="sxs-lookup"><span data-stu-id="e81d8-166">See also</span></span>

- [<span data-ttu-id="e81d8-167">전송 보안</span><span class="sxs-lookup"><span data-stu-id="e81d8-167">Transport Security</span></span>](transport-security.md)
- [<span data-ttu-id="e81d8-168">메시지 보안</span><span class="sxs-lookup"><span data-stu-id="e81d8-168">Message Security</span></span>](message-security-in-wcf.md)
