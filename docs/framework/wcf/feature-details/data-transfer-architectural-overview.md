---
title: 데이터 전송 아키텍처 개요
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: efb6933ba90975d5ba35deb2bf22af12fc7c2cdc
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96291689"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="fb816-102">데이터 전송 아키텍처 개요</span><span class="sxs-lookup"><span data-stu-id="fb816-102">Data Transfer Architectural Overview</span></span>

<span data-ttu-id="fb816-103">WCF (Windows Communication Foundation)는 메시징 인프라로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="fb816-104">WCF는 메시지를 받고, 처리하고, 추가 작업을 위해 사용자 코드로 디스패치하거나, 사용자 코드에서 제공된 데이터로부터 메시지를 생성하고 이 메시지를 대상에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="fb816-105">고급 개발자를 대상으로 한 이 항목에서는 메시지 및 포함된 데이터를 처리하기 위한 아키텍처에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="fb816-106">데이터를 주고 받는 방법을 보다 간단하게, 작업에 초점을 두고 설명하는 내용은 [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="fb816-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fb816-107">이 항목에서는 WCF 개체 모델을 검사 하 여 표시 되지 않는 WCF 구현 세부 정보에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="fb816-108">문서화된 구현 세부 정보와 관련하여 두 가지 주의해야 할 점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="fb816-109">첫째, 설명은 간결하지만 실제 구현은 최적화 또는 다른 이유로 인해 훨씬 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="fb816-110">둘째, 문서화된 사항을 비롯한 특정 구현 세부 정보에 의존해서는 안 됩니다. 이러한 사항은 버전이 변경되는 경우 또는 서비스 릴리스에서 예고 없이 변경될 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="fb816-111">기본 아키텍처</span><span class="sxs-lookup"><span data-stu-id="fb816-111">Basic Architecture</span></span>  

 <span data-ttu-id="fb816-112">WCF 메시지 처리 기능의 핵심은 <xref:System.ServiceModel.Channels.Message> [메시지 클래스 사용](using-the-message-class.md)에서 자세히 설명 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="fb816-113">WCF의 런타임 구성 요소는 두 가지 주요 부분으로 나눌 수 있습니다. 즉, 채널 스택과 서비스 프레임 워크는 <xref:System.ServiceModel.Channels.Message> 클래스가 연결 지점입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="fb816-114">채널 스택은 유효한 <xref:System.ServiceModel.Channels.Message> 인스턴스와 메시지 데이터를 주고받는 일부 동작 간의 변환을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="fb816-115">보내는 쪽에서는 채널 스택이 유효한 <xref:System.ServiceModel.Channels.Message> 인스턴스를 사용하고, 처리를 수행한 다음 논리적으로 메시지 보내기에 해당하는 동작을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="fb816-116">이러한 동작은 구현에 따라 TCP 또는 HTTP 패킷 보내기, 메시지 큐에서 메시지 대기시키기, 메시지를 데이터베이스에 쓰기, 파일 공유를 위해 메시지 저장하기 또는 기타 동작이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="fb816-117">가장 일반적인 동작은 네트워크 프로토콜을 통해 메시지를 보내는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="fb816-118">받는 쪽에서는 이와 반대의 작업을 수행합니다. 동작(TCP 또는 HTTP 패킷의 도착 또는 기타 동작)을 감지하면 처리를 수행한 다음 채널 스택에서 이 동작을 유효한 <xref:System.ServiceModel.Channels.Message> 인스턴스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="fb816-119">클래스 및 채널 스택을 직접 사용 하 여 WCF를 사용할 수 있습니다 <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="fb816-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="fb816-120">그러나 이 방법은 어렵고 시간이 많이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="fb816-121">또한 <xref:System.ServiceModel.Channels.Message> 이 방법으로 wcf를 사용 하는 경우 개체는 메타 데이터 지원을 제공 하지 않으므로 강력한 형식의 wcf 클라이언트를 생성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="fb816-122">따라서 WCF에는 개체를 생성 하 고 받는 데 사용할 수 있는 사용 하기 쉬운 프로그래밍 모델을 제공 하는 서비스 프레임 워크가 포함 되어 있습니다 `Message` .</span><span class="sxs-lookup"><span data-stu-id="fb816-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="fb816-123">서비스 프레임 워크는 서비스 계약의 개념을 통해 서비스를 .NET Framework 형식으로 매핑하고, 특성으로 표시 된 메서드만 .NET Framework 사용자 작업으로 메시지를 디스패치합니다 <xref:System.ServiceModel.OperationContractAttribute> . 자세한 내용은 [서비스 계약 디자인](../designing-service-contracts.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fb816-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="fb816-124">이러한 메서드에는 매개 변수와 반환 값이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="fb816-125">서비스 쪽에서는 서비스 프레임워크가 들어오는 <xref:System.ServiceModel.Channels.Message> 인스턴스를 매개 변수로 변환하고, 반환 값을 나가는 <xref:System.ServiceModel.Channels.Message> 인스턴스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="fb816-126">클라이언트 쪽에서는 반대로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="fb816-127">예를 들어 아래의 `FindAirfare` 작업을 살펴 봅니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="fb816-128">`FindAirfare` 를 클라이언트에서 호출했다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="fb816-129">클라이언트의 서비스 프레임워크는 `FromCity` 및 `ToCity` 매개 변수를 나가는 <xref:System.ServiceModel.Channels.Message> 인스턴스로 변환하고, 보낼 채널 스택에 이를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="fb816-130">서비스 쪽에서는 <xref:System.ServiceModel.Channels.Message> 인스턴스가 채널 스택으로부터 도착할 때 서비스 프레임워크가 메시지로부터 관련 데이터를 추출하여 `FromCity` 및 `ToCity` 매개 변수를 채운 다음, 서비스측 `FindAirfare` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="fb816-131">메서드가 반환되면 서비스 프레임워크는 반환된 정수 값과 `IsDirectFlight` 출력 매개 변수를 사용하여 이 정보가 포함된 <xref:System.ServiceModel.Channels.Message> 개체 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="fb816-132">그런 다음 `Message` 인스턴스를 클라이언트로 다시 보낼 채널 스택에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="fb816-133">클라이언트 쪽에서는 응답 메시지가 포함된 <xref:System.ServiceModel.Channels.Message> 인스턴스가 채널 스택으로부터 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="fb816-134">서비스 프레임워크는 반환 값과 `IsDirectFlight` 값을 추출하고 이러한 값을 클라이언트의 호출자에게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="fb816-135">Message 클래스</span><span class="sxs-lookup"><span data-stu-id="fb816-135">Message Class</span></span>  

 <span data-ttu-id="fb816-136"><xref:System.ServiceModel.Channels.Message> 클래스는 메시지를 추상적으로 표현하도록 만들어졌으나 해당 디자인은 SOAP 메시지에 강하게 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="fb816-137"><xref:System.ServiceModel.Channels.Message> 에는 메시지 본문, 메시지 헤더 및 메시지 속성이라는 세 가지 주요 정보가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="fb816-138">메시지 본문</span><span class="sxs-lookup"><span data-stu-id="fb816-138">Message Body</span></span>  

 <span data-ttu-id="fb816-139">메시지 본문은 메시지의 실제 데이터 페이로드를 나타내는 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="fb816-140">메시지 본문은 항상 XML Infoset으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="fb816-141">이는 WCF에서 만들어지거나 받은 모든 메시지가 XML 형식 이어야 한다는 것을 의미 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="fb816-142">메시지 형식은 메시지 본문의 해석 방법을 결정하는 채널 스택에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="fb816-143">채널 스택은 메시지를 XML로 내보내거나, 다른 형식으로 변환하거나, 아예 전부 생략할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="fb816-144">물론 WCF에서 제공 하는 대부분의 바인딩을 사용 하는 경우 메시지 본문은 SOAP 봉투의 본문 섹션에서 XML 콘텐츠로 표현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="fb816-145">`Message` 클래스가 본문을 나타내는 XML 데이터와 함께 반드시 버퍼를 포함하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="fb816-146">논리적으로는 `Message` 가 XML Infoset을 포함하지만, 이 Infoset은 동적으로 생성될 수 있으며, 메모리에 물리적으로 존재하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="fb816-147">데이터를 메시지 본문에 넣기</span><span class="sxs-lookup"><span data-stu-id="fb816-147">Putting Data into the Message Body</span></span>  

 <span data-ttu-id="fb816-148">데이터를 메시지 본문에 넣기 위한 일관된 메커니즘은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="fb816-149"><xref:System.ServiceModel.Channels.Message> 클래스에는 추상 메서드인 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>가 있으며, 이 메서드는 <xref:System.Xml.XmlDictionaryWriter>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="fb816-150"><xref:System.ServiceModel.Channels.Message> 클래스의 각 서브클래스는 이 메서드를 재정의하고, 해당 콘텐츠를 작성하는 기능을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="fb816-151">메시지 본문은 `OnWriteBodyContent` 를 생성하는 XML Infoset을 논리적으로 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="fb816-152">다음 `Message` 서브클래스 예제를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="fb816-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="fb816-153">물리적으로 `AirfareRequestMessage` 인스턴스에는 두 개의 문자열("fromCity" 및 "toCity")만 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="fb816-154">그러나 논리적으로는 이 메시지에 다음 XML infoset이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="fb816-155">물론, 서비스 프레임워크를 사용하여 작업 계약 매개 변수로부터 이전과 같은 메시지를 만들 수 있기 때문에 일반적으로는 이 방식으로 메시지를 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="fb816-156">또한 <xref:System.ServiceModel.Channels.Message> 클래스에는 일반 콘텐츠 형식을 가진 메시지를 만드는 데 사용할 수 있는 정적 `CreateMessage` 메서드가 있습니다. 이러한 일반 콘텐츠 형식에는 빈 메시지, <xref:System.Runtime.Serialization.DataContractSerializer>와 함께 XML로 serialize된 개체가 포함된 메시지, SOAP 오류가 포함된 메시지, <xref:System.Xml.XmlReader>로 표시되는 XML이 포함된 메시지 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="fb816-157">메시지 본문에서 데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="fb816-157">Getting Data from a Message Body</span></span>  

 <span data-ttu-id="fb816-158">메시지 본문에 저장된 데이터를 추출하는 방법으로는 다음 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="fb816-159"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 메서드를 호출하고 XML 작성기에서 전달하면 한 번에 메시지 본문 전체를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="fb816-160">전체 메시지 본문이 이 작성기에 작성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="fb816-161">전체 메시지 본문을 한 번에 가져오는 것을 *메시지 쓰기* 라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="fb816-162">쓰기는 주로 메시지를 보낼 때 채널 스택에서 수행합니다. 채널 스택의 일부는 일반적으로 전체 메시지 본문에 대한 액세스 권한, 인코딩 권한, 전송 권한을 가집니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="fb816-163">메시지 본문에서 정보를 가져오는 또 다른 방법은 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> 를 호출하고 XML 판독기를 가져오는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="fb816-164">그런 다음 필요에 따라 판독기에서 메서드를 호출하여 메시지 본문에 순차적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="fb816-165">메시지 본문을 하나씩 가져오는 것을 *메시지 읽기* 라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="fb816-166">메시지 읽기는 주로 메시지를 받을 때 서비스 프레임워크에서 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="fb816-167">예를 들어 <xref:System.Runtime.Serialization.DataContractSerializer> 를 사용 중일 때 서비스 프레임워크는 본문에 대해 XML 판독기를 가져오고 이를 deserialization 엔진에 전달합니다. 그러면 이 엔진은 메시지를 요소별로 읽기 시작하고 해당 개체 그래프를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="fb816-168">메시지 본문은 한 번만 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="fb816-169">이를 통해 정방향 스트림을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="fb816-170">예를 들어 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 으로부터 읽은 <xref:System.IO.FileStream> 재정의를 쓰고, 결과를 XML Infoset으로 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="fb816-171">파일의 시작 부분으로 "되감기" 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="fb816-172">`WriteBodyContents` 및 `GetReaderAtBodyContents` 메서드는 해당 메시지 본문이 전에 검색된 적이 없는지 확인한 다음 `OnWriteBodyContents` 또는 `OnGetReaderAtBodyContents`를 각각 호출하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="fb816-173">WCF의 메시지 사용</span><span class="sxs-lookup"><span data-stu-id="fb816-173">Message Usage in WCF</span></span>  

 <span data-ttu-id="fb816-174">대부분의 메시지는 *보내는* 메시지(채널 스택에서 보낼 서비스 프레임워크에서 만드는 메시지) 또는 *들어오는* 메시지(채널 스택에서 전송되어 서비스 프레임워크에서 해석되는 메시지) 중 하나로 분류될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="fb816-175">또한 채널 스택은 버퍼링 모드 또는 스트리밍 모드로 작동할 수 있으며</span><span class="sxs-lookup"><span data-stu-id="fb816-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="fb816-176">서비스 프레임워크는 스트리밍 또는 비스트리밍 프로그래밍 모델을 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="fb816-177">다음 표는 이러한 조합에 따라 발생 가능한 경우를 간략한 구현 정보와 함께 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="fb816-178">메시지 유형</span><span class="sxs-lookup"><span data-stu-id="fb816-178">Message type</span></span>|<span data-ttu-id="fb816-179">메시지의 본문 데이터</span><span class="sxs-lookup"><span data-stu-id="fb816-179">Body data in message</span></span>|<span data-ttu-id="fb816-180">쓰기(OnWriteBodyContents) 구현</span><span class="sxs-lookup"><span data-stu-id="fb816-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="fb816-181">읽기(OnGetReaderAtBodyContents) 구현</span><span class="sxs-lookup"><span data-stu-id="fb816-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="fb816-182">비스트리밍 프로그래밍 모델에서 만들어진 나가는 메시지</span><span class="sxs-lookup"><span data-stu-id="fb816-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="fb816-183">메시지 작성에 필요한 데이터(예: serialize하는 데 필요한 개체 및 <xref:System.Runtime.Serialization.DataContractSerializer> 인스턴스)\*</span><span class="sxs-lookup"><span data-stu-id="fb816-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="fb816-184">저장된 데이터를 기반으로 메시지를 작성하는 사용자 지정 논리(예: `WriteObject` 의 `DataContractSerializer` 호출. 단 이 serializer를 사용 중인 경우)\*</span><span class="sxs-lookup"><span data-stu-id="fb816-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="fb816-185">`OnWriteBodyContents`를 호출하고, 결과를 버퍼링하고, 버퍼를 통해 XML 판독기를 반환</span><span class="sxs-lookup"><span data-stu-id="fb816-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="fb816-186">스트리밍된 프로그래밍 모델에서 만들어진 나가는 메시지</span><span class="sxs-lookup"><span data-stu-id="fb816-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="fb816-187">작성할 데이터가 포함된 `Stream` \*</span><span class="sxs-lookup"><span data-stu-id="fb816-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="fb816-188"><xref:System.Xml.IStreamProvider> 메커니즘을 사용하여 저장된 스트림에서 가져온 데이터 작성\*</span><span class="sxs-lookup"><span data-stu-id="fb816-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="fb816-189">`OnWriteBodyContents`를 호출하고, 결과를 버퍼링하고, 버퍼를 통해 XML 판독기를 반환</span><span class="sxs-lookup"><span data-stu-id="fb816-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="fb816-190">스트리밍 채널 스택에서 들어오는 메시지</span><span class="sxs-lookup"><span data-stu-id="fb816-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="fb816-191">네트워크를 통해 `Stream` 와 함께 들어오는 데이터를 나타내는 <xref:System.Xml.XmlReader> 개체</span><span class="sxs-lookup"><span data-stu-id="fb816-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="fb816-192">`XmlReader` 를 사용하여 저장된 `WriteNode`로부터 콘텐츠 작성</span><span class="sxs-lookup"><span data-stu-id="fb816-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="fb816-193">저장된 `XmlReader`반환</span><span class="sxs-lookup"><span data-stu-id="fb816-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="fb816-194">스트리밍되지 않은 채널 스택에서 들어오는 메시지</span><span class="sxs-lookup"><span data-stu-id="fb816-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="fb816-195">`XmlReader` 와 함께 본문 데이터가 포함된 버퍼</span><span class="sxs-lookup"><span data-stu-id="fb816-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="fb816-196">`XmlReader` 를 사용하여 저장된 `WriteNode`로부터 콘텐츠를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="fb816-197">저장된 lang 반환</span><span class="sxs-lookup"><span data-stu-id="fb816-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="fb816-198">\* 이러한 항목은 클래스의 서브 클래스에서 직접 구현 되지 않습니다 `Message` <xref:System.ServiceModel.Channels.BodyWriter> .</span><span class="sxs-lookup"><span data-stu-id="fb816-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="fb816-199">에 대 한 자세한 내용은 <xref:System.ServiceModel.Channels.BodyWriter> [메시지 클래스 사용](using-the-message-class.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fb816-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="fb816-200">메시지 헤더</span><span class="sxs-lookup"><span data-stu-id="fb816-200">Message Headers</span></span>  

 <span data-ttu-id="fb816-201">메시지에는 헤더가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-201">A message may contain headers.</span></span> <span data-ttu-id="fb816-202">헤더는 논리적으로 이름, 네임스페이스 및 다른 속성과 연관된 XML Infoset으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="fb816-203">`Headers` 의 <xref:System.ServiceModel.Channels.Message>속성을 사용하여 메시지 헤더에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="fb816-204">각 헤더는 <xref:System.ServiceModel.Channels.MessageHeader> 클래스로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="fb816-205">일반적으로 메시지 헤더는 SOAP 메시지를 사용하기 위해 구성된 채널 스택을 사용할 때 SOAP 메시지 헤더로 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="fb816-206">메시지 헤더로 정보를 가져오고, 메시지 헤더에서 정보를 추출하는 것은 메시지 본문을 사용하는 것과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="fb816-207">스트리밍이 지원되지 않으므로 프로세스가 다소 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="fb816-208">동일한 헤더의 콘텐츠에 두 번 이상 액세스할 수 있으며, 헤더가 항상 버퍼링되도록 하여 임의의 순서로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="fb816-209">헤더를 통해 XML 판독기를 가져오는 데 사용할 수 있는 범용 메커니즘이 없지만 `MessageHeader` 이러한 기능을 사용 하 여 읽을 수 있는 헤더를 나타내는 WCF 내부 하위 클래스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="fb816-210">이 `MessageHeader` 형식은 사용자 지정 애플리케이션 헤더가 포함된 메시지가 들어올 경우 채널 스택에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="fb816-211">그러면 서비스 프레임워크에서 <xref:System.Runtime.Serialization.DataContractSerializer>와 같은 deserialization 엔진을 사용하여 이러한 헤더를 해석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="fb816-212">자세한 내용은 [메시지 클래스 사용](using-the-message-class.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fb816-212">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="fb816-213">메시지 속성</span><span class="sxs-lookup"><span data-stu-id="fb816-213">Message Properties</span></span>  

 <span data-ttu-id="fb816-214">메시지에는 속성이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-214">A message may contain properties.</span></span> <span data-ttu-id="fb816-215">*속성* 은 문자열 이름과 연결 된 .NET Framework 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="fb816-216">`Properties` 의 `Message`속성을 통해 속성에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="fb816-217">일반적으로 각각 SOAP 본문과 SOAP 헤더로 매핑되는 메시지 본문과 메시지 헤더와는 달리, 메시지 속성은 일반적으로 메시지와 함께 보내거나 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="fb816-218">메시지 속성은 주로 채널 스택의 다양한 채널 간이나 채널 스택과 서비스 모델 간에 메시지에 대한 데이터를 전달하기 위한 통신 메커니즘으로 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="fb816-219">예를 들어 WCF의 일부로 포함 된 HTTP 전송 채널은 클라이언트에 응답을 보낼 때 "404 (찾을 수 없음)" 및 "500 (내부 서버 오류)"와 같은 다양 한 HTTP 상태 코드를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="fb816-220">회신 메시지를 보내기 전에는의에 `Properties` `Message` 형식의 개체가 포함 된 "httpresponse.cache" 라는 속성이 포함 되어 있는지 확인 합니다 <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> .</span><span class="sxs-lookup"><span data-stu-id="fb816-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="fb816-221">이러한 속성이 있으면 <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> 속성을 살펴보고 해당 상태 코드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="fb816-222">이러한 속성이 없으면 기본 "200(확인)" 코드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="fb816-223">자세한 내용은 [메시지 클래스 사용](using-the-message-class.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fb816-223">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="fb816-224">메시지 전체</span><span class="sxs-lookup"><span data-stu-id="fb816-224">The Message as a Whole</span></span>  

 <span data-ttu-id="fb816-225">지금까지 메시지의 여러 부분에 각각 액세스하는 데 사용되는 메서드를 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="fb816-226">그러나 <xref:System.ServiceModel.Channels.Message> 클래스는 메시지 전체를 대상으로 작동하는 메서드도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="fb816-227">예를 들어 `WriteMessage` 메서드는 XML 작성기에 전체 메시지를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="fb816-228">이렇게 하려면 전체 `Message` 인스턴스와 하나의 XML Infoset 간에 매핑이 정의되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="fb816-229">이러한 매핑은 실제로 존재 합니다. WCF는 SOAP 표준을 사용 하 여이 매핑을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="fb816-230">`Message` 인스턴스를 XML Infoset으로 작성할 때, 결과 Infoset은 해당 메시지가 포함된 유효한 SOAP 봉투입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="fb816-231">따라서 `WriteMessage` 는 일반적으로 다음 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="fb816-232">SOAP 봉투 요소 열기 태그를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="fb816-233">SOAP 헤더 요소 열기 태그를 쓰고, 모든 헤더를 작성하고, 헤더 요소를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="fb816-234">SOAP 본문 요소 열기 태그를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="fb816-235">`WriteBodyContents` 또는 동등한 메서드를 호출하여 본문을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="fb816-236">본문 및 봉투 요소를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="fb816-237">이전 단계는 SOAP 표준과 밀접하게 연관되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="fb816-238">여러 버전의 SOAP가 존재하기 때문에 발생하는 문제가 있습니다. 예를 들어 사용 중인 SOAP 버전을 모르면 SOAP 봉투 요소를 올바르게 작성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="fb816-239">또한 복잡한 SOAP별 매핑을 완전히 해제하는 것이 좋은 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="fb816-240">이러한 목적을 위해 `Version` 속성이 `Message`에서 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="fb816-241">이 속성은 메시지를 작성할 때 사용할 SOAP 버전으로 설정하거나, SOAP별 매핑을 방지하도록 `None` 으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="fb816-242">`Version` 속성이 `None`으로 설정되면 전체 메시지를 대상으로 작동하는 메서드는 메시지가 본문으로만 구성되어 있는 것처럼 작동합니다. 예를 들어 `WriteMessage` 는 앞에서 설명한 여러 단계를 수행하는 대신 `WriteBodyContents` 만 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="fb816-243">들어오는 메시지에서 `Version` 이 자동으로 감지되고 올바르게 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="fb816-244">채널 스택</span><span class="sxs-lookup"><span data-stu-id="fb816-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="fb816-245">채널</span><span class="sxs-lookup"><span data-stu-id="fb816-245">Channels</span></span>  

 <span data-ttu-id="fb816-246">앞서 언급한 대로 채널 스택은 나가는 <xref:System.ServiceModel.Channels.Message> 인스턴스를 일부 동작(예: 네트워크를 통한 패킷 전송)으로 변환하거나 일부 동작(예: 네트워크 패킷 수신)을 들어오는 `Message` 인스턴스로 변환하는 역할을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="fb816-247">채널 스택은 시퀀스의 순서로 하나 이상의 채널로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="fb816-248">나가는 `Message` 인스턴스는 스택의 첫 번째 채널( *맨 위 채널* 이라고도 함)로 전달되며, 이 채널은 해당 인스턴스를 스택의 다음 아래 채널로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="fb816-249">메시지는 *전송 채널* 이라고도 하는 마지막 채널에서 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="fb816-250">들어오는 메시지는 전송 채널에서 시작되며, 스택의 아래 채널에서 위 채널로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="fb816-251">메시지는 보통 맨 위 채널에서부터 서비스 프레임워크로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="fb816-252">이는 애플리케이션 메시지의 일반적인 패턴이지만 일부 채널은 조금 다르게 작동할 수 있습니다. 예를 들어 위의 채널로부터 전달되는 메시지 없이 자체 인프라 메시지를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="fb816-253">채널은 스택을 통과하므로 여러 방법으로 메시지에서 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="fb816-254">가장 일반적인 작업은 나가는 메시지에 헤더를 추가하고, 들어오는 메시지의 헤더를 읽는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="fb816-255">예를 들어 채널은 메시지의 디지털 서명을 컴퓨팅하고 이를 헤더로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="fb816-256">또한 채널은 들어오는 메시지에서 이 디지털 서명 헤더를 검사하고, 유효한 서명이 없는 메시지가 채널 스택에서 자체 방식을 만들지 못하도록 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="fb816-257">채널은 종종 메시지 속성을 설정하거나 검사하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="fb816-258">메시지 본문은 일반적으로 수정 되지 않지만, 예를 들어 WCF 보안 채널이 메시지 본문을 암호화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="fb816-259">전송 채널 및 메시지 인코더</span><span class="sxs-lookup"><span data-stu-id="fb816-259">Transport Channels and Message Encoders</span></span>  

 <span data-ttu-id="fb816-260">스택의 가장 아래쪽에 있는 채널은 나가는 <xref:System.ServiceModel.Channels.Message>를 다른 채널에서 수정된 대로 일부 동작으로 실제로 변환하는 기능을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="fb816-261">받는 쪽에서 이 채널은 다른 채널이 처리하는 `Message` 로 일부 동작을 변환하는 채널입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="fb816-262">앞에서 설명한 대로 일부 예제만 제공하기 위해서도 다양한 동작이 있을 수 있습니다. 이러한 동작으로는 다양한 프로토콜을 통한 네트워크 패킷 주고받기, 데이터베이스의 메시지 읽기 또는 쓰기, 메시지 큐에서 메시지 대기시키기 또는 제거하기 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="fb816-263">이러한 모든 작업은 일반적으로 다음과 같은 작업을 수행 합니다. 즉, WCF `Message` 인스턴스와 송신, 수신, 읽기, 쓰기, 큐에 대기 또는 큐에서 제거 될 수 있는 실제 바이트 그룹 간의 변환이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="fb816-264">`Message` 를 바이트 그룹으로 변환하는 프로세스를 *인코딩* 이라 하며, 바이트 그룹으로부터 `Message` 를 만드는 역 프로세스를 *디코딩* 이라 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="fb816-265">대부분의 전송 채널은 *메시지 인코더* 라는 구성 요소를 사용하여 인코딩 및 디코딩 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="fb816-266">메시지 인코더는 <xref:System.ServiceModel.Channels.MessageEncoder> 클래스의 서브클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="fb816-267">`MessageEncoder` 는 다양한 `ReadMessage` 및 `WriteMessage` 메서드 오버로드를 포함하여 `Message` 와 바이트 그룹 사이에서 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="fb816-268">보내는 쪽에서는 버퍼링 전송 채널이 상위 채널로부터 `Message` 개체를 받아서 `WriteMessage`로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="fb816-269">버퍼링 전송 채널은 바이트 배열을 다시 가져온 다음 이를 사용하여 해당 동작(예: 이러한 바이트를 유효한 TCP 패킷으로 패키지화하고 올바른 대상으로 이를 보냄)을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="fb816-270">스트리밍 전송 채널은 먼저 `Stream` 을 만든 다음(예: 나가는 TCP 연결을 통해), 메시지를 작성하는 적합한 `Stream` 오버로드로 보내기 위해 필요한 `Message` 과 `WriteMessage` 를 모두 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="fb816-271">받는 쪽에서는 버퍼링 전송 채널이 (들어오는 TCP 패킷 등으로부터) 들어오는 바이트를 배열로 추출하고, `ReadMessage` 를 호출하여 채널 스택 위쪽으로 전달할 수 있는 `Message` 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="fb816-272">스트리밍 전송 채널은 `Stream` 개체(예: 들어오는 TCP 연결을 통한 네트워크 스트림)를 만들고 이를 `ReadMessage` 로 전달하여 `Message` 개체를 다시 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="fb816-273">전송 채널과 메시지 인코더를 반드시 분리해야 하는 것은 아니지만 메시지 인코더를 사용하지 않는 전송 채널을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="fb816-274">단, 분리를 하게 되면 컴퍼지션이 쉽다는 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="fb816-275">전송 채널이 기본만 사용 하는 한 <xref:System.ServiceModel.Channels.MessageEncoder> , 모든 WCF 또는 타사 메시지 인코더를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="fb816-276">마찬가지로, 일반적으로 모든 전송 채널에서 동일한 인코더를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="fb816-277">메시지 인코더 작업</span><span class="sxs-lookup"><span data-stu-id="fb816-277">Message Encoder Operation</span></span>  

 <span data-ttu-id="fb816-278">인코더의 일반적인 작업을 설명하려면 다음 네 가지 경우를 고려하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="fb816-279">연산</span><span class="sxs-lookup"><span data-stu-id="fb816-279">Operation</span></span>|<span data-ttu-id="fb816-280">의견</span><span class="sxs-lookup"><span data-stu-id="fb816-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="fb816-281">인코딩, 버퍼링</span><span class="sxs-lookup"><span data-stu-id="fb816-281">Encoding, Buffered</span></span>|<span data-ttu-id="fb816-282">버퍼링 모드에서는 인코더가 보통 다양한 크기의 버퍼를 만든 다음 이를 통해 XML 작성기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="fb816-283">그런 다음 인코딩되는 메시지에서 <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> 를 호출합니다. 이 메시지는 이 항목의 <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>에 대한 이전 단원에서 설명한 것처럼 `Message` 를 사용하여 헤더와 본문을 차례로 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="fb816-284">그런 다음 사용할 전송 채널에 대해 바이트 배열로 표시되는 버퍼의 콘텐츠가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="fb816-285">인코딩, 스트리밍</span><span class="sxs-lookup"><span data-stu-id="fb816-285">Encoding, Streamed</span></span>|<span data-ttu-id="fb816-286">스트리밍 모드에서는 작업이 위의 모드와 비슷하지만 좀 더 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="fb816-287">버퍼링할 필요가 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-287">There is no need for a buffer.</span></span> <span data-ttu-id="fb816-288">XML 작성기는 일반적으로 스트림을 통해 만들어지며, <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> 에서 `Message` 가 호출되어 이 작성기에 이를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="fb816-289">디코딩, 버퍼링</span><span class="sxs-lookup"><span data-stu-id="fb816-289">Decoding, Buffered</span></span>|<span data-ttu-id="fb816-290">버퍼링 모드에서 디코딩할 때는 버퍼링된 데이터가 포함된 특별한 `Message` 서브클래스가 일반적으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="fb816-291">메시지의 헤더가 읽히고, 메시지 본문에 배치된 XML 판독기가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="fb816-292">이는 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>와 함께 반환될 판독기입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="fb816-293">디코딩, 스트리밍</span><span class="sxs-lookup"><span data-stu-id="fb816-293">Decoding, Streamed</span></span>|<span data-ttu-id="fb816-294">스트리밍 모드에서 디코딩할 때는 특별한 메시지 서브클래스가 일반적으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="fb816-295">스트림은 모든 헤더를 읽고 이를 메시지 본문에 배치할 수 있는 고급 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="fb816-296">그런 다음 XML 판독기가 스트림을 통해 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="fb816-297">이는 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>와 함께 반환될 판독기입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="fb816-298">인코더는 다른 기능도 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="fb816-299">예를 들어 인코더는 XML 판독기 및 작성기를 풀링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="fb816-300">필요할 때마다 새 XML 판독기나 작성기를 만들려면 비용이 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="fb816-301">그러므로 일반적으로 인코더는 구성 가능한 크기의 작성기 풀과 판독기 풀을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="fb816-302">앞에서 설명한 인코더 작업에 대 한 설명에서 "XML 판독기/작성기 만들기" 구문이 사용 될 때마다 일반적으로 "풀에서 하나를 사용 하거나, 사용할 수 없는 경우 하나를 만듭니다."를 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="fb816-303">인코더(및 디코딩하는 동안 인코더가 만드는 `Message` 서브클래스)는 작성기와 반환기가 더 이상 필요하지 않을 때(예: `Message` 가 닫힐 때) 이들을 풀로 반환하는 논리를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="fb816-304">WCF는 추가 사용자 지정 형식을 만들 수 있지만 세 가지 메시지 인코더를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="fb816-305">제공되는 형식에는 텍스트, 이진 및 MTOM(Message Transmission Optimization Mechanism)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="fb816-306">자세한 내용은 [Choosing a Message Encoder](choosing-a-message-encoder.md)에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-306">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="fb816-307">IStreamProvider 인터페이스</span><span class="sxs-lookup"><span data-stu-id="fb816-307">The IStreamProvider Interface</span></span>  

 <span data-ttu-id="fb816-308">스트리밍된 본문을 포함하고 있는 보내는 메시지를 XML 작성기에 쓸 때 <xref:System.ServiceModel.Channels.Message> 는 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 구현에서 다음과 유사한 호출의 시퀀스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="fb816-309">스트림 앞에 필요한 정보를 씁니다(예: 여는 XML 태그).</span><span class="sxs-lookup"><span data-stu-id="fb816-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="fb816-310">스트림을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-310">Write the stream.</span></span>  
  
- <span data-ttu-id="fb816-311">스트림 뒤에 필요한 정보를 씁니다(예: 닫는 XML 태그).</span><span class="sxs-lookup"><span data-stu-id="fb816-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="fb816-312">이는 텍스트 XML 인코딩과 유사한 인코딩을 사용하여 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="fb816-313">그러나 일부 인코딩은 XML infoset 정보(예: XML 요소의 시작 및 끝 태그)를 요소 내에 포함된 데이터와 함께 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="fb816-314">예를 들어 MTOM 인코딩에서 메시지는 여러 부분으로 나누어집니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="fb816-315">하나의 부분에는 실제 요소 콘텐츠의 다른 부분에 대한 참조가 포함될 수 있는 XML infoset이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="fb816-316">XML Infoset이 일반적으로 스트리밍된 콘텐츠와 비교하여 작으므로 Infoset을 버퍼링하고 쓴 다음 스트리밍된 방법으로 콘텐츠를 쓰는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="fb816-317">즉, 이는 닫는 요소 태그가 작성될 때까지는 스트림을 쓰면 안 된다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="fb816-318">이를 위해 <xref:System.Xml.IStreamProvider> 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="fb816-319">인터페이스에는 작성할 스트림을 반환하는 <xref:System.Xml.IStreamProvider.GetStream> 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="fb816-320"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 에서 스트리밍된 메시지 본문을 쓰는 올바른 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="fb816-321">스트림 앞에 필요한 정보를 씁니다(예: 여는 XML 태그).</span><span class="sxs-lookup"><span data-stu-id="fb816-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="fb816-322">쓸 스트림을 반환하는 `WriteValue` 구현과 함께 <xref:System.Xml.XmlDictionaryWriter> 를 사용하는 <xref:System.Xml.IStreamProvider>에서 `IStreamProvider` 오버로드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="fb816-323">스트림 뒤에 필요한 정보를 씁니다(예: 닫는 XML 태그).</span><span class="sxs-lookup"><span data-stu-id="fb816-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="fb816-324">이 방법을 사용하면 <xref:System.Xml.IStreamProvider.GetStream> 을 호출하고 스트리밍된 데이터를 작성할 때 XML 작성기를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="fb816-325">예를 들어 텍스트 및 이진 XML 작성기는 이를 즉각 호출하고 시작 및 끝 태그 사이에서 스트리밍된 콘텐츠를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="fb816-326">MTOM 작성기는 메시지의 적절한 일부를 쓸 준비가 되면 나중에 <xref:System.Xml.IStreamProvider.GetStream> 을 호출할지 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="fb816-327">서비스 프레임워크에서 데이터 표시</span><span class="sxs-lookup"><span data-stu-id="fb816-327">Representing Data in the Service Framework</span></span>  

 <span data-ttu-id="fb816-328">이 항목의 "기본 아키텍처" 단원에 설명 된 것 처럼 서비스 프레임 워크는 메시지 데이터와 실제 인스턴스의 사용자에 게 친숙 한 프로그래밍 모델 간에 변환 하는 작업을 담당 하는 WCF의 일부입니다 `Message` .</span><span class="sxs-lookup"><span data-stu-id="fb816-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="fb816-329">일반적으로 메시지 교환은 서비스 프레임 워크에서 특성으로 표시 된 .NET Framework 메서드로 표시 됩니다 <xref:System.ServiceModel.OperationContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="fb816-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="fb816-330">메서드는 일부 매개 변수에서 사용할 수 있으며, 반환 값 또는 out 매개 변수(또는 둘 다)를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="fb816-331">서비스 쪽에서는 입력 매개 변수가 들어오는 메시지를 나타내며, 반환 값 및 out 매개 변수는 나가는 메시지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="fb816-332">클라이언트 쪽에서는 그 반대입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="fb816-333">매개 변수 및 해당 반환 값을 사용하여 메시지를 설명하는 프로그래밍 모델은 [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md)에서 자세하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="fb816-334">이 단원에서는 간략한 개요만 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="fb816-335">프로그래밍 모델</span><span class="sxs-lookup"><span data-stu-id="fb816-335">Programming Models</span></span>  

 <span data-ttu-id="fb816-336">WCF 서비스 프레임 워크는 메시지를 설명 하는 다섯 가지 프로그래밍 모델을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="fb816-337">1. 빈 메시지</span><span class="sxs-lookup"><span data-stu-id="fb816-337">1. The Empty Message</span></span>  

 <span data-ttu-id="fb816-338">이는 가장 간단한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-338">This is the simplest case.</span></span> <span data-ttu-id="fb816-339">들어오는 빈 메시지를 설명하기 위해 입력 매개 변수를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="fb816-340">나가는 빈 메시지를 설명하기 위해 void 반환 값을 사용하고 out 매개 변수를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="fb816-341">이는 단방향 작업 계약과는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="fb816-342">`SetDesiredTemperature` 예제에서는 양방향 메시지 교환 패턴을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="fb816-343">작업에서 메시지가 반환되지만 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="fb816-344">작업에서 오류를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="fb816-345">"Lightbulb 설정" 예제에서 메시지 교환 패턴은 단방향이므로 설명을 위해 나가는 메시지가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="fb816-346">이 경우 서비스는 클라이언트로 반환되는 모든 상태를 통신할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="fb816-347">2. Message 클래스 직접 사용</span><span class="sxs-lookup"><span data-stu-id="fb816-347">2. Using the Message Class Directly</span></span>  

 <span data-ttu-id="fb816-348">작업 계약에서 직접 <xref:System.ServiceModel.Channels.Message> 클래스(또는 해당 서브클래스 중 하나)를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="fb816-349">이 경우에는 서비스 프레임워크가 추가 처리 없이 작업에서 채널 스택으로, 또는 그 반대로 `Message` 를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="fb816-350">`Message` 를 직접 사용하는 두 가지 주요 사례가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="fb816-351">사용자의 메시지를 설명하기에 충분한 유연성을 제공하는 다른 프로그래밍 모델이 없을 때 이를 고급 시나리오에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="fb816-352">예를 들어 메시지 헤더가 될 파일의 속성과 메시지 본문이 될 파일의 내용으로 메시지를 설명하기 위해 디스크의 파일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="fb816-353">그런 다음, 다음과 유사한 항목을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="fb816-354">작업 계약에서 `Message` 의 두 번째 일반적인 용도는 서비스가 특정 메시지 콘텐츠에 대해 고려하지 않고 메시지에서 검정 상자의 역할을 수행하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="fb816-355">예를 들어 메시지를 다른 여러 받는 사람에게 전달하는 서비스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="fb816-356">계약은 다음과 같이 작성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="fb816-357">Action = "\*" 줄은 메시지 디스패치를 효과적으로 해제 하 고 계약에 전송 된 모든 메시지가 `IForwardingService` 작업에 적용 되도록 합니다 `ForwardMessage` .</span><span class="sxs-lookup"><span data-stu-id="fb816-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="fb816-358">(일반적으로 디스패처는 메시지의 "Action" 헤더를 검사 하 여 의도 한 작업을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="fb816-359">Action = " \* "은 "동작 헤더의 모든 가능한 값"을 의미 합니다. Action = " \* "과 (와) 메시지를 매개 변수로 사용 하는 조합은 가능한 모든 메시지를 받을 수 있기 때문에 "유니버설 계약" 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="fb816-360">가능한 모든 메시지를 보내려면 메시지를 반환 값으로 사용 하 고 `ReplyAction` 를 ""로 설정 \* 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="fb816-361">이렇게 하면 사용자가 반환하는 `Message` 개체를 사용하여 이 헤더를 제어할 수 있으므로 서비스 프레임워크가 자체 Action 헤더에 추가되지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="fb816-362">3. 메시지 계약</span><span class="sxs-lookup"><span data-stu-id="fb816-362">3. Message Contracts</span></span>  

 <span data-ttu-id="fb816-363">WCF는 *메시지 계약* 이라는 메시지를 설명 하는 선언적 프로그래밍 모델을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="fb816-364">이 모델은 [Using Message Contracts](using-message-contracts.md)에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-364">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="fb816-365">기본적으로 전체 메시지는 및와 같은 특성을 사용 하는 단일 .NET Framework 형식으로 표시 되며 메시지 <xref:System.ServiceModel.MessageBodyMemberAttribute> <xref:System.ServiceModel.MessageHeaderAttribute> 계약 클래스의 어떤 부분이 메시지의 어떤 부분에 매핑되는지 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="fb816-366">`Message` 클래스를 직접 사용하는 것만큼 많은 제어를 할 수는 없지만, 메시지 계약을 사용하여 결과 `Message` 인스턴스에 대해 여러 가지 제어를 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="fb816-367">예를 들어 메시지 본문은 종종 여러 가지 정보로 구성되며, 이러한 정보는 각각 자체 XML 요소로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="fb816-368">이러한 요소는 본문에서 직접 발생할 수도 있고(*bare* 모드), 포함된 XML 요소에서 *wrapped* 가 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="fb816-369">메시지 계약 프로그래밍 모델을 사용하면 bare-wrapped 모드를 결정하고 래퍼 이름과 네임스페이스를 제어할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="fb816-370">메시지 계약의 다음 코드 예제에서는 이러한 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="fb816-371"><xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>또는 기타 관련 특성과 함께 serialize하도록 표시된 항목이 serialize 가능해야 메시지 계약에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="fb816-372">자세한 내용은이 항목의 뒷부분에 나오는 "Serialization" 단원을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="fb816-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="fb816-373">4. 매개 변수</span><span class="sxs-lookup"><span data-stu-id="fb816-373">4. Parameters</span></span>  

 <span data-ttu-id="fb816-374">여러 데이터에 대해 작동하는 작업을 설명하려는 개발자는 종종 메시지 계약이 제공하는 일정 정도의 제어를 필요로 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="fb816-375">예를 들어 새 서비스를 만들 때 사용자는 보통 bare-wrapped 모드나 래퍼 요소 이름을 결정하지 않으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="fb816-376">이러한 결정을 내리려면 웹 서비스와 SOAP에 대해 잘 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="fb816-377">WCF 서비스 프레임 워크는 사용자에 게 이러한 선택 항목을 적용 하지 않고도 관련 된 여러 가지 정보를 보내거나 받기 위한 가장 효율적이 고, 상호 운용 가능한 SOAP 표현을 자동으로 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="fb816-378">이러한 여러 가지 정보를 작업 계약의 매개 변수 또는 반환 값으로 설명하기만 해도 이를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="fb816-379">예를 들어 다음 작업 계약을 확인해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="fb816-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="fb816-380">서비스 프레임워크는`customerID`, `item`, `quantity`라는 세 가지의 정보를 모두 메시지 본문에 삽입하고, `SubmitOrderRequest`라는 래퍼 요소에서 이들을 래핑하도록 자동으로 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="fb816-381">보다 복잡한 메시지 계약 또는 `Message`기반 프로그래밍 모델로 이동해야 하는 특별한 이유가 없다면 작업 계약 매개 변수의 간단한 목록으로 보내거나 받을 정보를 설명하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="fb816-382">5. 스트림</span><span class="sxs-lookup"><span data-stu-id="fb816-382">5. Stream</span></span>  

 <span data-ttu-id="fb816-383">메시지 계약의 단독 메시지 본문 부분으로 또는 작업 계약에서 `Stream` (또는 해당 서브클래스 중 하나)을 사용하는 것은 위에서 설명한 항목과 별도의 프로그래밍 모델로 고려될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="fb816-384">이 방법으로 `Stream` 을 사용하면 사용자의 자체 스트리밍 호환 가능 `Message` 서브클래스를 간결하게 작성할 수 있으므로, 사용자의 계약을 스트리밍 방식으로 유일하게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="fb816-385">자세한 내용은 [대량 데이터 및 스트리밍](large-data-and-streaming.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fb816-385">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="fb816-386">`Stream` 또는 해당 서브클래스 중 하나를 이 방법으로 사용할 때는 serializer가 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="fb816-387">나가는 메시지의 경우 특별한 스트리밍 `Message` 서브클래스가 만들어지고, <xref:System.Xml.IStreamProvider> 인터페이스의 단원에서 설명한 대로 스트림이 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="fb816-388">들어오는 메시지의 경우 서비스 프레임워크가 들어오는 메시지에 대해 `Stream` 서브클래스를 만들고 이를 해당 작업에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="fb816-389">프로그래밍 모델 제한 사항</span><span class="sxs-lookup"><span data-stu-id="fb816-389">Programming Model Restrictions</span></span>  

 <span data-ttu-id="fb816-390">위에서 설명한 프로그래밍 모델은 임의로 조합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="fb816-391">예를 들어 작업이 메시지 계약 형식을 수락할 경우 해당 메시지 계약이 유일한 입력 매개 변수가 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="fb816-392">뿐만 아니라 해당 작업은 빈 메시지(void의 반환 형식) 또는 기타 메시지 계약을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="fb816-393">이 항목에서는 이러한 프로그래밍 모델 제한에 대해 [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md)및 [Large Data and Streaming](large-data-and-streaming.md)이라는 각 특정 프로그래밍 모델을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="fb816-394">메시지 포맷터</span><span class="sxs-lookup"><span data-stu-id="fb816-394">Message Formatters</span></span>  

 <span data-ttu-id="fb816-395">위에서 설명한 프로그래밍 모델은 *메시지 포맷터* 라는 구성 요소를 서비스 프레임워크로 플러그 인함으로써 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="fb816-396">메시지 포맷터는 <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> 클라이언트 및 서비스 WCF 클라이언트에서 각각 사용 하기 위해 또는 인터페이스, 또는 둘 다를 구현 하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="fb816-397">메시지 포맷터는 일반적으로 동작별로 플러그 인됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="fb816-398">예를 들어 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 는 데이터 계약 메시지 포맷터를 플러그 인합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="fb816-399">이는 서비스 쪽의 <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> 메서드에서 <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> 를 올바른 포맷터로 설정하거나 클라이언트 쪽의 <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> 메서드에서 <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> 를 올바른 포맷터로 설정함으로써 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="fb816-400">다음 표에서는 메시지 포맷터가 구현할 수 있는 메서드를 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="fb816-401">인터페이스</span><span class="sxs-lookup"><span data-stu-id="fb816-401">Interface</span></span>|<span data-ttu-id="fb816-402">메서드</span><span class="sxs-lookup"><span data-stu-id="fb816-402">Method</span></span>|<span data-ttu-id="fb816-403">작업</span><span class="sxs-lookup"><span data-stu-id="fb816-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="fb816-404">들어오는 `Message` 를 작업 매개 변수로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="fb816-405">작업 반환 값/출력 매개 변수로부터 나가는 `Message` 만들기</span><span class="sxs-lookup"><span data-stu-id="fb816-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="fb816-406">작업 매개 변수로부터 나가는 `Message` 만들기</span><span class="sxs-lookup"><span data-stu-id="fb816-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="fb816-407">들어오는 `Message` 를 반환 값/출력 매개 변수로 변환</span><span class="sxs-lookup"><span data-stu-id="fb816-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="fb816-408">Serialization</span><span class="sxs-lookup"><span data-stu-id="fb816-408">Serialization</span></span>  

 <span data-ttu-id="fb816-409">메시지 계약 또는 매개 변수를 사용 하 여 메시지 내용을 설명할 때마다 serialization을 사용 하 여 .NET Framework 형식과 XML Infoset 표현 간에 변환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="fb816-410">Serialization은 WCF의 다른 위치에서 사용 됩니다. 예를 들어에는 <xref:System.ServiceModel.Channels.Message> <xref:System.ServiceModel.Channels.Message.GetBody%2A> 개체로 deserialize 된 메시지의 전체 본문을 읽는 데 사용할 수 있는 제네릭 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="fb816-411">WCF는 매개 변수 및 메시지 부분을 serialize 및 deserialize 하는 데 사용할 수 있는 두 가지 serialization 기술인 <xref:System.Runtime.Serialization.DataContractSerializer> 및를 `XmlSerializer` 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="fb816-412">그뿐 아니라 사용자 지정 serializer도 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="fb816-413">그러나 WCF의 다른 부분 (예: 제네릭 `GetBody` 메서드 또는 SOAP 오류 serialization)은 서브 클래스 (및은 제외)만 사용 하도록 제한 될 수 있습니다 <xref:System.Runtime.Serialization.XmlObjectSerializer> <xref:System.Runtime.Serialization.DataContractSerializer> <xref:System.Runtime.Serialization.NetDataContractSerializer> <xref:System.Xml.Serialization.XmlSerializer> . 또는만 사용 하도록 하드 코드 될 수도 있습니다 <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="fb816-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="fb816-414">는 `XmlSerializer` ASP.NET 웹 서비스에서 사용 되는 serialization 엔진입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-414">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="fb816-415">`DataContractSerializer` 는 새 데이터 계약 프로그래밍 모델을 이해하는 새 serialization 엔진입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="fb816-416">`DataContractSerializer` 가 기본 선택되며, `XmlSerializer` 를 사용할지 여부는 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> 특성을 사용하여 작업별로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="fb816-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 및 <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> 는 `DataContractSerializer` 와 `XmlSerializer`각각에 대해 메시지 포맷터에서의 플러그 인을 담당하는 작업 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="fb816-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 동작은 실제로 <xref:System.Runtime.Serialization.XmlObjectSerializer>를 비롯하여 <xref:System.Runtime.Serialization.NetDataContractSerializer> 에서 파생되는 모든 serializer와 함께 작동할 수 있습니다. 자세한 내용은 독립 실행형 Serialization 사용에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="fb816-419">해당 동작은 `CreateSerializer` 가상 메서드 오버로드 중 하나를 호출하여 serializer를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="fb816-420">다른 serializer를 플러그 인하려면 새 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 서브클래스를 만들고, 두 `CreateSerializer` 오버로드를 모두 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="fb816-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fb816-421">참고 항목</span><span class="sxs-lookup"><span data-stu-id="fb816-421">See also</span></span>

- [<span data-ttu-id="fb816-422">서비스 계약에서 데이터 전송 지정</span><span class="sxs-lookup"><span data-stu-id="fb816-422">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
