---
description: '자세한 정보: 클라이언트를 사용 하 여 서비스 액세스'
title: 클라이언트를 사용하여 서비스 액세스
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d
ms.openlocfilehash: 112e401f96fb1bf4231fb6bef3e5a57b6f40949e
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793885"
---
# <a name="accessing-services-using-a-client"></a><span data-ttu-id="2cf6b-103">클라이언트를 사용하여 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="2cf6b-103">Accessing Services Using a Client</span></span>

<span data-ttu-id="2cf6b-104">클라이언트 응용 프로그램은 WCF 클라이언트 또는 채널 개체를 만들고 구성 하 고 사용 하 여 서비스와 통신 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-104">Client applications must create, configure, and use WCF client or channel objects to communicate with services.</span></span> <span data-ttu-id="2cf6b-105">[WCF 클라이언트 개요](../wcf-client-overview.md) 항목에서는 기본 클라이언트 및 채널 개체를 만들고 사용 하는 것과 관련 된 개체 및 단계에 대해 간략하게 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-105">The [WCF Client Overview](../wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.</span></span>  
  
 <span data-ttu-id="2cf6b-106">이 항목에서는 시나리오에 따라 유용할 수 있는 클라이언트 및 채널 개체와 클라이언트 애플리케이션과 관련된 몇 가지 문제에 대한 자세한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-106">This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.</span></span>  
  
## <a name="overview"></a><span data-ttu-id="2cf6b-107">개요</span><span class="sxs-lookup"><span data-stu-id="2cf6b-107">Overview</span></span>  

 <span data-ttu-id="2cf6b-108">이 항목에서는 다음과 관련된 동작 및 문제에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-108">This topic describes behavior and issues relating to:</span></span>  
  
- <span data-ttu-id="2cf6b-109">채널 및 세션 수명</span><span class="sxs-lookup"><span data-stu-id="2cf6b-109">Channel and session lifetimes.</span></span>  
  
- <span data-ttu-id="2cf6b-110">예외 처리</span><span class="sxs-lookup"><span data-stu-id="2cf6b-110">Handling exceptions.</span></span>  
  
- <span data-ttu-id="2cf6b-111">블로킹 문제 이해</span><span class="sxs-lookup"><span data-stu-id="2cf6b-111">Understanding blocking issues.</span></span>  
  
- <span data-ttu-id="2cf6b-112">대화형으로 채널 초기화</span><span class="sxs-lookup"><span data-stu-id="2cf6b-112">Initializing channels interactively.</span></span>  
  
### <a name="channel-and-session-lifetimes"></a><span data-ttu-id="2cf6b-113">채널 및 세션 수명</span><span class="sxs-lookup"><span data-stu-id="2cf6b-113">Channel and Session Lifetimes</span></span>  

 <span data-ttu-id="2cf6b-114">WCF (Windows Communication Foundation) 응용 프로그램에는 두 가지 범주의 채널, 데이터 그램 및 세션 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-114">Windows Communication Foundation (WCF) applications includes two categories of channels, datagram and sessionful.</span></span>  
  
 <span data-ttu-id="2cf6b-115">*데이터 그램* 채널은 모든 메시지를 상관 관계가 없는 하는 채널입니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-115">A *datagram* channel is a channel in which all messages are uncorrelated.</span></span> <span data-ttu-id="2cf6b-116">데이터그램 채널을 사용할 경우 입력 또는 출력 작업이 실패해도 일반적으로 다음 작업이 영향을 받지 않으며 동일한 채널을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-116">With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused.</span></span> <span data-ttu-id="2cf6b-117">이 때문에 데이터그램 채널은 실패하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-117">Because of this, datagram channels typically do not fault.</span></span>  
  
 <span data-ttu-id="2cf6b-118">그러나 *세션* 채널은 다른 끝점에 대 한 연결을 사용 하는 채널입니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-118">*Sessionful* channels, however, are channels with a connection to the other endpoint.</span></span> <span data-ttu-id="2cf6b-119">한쪽의 세션 메시지는 항상 다른 쪽의 동일한 세션과 상호 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-119">Messages in a session on one side are always correlated with the same session on the other side.</span></span> <span data-ttu-id="2cf6b-120">또한 한 세션이 성공한 것으로 간주되려면 해당 세션의 두 참가자가 모두 대화 요구 사항이 충족되었다고 동의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-120">In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful.</span></span> <span data-ttu-id="2cf6b-121">동의할 수 없는 경우 세션 채널이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-121">If they cannot agree, the sessionful channel may fault.</span></span>  
  
 <span data-ttu-id="2cf6b-122">첫 번째 작업을 호출하여 명시적 또는 암시적으로 클라이언트를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-122">Open clients explicitly or implicitly by calling the first operation.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2cf6b-123">알림을 받는 시기가 세션 구현에 따라 달라지므로 실패한 세션 채널을 명시적으로 검색하려는 시도는 일반적으로 유용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-123">Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation.</span></span> <span data-ttu-id="2cf6b-124">예를 들어 신뢰할 수 있는 세션을 사용하지 않는 <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType>은 TCP 연결의 세션을 표시하므로 서비스 또는 클라이언트의 <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> 이벤트를 수신 대기하면 네트워크 오류가 발생할 경우 신속하게 알림을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-124">For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure.</span></span> <span data-ttu-id="2cf6b-125">그러나 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>를 사용하는 바인딩으로 설정된 신뢰할 수 있는 세션은 소규모 네트워크 오류로부터 서비스를 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-125">But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures.</span></span> <span data-ttu-id="2cf6b-126">적절한 기간 내에 세션을 다시 설정할 수 있는 경우 보다 긴 기간 동안 중단이 계속될 때까지 신뢰할 수 있는 세션에 대해 구성된 동일한 바인딩이 실패하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-126">If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.</span></span>  
  
 <span data-ttu-id="2cf6b-127">채널을 애플리케이션 계층에 노출하는 대부분의 시스템 제공 바인딩은 기본적으로 세션을 사용하지만 <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType>은 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-127">Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not.</span></span> <span data-ttu-id="2cf6b-128">자세한 내용은 [세션 사용](../using-sessions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-128">For more information, see [Using Sessions](../using-sessions.md).</span></span>  
  
### <a name="the-proper-use-of-sessions"></a><span data-ttu-id="2cf6b-129">적절한 세션 사용</span><span class="sxs-lookup"><span data-stu-id="2cf6b-129">The Proper Use of Sessions</span></span>  

 <span data-ttu-id="2cf6b-130">세션은 전체 메시지 교환이 완료되었는지 여부 및 양쪽에서 성공했다고 간주하는지 여부를 확인하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-130">Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful.</span></span> <span data-ttu-id="2cf6b-131">호출 애플리케이션은 하나의 try 블록 내에서 채널을 열고 사용한 후 닫는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-131">It is recommended that a calling application open the channel, use it, and close the channel inside one try block.</span></span> <span data-ttu-id="2cf6b-132">세션 채널이 열려 있고 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 메서드를 한 번 호출한 후 해당 호출이 성공적으로 반환되면 세션이 성공했습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-132">If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful.</span></span> <span data-ttu-id="2cf6b-133">이 경우 성공은 바인딩에서 지정한 모든 배달 보증이 충족되었으며 다른 쪽이 <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType>를 호출하기 전에 채널에서 <xref:System.ServiceModel.ICommunicationObject.Close%2A>를 호출하지 않았음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-133">Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>.</span></span>  
  
 <span data-ttu-id="2cf6b-134">다음 섹션에서는 이 클라이언트 접근 방법의 예를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-134">The following section provides an example of this client approach.</span></span>  
  
### <a name="handling-exceptions"></a><span data-ttu-id="2cf6b-135">예외 처리</span><span class="sxs-lookup"><span data-stu-id="2cf6b-135">Handling Exceptions</span></span>  

 <span data-ttu-id="2cf6b-136">클라이언트 애플리케이션의 예외 처리는 단순합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-136">Handling exceptions in client applications is straightforward.</span></span> <span data-ttu-id="2cf6b-137">하나의 try 블록 내에서 채널을 열고 사용한 후 닫으면 예외가 throw되지 않는 한 대화가 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-137">If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown.</span></span> <span data-ttu-id="2cf6b-138">일반적으로 예외가 throw되면 대화가 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-138">Typically, if an exception is thrown the conversation is aborted.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2cf6b-139">`using`문 ( `Using` Visual Basic)은 사용 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-139">Use of the `using` statement (`Using` in Visual Basic) is not recommended.</span></span> <span data-ttu-id="2cf6b-140">이는 `using` 문의 끝에서 예외가 발생하여 사용자가 확인해야 하는 다른 예외를 마스킹할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-140">This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about.</span></span> <span data-ttu-id="2cf6b-141">자세한 내용은 [Close 및 Abort를 사용 하 여 WCF 클라이언트 리소스 해제](../samples/use-close-abort-release-wcf-client-resources.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-141">For more information, see [Use Close and Abort to release WCF client resources](../samples/use-close-abort-release-wcf-client-resources.md).</span></span>  
  
 <span data-ttu-id="2cf6b-142">다음 코드 예제에서는 `using` 문이 아니라 try/catch 블록을 사용한 권장되는 클라이언트 패턴을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-142">The following code example shows the recommended client pattern using a try/catch block and not the `using` statement.</span></span>  
  
 [!code-csharp[FaultContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="2cf6b-143"><xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> 속성 값 확인은 경합 상태이며 채널을 다시 사용할지 또는 닫을지 결정하는 데 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-143">Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.</span></span>  
  
 <span data-ttu-id="2cf6b-144">데이터그램 채널은 닫을 때 예외가 발생하는 경우에도 실패하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-144">Datagram channels never fault even if exceptions occur when they are closed.</span></span> <span data-ttu-id="2cf6b-145">또한 보안 대화를 사용하여 인증할 수 없는 비이중 클라이언트는 일반적으로 <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-145">In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2cf6b-146">그러나 보안 대화를 사용하는 이중 클라이언트가 인증할 수 없는 경우 클라이언트는 대신 <xref:System.TimeoutException?displayProperty=nameWithType>을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-146">However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead.</span></span>  
  
 <span data-ttu-id="2cf6b-147">응용 프로그램 수준에서 오류 정보를 사용 하는 방법에 대 한 자세한 내용은 [계약 및 서비스에서 오류 지정 및 처리](../specifying-and-handling-faults-in-contracts-and-services.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-147">For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="2cf6b-148">예상 되는 [예외](../samples/expected-exceptions.md) 는 예상 되는 예외를 설명 하 고이를 처리 하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-148">[Expected Exceptions](../samples/expected-exceptions.md) describes expected exceptions and shows how to handle them.</span></span> <span data-ttu-id="2cf6b-149">채널을 개발할 때 발생 하는 오류를 처리 하는 방법에 대 한 자세한 내용은 [예외 및 오류 처리](../extending/handling-exceptions-and-faults.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-149">For more information about how to handle errors when developing channels, see [Handling Exceptions and Faults](../extending/handling-exceptions-and-faults.md).</span></span>  
  
### <a name="client-blocking-and-performance"></a><span data-ttu-id="2cf6b-150">클라이언트 차단 및 성능</span><span class="sxs-lookup"><span data-stu-id="2cf6b-150">Client Blocking and Performance</span></span>  

 <span data-ttu-id="2cf6b-151">애플리케이션에서 동기적으로 request-reply 작업을 호출하는 경우 클라이언트는 반환 값이 수신되거나 <xref:System.TimeoutException?displayProperty=nameWithType> 같은 예외가 throw될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-151">When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown.</span></span> <span data-ttu-id="2cf6b-152">이 동작은 로컬 동작과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-152">This behavior is similar to local behavior.</span></span> <span data-ttu-id="2cf6b-153">응용 프로그램에서 WCF 클라이언트 개체 또는 채널에 대 한 작업을 동기적으로 호출 하면 클라이언트는 채널 계층에서 네트워크에 데이터를 쓸 수 있을 때까지 또는 예외가 throw 될 때까지 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-153">When an application synchronously invokes an operation on a WCF client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown.</span></span> <span data-ttu-id="2cf6b-154"><xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType>를 `true`로 설정하여 작업을 표시함으로써 지정된 단방향 메시지 교환 패턴은 일부 클라이언트의 응답을 향상시키지만 바인딩 및 이미 전송된 메시지에 따라 단방향 작업이 차단될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-154">And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent.</span></span> <span data-ttu-id="2cf6b-155">단방향 작업은 메시지 교환에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-155">One-way operations are only about the message exchange, no more and no less.</span></span> <span data-ttu-id="2cf6b-156">자세한 내용은 단방향 [서비스](one-way-services.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-156">For more information, see [One-Way Services](one-way-services.md).</span></span>  
  
 <span data-ttu-id="2cf6b-157">큰 데이터 청크는 메시지 교환 패턴에 관계없이 클라이언트 처리 속도를 저하시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-157">Large data chunks can slow client processing no matter what the message exchange pattern.</span></span> <span data-ttu-id="2cf6b-158">이러한 문제를 처리 하는 방법을 이해 하려면 [대량 데이터 및 스트리밍](large-data-and-streaming.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-158">To understand how to handle these issues, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="2cf6b-159">작업이 완료 되는 동안 응용 프로그램에서 더 많은 작업을 수행 해야 하는 경우 WCF 클라이언트가 구현 하는 서비스 계약 인터페이스에 비동기 메서드 쌍을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-159">If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your WCF client implements.</span></span> <span data-ttu-id="2cf6b-160">이 작업을 수행 하는 가장 쉬운 방법은 `/async` [ServiceModel Metadata 유틸리티 도구 (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)에서 스위치를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-160">The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="2cf6b-161">예제는 [방법: 비동기적으로 서비스 작업 호출](how-to-call-wcf-service-operations-asynchronously.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-161">For an example, see [How to: Call Service Operations Asynchronously](how-to-call-wcf-service-operations-asynchronously.md).</span></span>  
  
 <span data-ttu-id="2cf6b-162">클라이언트 성능 향상에 대 한 자세한 내용은 [중간 계층 클라이언트 응용 프로그램](middle-tier-client-applications.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-162">For more information about increasing client performance, see [Middle-Tier Client Applications](middle-tier-client-applications.md).</span></span>  
  
### <a name="enabling-the-user-to-select-credentials-dynamically"></a><span data-ttu-id="2cf6b-163">사용자가 동적으로 자격 증명을 선택할 수 있도록 설정</span><span class="sxs-lookup"><span data-stu-id="2cf6b-163">Enabling the User to Select Credentials Dynamically</span></span>  

 <span data-ttu-id="2cf6b-164"><xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> 인터페이스를 사용하면 애플리케이션이 시간 제한 타이머가 시작되기 전에 채널을 만드는 데 사용할 자격 증명을 사용자가 선택할 수 있도록 하는 사용자 인터페이스를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-164">The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.</span></span>  
  
 <span data-ttu-id="2cf6b-165">애플리케이션 개발자는 삽입된 <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer>를 두 가지 방법으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-165">Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways.</span></span> <span data-ttu-id="2cf6b-166">클라이언트 응용 프로그램은 채널을 <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> 열기 전에 또는 (또는 비동기 버전)를 호출 하거나 ( *명시적* 방법) 첫 번째 작업 ( *암시적* 방법)을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-166">The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach).</span></span>  
  
 <span data-ttu-id="2cf6b-167">암시적 방법을 사용하는 경우 애플리케이션은 <xref:System.ServiceModel.ClientBase%601> 또는 <xref:System.ServiceModel.IClientChannel> 확장에서 첫 번째 작업을 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-167">If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension.</span></span> <span data-ttu-id="2cf6b-168">첫 번째 작업 이외의 항목을 호출 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-168">If it calls anything other than the first operation, an exception is thrown.</span></span>  
  
 <span data-ttu-id="2cf6b-169">명시적 방법을 사용하는 경우 애플리케이션은 다음 단계를 순서대로 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-169">If using the explicit approach, the application must perform the following steps in order:</span></span>  
  
1. <span data-ttu-id="2cf6b-170"><xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType>또는 <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (또는 비동기 버전)를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-170">Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version).</span></span>  
  
2. <span data-ttu-id="2cf6b-171">이니셜라이저가 반환 되 면 <xref:System.ServiceModel.ICommunicationObject.Open%2A> 개체의 메서드 <xref:System.ServiceModel.IClientChannel> 또는 <xref:System.ServiceModel.IClientChannel> 속성에서 반환 된 개체를 호출 합니다 <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2cf6b-171">When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property.</span></span>  
  
3. <span data-ttu-id="2cf6b-172">작업을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-172">Call operations.</span></span>  
  
 <span data-ttu-id="2cf6b-173">프로덕션 품질 애플리케이션에서는 명시적 방법을 사용하여 사용자 인터페이스 프로세스를 제어하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-173">It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.</span></span>  
  
 <span data-ttu-id="2cf6b-174">암시적 방법을 사용하는 애플리케이션은 사용자 인터페이스 이니셜라이저를 호출하지만, 애플리케이션 사용자가 바인딩에 대한 전송 시간 제한 내에 응답하지 않을 경우 사용자 인터페이스가 반환될 때 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cf6b-174">Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2cf6b-175">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2cf6b-175">See also</span></span>

- [<span data-ttu-id="2cf6b-176">이중 서비스</span><span class="sxs-lookup"><span data-stu-id="2cf6b-176">Duplex Services</span></span>](duplex-services.md)
- [<span data-ttu-id="2cf6b-177">방법: 단방향 및 요청-회신 계약을 사용하여 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="2cf6b-177">How to: Access Services with One-Way and Request-Reply Contracts</span></span>](how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)
- [<span data-ttu-id="2cf6b-178">방법: 이중 계약을 사용하여 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="2cf6b-178">How to: Access Services with a Duplex Contract</span></span>](how-to-access-services-with-a-duplex-contract.md)
- [<span data-ttu-id="2cf6b-179">방법: WSE 3.0 서비스 액세스</span><span class="sxs-lookup"><span data-stu-id="2cf6b-179">How to: Access a WSE 3.0 Service</span></span>](how-to-access-a-wse-3-0-service-with-a-wcf-client.md)
- [<span data-ttu-id="2cf6b-180">방법: ChannelFactory 사용</span><span class="sxs-lookup"><span data-stu-id="2cf6b-180">How to: Use the ChannelFactory</span></span>](how-to-use-the-channelfactory.md)
- [<span data-ttu-id="2cf6b-181">방법: 비동기적으로 서비스 작업 호출</span><span class="sxs-lookup"><span data-stu-id="2cf6b-181">How to: Call Service Operations Asynchronously</span></span>](how-to-call-wcf-service-operations-asynchronously.md)
- [<span data-ttu-id="2cf6b-182">중간 계층 클라이언트 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="2cf6b-182">Middle-Tier Client Applications</span></span>](middle-tier-client-applications.md)
