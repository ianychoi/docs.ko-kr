---
title: 보안 및 원격 서비스 고려 사항
description: 응용 프로그램 도메인, 프로세스 또는 컴퓨터 간에 투명 한 호출을 설정할 수 있도록 하는 원격 작업과 관련 된 보안 고려 사항에 대해 알아봅니다.
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 883c20483c4d315a45e1f4dab959d42cbb6e3c4b
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96288205"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="6d73b-103">보안 및 원격 서비스 고려 사항</span><span class="sxs-lookup"><span data-stu-id="6d73b-103">Security and Remoting Considerations</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

<span data-ttu-id="6d73b-104">원격 기능을 사용하면 애플리케이션 도메인, 프로세스 또는 컴퓨터 간에 투명한 호출을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-104">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="6d73b-105">그러나 코드 액세스 보안 스택 워크는 프로세스 또는 시스템 경계를 넘어갈 수 없습니다(동일한 프로세스의 애플리케이션 도메인 간에 적용됨).</span><span class="sxs-lookup"><span data-stu-id="6d73b-105">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="6d73b-106">원격으로 사용 가능한(<xref:System.MarshalByRefObject> 클래스에서 파생된) 모든 클래스는 보안을 책임져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-106">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="6d73b-107">호출하는 코드를 암시적으로 신뢰할 수 있는 폐쇄된 환경에서만 코드를 사용해야 하거나, 악의적으로 사용될 수 있는 외부 입력이 보호된 코드에 적용되지 않도록 원격 호출을 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-107">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="6d73b-108">일반적으로 선언적 [LinkDemand](link-demands.md) 및 보안 검사로 보호 되는 메서드, 속성 또는 이벤트를 노출 하면 안 됩니다 <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> .</span><span class="sxs-lookup"><span data-stu-id="6d73b-108">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="6d73b-109">원격 기능에서는 이러한 검사가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-109">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="6d73b-110">, Assert 등의 다른 보안 검사는 <xref:System.Security.Permissions.SecurityAction.Demand> 프로세스 내의 응용 프로그램 도메인 간에는 작동 하지만 크로스 프로세스 또는 크로스 시스템 시나리오에서는 작동 하지 않습니다. [Assert](using-the-assert-method.md)</span><span class="sxs-lookup"><span data-stu-id="6d73b-110">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="6d73b-111">보호되는 개체</span><span class="sxs-lookup"><span data-stu-id="6d73b-111">Protected objects</span></span>  

 <span data-ttu-id="6d73b-112">일부 개체는 그 자체에 보안 상태를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-112">Some objects hold security state in themselves.</span></span> <span data-ttu-id="6d73b-113">고유한 권한 이상의 보안 권한이 부여되지 않도록 신뢰할 수 없는 코드에는 이러한 개체를 전달하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-113">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="6d73b-114">한 가지 예로 <xref:System.IO.FileStream> 개체 만들기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-114">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="6d73b-115">생성 시 <xref:System.Security.Permissions.FileIOPermission>이 요구되며, 성공하면 파일 개체가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-115">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="6d73b-116">그러나 이 개체 참조가 파일 권한이 없는 코드에 전달되면 개체가 이 특정 파일을 읽고 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-116">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="6d73b-117">이러한 개체에 대 한 가장 간단한 방어는 공용 API 요소를 통해 개체 참조를 가져오도록 하는 코드와 동일한 **FileIOPermission** 을 요구 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-117">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="6d73b-118">애플리케이션 도메인을 넘을 때의 문제</span><span class="sxs-lookup"><span data-stu-id="6d73b-118">Application domain crossing issues</span></span>  

 <span data-ttu-id="6d73b-119">관리되는 호스팅 환경에서 코드를 격리하려면 다양한 어셈블리에 대한 권한 수준을 축소하는 명시적 정책을 사용하여 여러 자식 애플리케이션 도메인을 생성하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-119">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="6d73b-120">그러나 해당 어셈블리에 대한 정책은 기본 애플리케이션 도메인에 변경되지 않고 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-120">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="6d73b-121">자식 애플리케이션 도메인 중 하나가 기본 애플리케이션 도메인에서 어셈블리를 로드하도록 강제할 수 있는 경우 코드 격리 효과가 손실되며 강제로 로드된 어셈블리의 형식이 상위 신뢰 수준으로 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-121">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="6d73b-122">애플리케이션 도메인은 다른 애플리케이션 도메인에서 어셈블리를 로드하도록 강제하고 다른 애플리케이션 도메인에 호스트된 개체에 대한 프록시를 호출하여 포함된 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-122">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="6d73b-123">애플리케이션 도메인 간 프록시를 가져오려면 개체를 호스트하는 애플리케이션 도메인이 메서드 호출 매개 변수나 반환 값을 통해 프록시를 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-123">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="6d73b-124">또는 애플리케이션 도메인이 방금 만들어진 경우 기본적으로 작성자에게 <xref:System.AppDomain> 개체에 대한 프록시가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-124">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="6d73b-125">따라서 코드 격리 손상을 방지하려면 상위 신뢰 수준의 애플리케이션 도메인이 해당 도메인의 참조 방식 마샬링 개체에 대한 참조(<xref:System.MarshalByRefObject>에서 파생된 클래스 인스턴스)를 하위 신뢰 수준의 애플리케이션 도메인에 배포하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-125">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="6d73b-126">일반적으로 기본 애플리케이션 도메인은 각각 컨트롤 개체가 있는 자식 애플리케이션 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-126">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="6d73b-127">컨트롤 개체는 새 애플리케이션 도메인을 관리하고 때때로 기본 애플리케이션 도메인에서 주문을 받지만 실제로 도메인에 직접 연결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-127">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="6d73b-128">때로는 기본 애플리케이션 도메인이 컨트롤 개체에 대한 프록시를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-128">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="6d73b-129">그러나 컨트롤 개체가 기본 애플리케이션 도메인을 다시 호출해야 하는 경우도 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-129">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="6d73b-130">이러한 경우 기본 애플리케이션 도메인은 참조 방식 마샬링 콜백 개체를 컨트롤 개체의 생성자에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-130">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="6d73b-131">이 프록시를 보호하는 것은 컨트롤 개체의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-131">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="6d73b-132">컨트롤 개체가 public 클래스의 public 정적 필드에 프록시를 배치 했거나 프록시를 공개적으로 노출 하는 경우 다른 코드에서 기본 응용 프로그램 도메인으로 다시 호출 하는 위험한 메커니즘이 열립니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-132">If the control object placed the proxy on a public static field of a public class or otherwise publicly exposed the proxy, a dangerous mechanism for other code to call back into the default application domain would be opened up.</span></span> <span data-ttu-id="6d73b-133">이런 이유로, 컨트롤 개체는 프록시를 비공개로 유지하기 위해 항상 암시적으로 신뢰됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d73b-133">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6d73b-134">참고 항목</span><span class="sxs-lookup"><span data-stu-id="6d73b-134">See also</span></span>

- [<span data-ttu-id="6d73b-135">보안 코딩 지침</span><span class="sxs-lookup"><span data-stu-id="6d73b-135">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
