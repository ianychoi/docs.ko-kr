---
title: 초기화 지연
description: 개체를 처음 사용할 때까지 개체 만들기가 지연 된다는 것을 의미 하는 .NET의 초기화 지연에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 6cbda2bd45f2cdc5085ca30af878824069fb019a
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96242177"
---
# <a name="lazy-initialization"></a><span data-ttu-id="01216-103">초기화 지연</span><span class="sxs-lookup"><span data-stu-id="01216-103">Lazy Initialization</span></span>

<span data-ttu-id="01216-104">개체 *초기화 지연* 은 개체를 처음 사용할 때까지 생성이 지연된다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="01216-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="01216-105">이 항목의 경우 *초기화 지연* 및 *지연 인스턴스화* 는 동의어입니다. 초기화 지연은 주로 성능을 향상 시키고 불필요 한 계산을 방지 하 고 프로그램 메모리 요구 사항을 줄이는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="01216-106">다음은 가장 일반적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="01216-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="01216-107">만드는 데 비용이 많이 드는 개체가 있으며 프로그램에서 이 개체를 사용하지 않는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="01216-108">예를 들어 초기화되기 위해 데이터베이스 연결이 필요한 큰 `Order` 개체 배열이 포함된 `Orders` 속성이 있는 `Customer` 개체가 메모리에 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="01216-109">사용자는 주문을 표시하거나 계산에서 데이터를 사용하도록 요청하지 않으면 시스템 메모리 또는 계산 주기를 사용하여 만들 이유가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="01216-110">`Lazy<Orders>`를 사용하여 `Orders` 개체의 초기화 지연을 선언하면 개체를 사용하지 않을 때 시스템 리소스 낭비를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="01216-111">만드는 데 비용이 많이 드는 개체가 있고 다른 비용이 많이 드는 작업이 완료될 때까지 생성을 지연시키려는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="01216-112">예를 들어, 프로그램을 시작할 때 여러 개체 인스턴스를 로드하지만 그중 일부만 즉시 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="01216-113">필요한 개체를 만들 때까지 필요하지 않은 개체의 초기화를 지연하여 프로그램의 시작 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="01216-114">초기화 지연을 수행하도록 고유 코드를 작성할 수 있지만 <xref:System.Lazy%601>를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="01216-115"><xref:System.Lazy%601> 및 관련 유형에서도 스레드로부터 안전을 지원하고 일관된 예외 전파 정책을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="01216-116">다음 표에는 다양한 시나리오에서 초기화 지연을 사용하도록 .NET Framework 버전 4에서 제공하는 유형이 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="01216-117">유형</span><span class="sxs-lookup"><span data-stu-id="01216-117">Type</span></span>|<span data-ttu-id="01216-118">Description</span><span class="sxs-lookup"><span data-stu-id="01216-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="01216-119">클래스 라이브러리 또는 사용자 정의 형식에 대한 초기화 지연 의미 체계를 제공하는 래퍼 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="01216-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="01216-120">스레드-로컬 기반으로 초기화 지연 의미 체계를 제공한다는 점을 제외하고는 <xref:System.Lazy%601>와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="01216-121">모든 스레드는 고유 값에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="01216-122">클래스의 오버헤드 없이 개체의 초기화 지연을 위한 고급 `static`(Visual Basic의 `Shared`) 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="01216-123">기본 초기화 지연</span><span class="sxs-lookup"><span data-stu-id="01216-123">Basic Lazy Initialization</span></span>  

 <span data-ttu-id="01216-124">초기화 지연 형식(예: `MyType`)을 지정하려면 다음 예에 표시된 대로 `Lazy<MyType>`(Visual Basic에서 `Lazy(Of MyType)`)을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="01216-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="01216-125"><xref:System.Lazy%601> 생성자에 대리자가 전달되지 않으면 값 속성에 처음 액세스할 때 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>을 사용하여 래핑된 형식이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="01216-126">형식에 매개 변수가 없는 생성자가 없는 경우 런타임 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="01216-127">다음 예에서 `Orders`는 데이터베이스에서 검색된 `Order` 개체의 배열을 포함하는 클래스라고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="01216-128">`Customer` 개체에는 `Orders`의 인스턴스가 포함되어 있지만 사용자 작업에 따라 `Orders` 개체의 데이터가 필요하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="01216-129">생성 시 래핑된 형식에서 특정 생성자 오버로드를 호출하는 <xref:System.Lazy%601> 생성자에서 대리자를 전달할 수도 있고, 다음 예에 표시된 대로 필수인 기타 초기화 단계를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="01216-130">지연 개체를 만들고 나면 지연 변수의 <xref:System.Lazy%601.Value%2A> 속성에 처음으로 액세스할 때까지 `Orders`의 인스턴스가 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="01216-131">처음 액세스할 때 래핑된 형식이 생성되고 반환되며 나중에 액세스하는 데 사용하기 위해 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="01216-132"><xref:System.Lazy%601> 개체는 항상 초기화 시 사용된 값 또는 개체와 동일한 값 또는 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="01216-133">따라서 <xref:System.Lazy%601.Value%2A> 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="01216-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="01216-134"><xref:System.Lazy%601.Value%2A>에서 참조 형식을 저장하면 새로운 개체를 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="01216-135">그러나 설정할 수 있는 공용 필드 및 속성의 값을 변경할 수 있습니다. <xref:System.Lazy%601.Value%2A> 에서 값 형식을 저장 하는 경우 해당 값을 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="01216-136">그렇지만 새 인수를 사용하여 변수 생성자를 다시 호출하면 새 변수를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="01216-137">이전 지연 인스턴스와 같이 새로운 지연 인스턴스는 <xref:System.Lazy%601.Value%2A> 속성에 처음 액세스할 때까지 `Orders`를 인스턴스화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="01216-138">스레드로부터 안전한 초기화</span><span class="sxs-lookup"><span data-stu-id="01216-138">Thread-Safe Initialization</span></span>  

 <span data-ttu-id="01216-139">기본적으로 <xref:System.Lazy%601> 개체는 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="01216-140">즉, 생성자가 스레드 보안 유형을 지정하지 않으면 생성된 <xref:System.Lazy%601> 개체는 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="01216-141">다중 스레드 시나리오에서 스레드로부터 안전한 <xref:System.Lazy%601> 개체의 <xref:System.Lazy%601.Value%2A> 속성에 액세스하는 첫 번째 스레드가 모든 스레드에서의 모든 후속 액세스를 위해 개체를 초기화하고 모든 스레드에서 동일한 데이터를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="01216-142">따라서 어떤 스레드가 개체를 초기화하는지는 중요하지 않으며 경합 상태는 심각하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="01216-143">예외 캐싱을 사용하여 이러한 일관성을 오류 조건까지 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="01216-144">자세한 내용은 다음 섹션인 [Lazy 개체의 예외](lazy-initialization.md#ExceptionsInLazyObjects)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="01216-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="01216-145">다음 예에서는 동일한 `Lazy<int>` 인스턴스에서는 개별 스레드의 값이 동일함을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="01216-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="01216-146">스레드마다 개별 데이터가 필요한 경우 이 항목의 뒷부분에 설명된 대로 <xref:System.Threading.ThreadLocal%601> 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="01216-147">일부 <xref:System.Lazy%601> 생성자에는 여러 스레드에서 <xref:System.Lazy%601.Value%2A> 속성에 액세스할지 지정하는 데 사용하는 `isThreadSafe`라는 부울 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="01216-148">하나의 스레드에서만 속성에 액세스하게 하려는 경우 `false`를 전달하여 보통 수준의 성능 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="01216-149">여러 스레드에서 속성에 액세스하게 하려면 `true`를 전달하여 초기화 시 한 스레드에서 예외 처리를 하는 경합 상태를 올바르게 처리하도록 <xref:System.Lazy%601> 인스턴스에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="01216-150">일부 <xref:System.Lazy%601> 생성자에는 `mode`라는 <xref:System.Threading.LazyThreadSafetyMode> 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="01216-151">이러한 생성자는 추가 스레드 보안 모드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="01216-152">다음 표에서는 스레드 보안을 지정하는 생성자 매개 변수가 <xref:System.Lazy%601> 개체의 스레드 보안에 미치는 영향을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="01216-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="01216-153">각 생성자에는 이러한 매개 변수가 최대 한 개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="01216-154">개체의 스레드 보안</span><span class="sxs-lookup"><span data-stu-id="01216-154">Thread safety of the object</span></span>|<span data-ttu-id="01216-155">`LazyThreadSafetyMode``mode`매개 변수</span><span class="sxs-lookup"><span data-stu-id="01216-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="01216-156">부울 `isThreadSafe` 매개 변수</span><span class="sxs-lookup"><span data-stu-id="01216-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="01216-157">스레드 보안 매개 변수 없음</span><span class="sxs-lookup"><span data-stu-id="01216-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="01216-158">완벽하게 스레드로부터 안전. 한 번에 하나의 스레드만 값을 초기화하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="01216-159">예.</span><span class="sxs-lookup"><span data-stu-id="01216-159">Yes.</span></span>|  
|<span data-ttu-id="01216-160">스레드로부터 안전하지 않음.</span><span class="sxs-lookup"><span data-stu-id="01216-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="01216-161">해당 사항 없음</span><span class="sxs-lookup"><span data-stu-id="01216-161">Not applicable.</span></span>|  
|<span data-ttu-id="01216-162">완벽하게 스레드로부터 안전. 스레드에서 값을 초기화하기 위해 경합합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="01216-163">해당 사항 없음</span><span class="sxs-lookup"><span data-stu-id="01216-163">Not applicable.</span></span>|<span data-ttu-id="01216-164">해당 사항 없음</span><span class="sxs-lookup"><span data-stu-id="01216-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="01216-165">표에 표시된 바와 같이 `mode` 매개 변수에 대해 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>을 지정하면 `isThreadSafe` 매개 변수에 대해 `true`를 지정하는 것과 같으며 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>을 지정하면 `false`를 지정하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="01216-166"><xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>을 지정하면 여러 스레드에서 <xref:System.Lazy%601> 인스턴스를 초기화하려고 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="01216-167">하나의 스레드만 이 경합에서 이길 수 있고 다른 모든 스레드는 성공한 스레드를 통해 초기화된 값을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="01216-168">초기화 중에 스레드에서 예외가 throw되면 해당 스레드는 성공한 스레드를 통해 설정된 값을 받지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="01216-169">예외가 캐시되지 않으므로 다음에 <xref:System.Lazy%601.Value%2A> 속성에 액세스하려고 하면 초기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="01216-170">이 방식은 다음 섹션에 설명된 대로 다른 모드에서 예외를 처리하는 방식과는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="01216-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="01216-171">자세한 내용은 <xref:System.Threading.LazyThreadSafetyMode> 열거형을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="01216-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>

## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="01216-172">Lazy 개체의 예외</span><span class="sxs-lookup"><span data-stu-id="01216-172">Exceptions in Lazy Objects</span></span>  

 <span data-ttu-id="01216-173">앞에서 설명한 것처럼 <xref:System.Lazy%601> 개체는 항상 초기화 시와 동일한 개체 또는 값을 반환하므로 <xref:System.Lazy%601.Value%2A> 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="01216-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="01216-174">예외 캐싱을 사용하도록 설정하면 이 불변성이 예외 동작까지 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="01216-175">지연 초기화 된 개체에 예외 캐싱이 설정 되어 있고 속성에 처음 액세스할 때 초기화 메서드에서 예외를 throw 하는 경우 <xref:System.Lazy%601.Value%2A> 모든 후속 시도에서 속성에 대 한 액세스를 시도할 때마다 동일한 예외가 throw 됩니다 <xref:System.Lazy%601.Value%2A> .</span><span class="sxs-lookup"><span data-stu-id="01216-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="01216-176">즉, 다중 스레드 시나리오에서도 래핑된 형식의 생성자가 다시 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="01216-177">따라서 <xref:System.Lazy%601> 개체는 한 번의 액세스에서 예외 처리를 할 수 없으며 후속 액세스에서 값을 반환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="01216-178">초기화 메서드(`valueFactory` 매개 변수)를 사용하는 <xref:System.Lazy%601?displayProperty=nameWithType> 생성자를 사용할 때 예외 캐싱이 사용됩니다. 예를 들어 `Lazy(T)(Func(T))` 생성자를 사용할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="01216-179">생성자에서 <xref:System.Threading.LazyThreadSafetyMode> 값(`mode` 매개 변수)도 사용하는 경우 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 또는 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>을 지정하세요.</span><span class="sxs-lookup"><span data-stu-id="01216-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01216-180">초기화 메서드를 지정하면 이 두 모드에 대해 예외 캐싱을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="01216-181">초기화 메서드는 매우 간단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-181">The initialization method can be very simple.</span></span> <span data-ttu-id="01216-182">예를 들어 `T` `new Lazy<Contents>(() => new Contents(), mode)` c #의 경우 또는 `New Lazy(Of Contents)(Function() New Contents())` Visual Basic에서 매개 변수가 없는 생성자를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="01216-183">초기화 메소드를 지정하지 않는 <xref:System.Lazy%601?displayProperty=nameWithType> 생성자를 사용하는 경우 `T`의 매개 변수가 없는 생성자가 throw하는 예외는 캐싱되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="01216-184">자세한 내용은 <xref:System.Threading.LazyThreadSafetyMode> 열거형을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="01216-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="01216-185">`isThreadSafe` 생성자 매개 변수를 `false`로 설정하거나 `mode` 생성자 매개 변수를 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>으로 설정하여 <xref:System.Lazy%601> 개체를 만들면 단일 스레드에서 <xref:System.Lazy%601> 개체에 액세스하거나 고유 동기화를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="01216-186">그러면 예외 캐싱을 포함하여 개체의 모든 요소에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="01216-187">이전 섹션에서 설명한 대로 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>을 지정하여 만든 <xref:System.Lazy%601> 개체는 예외를 다르게 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="01216-188"><xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>를 사용하면 여러 스레드에서 <xref:System.Lazy%601> 인스턴스를 초기화하기 위해 경쟁할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="01216-189">이 경우 예외가 캐시되지 않고, 초기화에 성공할 때까지 <xref:System.Lazy%601.Value%2A> 속성에 계속 액세스하려고 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="01216-190">다음 표에는 <xref:System.Lazy%601> 생성자가 예외 캐싱을 제어하는 방식이 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="01216-191">생성자</span><span class="sxs-lookup"><span data-stu-id="01216-191">Constructor</span></span>|<span data-ttu-id="01216-192">스레드 보안 모드</span><span class="sxs-lookup"><span data-stu-id="01216-192">Thread safety mode</span></span>|<span data-ttu-id="01216-193">초기화 메서드 사용</span><span class="sxs-lookup"><span data-stu-id="01216-193">Uses initialization method</span></span>|<span data-ttu-id="01216-194">예외가 캐시됨</span><span class="sxs-lookup"><span data-stu-id="01216-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="01216-195">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="01216-195">Lazy(T)()</span></span>|<span data-ttu-id="01216-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="01216-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="01216-197">아니요</span><span class="sxs-lookup"><span data-stu-id="01216-197">No</span></span>|<span data-ttu-id="01216-198">아니요</span><span class="sxs-lookup"><span data-stu-id="01216-198">No</span></span>|  
|<span data-ttu-id="01216-199">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="01216-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="01216-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="01216-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="01216-201">예</span><span class="sxs-lookup"><span data-stu-id="01216-201">Yes</span></span>|<span data-ttu-id="01216-202">예</span><span class="sxs-lookup"><span data-stu-id="01216-202">Yes</span></span>|  
|<span data-ttu-id="01216-203">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="01216-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="01216-204">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) 또는 `false`(<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="01216-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="01216-205">아니요</span><span class="sxs-lookup"><span data-stu-id="01216-205">No</span></span>|<span data-ttu-id="01216-206">아니요</span><span class="sxs-lookup"><span data-stu-id="01216-206">No</span></span>|  
|<span data-ttu-id="01216-207">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="01216-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="01216-208">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) 또는 `false`(<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="01216-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="01216-209">예</span><span class="sxs-lookup"><span data-stu-id="01216-209">Yes</span></span>|<span data-ttu-id="01216-210">예</span><span class="sxs-lookup"><span data-stu-id="01216-210">Yes</span></span>|  
|<span data-ttu-id="01216-211">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="01216-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="01216-212">사용자 지정</span><span class="sxs-lookup"><span data-stu-id="01216-212">User-specified</span></span>|<span data-ttu-id="01216-213">아니요</span><span class="sxs-lookup"><span data-stu-id="01216-213">No</span></span>|<span data-ttu-id="01216-214">아니요</span><span class="sxs-lookup"><span data-stu-id="01216-214">No</span></span>|  
|<span data-ttu-id="01216-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="01216-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="01216-216">사용자 지정</span><span class="sxs-lookup"><span data-stu-id="01216-216">User-specified</span></span>|<span data-ttu-id="01216-217">예</span><span class="sxs-lookup"><span data-stu-id="01216-217">Yes</span></span>|<span data-ttu-id="01216-218">사용자가 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>를 지정하는 경우 No, 지정하지 않으면 Yes.</span><span class="sxs-lookup"><span data-stu-id="01216-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="01216-219">초기화 지연 속성 구현</span><span class="sxs-lookup"><span data-stu-id="01216-219">Implementing a Lazy-Initialized Property</span></span>  

 <span data-ttu-id="01216-220">초기화 지연을 사용하여 공용 속성을 구현하려면 속성의 지원 필드를 <xref:System.Lazy%601>로 정의하고 속성의 `get` 접근자에서 <xref:System.Lazy%601.Value%2A> 속성을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="01216-221"><xref:System.Lazy%601.Value%2A> 속성은 읽기 전용입니다. 따라서 이 속성을 노출하는 속성에는 `set` 접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="01216-222"><xref:System.Lazy%601> 개체에서 지원하는 읽기/쓰기 속성이 필요하면 `set` 접근자가 새로운 <xref:System.Lazy%601> 개체를 만들어 백업 저장소에 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="01216-223">`set` 접근자는 `set` 접근자에 전달된 새 속성 값을 반환하는 람다 식을 생성해야 하며 이 람다 식을 새로운 <xref:System.Lazy%601> 개체의 생성자에 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="01216-224">다음번에 <xref:System.Lazy%601.Value%2A> 속성에 액세스하면 새로운 <xref:System.Lazy%601>가 초기화되고, 그 이후로 <xref:System.Lazy%601.Value%2A> 속성이 속성에 할당된 새 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="01216-225">이와 같이 복잡하게 배열하는 이유는 <xref:System.Lazy%601>에 기본 제공된 다중 스레딩 보호를 유지하기 위해서입니다.</span><span class="sxs-lookup"><span data-stu-id="01216-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="01216-226">그러지 않으면 속성 접근자가 <xref:System.Lazy%601.Value%2A> 속성을 통해 반환된 첫 번째 값을 캐시하고 캐시된 값만 수정해야 하며, 이 작업을 수행하려면 스레드로부터 안전한 코드를 고유하게 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="01216-227"><xref:System.Lazy%601> 개체에서 지원하는 읽기/쓰기 속성에 필요한 추가 초기화때문에 성능이 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="01216-228">또한 특정 시나리오에 따라 setter와 getter 사이의 경합 상태를 방지하기 위해 추가 조정이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="01216-229">스레드 로컬 초기화 지연</span><span class="sxs-lookup"><span data-stu-id="01216-229">Thread-Local Lazy Initialization</span></span>  

 <span data-ttu-id="01216-230">일부 다중 스레드 시나리오에서는 각 스레드에 고유 개인 데이터를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="01216-231">이러한 데이터는 *스레드 로컬 데이터* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="01216-232">.NET Framework 버전 3.5 이하에서 `ThreadStatic` 특성을 정적 변수에 적용하여 스레드 로컬로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="01216-233">그러나 `ThreadStatic` 특성을 사용하면 사소한 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="01216-234">예를 들어 다음 예제에 표시된 대로 기본 초기화 명령문도 액세스하는 첫 번째 스레드에서만 변수가 초기화되게 합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="01216-235">다른 모든 스레드에서는 변수가 기본값(0)을 사용하여 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="01216-236">.NET Framework 버전 4의 대안으로 <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> 유형을 사용하여 인스턴스 기반의 스레드 지역 변수를 만들 수 있습니다. 이 변수는 사용자가 제공하는 <xref:System.Action%601> 대리자가 모든 스레드에서 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="01216-237">다음 예제에서 `counter`에 액세스하는 모든 스레드에는 시작 값이 1로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="01216-238"><xref:System.Threading.ThreadLocal%601>에서는 <xref:System.Lazy%601>와 거의 동일한 방식으로 개체를 래핑합니다. 단, 다음과 같은 중요한 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="01216-239">각 스레드가 다른 스레드에서 액세스할 수 없는 고유한 개인 데이터를 사용하여 스레드 지역 변수를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="01216-240"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> 속성은 읽기-쓰기이고 여러 번 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="01216-241">따라서 예외 전파에 영향을 미칠 수 있습니다. 예를 들어 하나의 `get` 작업에서는 예외가 throw될 수 있지만, 다른 작업에서는 성공적으로 값을 초기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="01216-242">초기화 대리자가 제공되지 않으면 <xref:System.Threading.ThreadLocal%601>에서 형식의 기본값을 사용하여 래핑된 형식을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="01216-243">이런 점에서 <xref:System.Threading.ThreadLocal%601>은 <xref:System.ThreadStaticAttribute> 특성과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="01216-244">다음 예제에서는 `ThreadLocal<int>` 인스턴스에 액세스하는 모든 스레드가 고유한 데이터 복사본을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="01216-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="01216-245">Parallel.For 및 ForEach의 스레드 지역 변수</span><span class="sxs-lookup"><span data-stu-id="01216-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  

 <span data-ttu-id="01216-246"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 또는 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드를 사용하여 데이터 소스를 병렬로 반복할 때 스레드 로컬 데이터 지원을 기본으로 제공하는 오버로드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="01216-247">이러한 메서드에서는 데이터를 만들고 액세스하며 정리하기 위해 로컬 대리자를 사용하여 스레드 국부성을 달성합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="01216-248">자세한 내용은 [방법: 스레드 로컬 변수를 사용하는 Parallel.For 루프 작성](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) 및 [방법: 파티션 로컬 변수를 사용하는 Parallel.ForEach 루프 작성](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="01216-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="01216-249">오버헤드가 적은 시나리오에 초기화 지연 사용</span><span class="sxs-lookup"><span data-stu-id="01216-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  

 <span data-ttu-id="01216-250">다수의 개체를 초기화 지연해야 하는 시나리오에서는 <xref:System.Lazy%601>의 각 개체를 래핑하는 데 너무 많은 메모리 또는 너무 많은 계산 리소스가 필요한지 판별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="01216-251">또는 초기화 지연 노출 방법에 대한 엄격한 요구 사항이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="01216-252">이 경우 <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> 클래스의 `static`(Visual Basic에서 `Shared`) 메서드를 사용하여 <xref:System.Lazy%601> 인스턴스에 래핑하지 않고 각 개체의 초기화를 지연할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="01216-253">다음 예에서는 하나의 <xref:System.Lazy%601> 개체에 전체 `Orders` 개체를 래핑하지 않고 필요한 경우에만 개별 `Order` 개체의 초기화를 지연합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="01216-254">이 예에서는 루프를 반복할 때마다 초기화 프로시저가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="01216-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="01216-255">다중 스레드 시나리오에서 초기화 프로시저를 호출하는 첫 번째 스레드는 모든 스레드에 해당 값이 표시되는 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="01216-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="01216-256">나중에 스레드에서 초기화 프로시저도 호출하지만 해당 결과는 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="01216-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="01216-257">이 유형의 잠재적 경합 상태가 허용되지 않는 경우 부울 인수와 동기화 개체를 사용하는 <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType>의 오버로드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="01216-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="01216-258">참조</span><span class="sxs-lookup"><span data-stu-id="01216-258">See also</span></span>

- [<span data-ttu-id="01216-259">관리되는 스레딩 기본 사항</span><span class="sxs-lookup"><span data-stu-id="01216-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="01216-260">스레드 및 스레딩</span><span class="sxs-lookup"><span data-stu-id="01216-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="01216-261">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="01216-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="01216-262">방법: 개체의 초기화 지연 수행</span><span class="sxs-lookup"><span data-stu-id="01216-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
