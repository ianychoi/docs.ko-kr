---
title: 동적으로 형식 로드 및 사용
description: .NET에서 동적으로 형식을 로드하고 사용합니다. 리플렉션을 사용하면 언어 컴파일러에서 암시적 런타임에 바인딩을 구현하는 데 사용되는 인프라를 제공합니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: be9991a4df866f65aabe063be3cc2b374f4d124d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96266794"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="c3922-104">동적으로 형식 로드 및 사용</span><span class="sxs-lookup"><span data-stu-id="c3922-104">Dynamically Loading and Using Types</span></span>

<span data-ttu-id="c3922-105">리플렉션은 언어 컴파일러에서 암시적 런타임에 바인딩을 구현하는 데 사용되는 인프라를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-105">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="c3922-106">바인딩은 고유하게 지정된 형식에 해당하는 선언(즉, 구현)을 찾는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-106">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="c3922-107">이 프로세스가 컴파일 시간이 아닌 런타임에 수행되는 경우 이를 런타임에 바인딩이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-107">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="c3922-108">Visual Basic을 통해 코드에서 암시적 런타임에 바인딩을 사용할 수 있고, Visual Basic 컴파일러는 리플렉션을 사용하여 개체 형식을 가져오는 도우미 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-108">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="c3922-109">인수가 도우미 메서드에 전달되면 런타임에 적절한 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-109">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="c3922-110">이러한 인수는 메서드를 호출하는 인스턴스(개체), 호출된 메서드의 이름(문자열) 및 호출된 메서드에 전달된 인수(개체 배열)입니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-110">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="c3922-111">다음 예제에서는 Visual Basic 컴파일러가 리플렉션을 암시적으로 사용하여 컴파일 시간에 형식이 알려지지 않은 개체에 대해 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-111">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="c3922-112">**HelloWorld** 클래스에는 **PrintHello** 메서드에 전달되는 일부 텍스트와 연결된 "Hello World"를 출력하는 **PrintHello** 메서드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-112">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="c3922-113">이 예제에서 호출된 **PrintHello** 메서드는 실제로 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>이고, Visual Basic 코드에서는 개체 형식(helloObj)이 런타임(런타임에 바인딩)이 아닌 컴파일 시간(초기 바인딩)에 알려진 것처럼 **PrintHello** 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-113">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="c3922-114">사용자 지정 바인딩</span><span class="sxs-lookup"><span data-stu-id="c3922-114">Custom Binding</span></span>  

 <span data-ttu-id="c3922-115">리플렉션은 런타임에 바인딩을 위해 컴파일러에서 암시적으로 사용될 뿐만 아니라 코드에서 런타임에 바인딩을 수행하기 위해 명시적으로 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-115">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="c3922-116">[공용 언어 런타임](../../standard/clr.md)은 여러 가지 프로그래밍 언어를 지원하고 이러한 언어의 바인딩 규칙은 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-116">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="c3922-117">초기 바인딩된 경우 코드 생성기는 이 바인딩을 완전히 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-117">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="c3922-118">그러나 리플렉션을 통한 런타임에 바인딩에서는 사용자 지정된 바인딩을 통해 바인딩을 제어해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-118">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="c3922-119"><xref:System.Reflection.Binder> 클래스는 멤버 선택 및 호출의 사용자 지정 컨트롤을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-119">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="c3922-120">사용자 지정 바인딩을 사용하면 런타임에 어셈블리를 로드하고, 해당 어셈블리에서 형식 정보를 가져오고, 원하는 형식을 지정하고 나서, 해당 형식에 대한 메서드를 호출하거나 필드 또는 속성에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-120">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="c3922-121">개체 형식에 사용자 입력이 사용되는 경우와 같이 컴파일 시간에 개체 형식을 알 수 없는 경우 이 기술이 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-121">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="c3922-122">다음 예제에서는 인수 형식 변환을 제공하지 않는 간단한 사용자 지정 바인더를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-122">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="c3922-123">`Simple_Type.dll`에 대한 코드가 기본 예제 앞에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-123">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="c3922-124">`Simple_Type.dll`을 빌드하고 나서 빌드 시간에 프로젝트에서 이에 대한 참조를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-124">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="c3922-125">InvokeMember 및 CreateInstance</span><span class="sxs-lookup"><span data-stu-id="c3922-125">InvokeMember and CreateInstance</span></span>  

 <span data-ttu-id="c3922-126"><xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>를 사용하여 형식의 멤버를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-126">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="c3922-127"><xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>와 같은 다양한 클래스의 **CreateInstance** 메서드는 지정된 형식의 새 인스턴스를 만드는 **InvokeMember** 의 형식으로 특수화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-127">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="c3922-128">**Binder** 클래스는 이러한 메서드의 오버로드 확인 및 인수 강제 변환에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-128">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="c3922-129">다음 예제에서는 인수 강제 변환(형식 변환) 및 멤버 선택의 세 가지 가능한 조합을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-129">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="c3922-130">사례 1에서는 인수 강제 변환 또는 멤버 선택이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-130">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="c3922-131">사례 2에서는 멤버 선택만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-131">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="c3922-132">사례 3에서는 인수 강제 변환만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-132">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="c3922-133">같은 이름을 가진 두 개 이상의 멤버를 사용할 수 있는 경우 오버로드 확인이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-133">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="c3922-134"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> 메서드는 바인딩을 단일 멤버로 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-134">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="c3922-135">또한 **Binder.BindToMethod** 는 **get** 및 **set** 속성 접근자를 통해 속성 확인을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-135">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="c3922-136">**BindToMethod** 는 호출할 <xref:System.Reflection.MethodBase>를 반환하거나 해당 호출이 가능하지 않은 경우 null 참조(Visual Basic의 경우 **Nothing**)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-136">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="c3922-137">**MethodBase** 반환 값은 일반적인 사례인 경우에도 *match* 매개 변수에 포함된 값 중 하나일 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-137">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="c3922-138">ByRef 인수가 있으면 호출자가 해당 인수를 되찾으려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-138">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="c3922-139">따라서 **BindToMethod** 가 인수 배열을 조작한 경우 **Binder** 를 사용하여 클라이언트가 인수 배열을 다시 원래 폼에 매핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-139">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="c3922-140">이 작업을 위해 호출자는 인수 순서가 변경되지 않도록 보장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-140">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="c3922-141">인수가 이름으로 저장되면 **Binder** 는 인수 배열을 다시 정렬하고 호출자는 이 순서를 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-141">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="c3922-142">자세한 내용은 <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c3922-142">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c3922-143">사용 가능한 멤버 집합은 형식 또는 기본 형식에 정의된 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-143">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="c3922-144"><xref:System.Reflection.BindingFlags>가 지정되면 접근성이 있는 멤버가 집합에 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-144">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="c3922-145">**BindingFlags.NonPublic** 이 지정되지 않으면 바인더가 접근성 규칙을 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-145">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="c3922-146">**Public** 또는 **NonPublic** 바인딩 플래그를 지정할 경우에는 **Instance** 또는 **Static** 바인딩 플래그도 지정해야 합니다. 그렇지 않으면 멤버가 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-146">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="c3922-147">지정된 이름의 멤버가 하나만 있는 경우에는 콜백이 필요하지 않고 바인딩이 해당 메서드에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-147">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="c3922-148">코드 예제의 사례 1은 이러한 점을 보여줍니다. 하나의 **PrintBob** 메서드만 사용할 수 있으므로 콜백이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-148">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="c3922-149">사용 가능한 집합에 두 개 이상의 멤버가 있으면 이러한 메서드가 모두 적절한 메서드를 선택하고 반환하는 **BindToMethod** 에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-149">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="c3922-150">코드 예제의 사례 2에는 **PrintValue** 라는 두 개의 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-150">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="c3922-151">**BindToMethod** 를 호출하여 적절한 메서드를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-151">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="c3922-152"><xref:System.Reflection.Binder.ChangeType%2A>은 실제 인수를 선택된 메서드의 형식 인수 형식으로 변환하는 인수 강제 변환(형식 변환)을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-152"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="c3922-153">형식이 정확히 일치하는 경우에도 모든 인수에 대해 **ChangeType** 이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-153">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="c3922-154">코드 예제의 사례 3에서 값이 5.5인 **String** 형식의 실제 인수가 **Double** 형식의 형식 인수와 함께 메서드에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-154">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="c3922-155">호출이 성공하려면 문자열 값 "5.5"가 double 값으로 변환되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-155">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="c3922-156">**ChangeType** 이 이 변환을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-156">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="c3922-157">**ChangeType** 은 다음 표에 나와 있는 대로 무손실 또는 [확대 강제 변환](../../standard/base-types/type-conversion.md)을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-157">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="c3922-158">소스 형식</span><span class="sxs-lookup"><span data-stu-id="c3922-158">Source type</span></span>|<span data-ttu-id="c3922-159">대상 형식</span><span class="sxs-lookup"><span data-stu-id="c3922-159">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="c3922-160">모든 형식</span><span class="sxs-lookup"><span data-stu-id="c3922-160">Any type</span></span>|<span data-ttu-id="c3922-161">기본 형식</span><span class="sxs-lookup"><span data-stu-id="c3922-161">Its base type</span></span>|  
|<span data-ttu-id="c3922-162">모든 형식</span><span class="sxs-lookup"><span data-stu-id="c3922-162">Any type</span></span>|<span data-ttu-id="c3922-163">구현되는 인터페이스</span><span class="sxs-lookup"><span data-stu-id="c3922-163">Interface it implements</span></span>|  
|<span data-ttu-id="c3922-164">Char</span><span class="sxs-lookup"><span data-stu-id="c3922-164">Char</span></span>|<span data-ttu-id="c3922-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="c3922-166">Byte</span><span class="sxs-lookup"><span data-stu-id="c3922-166">Byte</span></span>|<span data-ttu-id="c3922-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="c3922-168">SByte</span><span class="sxs-lookup"><span data-stu-id="c3922-168">SByte</span></span>|<span data-ttu-id="c3922-169">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-169">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="c3922-170">UInt16</span><span class="sxs-lookup"><span data-stu-id="c3922-170">UInt16</span></span>|<span data-ttu-id="c3922-171">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-171">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="c3922-172">Int16</span><span class="sxs-lookup"><span data-stu-id="c3922-172">Int16</span></span>|<span data-ttu-id="c3922-173">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-173">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="c3922-174">UInt32</span><span class="sxs-lookup"><span data-stu-id="c3922-174">UInt32</span></span>|<span data-ttu-id="c3922-175">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-175">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="c3922-176">Int32</span><span class="sxs-lookup"><span data-stu-id="c3922-176">Int32</span></span>|<span data-ttu-id="c3922-177">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-177">Int64, Single, Double</span></span>|  
|<span data-ttu-id="c3922-178">UInt64</span><span class="sxs-lookup"><span data-stu-id="c3922-178">UInt64</span></span>|<span data-ttu-id="c3922-179">Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-179">Single, Double</span></span>|  
|<span data-ttu-id="c3922-180">Int64</span><span class="sxs-lookup"><span data-stu-id="c3922-180">Int64</span></span>|<span data-ttu-id="c3922-181">Single, Double</span><span class="sxs-lookup"><span data-stu-id="c3922-181">Single, Double</span></span>|  
|<span data-ttu-id="c3922-182">Single</span><span class="sxs-lookup"><span data-stu-id="c3922-182">Single</span></span>|<span data-ttu-id="c3922-183">Double</span><span class="sxs-lookup"><span data-stu-id="c3922-183">Double</span></span>|  
|<span data-ttu-id="c3922-184">비참조 형식</span><span class="sxs-lookup"><span data-stu-id="c3922-184">Nonreference type</span></span>|<span data-ttu-id="c3922-185">참조 형식</span><span class="sxs-lookup"><span data-stu-id="c3922-185">Reference type</span></span>|  
  
 <span data-ttu-id="c3922-186"><xref:System.Type> 클래스에는 **Binder** 형식의 매개 변수를 사용하여 특정 멤버에 대한 참조를 확인하는 **Get** 메서드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-186">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="c3922-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> 및 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType>는 해당 멤버에 대한 시그니처 정보를 제공하여 현재 형식의 특정 멤버를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="c3922-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType>는 해당하는 메서드의 지정된 시그니처 정보를 선택하기 위해 콜백됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3922-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c3922-189">참조</span><span class="sxs-lookup"><span data-stu-id="c3922-189">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="c3922-190">형식 정보 보기</span><span class="sxs-lookup"><span data-stu-id="c3922-190">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="c3922-191">.NET Framework의 형식 변환</span><span class="sxs-lookup"><span data-stu-id="c3922-191">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
