---
title: 리플렉션 내보내기의 보안 문제점
description: 동적 어셈블리 또는 기존 어셈블리와 연결되거나 익명으로 호스팅된 동적 메서드를 통해 수행되는 리플렉션 내보내기의 보안 문제점을 파악합니다.
ms.date: 03/30/2017
helpviewer_keywords:
- partially trusted code
- emitting dynamic assemblies, security
- reflection emit, security
- reflection emit, partial trust scenarios
- partial trust,emitting dynamic methods
- anonymously hosted dynamic methods [.NET Framework]
- emitting dynamic assemblies,partial trust scenarios
- dynamic assemblies, security
ms.assetid: 0f8bf8fa-b993-478f-87ab-1a1a7976d298
ms.openlocfilehash: 859c564e107fd3a9b219d71dc6ac5ccdf6e9d690
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96259280"
---
# <a name="security-issues-in-reflection-emit"></a><span data-ttu-id="e6dd4-103">리플렉션 내보내기의 보안 문제점</span><span class="sxs-lookup"><span data-stu-id="e6dd4-103">Security Issues in Reflection Emit</span></span>

<span data-ttu-id="e6dd4-104">.NET Framework에서는 MSIL(Microsoft Intermediate Language)을 내보내는 세 가지 방법을 제공하며, 각각 고유한 보안 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-104">The .NET Framework provides three ways to emit Microsoft intermediate language (MSIL), each with its own security issues:</span></span>  
  
- [<span data-ttu-id="e6dd4-105">동적 어셈블리</span><span class="sxs-lookup"><span data-stu-id="e6dd4-105">Dynamic assemblies</span></span>](#Dynamic_Assemblies)  
  
- [<span data-ttu-id="e6dd4-106">익명으로 호스트된 동적 메서드</span><span class="sxs-lookup"><span data-stu-id="e6dd4-106">Anonymously hosted dynamic methods</span></span>](#Anonymously_Hosted_Dynamic_Methods)  
  
- [<span data-ttu-id="e6dd4-107">기존 어셈블리와 연결된 동적 메서드</span><span class="sxs-lookup"><span data-stu-id="e6dd4-107">Dynamic methods associated with existing assemblies</span></span>](#Dynamic_Methods_Associated_with_Existing_Assemblies)  
  
 <span data-ttu-id="e6dd4-108">동적 코드를 생성하는 방법에 관계없이 생성된 코드를 실행하려면 생성된 코드가 사용하는 형식 및 메서드에 필요한 모든 권한이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-108">Regardless of the way you generate dynamic code, executing the generated code requires all the permissions that are required by the types and methods the generated code uses.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-109">.NET Framework의 이후 릴리스에서는 코드에 반영하고 코드를 내보내는 데 필요한 권한이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-109">The permissions that are required for reflecting on code and emitting code have changed with succeeding releases of the .NET Framework.</span></span> <span data-ttu-id="e6dd4-110">이 항목의 뒷부분에 있는 [버전 정보](#Version_Information)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-110">See [Version Information](#Version_Information), later in this topic.</span></span>  
  
<a name="Dynamic_Assemblies"></a>

## <a name="dynamic-assemblies"></a><span data-ttu-id="e6dd4-111">동적 어셈블리</span><span class="sxs-lookup"><span data-stu-id="e6dd4-111">Dynamic Assemblies</span></span>  

 <span data-ttu-id="e6dd4-112">동적 어셈블리는 <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType> 메서드의 오버로드를 사용하여 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-112">Dynamic assemblies are created by using overloads of the <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e6dd4-113">이 메서드의 오버로드는 시스템 수준의 보안 정책이 제거되어 .NET Framework 4에서 대부분 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-113">Most overloads of this method are deprecated in the .NET Framework 4, because of the elimination of machine-wide security policy.</span></span> <span data-ttu-id="e6dd4-114">[보안 변경 내용](/previous-versions/dotnet/framework/security/security-changes)을 참조하세요. 나머지 오버로드는 신뢰 수준에 관계없이 모든 코드에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-114">(See [Security Changes](/previous-versions/dotnet/framework/security/security-changes).) The remaining overloads can be executed by any code, regardless of trust level.</span></span> <span data-ttu-id="e6dd4-115">이러한 오버로드는 만들 때 동적 어셈블리에 적용할 특성 목록을 지정하는 오버로드와 그러지 않은 오버로드의 두 그룹으로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-115">These overloads fall into two groups: those that specify a list of attributes to apply to the dynamic assembly when it is created, and those that do not.</span></span> <span data-ttu-id="e6dd4-116">어셈블리를 만들 때 <xref:System.Security.SecurityRulesAttribute> 특성을 적용하여 어셈블리에 대한 투명도 모델을 지정하지 않을 경우 내보내는 어셈블리에서 투명도 모델이 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-116">If you do not specify the transparency model for the assembly, by applying the <xref:System.Security.SecurityRulesAttribute> attribute when you create it, the transparency model is inherited from the emitting assembly.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-117">동적 어셈블리를 만든 후에 <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> 메서드를 사용하여 적용하는 특성은 어셈블리를 디스크에 저장하고 메모리에 다시 로드할 때까지 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-117">Attributes that you apply to the dynamic assembly after it is created, by using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method, do not take effect until the assembly has been saved to disk and loaded into memory again.</span></span>  
  
 <span data-ttu-id="e6dd4-118">동적 어셈블리의 코드는 다른 어셈블리에 표시되는 형식 및 멤버에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-118">Code in a dynamic assembly can access visible types and members in other assemblies.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-119">동적 어셈블리는 동적 멤버가 public이 아닌 형식 및 멤버에 액세스할 수 있도록 허용하는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 및 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-119">Dynamic assemblies do not use the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> and <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flags that allow dynamic methods to access nonpublic types and members.</span></span>  
  
 <span data-ttu-id="e6dd4-120">임시 동적 어셈블리는 메모리에 만들어지고 디스크에 저장되지 않으므로 파일 액세스 권한이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-120">Transient dynamic assemblies are created in memory and never saved to disk, so they require no file access permissions.</span></span> <span data-ttu-id="e6dd4-121">동적 어셈블리를 디스크에 저장하려면 적절한 플래그가 있는 <xref:System.Security.Permissions.FileIOPermission>이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-121">Saving a dynamic assembly to disk requires <xref:System.Security.Permissions.FileIOPermission> with the appropriate flags.</span></span>  
  
### <a name="generating-dynamic-assemblies-from-partially-trusted-code"></a><span data-ttu-id="e6dd4-122">부분적으로 신뢰할 수 있는 코드에서 동적 어셈블리 생성</span><span class="sxs-lookup"><span data-stu-id="e6dd4-122">Generating Dynamic Assemblies from Partially Trusted Code</span></span>  

 <span data-ttu-id="e6dd4-123">인터넷 권한이 있는 어셈블리가 임시 동적 어셈블리를 생성하고 해당 코드를 실행할 수 있는 다음 조건을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-123">Consider the conditions in which an assembly with Internet permissions can generate a transient dynamic assembly and execute its code:</span></span>  
  
- <span data-ttu-id="e6dd4-124">동적 어셈블리가 다른 어셈블리의 public 형식 및 멤버만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-124">The dynamic assembly uses only public types and members of other assemblies.</span></span>  
  
- <span data-ttu-id="e6dd4-125">이러한 형식과 멤버가 요구하는 권한이 부분적으로 신뢰할 수 있는 어셈블리의 권한 부여 집합에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-125">The permissions demanded by those types and members are included in the grant set of the partially trusted assembly.</span></span>  
  
- <span data-ttu-id="e6dd4-126">어셈블리가 디스크에 저장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-126">The assembly is not saved to disk.</span></span>  
  
- <span data-ttu-id="e6dd4-127">디버그 기호가 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-127">Debug symbols are not generated.</span></span> <span data-ttu-id="e6dd4-128">`Internet` 및 `LocalIntranet` 권한 집합에는 필요한 권한이 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-128">(`Internet` and `LocalIntranet` permission sets do not include the necessary permissions.)</span></span>  
  
<a name="Anonymously_Hosted_Dynamic_Methods"></a>

## <a name="anonymously-hosted-dynamic-methods"></a><span data-ttu-id="e6dd4-129">익명으로 호스트된 동적 메서드</span><span class="sxs-lookup"><span data-stu-id="e6dd4-129">Anonymously Hosted Dynamic Methods</span></span>  

 <span data-ttu-id="e6dd4-130">익명으로 호스트된 동적 메서드는 연결된 형식이나 모듈을 지정하지 않는 두 개의 <xref:System.Reflection.Emit.DynamicMethod> 생성자인 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> 및 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>를 사용하여 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-130">Anonymously hosted dynamic methods are created by using the two <xref:System.Reflection.Emit.DynamicMethod> constructors that do not specify an associated type or module, <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> and <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="e6dd4-131">이러한 생성자는 완전히 신뢰할 수 있는 시스템 제공 보안 투명 어셈블리에 동적 메서드를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-131">These constructors place the dynamic methods in a system-provided, fully trusted, security-transparent assembly.</span></span> <span data-ttu-id="e6dd4-132">이 생성자를 사용하거나 동적 메서드에 대한 코드를 내보내는 데 필요한 권한은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-132">No permissions are required to use these constructors or to emit code for the dynamic methods.</span></span>  
  
 <span data-ttu-id="e6dd4-133">대신 익명으로 호스트된 동적 메서드를 만들 때 호출 스택이 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-133">Instead, when an anonymously hosted dynamic method is created, the call stack is captured.</span></span> <span data-ttu-id="e6dd4-134">메서드를 생성할 때 캡처된 호출 스택에 대해 보안 요구가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-134">When the method is constructed, security demands are made against the captured call stack.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-135">개념적으로, 메서드의 생성하는 동안 요구가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-135">Conceptually, demands are made during the construction of the method.</span></span> <span data-ttu-id="e6dd4-136">즉, 각 MSIL 명령을 내보낼 때 요구를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-136">That is, demands could be made as each MSIL instruction is emitted.</span></span> <span data-ttu-id="e6dd4-137">현재 구현에서는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>를 호출하지 않고 메서드가 호출된 경우 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> 메서드를 호출하거나 JIT(Just-In-Time) 컴파일러를 호출할 때 모든 요구가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-137">In the current implementation, all demands are made when the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> method is called or when the just-in-time (JIT) compiler is invoked, if the method is invoked without calling <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>.</span></span>  
  
 <span data-ttu-id="e6dd4-138">애플리케이션 도메인에서 허용하는 경우, 익명으로 호스트되는 동적 메서드는 다음 제한 사항에 따라 JIT 가시성 검사를 건너뛸 수 있습니다. 익명으로 호스트되는 동적 메서드로 액세스되는 비공개 형식과 멤버는 내보내기 호출 스택의 해당 권한 부여 집합과 같거나 하위 집합인 어셈블리에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-138">If the application domain permits it, anonymously hosted dynamic methods can skip JIT visibility checks, subject to the following restriction: The nonpublic types and members accessed by an anonymously hosted dynamic method must be in assemblies whose grant sets are equal to, or subsets of, the grant set of the emitting call stack.</span></span> <span data-ttu-id="e6dd4-139">JIT 가시성 검사를 건너뛸 수 있는 이 제한된 기능은 애플리케이션 도메인에서 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그로 <xref:System.Security.Permissions.ReflectionPermission> 권한을 부여하는 경우에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-139">This restricted ability to skip JIT visibility checks is enabled if the application domain grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="e6dd4-140">메서드가 public 형식 및 멤버만 사용하는 경우에는 생성 중 권한이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-140">If your method uses only public types and members, no permissions are required during construction.</span></span>  
  
- <span data-ttu-id="e6dd4-141">JIT 가시성 검사를 건너뛰도록 지정하면 메서드를 생성할 때 수행되는 요구에 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission> 및 액세스되는 public이 아닌 멤버를 포함하는 어셈블리의 권한 부여 집합이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-141">If you specify that JIT visibility checks should be skipped, the demand that is made when the method is constructed includes <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and the grant set of the assembly that contains the nonpublic member that is being accessed.</span></span>  
  
 <span data-ttu-id="e6dd4-142">public이 아닌 멤버의 권한 부여 집합을 고려하기 때문에 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 권한이 부여된 부분적으로 신뢰할 수 있는 코드는 신뢰할 수 있는 어셈블리의 public이 아닌 멤버를 실행하여 권한을 높일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-142">Because the grant set of the nonpublic member is taken into consideration, partially trusted code that has been granted <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> cannot elevate its privileges by executing nonpublic members of trusted assemblies.</span></span>  
  
 <span data-ttu-id="e6dd4-143">다른 내보낸 코드와 마찬가지로, 동적 메서드를 실행하려면 동적 메서드가 사용하는 메서드에서 요구하는 권한이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-143">As with any other emitted code, executing the dynamic method requires whatever permissions are demanded by the methods the dynamic method uses.</span></span>  
  
 <span data-ttu-id="e6dd4-144">익명으로 호스트된 동적 메서드를 호스트하는 시스템 어셈블리는 .NET Framework 4 이전의 .NET Framework에서 사용된 투명도 모델인 <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType> 투명도 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-144">The system assembly that hosts anonymously-hosted dynamic methods uses the <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType> transparency model, which is the transparency model that was used in the .NET Framework before the .NET Framework 4.</span></span>  
  
 <span data-ttu-id="e6dd4-145">자세한 내용은 <xref:System.Reflection.Emit.DynamicMethod> 클래스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-145">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-anonymously-hosted-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="e6dd4-146">부분적으로 신뢰할 수 있는 코드에서 익명으로 호스트된 동적 메서드 생성</span><span class="sxs-lookup"><span data-stu-id="e6dd4-146">Generating Anonymously Hosted Dynamic Methods from Partially Trusted Code</span></span>  

 <span data-ttu-id="e6dd4-147">인터넷 권한이 있는 어셈블리가 익명으로 호스트된 동적 메서드를 생성하고 실행할 수 있는 다음 조건을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-147">Consider the conditions in which an assembly with Internet permissions can generate an anonymously hosted dynamic method and execute it:</span></span>  
  
- <span data-ttu-id="e6dd4-148">동적 메서드가 public 형식 및 멤버만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-148">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="e6dd4-149">권한 부여 집합에 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>가 포함된 경우 권한 부여 집합이 내보내는 어셈블리의 권한 부여 집합과 같거나 하위 집합인 어셈블리의 public이 아닌 형식 및 멤버를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-149">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, it can use nonpublic types and members of any assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
- <span data-ttu-id="e6dd4-150">동적 메서드가 사용하는 모든 형식과 멤버에 필요한 권한이 부분적으로 신뢰할 수 있는 어셈블리의 권한 부여 집합에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-150">The permissions that are required by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-151">동적 메서드가 디버그 기호를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-151">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Dynamic_Methods_Associated_with_Existing_Assemblies"></a>

## <a name="dynamic-methods-associated-with-existing-assemblies"></a><span data-ttu-id="e6dd4-152">기존 어셈블리와 연결된 동적 메서드</span><span class="sxs-lookup"><span data-stu-id="e6dd4-152">Dynamic Methods Associated with Existing Assemblies</span></span>  

 <span data-ttu-id="e6dd4-153">동적 메서드를 기존 어셈블리의 형식이나 모듈에 연결하려면 연결된 형식이나 모듈을 지정하는 <xref:System.Reflection.Emit.DynamicMethod> 생성자 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-153">To associate a dynamic method with a type or module in an existing assembly, use any of the <xref:System.Reflection.Emit.DynamicMethod> constructors that specify the associated type or module.</span></span> <span data-ttu-id="e6dd4-154">동적 메서드를 기존 형식이나 모듈에 연결하면 동적 메서드가 public이 아닌 형식과 멤버에 액세스할 수 있으므로 이 생성자를 호출하는 데 필요한 권한은 경우에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-154">The permissions that are required to call these constructors vary, because associating a dynamic method with an existing type or module gives the dynamic method access to nonpublic types and members:</span></span>  
  
- <span data-ttu-id="e6dd4-155">형식과 연결된 동적 메서드는 private 멤버를 비롯한 해당 형식의 모든 멤버와 연결된 형식을 포함하는 어셈블리의 모든 내부 형식과 멤버에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-155">A dynamic method that is associated with a type has access to all members of that type, even private members, and to all internal types and members in the assembly that contains the associated type.</span></span>  
  
- <span data-ttu-id="e6dd4-156">모듈과 연결된 동적 메서드는 모듈의 모든 `internal` 형식과 멤버(Visual Basic에서는 `Friend`, 공용 언어 런타임 메타데이터에서는 `assembly`)에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-156">A dynamic method that is associated with a module has access to all the `internal` types and members (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the module.</span></span>  
  
 <span data-ttu-id="e6dd4-157">또한 JIT 컴파일러의 가시성 검사를 건너뛰는 기능을 지정하는 생성자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-157">In addition, you can use a constructor that specifies the ability to skip the visibility checks of the JIT compiler.</span></span> <span data-ttu-id="e6dd4-158">이렇게 하면 동적 메서드가 액세스 수준에 관계없이 모든 어셈블리의 모든 형식과 멤버에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-158">Doing so gives your dynamic method access to all types and members in all assemblies, regardless of access level.</span></span>  
  
 <span data-ttu-id="e6dd4-159">생성자가 요구하는 권한은 동적 메서드에 제공할 액세스 권한에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-159">The permissions demanded by the constructor depend on how much access you decide to give your dynamic method:</span></span>  
  
- <span data-ttu-id="e6dd4-160">메서드가 public 형식과 멤버만 사용하고 메서드를 고유한 형식이나 모듈에 연결하는 경우에는 권한이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-160">If your method uses only public types and members, and you associate it with your own type or your own module, no permissions are required.</span></span>  
  
- <span data-ttu-id="e6dd4-161">JIT 가시성 검사를 건너뛰도록 지정하는 경우 생성자는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-161">If you specify that JIT visibility checks should be skipped, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="e6dd4-162">고유한 어셈블리의 다른 형식을 포함하여 다른 형식에 동적 메서드를 연결하는 경우 생성자는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission> 및 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.SecurityPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-162">If you associate the dynamic method with another type, even another type in your own assembly, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag and <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="e6dd4-163">다른 어셈블리의 형식이나 모듈에 동적 메서드를 연결하는 경우 생성자는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission> 및 다른 모듈을 포함하는 어셈블리의 권한 부여 집합을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-163">If you associate the dynamic method with a type or module in another assembly, the constructor demands two things: <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, and the grant set of the assembly that contains the other module.</span></span> <span data-ttu-id="e6dd4-164">즉, 호출 스택에 대상 모듈의 권한 부여 집합에 있는 모든 권한과 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>가 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-164">That is, your call stack must include all the permissions in the grant set of the target module, plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="e6dd4-165">대상 권한 부여 집합 및 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 요구가 실패할 경우 생성자는 이전 버전과의 호환성을 위해 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.SecurityPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-165">For backward compatibility, if the demand for the target grant set plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> fails, the constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="e6dd4-166">이 목록의 항목은 내보내는 어셈블리의 권한 부여 집합 측면에서 설명하지만 요구는 애플리케이션 도메인 경계를 포함하여 전체 호출 스택에 대해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-166">Although the items in this list are described in terms of the grant set of the emitting assembly, remember that the demands are made against the full call stack, including the application domain boundary.</span></span>  
  
 <span data-ttu-id="e6dd4-167">자세한 내용은 <xref:System.Reflection.Emit.DynamicMethod> 클래스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-167">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="e6dd4-168">부분적으로 신뢰할 수 있는 코드에서 동적 메서드 생성</span><span class="sxs-lookup"><span data-stu-id="e6dd4-168">Generating Dynamic Methods from Partially Trusted Code</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-169">부분적으로 신뢰할 수 있는 코드에서 동적 메서드를 생성하는 경우 [익명으로 호스트된 동적 메서드](#Anonymously_Hosted_Dynamic_Methods)를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-169">The recommended way to generate dynamic methods from partially trusted code is to use [anonymously hosted dynamic methods](#Anonymously_Hosted_Dynamic_Methods).</span></span>  
  
 <span data-ttu-id="e6dd4-170">인터넷 권한이 있는 어셈블리가 동적 메서드를 생성하고 실행할 수 있는 다음 조건을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-170">Consider the conditions in which an assembly with Internet permissions can generate a dynamic method and execute it:</span></span>  
  
- <span data-ttu-id="e6dd4-171">동적 메서드가 메서드를 내보내는 모듈 또는 형식과 연결되어 있거나, 해당 권한 부여 집합이 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>를 포함하며 권한 부여 집합이 내보내는 어셈블리의 권한 부여 집합과 같거나 하위 집합인 어셈블리의 모듈과 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-171">Either the dynamic method is associated with the module or type that emits it, or its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
- <span data-ttu-id="e6dd4-172">동적 메서드가 public 형식 및 멤버만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-172">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="e6dd4-173">해당 권한 부여 집합이 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>를 포함하며 권한 부여 집합이 내보내는 어셈블리의 권한 부여 집합과 같거나 하위 집합인 어셈블리의 모듈과 연결된 경우 연결된 모듈에서 `internal`(Visual Basic에서는 `Friend`, 공용 언어 런타임 메타데이터에서는 `assembly`)로 표시된 형식과 멤버를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-173">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly, it can use types and members marked `internal` (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the associated module.</span></span>  
  
- <span data-ttu-id="e6dd4-174">동적 메서드가 사용하는 모든 형식과 멤버가 요구하는 권한이 부분적으로 신뢰할 수 있는 어셈블리의 권한 부여 집합에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-174">The permissions demanded by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
- <span data-ttu-id="e6dd4-175">동적 메서드가 JIT 가시성 검사를 건너뛰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-175">The dynamic method does not skip JIT visibility checks.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-176">동적 메서드가 디버그 기호를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-176">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Version_Information"></a>

## <a name="version-information"></a><span data-ttu-id="e6dd4-177">버전 정보</span><span class="sxs-lookup"><span data-stu-id="e6dd4-177">Version Information</span></span>  

 <span data-ttu-id="e6dd4-178">.NET Framework 4부터 시스템 수준의 보안 정책이 제거되었으며 보안 투명도가 기본 적용 메커니즘이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-178">Starting with the .NET Framework 4, machine-wide security policy is eliminated and security transparency becomes the default enforcement mechanism.</span></span> <span data-ttu-id="e6dd4-179">[보안 변경 내용](/previous-versions/dotnet/framework/security/security-changes)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-179">See [Security Changes](/previous-versions/dotnet/framework/security/security-changes).</span></span>  
  
 <span data-ttu-id="e6dd4-180">.NET Framework 2.0 Service Pack 1부터 동적 어셈블리와 동적 메서드를 내보낼 때 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission>이 더 이상 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-180">Starting with the .NET Framework 2.0 Service Pack 1, <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is no longer required when emitting dynamic assemblies and dynamic methods.</span></span> <span data-ttu-id="e6dd4-181">이 플래그는 .NET Framework의 모든 이전 버전에서 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-181">This flag is required in all earlier versions of the .NET Framework.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6dd4-182"><xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission>은 기본적으로 명명된 권한 집합 `FullTrust` 및 `LocalIntranet` 에 포함되지만 `Internet` 권한 집합에는 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-182"><xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is included by default in the `FullTrust` and `LocalIntranet` named permission sets, but not in the `Internet` permission set.</span></span> <span data-ttu-id="e6dd4-183">따라서 이전 버전의 .NET Framework에서는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>에 대해 <xref:System.Security.PermissionSet.Assert%2A>를 실행하는 경우에만 인터넷 권한으로 라이브러리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-183">Therefore, in earlier versions of the .NET Framework, a library can be used with Internet permissions only if it executes an <xref:System.Security.PermissionSet.Assert%2A> for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="e6dd4-184">코딩 오류가 있을 경우 보안 허점이 발생할 수 있으므로 이러한 라이브러리는 신중한 보안 검토가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-184">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="e6dd4-185">.NET Framework 2.0 SP1에서는 코드 생성이 기본적으로 권한 있는 작업이 아니기 때문에 보안 요구를 실행하지 않고 부분 신뢰 시나리오에서 코드를 내보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-185">The .NET Framework 2.0 SP1 allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="e6dd4-186">즉, 생성된 코드에 코드를 내보내는 어셈블리보다 많은 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-186">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="e6dd4-187">따라서 코드를 내보내는 라이브러리가 보안상 투명할 수 있으며 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>를 어설션할 필요가 없으므로 보안 라이브러리 작성 작업이 간소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-187">This allows libraries that emit code to be security transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, which simplifies the task of writing a secure library.</span></span>  
  
 <span data-ttu-id="e6dd4-188">또한 .NET Framework 2.0 SP1에서는 부분적으로 신뢰할 수 있는 동적 메서드에서 public이 아닌 형식과 멤버에 액세스하기 위한 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그가 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-188">In addition, the .NET Framework 2.0 SP1 introduces the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag for accessing nonpublic types and members from partially trusted dynamic methods.</span></span> <span data-ttu-id="e6dd4-189">이전 버전의 .NET Framework에서는 public이 아닌 형식과 멤버에 액세스하는 동적 메서드에 대해 부분적으로 신뢰할 수 있는 코드에 부여하면 안 되는 권한인 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-189">Earlier versions of the .NET Framework require the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag for dynamic methods that access nonpublic types and members; this is a permission that should never be granted to partially trusted code.</span></span>  
  
 <span data-ttu-id="e6dd4-190">끝으로, .NET Framework 2.0 SP1에서는 익명으로 호스트된 메서드가 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-190">Finally, the .NET Framework 2.0 SP1 introduces anonymously hosted methods.</span></span>  
  
### <a name="obtaining-information-on-types-and-members"></a><span data-ttu-id="e6dd4-191">형식 및 멤버에 대한 정보 가져오기</span><span class="sxs-lookup"><span data-stu-id="e6dd4-191">Obtaining Information on Types and Members</span></span>  

 <span data-ttu-id="e6dd4-192">.NET Framework 2.0부터 public이 아닌 형식과 멤버에 대한 정보를 가져오는 데 필요한 권한은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-192">Starting with the .NET Framework 2.0, no permissions are required to obtain information about nonpublic types and members.</span></span> <span data-ttu-id="e6dd4-193">리플렉션을 사용하여 동적 메서드를 내보내는 데 필요한 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-193">Reflection is used to obtain information needed to emit dynamic methods.</span></span> <span data-ttu-id="e6dd4-194">예를 들어 <xref:System.Reflection.MethodInfo> 개체를 사용하여 메서드 호출을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-194">For example, <xref:System.Reflection.MethodInfo> objects are used to emit method calls.</span></span> <span data-ttu-id="e6dd4-195">이전 버전의 .NET Framework에서는 <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission>이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-195">Earlier versions of the .NET Framework require <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="e6dd4-196">자세한 내용은 [리플렉션의 보안 고려 사항](security-considerations-for-reflection.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e6dd4-196">For more information, see [Security Considerations for Reflection](security-considerations-for-reflection.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e6dd4-197">참조</span><span class="sxs-lookup"><span data-stu-id="e6dd4-197">See also</span></span>

- [<span data-ttu-id="e6dd4-198">리플렉션의 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="e6dd4-198">Security Considerations for Reflection</span></span>](security-considerations-for-reflection.md)
- [<span data-ttu-id="e6dd4-199">동적 메서드 및 어셈블리 내보내기</span><span class="sxs-lookup"><span data-stu-id="e6dd4-199">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
