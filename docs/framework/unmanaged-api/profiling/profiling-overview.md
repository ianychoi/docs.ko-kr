---
description: '자세한 정보: 프로 파일링 개요'
title: 프로파일링 개요
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: f83a4435f6a4a62a190383543cf824c76a54a838
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99798916"
---
# <a name="profiling-overview"></a><span data-ttu-id="20e14-103">프로파일링 개요</span><span class="sxs-lookup"><span data-stu-id="20e14-103">Profiling Overview</span></span>

<span data-ttu-id="20e14-104">프로파일러는 다른 응용 프로그램의 실행을 모니터링하는 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-104">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="20e14-105">CLR(공용 언어 런타임) 프로파일러는 프로 파일링 API를 사용하여 CLR에서 메시지를 받고 보내는 함수로 구성된 DLL(동적 연결 라이브러리)입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-105">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="20e14-106">프로파일러 DLL은 런타임에 CLR에 의해 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-106">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="20e14-107">기존의 프로파일링 도구는 애플리케이션의 실행 측정에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-107">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="20e14-108">즉, 각 함수에서 소요된 시간이나 시간 경과에 따른 애플리케이션의 메모리 사용량을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-108">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="20e14-109">프로파일링 API는 코드 검사 유틸리티 및 고급 디버깅 지원과 같은 광범위한 진단 도구 클래스를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-109">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="20e14-110">이러한 사용은 본질적으로 모두 진단입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-110">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="20e14-111">프로파일링 API는 애플리케이션의 실행을 측정할 뿐 아니라 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-111">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="20e14-112">이러한 이유로 프로파일링 API는 애플리케이션 자체에서 사용하면 안 되며, 애플리케이션의 실행이 프로파일러에 종속되거나 영향을 받아서도 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-112">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="20e14-113">CLR 애플리케이션을 프로파일링하려면 기존의 컴파일된 기계어 코드를 프로파일링하는 것보다 많은 지원이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-113">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="20e14-114">이는 CLR에서 애플리케이션 도메인, 가비지 컬렉션, 관리되는 예외 처리, 코드의 JIT(Just-In-Time) 컴파일(Microsoft Intermediate Language, 즉 MSIL 코드를 네이티브 기계어 코드로 변환) 및 비슷한 기능과 같은 개념을 도입하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-114">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="20e14-115">기존의 프로파일링 메커니즘은 이러한 기능에 대한 유용한 정보를 식별하거나 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-115">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="20e14-116">프로파일링 API는 CLR 및 프로파일링된 애플리케이션의 성능에 미치는 영향을 최소화하여 이 누락된 정보를 효율적으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-116">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="20e14-117">런타임의 JIT 컴파일은 프로파일링에 좋은 기회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-117">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="20e14-118">프로파일링 API를 통해 프로파일러는 JIT 컴파일되기 전에 루틴에 대한 메모리 내 MSIL 코드 스트림을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-118">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="20e14-119">이런 방식으로 프로파일러는 더 세부적인 조사가 필요한 특정 루틴에 계측 코드를 동적으로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-119">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="20e14-120">이 접근 방식은 기존 시나리오에서도 가능하지만 프로파일링 API를 사용하여 CLR에 대해 구현하는 것이 훨씬 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-120">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="20e14-121">프로파일링 API</span><span class="sxs-lookup"><span data-stu-id="20e14-121">The Profiling API</span></span>

<span data-ttu-id="20e14-122">일반적으로 프로 파일링 API는 관리 되는 응용 프로그램의 실행을 모니터링 하는 프로그램인 *코드 프로파일러* 를 작성 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-122">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="20e14-123">프로파일링 API는 프로파일링되는 애플리케이션과 동일한 프로세스에 로드된 프로파일러 DLL에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-123">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="20e14-124">프로파일러 DLL은 콜백 인터페이스 (.NET Framework 버전 1.0 및 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) 버전 2.0 이상)에서[ICorProfilerCallback](icorprofilercallback-interface.md) 를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-124">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="20e14-125">CLR은 해당 인터페이스의 메서드를 호출하여 프로파일링된 프로세스의 이벤트를 프로파일러에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-125">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="20e14-126">프로파일러는 [ICorProfilerInfo](icorprofilerinfo-interface.md) 및 [ICorProfilerInfo2](icorprofilerinfo2-interface.md) 인터페이스의 메서드를 사용 하 여 프로 파일링 된 응용 프로그램의 상태에 대 한 정보를 가져올 때 런타임으로 다시 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-126">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="20e14-127">프로파일러 솔루션의 데이터 수집 부분만 프로파일링된 애플리케이션과 동일한 프로세스에서 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-127">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="20e14-128">모든 사용자 인터페이스 및 데이터 분석은 별도 프로세스에서 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-128">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="20e14-129">다음 그림에서는 프로파일러 DLL이 프로파일링되는 애플리케이션 및 CLR과 상호 작용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-129">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![프로 파일링 아키텍처를 보여 주는 스크린샷](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="20e14-131">알림 인터페이스</span><span class="sxs-lookup"><span data-stu-id="20e14-131">The Notification Interfaces</span></span>

<span data-ttu-id="20e14-132">[ICorProfilerCallback](icorprofilercallback-interface.md) 및 [ICorProfilerCallback2](icorprofilercallback2-interface.md) 는 알림 인터페이스로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-132">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="20e14-133">이러한 인터페이스는 [Classloadstarted](icorprofilercallback-classloadstarted-method.md), [Classloadstarted](icorprofilercallback-classloadfinished-method.md)및 [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md)와 같은 메서드로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-133">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="20e14-134">CLR은 클래스를 로드 또는 언로드하고 함수를 컴파일할 때마다 프로파일러의 `ICorProfilerCallback` 또는 `ICorProfilerCallback2` 인터페이스에서 해당 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-134">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="20e14-135">예를 들어 프로파일러가 [FunctionEnter2](functionenter2-function.md) 및 [FunctionLeave2](functionleave2-function.md)의 두 가지 알림 함수를 통해 코드 성능을 측정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-135">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="20e14-136">단순히 각 알림에 타임스탬프를 지정하고, 결과를 누적한 다음 애플리케이션 실행 중에 가장 많은 CPU 또는 벽시계 시간을 사용한 함수를 나타내는 목록을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-136">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="20e14-137">정보 검색 인터페이스</span><span class="sxs-lookup"><span data-stu-id="20e14-137">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="20e14-138">프로 파일링과 관련 된 다른 주요 인터페이스는 [ICorProfilerInfo](icorprofilerinfo-interface.md) 및 [ICorProfilerInfo2](icorprofilerinfo2-interface.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-138">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="20e14-139">프로파일러는 필요에 따라 이러한 인터페이스를 호출하여 분석에 도움이 되는 자세한 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-139">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="20e14-140">예를 들어 CLR은 [FunctionEnter2](functionenter2-function.md) 함수를 호출할 때마다 함수 식별자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-140">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="20e14-141">프로파일러는 [ICorProfilerInfo2:: GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) 메서드를 호출 하 여 함수의 부모 클래스, 해당 이름 등을 검색 하 여 해당 함수에 대 한 자세한 정보를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-141">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="20e14-142">지원되는 기능</span><span class="sxs-lookup"><span data-stu-id="20e14-142">Supported Features</span></span>

<span data-ttu-id="20e14-143">프로파일링 API는 공용 언어 런타임에서 발생하는 다양한 이벤트와 작업에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-143">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="20e14-144">이 정보를 사용하여 프로세스의 내부 작업을 모니터링하고 .NET Framework 애플리케이션의 성능을 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-144">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="20e14-145">프로파일링 API는 CLR에서 발생하는 다음 작업 및 이벤트에 대한 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-145">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="20e14-146">CLR 시작 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-146">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="20e14-147">애플리케이션 도메인 생성 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-147">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="20e14-148">어셈블리 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-148">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="20e14-149">모듈 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-149">Module loading and unloading events.</span></span>

- <span data-ttu-id="20e14-150">COM vtable 생성 및 소멸 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-150">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="20e14-151">JIT(Just-In-Time) 컴파일 및 코드 피칭 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-151">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="20e14-152">클래스 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-152">Class loading and unloading events.</span></span>

- <span data-ttu-id="20e14-153">스레드 생성 및 소멸 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-153">Thread creation and destruction events.</span></span>

- <span data-ttu-id="20e14-154">함수 진입 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="20e14-154">Function entry and exit events.</span></span>

- <span data-ttu-id="20e14-155">예외.</span><span class="sxs-lookup"><span data-stu-id="20e14-155">Exceptions.</span></span>

- <span data-ttu-id="20e14-156">관리 코드와 비관리 코드 실행 간의 전환</span><span class="sxs-lookup"><span data-stu-id="20e14-156">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="20e14-157">다양한 런타임 컨텍스트 간의 전환</span><span class="sxs-lookup"><span data-stu-id="20e14-157">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="20e14-158">런타임 일시 중단에 대한 정보</span><span class="sxs-lookup"><span data-stu-id="20e14-158">Information about runtime suspensions.</span></span>

- <span data-ttu-id="20e14-159">런타임 메모리 힙 및 가비지 수집 작업에 대한 정보</span><span class="sxs-lookup"><span data-stu-id="20e14-159">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="20e14-160">모든(관리되지 않는) COM 호환 언어에서 프로파일링 API를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-160">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="20e14-161">이 API는 CPU 및 메모리 사용과 관련해서 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-161">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="20e14-162">프로파일링에서는 프로파일링된 애플리케이션에 대해 잘못된 결과를 일으킬 만큼 중요한 변경 작업을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-162">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="20e14-163">프로파일링 API는 샘플링 및 비샘플링 프로파일러 둘 다에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-163">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="20e14-164">*샘플링 프로파일러* 는 일반 클록 틱, 즉 5 밀리초 간격으로 프로필을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-164">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="20e14-165">*비 샘플링 프로파일러* 는 이벤트를 발생 시키는 스레드를 사용 하 여 동기적으로 이벤트를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-165">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="20e14-166">지원되지 않는 기능</span><span class="sxs-lookup"><span data-stu-id="20e14-166">Unsupported Functionality</span></span>

<span data-ttu-id="20e14-167">프로파일링 API에서는 다음 기능을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-167">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="20e14-168">기존의 Win32 메서드를 통해 프로파일링해야 하는 비관리 코드.</span><span class="sxs-lookup"><span data-stu-id="20e14-168">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="20e14-169">그러나 CLR 프로파일러에는 관리 코드와 비관리 코드 간의 경계를 결정하는 전환 이벤트가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-169">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="20e14-170">관점 지향 프로그래밍과 같은 목적을 위해 해당 코드를 수정하는 자체 수정 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="20e14-170">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="20e14-171">범위 검사. 프로파일링 API에서 이 정보를 제공하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-171">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="20e14-172">CLR은 모든 관리 코드의 범위 검사를 기본적으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-172">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="20e14-173">원격 프로파일링. 다음과 같은 이유로 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-173">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="20e14-174">원격 프로파일링은 실행 시간을 연장합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-174">Remote profiling extends execution time.</span></span> <span data-ttu-id="20e14-175">프로파일링 인터페이스를 사용하는 경우 프로파일링 결과가 과도한 영향을 받지 않도록 실행 시간을 최소화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-175">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="20e14-176">이는 실행 성능을 모니터링하는 경우 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-176">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="20e14-177">그러나 원격 프로파일링은 프로파일링 인터페이스를 사용하여 메모리 사용량을 모니터링하거나 스택 프레임, 개체 등에 대한 런타임 정보를 가져올 때 제한 사항이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-177">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="20e14-178">CLR 코드 프로파일러는 프로파일링된 애플리케이션이 실행되고 있는 로컬 컴퓨터에서 런타임에 하나 이상의 콜백 인터페이스를 등록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-178">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="20e14-179">이로 인해 원격 코드 프로파일러를 만드는 기능이 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-179">This limits the ability to create a remote code profiler.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="20e14-180">알림 스레드</span><span class="sxs-lookup"><span data-stu-id="20e14-180">Notification Threads</span></span>

<span data-ttu-id="20e14-181">대부분의 경우 이벤트를 생성하는 스레드도 알림을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-181">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="20e14-182">이러한 알림 (예: [Functionenter](functionenter-function.md) 및 [functionenter](functionleave-function.md))은 명시적를 제공할 필요가 없습니다 `ThreadID` .</span><span class="sxs-lookup"><span data-stu-id="20e14-182">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="20e14-183">또한 프로파일러는 영향을 받는 스레드의 `ThreadID`에 따라, 전역 스토리지의 분석 블록을 인덱싱하는 대신 스레드 로컬 스토리지를 사용하여 분석 블록을 저장 및 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-183">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="20e14-184">이러한 콜백은 직렬화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-184">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="20e14-185">사용자는 스레드로부터 안전한 데이터 구조를 만들고 여러 스레드에서의 병렬 액세스를 방지하기 위해 필요에 따라 프로파일러 코드를 잠가 코드를 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-185">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="20e14-186">따라서 특정 경우에서는 사용자가 평소와 다른 콜백 시퀀스를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-186">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="20e14-187">예를 들어 관리되는 애플리케이션이 동일한 코드를 실행하는 두 스레드를 생성한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-187">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="20e14-188">이 경우 [](icorprofilercallback-jitcompilationstarted-method.md) `FunctionEnter` [ICorProfilerCallback:: JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) 콜백을 받기 전에 한 스레드에서 일부 함수에 대해 ICorProfilerCallback:: JITCompilationStarted 이벤트를 수신 하 고 다른 스레드의 콜백을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-188">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="20e14-189">이 경우에는 사용자가 아직 완전히 JIT(Just-In-Time) 컴파일되지 않았을 수 있는 함수에 대해 `FunctionEnter` 콜백을 받는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-189">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="20e14-190">보안</span><span class="sxs-lookup"><span data-stu-id="20e14-190">Security</span></span>

<span data-ttu-id="20e14-191">프로파일러 DLL은 공용 언어 런타임 실행 엔진의 일부로 실행되는 관리되지 않는 DLL입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-191">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="20e14-192">따라서 프로파일러 DLL의 코드에 관리 코드 액세스 보안의 제한이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-192">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="20e14-193">프로파일러 DLL에 대한 유일한 제한 사항은 운영 체제에서 프로파일링된 애플리케이션을 실행하는 사용자에 대해 적용하는 제한입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-193">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="20e14-194">프로파일러 작성자는 보안 관련 문제를 방지하기 위해 적절한 예방 조치를 취해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-194">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="20e14-195">예를 들어 악의적인 사용자가 수정할 수 없도록 설치 중에 프로파일러 DLL을 ACL(액세스 제어 목록)에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-195">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="20e14-196">코드 프로파일러에서 관리 코드와 비관리 코드 결합</span><span class="sxs-lookup"><span data-stu-id="20e14-196">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="20e14-197">잘못 작성된 프로파일러는 자체 순환 참조를 생성하여 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-197">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="20e14-198">CLR 프로파일링 API를 검토하면 COM interop 또는 간접 호출을 통해 서로 호출하는 관리되는 구성 요소와 관리되지 않는 구성 요소를 포함하는 프로파일러를 작성할 수 있다는 인상을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-198">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="20e14-199">디자인 관점에서는 가능하지만 프로파일링 API는 관리되는 구성 요소를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-199">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="20e14-200">CLR 프로파일러는 완전히 관리되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-200">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="20e14-201">CLR 프로파일러에서 관리 코드와 비관리 코드를 결합하려고 하면 액세스 위반, 프로그램 오류 또는 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-201">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="20e14-202">프로파일러의 관리되는 구성 요소는 관리되지 않는 해당 구성 요소로 다시 이벤트를 발생시키고, 이후에 이 구성 요소가 관리되는 구성 요소를 다시 호출하여 순환 참조가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-202">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="20e14-203">CLR 프로파일러가 관리 코드를 안전하게 호출할 수 있는 유일한 위치는 메서드의 MSIL(Microsoft Intermediate Language) 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-203">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="20e14-204">MSIL 본문을 수정 하는 권장 방법은 [ICorProfilerCallback4](icorprofilercallback4-interface.md) 인터페이스에서 JIT 재컴파일 메서드를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-204">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="20e14-205">오래된 계측 메서드를 사용하여 MSIL을 수정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-205">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="20e14-206">함수의 JIT (just-in-time) 컴파일이 완료 되기 전에 프로파일러는 메서드의 MSIL 본문에 관리 되는 호출을 삽입 한 다음 JIT 컴파일할 수 있습니다 ( [ICorProfilerInfo:: GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) 메서드 참조).</span><span class="sxs-lookup"><span data-stu-id="20e14-206">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="20e14-207">이 기술은 관리 코드의 선택적 계측이나 JIT에 대한 통계 및 성능 데이터 수집을 위해 성공적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-207">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="20e14-208">또는 코드 프로파일러가 비관리 코드를 호출하는 모든 관리되는 함수의 MSIL 본문에 네이티브 후크를 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-208">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="20e14-209">이 기술은 계측 및 검사에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-209">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="20e14-210">예를 들어 코드 프로파일러가 모든 MSIL 블록 뒤에 계측 후크를 삽입하여 블록이 실행되었는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-210">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="20e14-211">메서드의 MSIL 본문 수정은 매우 정교한 작업이며 여러 가지 요인을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-211">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="20e14-212">비관리 코드 프로파일링</span><span class="sxs-lookup"><span data-stu-id="20e14-212">Profiling Unmanaged Code</span></span>

<span data-ttu-id="20e14-213">CLR(공용 언어 런타임) 프로파일링 API는 비관리 코드 프로파일링에 대해 최소한의 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-213">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="20e14-214">다음 기능이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-214">The following functionality is provided:</span></span>

- <span data-ttu-id="20e14-215">스택 체인 열거형.</span><span class="sxs-lookup"><span data-stu-id="20e14-215">Enumeration of stack chains.</span></span> <span data-ttu-id="20e14-216">이 기능을 통해 코드 프로파일러는 관리 코드와 비관리 코드 사이의 경계를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-216">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="20e14-217">스택 체인이 관리 코드에 해당하는지 또는 네이티브 코드에 해당하는지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-217">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="20e14-218">.NET Framework 버전 1.0 및 1.1에서는 CLR 디버깅 API의 in-process 하위 집합을 통해 이러한 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-218">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="20e14-219">CorDebug.idl 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-219">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="20e14-220">.NET Framework 2.0 이상에서는이 기능에 대해 [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-220">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="20e14-221">COM 사용</span><span class="sxs-lookup"><span data-stu-id="20e14-221">Using COM</span></span>

<span data-ttu-id="20e14-222">프로파일링 인터페이스는 COM 인터페이스로 정의되지만 CLR(공용 언어 런타임)에서 실제로 이러한 인터페이스를 사용하도록 COM를 초기화하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-222">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="20e14-223">그 이유는 관리 되는 응용 프로그램에서 원하는 스레딩 모델을 지정 하기 전에 [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) 함수를 사용 하 여 스레딩 모델을 설정 하지 않도록 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-223">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="20e14-224">마찬가지로, 프로파일러 자체는 프로파일링되는 애플리케이션과 호환되지 않는 스레딩 모델을 선택하여 애플리케이션이 실패하게 만들 수 있으므로 `CoInitialize`를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-224">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="20e14-225">호출 스택</span><span class="sxs-lookup"><span data-stu-id="20e14-225">Call Stacks</span></span>

<span data-ttu-id="20e14-226">프로파일링 API는 호출 스택을 가져오는 두 가지 방법을 제공합니다. 스택 스냅샷 메서드는 호출 스택의 스파스 수집을 가능하게 하고 섀도 스택 메서드는 모든 순간에 호출 스택을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-226">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="20e14-227">스택 스냅샷</span><span class="sxs-lookup"><span data-stu-id="20e14-227">Stack Snapshot</span></span>

<span data-ttu-id="20e14-228">스택 스냅샷은 한 순간의 스레드 스택 추적입니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-228">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="20e14-229">프로파일링 API는 스택에서 관리되는 함수의 추적을 지원하지만 관리되지 않는 함수의 추적은 프로파일러의 자체 스택 워크에 맡깁니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-229">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="20e14-230">관리 되는 스택을 탐색 하기 위해 프로파일러를 프로그래밍 하는 방법에 대 한 자세한 내용은이 설명서 집합의 [ICorProfilerInfo2::D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) 메서드 및 [.NET Framework 2.0: 기본 사항 및 그 이상에서 프로파일러 스택 탐색](/previous-versions/dotnet/articles/bb264782(v=msdn.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="20e14-230">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="20e14-231">섀도 스택</span><span class="sxs-lookup"><span data-stu-id="20e14-231">Shadow Stack</span></span>

<span data-ttu-id="20e14-232">스냅샷 메서드를 너무 자주 사용하면 성능 문제가 빠르게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-232">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="20e14-233">스택 추적을 자주 수행 하려는 경우 프로파일러가 [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md)및 [ICorProfilerCallback2](icorprofilercallback2-interface.md) 예외 콜백을 사용 하 여 섀도 스택을 대신 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-233">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="20e14-234">섀도 스택은 항상 최신 상태이며 스택 스냅샷이 필요할 때마다 스토리지로 빠르게 복사될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-234">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="20e14-235">섀도 스택은 함수 인수, 반환 값 및 제네릭 인스턴스화에 대한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-235">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="20e14-236">이 정보는 섀도 스택을 통해서만 제공되며 컨트롤이 함수에 전달될 때 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-236">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="20e14-237">그러나 나중에 함수 실행 중에는 이 정보는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-237">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="20e14-238">콜백 및 스택 수준</span><span class="sxs-lookup"><span data-stu-id="20e14-238">Callbacks and Stack Depth</span></span>

<span data-ttu-id="20e14-239">프로파일러 콜백은 스택이 매우 제한된 환경에서 실행할 수 있으며, 프로파일러 콜백의 스택 오버플로로 인해 즉시 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-239">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="20e14-240">프로파일러는 콜백에 대한 응답으로 가능한 한 적은 스택을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-240">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="20e14-241">프로파일러가 스택 오버플로에 대해 강력한 프로세스에 사용하기 위한 것이면 프로파일러 자체에서 스택 오버플로 트리거도 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-241">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="20e14-242">관련 항목</span><span class="sxs-lookup"><span data-stu-id="20e14-242">Related Topics</span></span>

|<span data-ttu-id="20e14-243">제목</span><span class="sxs-lookup"><span data-stu-id="20e14-243">Title</span></span>|<span data-ttu-id="20e14-244">설명</span><span class="sxs-lookup"><span data-stu-id="20e14-244">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="20e14-245">프로파일링 환경 설정</span><span class="sxs-lookup"><span data-stu-id="20e14-245">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="20e14-246">프로파일러를 초기화하고, 이벤트 알림을 설정하고, Windows 서비스를 프로파일링하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-246">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="20e14-247">프로파일링 인터페이스</span><span class="sxs-lookup"><span data-stu-id="20e14-247">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="20e14-248">프로파일링 API에서 사용하는 관리되지 않는 인터페이스를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-248">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="20e14-249">프로파일링 전역 정적 함수</span><span class="sxs-lookup"><span data-stu-id="20e14-249">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="20e14-250">프로파일링 API에서 사용하는 관리되지 않는 전역 정적 함수를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-250">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="20e14-251">프로파일링 열거형</span><span class="sxs-lookup"><span data-stu-id="20e14-251">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="20e14-252">프로파일링 API에서 사용하는 관리되지 않는 열거형을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-252">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="20e14-253">프로파일링 구조체</span><span class="sxs-lookup"><span data-stu-id="20e14-253">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="20e14-254">프로파일링 API에서 사용하는 관리되지 않는 구조체를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20e14-254">Describes the unmanaged structures that the profiling API uses.</span></span>|
