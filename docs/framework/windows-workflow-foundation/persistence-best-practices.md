---
title: 지속성 최선의 구현 방법
ms.date: 03/30/2017
ms.assetid: 6974c5a4-1af8-4732-ab53-7d694608a3a0
ms.openlocfilehash: 950a5d5c742b7882db93d71f3e7f205009f2a863
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96246149"
---
# <a name="persistence-best-practices"></a><span data-ttu-id="04f6f-102">지속성 최선의 구현 방법</span><span class="sxs-lookup"><span data-stu-id="04f6f-102">Persistence Best Practices</span></span>

<span data-ttu-id="04f6f-103">이 문서에서는 워크플로 지속성과 관련된 워크플로 디자인 및 구성에 대한 최상의 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-103">This document covers best practices for workflow design and configuration related to workflow persistence.</span></span>  
  
## <a name="design-and-implementation-of-durable-workflows"></a><span data-ttu-id="04f6f-104">지속형 워크플로의 디자인 및 구현</span><span class="sxs-lookup"><span data-stu-id="04f6f-104">Design and Implementation of Durable Workflows</span></span>  

 <span data-ttu-id="04f6f-105">일반적으로 워크플로는 이벤트를 기다리고 있기 때문에 유휴 상태인 시간과 인터리브된 짧은 기간 동안 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-105">In general, workflows perform work in short periods that are interleaved with times during which the workflow is idle because it is waiting for an event.</span></span> <span data-ttu-id="04f6f-106">이러한 이벤트는 메시지, 만료 타이머 등일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-106">This event can be such things as a message or an expiring timer.</span></span> <span data-ttu-id="04f6f-107">워크플로 인스턴스가 유휴 상태가 될 때 워크플로 인스턴스를 언로드할 수 있으려면 서비스 호스트가 워크플로 인스턴스를 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-107">To be able to unload the workflow instance when it becomes idle, the service host must persist the workflow instance.</span></span> <span data-ttu-id="04f6f-108">이는 워크플로 인스턴스가 비지속성 영역에 없는 경우(예를 들어 트랜잭션이 완료되기를 기다리거나 비동기 콜백을 기다리는 경우)에만 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-108">This is possible only if the workflow instance is not in a no-persist zone (for example, waiting for a transaction to complete, or waiting for an asynchronous callback).</span></span> <span data-ttu-id="04f6f-109">유휴 워크플로 인스턴스가 언로드될 수 있도록 하려면 워크플로 작성자가 수명이 짧은 작업에만 트랜잭션 범위와 비동기 활동을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-109">To allow an idle workflow instance to unload, the workflow author should use transaction scopes and asynchronous activities for short-lived actions only.</span></span> <span data-ttu-id="04f6f-110">특히 작성자는 이러한 비지속성 영역의 지연 활동을 가능한 한 짧게 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-110">In particular, the author should keep delay activities within these no-persist zones as short as possible.</span></span>  
  
 <span data-ttu-id="04f6f-111">워크플로에서 사용되는 모든 데이터 형식이 serialize 가능한 경우에만 워크플로가 유지될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-111">A workflow can only be persisted if all of the data types used by the workflow are serializable.</span></span> <span data-ttu-id="04f6f-112">또한 지속형 워크플로에서 사용되는 사용자 지정 형식은 <xref:System.Runtime.Serialization.NetDataContractSerializer>를 사용하여 serialize 가능해야 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>에 의해 유지될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-112">In addition, custom types used in persisted workflows must be serializable with <xref:System.Runtime.Serialization.NetDataContractSerializer> in order to be persisted by <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>.</span></span>  
  
 <span data-ttu-id="04f6f-113">워크플로 인스턴스가 유지되지 않은 경우 호스트나 컴퓨터에서 오류가 발생하면 워크플로 인스턴스를 복구할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-113">A workflow instance cannot be recovered in case of a host or computer failure if it has not been persisted.</span></span> <span data-ttu-id="04f6f-114">일반적으로 워크플로의 수명 주기 초반에 워크플로 인스턴스를 유지하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-114">In general, we recommend that you persist a workflow instance early in the workflow’s life cycle.</span></span>  
  
 <span data-ttu-id="04f6f-115">워크플로가 오랫동안 작업을 수행하는 경우 작업 중인 기간 동안 워크플로 인스턴스를 주기적으로 유지하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-115">If your workflow is busy for a long time, we recommend that you persist the workflow instance regularly throughout its busy period.</span></span> <span data-ttu-id="04f6f-116">이렇게 하려면 워크플로 인스턴스가 계속 작업을 수행하도록 하는 일련의 활동 전반에서 <xref:System.Activities.Statements.Persist> 활동을 추가하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-116">You can do this by adding <xref:System.Activities.Statements.Persist> activities throughout the sequence of activities that keep the workflow instance busy.</span></span> <span data-ttu-id="04f6f-117">이에 따라 애플리케이션 도메인 재활용, 호스트 오류 또는 컴퓨터 오류가 발생해도 시스템이 작업 중인 기간의 시작으로 롤백되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-117">In this manner, application domain recycling, host failures, or computer failures do not cause the system to be rolled back to the start of the busy period.</span></span> <span data-ttu-id="04f6f-118"><xref:System.Activities.Statements.Persist> 활동을 워크플로에 추가하면 성능이 저하될 수 있으므로 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="04f6f-118">Be aware that adding <xref:System.Activities.Statements.Persist> activities to your workflow could lead to a degradation of performance.</span></span>  
  
 <span data-ttu-id="04f6f-119">Windows Server AppFabric은 지속성의 구성과 사용을 크게 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-119">Windows Server App Fabric greatly simplifies the configuration and use of persistence.</span></span> <span data-ttu-id="04f6f-120">자세한 내용은 [Windows Server App Fabric 지 속성](/previous-versions/appfabric/ee677272(v=azure.10)) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="04f6f-120">For more information, see [Windows Server App Fabric Persistence](/previous-versions/appfabric/ee677272(v=azure.10))</span></span>  
  
## <a name="configuration-of-scalability-parameters"></a><span data-ttu-id="04f6f-121">확장성 매개 변수의 구성</span><span class="sxs-lookup"><span data-stu-id="04f6f-121">Configuration of Scalability Parameters</span></span>  

 <span data-ttu-id="04f6f-122">확장성 및 성능 요구 사항에 따라 다음 매개 변수의 설정이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-122">Scalability and performance requirements determine the settings of the following parameters:</span></span>  
  
- <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>  
  
- <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A>  
  
- <xref:System.ServiceModel.Activities.Description.SqlWorkflowInstanceStoreBehavior.InstanceLockedExceptionAction%2A>  
  
 <span data-ttu-id="04f6f-123">이러한 매개 변수는 현재 시나리오에 따라 다음과 같이 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-123">These parameters should be set as follows, according to the current scenario.</span></span>  
  
### <a name="scenario-a-small-number-of-workflow-instances-that-require-optimal-response-time"></a><span data-ttu-id="04f6f-124">시나리오: 최적의 응답 시간이 필요한 적은 수의 워크플로 인스턴스</span><span class="sxs-lookup"><span data-stu-id="04f6f-124">Scenario: A Small Number of Workflow Instances That Require Optimal Response Time</span></span>  

 <span data-ttu-id="04f6f-125">이 시나리오에서는 모든 워크플로 인스턴스가 유휴 상태가 될 때 로드된 상태로 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-125">In this scenario, all workflow instances should remain loaded when they become idle.</span></span> <span data-ttu-id="04f6f-126"><xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A>를 큰 값으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-126">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to a large value.</span></span> <span data-ttu-id="04f6f-127">이 설정을 사용하면 워크플로 인스턴스가 컴퓨터 간에 이동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-127">The use of this setting prevents a workflow instance from moving between computers.</span></span> <span data-ttu-id="04f6f-128">다음 중 하나 이상에 해당하는 경우에만 이 설정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-128">Use this setting only if one or more of the following are true:</span></span>  
  
- <span data-ttu-id="04f6f-129">워크플로 인스턴스가 수명 전반에서 단일 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-129">A workflow instance receives a single message throughout its lifetime.</span></span>  
  
- <span data-ttu-id="04f6f-130">모든 워크플로 인스턴스가 단일 컴퓨터에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-130">All workflow instances run on a single computer</span></span>  
  
- <span data-ttu-id="04f6f-131">워크플로 인스턴스가 받는 모든 메시지를 동일한 컴퓨터에서 받습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-131">All messages that are received by a workflow instance are received by the same computer.</span></span>  
  
 <span data-ttu-id="04f6f-132"><xref:System.Activities.Statements.Persist> 활동을 사용하거나 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>를 0으로 설정하여 서비스 호스트나 컴퓨터에서 오류가 발생한 후 워크플로 인스턴스를 복구할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-132">Use <xref:System.Activities.Statements.Persist> activities or set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A> to 0 to enable recovery of your workflow instance after service host or computer failures.</span></span>  
  
### <a name="scenario-workflow-instances-are-idle-for-long-periods-of-time"></a><span data-ttu-id="04f6f-133">시나리오: 워크플로 인스턴스가 오랫동안 유휴 상태임</span><span class="sxs-lookup"><span data-stu-id="04f6f-133">Scenario: Workflow Instances Are Idle for Long Periods of Time</span></span>  

 <span data-ttu-id="04f6f-134">이 시나리오에서는 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A>를 0으로 설정하여 리소스를 가능한 한 빨리 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-134">In this scenario, set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to 0 to release resources as soon as possible.</span></span>  
  
### <a name="scenario-workflow-instances-receive-multiple-messages-in-a-short-period-of-time"></a><span data-ttu-id="04f6f-135">시나리오: 워크플로 인스턴스가 짧은 기간 동안 여러 메시지를 받음</span><span class="sxs-lookup"><span data-stu-id="04f6f-135">Scenario: Workflow Instances Receive Multiple Messages in a Short Period of Time</span></span>  

 <span data-ttu-id="04f6f-136">이 시나리오에서는 해당 메시지를 동일한 컴퓨터에서 받는 경우 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A>를 60초로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-136">In this scenario, set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to 60 seconds if these messages are received by the same computer.</span></span> <span data-ttu-id="04f6f-137">이렇게 하면 워크플로 인스턴스가 빠르게 연속적으로 언로드되고 로드되지 않으며</span><span class="sxs-lookup"><span data-stu-id="04f6f-137">This prevents a rapid sequence of unloading and loading of a workflow instance.</span></span> <span data-ttu-id="04f6f-138">인스턴스가 메모리에 너무 오래 유지되지도 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-138">This also does not keep the instance in memory for too long.</span></span>  
  
 <span data-ttu-id="04f6f-139">해당 메시지를 여러 컴퓨터에서 받을 수 있는 경우에는 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A>를 0으로 설정하고 <xref:System.ServiceModel.Activities.Description.SqlWorkflowInstanceStoreBehavior.InstanceLockedExceptionAction%2A>을 BasicRetry 또는 AggressiveRetry로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-139">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to 0, and set <xref:System.ServiceModel.Activities.Description.SqlWorkflowInstanceStoreBehavior.InstanceLockedExceptionAction%2A> to BasicRetry or AggressiveRetry if these messages may be received by different computers.</span></span> <span data-ttu-id="04f6f-140">이렇게 하면 워크플로 인스턴스가 다른 컴퓨터에서 로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-140">This allows the workflow instance to be loaded by another computer.</span></span>  
  
### <a name="scenario-workflow-uses-delay-activities-with-short-durations"></a><span data-ttu-id="04f6f-141">시나리오: 워크플로에서 짧은 기간의 지연 활동을 사용함</span><span class="sxs-lookup"><span data-stu-id="04f6f-141">Scenario: Workflow Uses Delay Activities with Short Durations</span></span>  

 <span data-ttu-id="04f6f-142">이 시나리오에서는 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>가 만료된 <xref:System.Activities.Statements.Delay> 활동 때문에 로드되어야 하는 인스턴스를 지속성 데이터베이스에서 주기적으로 폴링합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-142">In this scenario, the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> regularly polls the persistence database for instances that should be loaded because of an expired <xref:System.Activities.Statements.Delay> activity.</span></span> <span data-ttu-id="04f6f-143"><xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>가 다음 폴링 간격에서 만료될 타이머를 찾는 경우 SQL 워크플로 인스턴스 저장소에서는 폴링 간격을 단축합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-143">If the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> finds a timer that will expire in the next polling interval, the SQL Workflow Instance Store shortens the polling interval.</span></span> <span data-ttu-id="04f6f-144">그러면 다음 폴링이 타이머가 만료된 직후에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-144">The next poll will then occur right after the timer has expired.</span></span> <span data-ttu-id="04f6f-145">이러한 방식으로 SQL 워크플로 인스턴스 저장소는 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>로 설정된 폴링 간격보다 길게 실행되는 타이머의 높은 정확도를 달성합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-145">This way, the SQL Workflow Instance Store achieves a high accuracy of timers that run longer than the polling interval, which is set by <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>.</span></span> <span data-ttu-id="04f6f-146">지연을 단축하여 적시에 처리할 수 있으려면 워크플로 인스턴스가 최소한 한 번의 폴링 간격 동안 메모리에 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-146">To enable timely processing of shorter delays, the workflow instance must remain in memory for at least one polling interval.</span></span>  
  
 <span data-ttu-id="04f6f-147"><xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>를 0으로 설정하여 만료 시간을 지속성 데이터베이스에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-147">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A> to 0 to write the expiration time to the persistence database.</span></span>  
  
 <span data-ttu-id="04f6f-148"><xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A>를 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>보다 길거나 같은 값으로 설정하여 최소한 한 번의 폴링 간격 동안 인스턴스를 메모리에 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-148">Set <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> to longer than or equal to <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> to keep the instance in memory for at least one polling interval.</span></span>  
  
 <span data-ttu-id="04f6f-149">지속성 데이터베이스에서 부하가 늘어날 수 있기 때문에 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>를 줄이지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-149">We do not recommend reducing the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> because this leads to an increased load on the persistence database.</span></span> <span data-ttu-id="04f6f-150"><xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>를 사용하는 각 서비스 호스트는 검색 기간마다 한 번씩 데이터베이스를 폴링합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-150">Each service host that uses the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> polls the database one time per detection period.</span></span> <span data-ttu-id="04f6f-151"><xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>를 너무 작은 시간 간격으로 설정하면 서비스 호스트 수가 많은 경우 시스템 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-151">Setting <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> to too small a time interval may cause your system's performance to decrease if the number of service hosts is large.</span></span>  
  
## <a name="configuring-the-sql-workflow-instance-store"></a><span data-ttu-id="04f6f-152">SQL 워크플로 인스턴스 저장소 구성</span><span class="sxs-lookup"><span data-stu-id="04f6f-152">Configuring the SQL Workflow Instance Store</span></span>  

 <span data-ttu-id="04f6f-153">SQL 워크플로 인스턴스 저장소에는 다음과 같은 구성 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-153">The SQL Workflow Instance Store has the following configuration parameters:</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceEncodingOption%2A>  
 <span data-ttu-id="04f6f-154">이 매개 변수는 워크플로 인스턴스 상태를 압축하도록 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-154">This parameter instructs the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> to compress the workflow instance state.</span></span> <span data-ttu-id="04f6f-155">압축을 하면 지속성 데이터베이스에 저장된 데이터의 양이 줄어들고 지속성 데이터베이스가 전용 데이터베이스 서버에 있는 경우 네트워크 트래픽이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-155">Compression reduces the amount of data that is stored in the persistence database and reduces network traffic in case the persistence database resides on a dedicated database server.</span></span> <span data-ttu-id="04f6f-156">압축을 사용하는 경우 인스턴스 상태를 압축하고 추출할 계산 리소스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-156">If compression is used, it requires computational resources to compress and extract the instance state.</span></span> <span data-ttu-id="04f6f-157">대부분의 경우 압축을 통해 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-157">In most cases, compression yields increased performance.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceCompletionAction%2A>  
 <span data-ttu-id="04f6f-158">이 매개 변수는 완료된 인스턴스를 유지하거나 삭제하도록 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-158">This parameter instructs the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> to either keep or delete completed instances.</span></span> <span data-ttu-id="04f6f-159">완료된 인스턴스를 유지하면 지속성 데이터베이스 스토리지 요구 사항이 증가하고 테이블이 커지며 테이블 조회 시간도 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-159">Keeping completed instances increases the persistence database storage requirements and leads to larger tables, which increases table lookup times.</span></span> <span data-ttu-id="04f6f-160">완료된 인스턴스가 디버깅이나 감사에 필요하지 않으면 완료된 인스턴스를 삭제하도록 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>에 지시하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-160">Unless completed instances are required for debugging or auditing, it is best to instruct the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> to delete completed instances.</span></span> <span data-ttu-id="04f6f-161">삭제된 인스턴스는 사용자가 해당 인스턴스를 결국 제거하는 프로세스를 설정하는 경우에만 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-161">Deleted instances should be kept only if the user establishes a process for eventually removing them.</span></span> <span data-ttu-id="04f6f-162">완료된 워크플로 인스턴스가 인스턴스 저장소에 있는 한 상관 관계 키를 다시 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-162">Note that correlation keys cannot be reused as long as the completed workflow instance resides in the instance store.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>  
 <span data-ttu-id="04f6f-163">이 매개 변수는 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>가 <xref:System.Activities.Statements.Delay> 활동이 만료될 때 로드되어야 하는 인스턴스를 지속성 데이터베이스에서 폴링하는 최대 간격을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-163">This parameter defines the maximum interval with which the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> polls the persistence database for instances that should be loaded when a <xref:System.Activities.Statements.Delay> activity expires.</span></span> <span data-ttu-id="04f6f-164"><xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>가 다음 폴링 간격에서 만료될 타이머를 찾는 경우 타이머가 만료된 직후에 다음 폴링이 발생하도록 폴링 간격을 단축합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-164">If the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> finds a timer that will expire in the next polling interval, it shortens the polling interval so that the next poll will occur right after the timer has expired.</span></span> <span data-ttu-id="04f6f-165">이러한 방식으로 SQL 워크플로 인스턴스 저장소는 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>보다 길게 실행되는 타이머의 높은 정확도를 달성합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-165">This way, the SQL Workflow Instance Store achieves a high accuracy of timers that run longer than <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>.</span></span>  
  
 <span data-ttu-id="04f6f-166">지속성 데이터베이스에서 부하가 늘어날 수 있기 때문에 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>를 줄이지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-166">We do not recommend reducing the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>, because this leads to an increased load on the persistence database.</span></span> <span data-ttu-id="04f6f-167"><xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>를 사용하는 각 서비스 호스트는 검색 기간마다 한 번씩 데이터베이스를 폴링합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-167">Each service host that uses the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> polls the database one time per detection period.</span></span> <span data-ttu-id="04f6f-168"><xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A>를 너무 작은 간격으로 설정하면 서비스 호스트 수가 많은 경우 시스템 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-168">Setting <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.RunnableInstancesDetectionPeriod%2A> to too small an interval may cause your system's performance to decrease if the number of service hosts is large.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.HostLockRenewalPeriod%2A>  
 <span data-ttu-id="04f6f-169">이 매개 변수는 호스트가 지속성 데이터베이스에서 잠금을 갱신하는 간격을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-169">This parameter defines the interval with which the host renews its lock in the persistence database.</span></span> <span data-ttu-id="04f6f-170">이 간격을 단축하면 호스트나 컴퓨터에서 오류가 발생하는 경우 워크플로 인스턴스를 더욱 빠르게 복구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-170">Shortening this interval will enable a quicker recovery of the workflow instances in case a host or computer fails.</span></span> <span data-ttu-id="04f6f-171">반면에 잠금 갱신 기간이 짧으면 지속성 데이터베이스에서 부하가 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-171">On the other hand, a short lock renewal period increases the load on the persistence database.</span></span> <span data-ttu-id="04f6f-172"><xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>를 사용하는 각 서비스 호스트는 갱신 기간마다 한 번씩 데이터베이스에서 잠금을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-172">Each service host that uses the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> will update its locks in the database one time per renewal period.</span></span> <span data-ttu-id="04f6f-173">컴퓨터에서 많은 서비스 호스트가 실행되는 경우 잠금 갱신으로 인한 부하 때문에 시스템 성능이 저하되지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-173">If a computer runs many service hosts, make sure that the load caused by lock renewal does not decrease your system's performance.</span></span> <span data-ttu-id="04f6f-174">시스템 성능이 저하되는 경우에는 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.HostLockRenewalPeriod%2A>를 늘리는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-174">If it does, consider increasing the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.HostLockRenewalPeriod%2A>.</span></span>  
  
 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A>  
 <span data-ttu-id="04f6f-175">사용할 경우 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>가 다음 30초 동안 잠긴 인스턴스를 로드하려고 다시 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-175">If enabled, the <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> retries to load a locked instance for the next 30 seconds.</span></span> <span data-ttu-id="04f6f-176">워크플로가 짧은 기간 동안 여러 메시지를 받고 여러 컴퓨터에서 이러한 메시지를 받는 경우에는 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A>을 BasicRetry 또는 AggressiveRetry로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-176">Set <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> to BasicRetry or AggressiveRetry if the workflow receives multiple messages in a short time, and these messages are received by different computers.</span></span>  
  
 <span data-ttu-id="04f6f-177">로드 재시도가 시도되지 않는 한 로드 재시도 메커니즘에서 성능 오버헤드를 유발하지 않기 때문에 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A>을 항상 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04f6f-177">Because the load retry mechanism does not introduce any performance overhead as long as load retries are not tried, <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> should always be enabled.</span></span>
