---
title: 명령 코드를 사용하여 워크플로, 활동 및 식 작성
description: Workflow Foundation 워크플로 정의는 구성 된 활동 개체의 트리입니다. 코드를 사용 하 여 워크플로 정의, 활동 및 식을 만듭니다.
ms.date: 03/30/2017
ms.assetid: cefc9cfc-2882-4eb9-8c94-7a6da957f2b2
ms.openlocfilehash: 5355f2090317a0bce3fec0f46550b202bd0af095
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96289128"
---
# <a name="authoring-workflows-activities-and-expressions-using-imperative-code"></a><span data-ttu-id="2dee7-104">명령 코드를 사용하여 워크플로, 활동 및 식 작성</span><span class="sxs-lookup"><span data-stu-id="2dee7-104">Authoring Workflows, Activities, and Expressions Using Imperative Code</span></span>

<span data-ttu-id="2dee7-105">워크플로 정의는 구성된 활동 개체의 트리입니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-105">A workflow definition is a tree of configured activity objects.</span></span> <span data-ttu-id="2dee7-106">XAML을 수동으로 편집하거나 Workflow Designer를 사용하여 XAML을 생성하는 등 여러 가지 방법으로 이 활동 트리를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-106">This tree of activities can be defined many ways, including by hand-editing XAML or by using the Workflow Designer to produce XAML.</span></span> <span data-ttu-id="2dee7-107">하지만 XAML 사용은 필수 사항이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-107">Use of XAML, however, is not a requirement.</span></span> <span data-ttu-id="2dee7-108">프로그래밍 방식으로 워크플로 정의를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-108">Workflow definitions can also be created programmatically.</span></span> <span data-ttu-id="2dee7-109">이 항목에서는 코드를 사용하여 워크플로 정의, 활동 및 식을 만드는 방법을 간략히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-109">This topic provides an overview of creating workflow definitions, activities, and expressions by using code.</span></span> <span data-ttu-id="2dee7-110">코드를 사용 하 여 XAML 워크플로를 사용 하는 예제는 [xaml로 워크플로 및 작업 serialize](serializing-workflows-and-activities-to-and-from-xaml.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-110">For examples of working with XAML workflows using code, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
## <a name="creating-workflow-definitions"></a><span data-ttu-id="2dee7-111">워크플로 정의 만들기</span><span class="sxs-lookup"><span data-stu-id="2dee7-111">Creating Workflow Definitions</span></span>  

 <span data-ttu-id="2dee7-112">활동 형식의 인스턴스를 인스턴스화하고 활동 개체의 속성을 구성하여 워크플로 정의를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-112">A workflow definition can be created by instantiating an instance of an activity type and configuring the activity object’s properties.</span></span> <span data-ttu-id="2dee7-113">자식 활동을 포함하지 않는 활동의 경우 코드 몇 행으로 이 작업을 완료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-113">For activities that do not contain child activities, this can be accomplished using a few lines of code.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#47](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#47)]  
  
> [!NOTE]
> <span data-ttu-id="2dee7-114">이 항목의 예제에서는 <xref:System.Activities.WorkflowInvoker>를 사용하여 샘플 워크플로를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-114">The examples in this topic use <xref:System.Activities.WorkflowInvoker> to run the sample workflows.</span></span> <span data-ttu-id="2dee7-115">워크플로 호출, 인수 전달 및 사용 가능한 다양 한 호스팅 선택에 대 한 자세한 내용은 [WorkflowInvoker 및 WorkflowApplication 사용](using-workflowinvoker-and-workflowapplication.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-115">For more information about invoking workflows, passing arguments, and the different hosting choices that are available, see [Using WorkflowInvoker and WorkflowApplication](using-workflowinvoker-and-workflowapplication.md).</span></span>  
  
 <span data-ttu-id="2dee7-116">이 예제에서는 <xref:System.Activities.Statements.WriteLine> 활동 하나로 구성된 워크플로를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-116">In this example, a workflow that consists of a single <xref:System.Activities.Statements.WriteLine> activity is created.</span></span> <span data-ttu-id="2dee7-117"><xref:System.Activities.Statements.WriteLine> 활동의 <xref:System.Activities.Statements.WriteLine.Text%2A> 인수를 설정하고 워크플로를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-117">The <xref:System.Activities.Statements.WriteLine> activity’s <xref:System.Activities.Statements.WriteLine.Text%2A> argument is set, and the workflow is invoked.</span></span> <span data-ttu-id="2dee7-118">활동이 자식 활동을 포함하는 경우 생성 메서드는 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-118">If an activity contains child activities, the method of construction is similar.</span></span> <span data-ttu-id="2dee7-119">다음 예에서는 <xref:System.Activities.Statements.Sequence> 활동 두 개를 포함하는 <xref:System.Activities.Statements.WriteLine> 활동을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-119">The following example uses a <xref:System.Activities.Statements.Sequence> activity that contains two <xref:System.Activities.Statements.WriteLine> activities.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#48](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#48)]  
  
### <a name="using-object-initializers"></a><span data-ttu-id="2dee7-120">개체 이니셜라이저 사용</span><span class="sxs-lookup"><span data-stu-id="2dee7-120">Using Object Initializers</span></span>  

 <span data-ttu-id="2dee7-121">이 항목의 예에서는 개체 초기화 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-121">The examples in this topic use object initialization syntax.</span></span> <span data-ttu-id="2dee7-122">개체 초기화 구문은 워크플로에 있는 활동의 계층적 뷰를 제공하고 활동 간의 관계를 표시하기 때문에 코드에서 워크플로 정의를 만드는 유용한 방법일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-122">Object initialization syntax can be a useful way to create workflow definitions in code because it provides a hierarchical view of the activities in the workflow and shows the relationship between the activities.</span></span> <span data-ttu-id="2dee7-123">프로그래밍 방식으로 워크플로를 만들 때 개체 초기화 구문을 사용하기 위한 요구 사항은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-123">There is no requirement to use object initialization syntax when you programmatically create workflows.</span></span> <span data-ttu-id="2dee7-124">다음 예는 이전 예와 기능적으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-124">The following example is functionally equivalent to the previous example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#49](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#49)]  
  
 <span data-ttu-id="2dee7-125">개체 이니셜라이저에 대 한 자세한 내용은 [방법: 생성자를 호출 하지 않고 개체 초기화 (c # 프로그래밍 가이드)](../../csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer.md) 및 [방법: 개체 이니셜라이저를 사용 하 여 개체 선언](../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-125">For more information about object initializers, see [How to: Initialize Objects without Calling a Constructor (C# Programming Guide)](../../csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer.md) and [How to: Declare an Object by Using an Object Initializer](../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md).</span></span>  
  
### <a name="working-with-variables-literal-values-and-expressions"></a><span data-ttu-id="2dee7-126">변수, 리터럴 값 및 식 작업</span><span class="sxs-lookup"><span data-stu-id="2dee7-126">Working with Variables, Literal Values, and Expressions</span></span>  

 <span data-ttu-id="2dee7-127">코드를 사용하여 워크플로 정의를 만들 때는 워크플로 정의 만들기 중 실행되는 코드와 해당 워크플로의 인스턴스 실행 중 실행되는 코드를 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-127">When creating a workflow definition using code, be aware of what code executes as part of the creation of the workflow definition and what code executes as part of the execution of an instance of that workflow.</span></span> <span data-ttu-id="2dee7-128">예를 들어, 다음은 난수를 생성하여 콘솔에 쓰기 위한 워크플로입니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-128">For example, the following workflow is intended to generate a random number and write it to the console.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#50)]  
  
 <span data-ttu-id="2dee7-129">이 워크플로 정의 코드를 실행하면 `Random.Next`가 호출되고 결과가 워크플로 정의에 리터럴 값으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-129">When this workflow definition code is executed, the call to `Random.Next` is made and the result is stored in the workflow definition as a literal value.</span></span> <span data-ttu-id="2dee7-130">이 워크플로의 많은 인스턴스를 호출할 수 있으며 모두 동일한 수를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-130">Many instances of this workflow can be invoked, and all would display the same number.</span></span> <span data-ttu-id="2dee7-131">워크플로 실행 중 난수가 생성되도록 하려면 워크플로를 실행할 때마다 계산되는 식을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-131">To have the random number generation occur during workflow execution, an expression must be used that is evaluated each time the workflow runs.</span></span> <span data-ttu-id="2dee7-132">다음 예제에서는 Visual Basic 식과 함께 <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-132">In the following example, a Visual Basic expression is used with a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="2dee7-133">이전 예제의 식을 <xref:Microsoft.CSharp.Activities.CSharpValue%601> 및 C# 식을 사용하여 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-133">The expression in the previous example could also be implemented using a <xref:Microsoft.CSharp.Activities.CSharpValue%601> and a C# expression.</span></span>  
  
```csharp  
new Assign<int>  
{  
    To = n,  
    Value = new CSharpValue<int>("new Random().Next(1, 101)")  
}  
```  
  
 <span data-ttu-id="2dee7-134">C# 식은 해당 식을 포함하는 워크플로를 호출하기 전에 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-134">C# expressions must be compiled before the workflow containing them is invoked.</span></span> <span data-ttu-id="2dee7-135">C # 식이 컴파일되지 않은 경우 <xref:System.NotSupportedException> 다음과 유사한 메시지를 사용 하 여 워크플로를 호출할 때이 throw 됩니다. ``Expression Activity type 'CSharpValue`1' requires compilation in order to run.  Please ensure that the workflow has been compiled.`` Visual Studio에서 만든 워크플로를 포함 하는 대부분의 시나리오에서 c # 식은 자동으로 컴파일되지만 코드 워크플로와 같은 일부 시나리오에서는 c # 식을 수동으로 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-135">If the C# expressions are not compiled, a <xref:System.NotSupportedException> is thrown when the workflow is invoked with a message similar to the following: ``Expression Activity type 'CSharpValue`1' requires compilation in order to run.  Please ensure that the workflow has been compiled.`` In most scenarios involving workflows created in Visual Studio the C# expressions are compiled automatically, but in some scenarios, such as code workflows, the C# expressions must be manually compiled.</span></span> <span data-ttu-id="2dee7-136">C # 식을 컴파일하는 방법에 대 한 예제는 [c # 식](csharp-expressions.md) 항목의 [코드 워크플로에서 c # 식 사용](csharp-expressions.md#CodeWorkflows) 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-136">For an example of how to compile C# expressions, see the [Using C# expressions in code workflows](csharp-expressions.md#CodeWorkflows) section of the [C# Expressions](csharp-expressions.md) topic.</span></span>  
  
 <span data-ttu-id="2dee7-137"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>는 식에서 r-value로 사용할 수 있는 Visual Basic 구문의 식을 나타내며, <xref:Microsoft.CSharp.Activities.CSharpValue%601>는 식에서 r-value로 사용할 수 있는 C# 구문의 식을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-137">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> represents an expression in Visual Basic syntax that can be used as an r-value in an expression, and a <xref:Microsoft.CSharp.Activities.CSharpValue%601> represents an expression in C# syntax that can be used as an r-value in an expression.</span></span> <span data-ttu-id="2dee7-138">이러한 식은 포함 활동이 실행될 때마다 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-138">These expressions are evaluated each time the containing activity is executed.</span></span> <span data-ttu-id="2dee7-139">식의 결과는 워크플로 변수 `n`에 할당되고 이 결과는 워크플로의 다음 활동에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-139">The result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="2dee7-140">런타임에 워크플로 변수 `n`에 액세스하려면 <xref:System.Activities.ActivityContext>가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-140">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="2dee7-141">다음 람다 식을 사용하여 이 변수에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-141">This can be accessed by using the following lambda expression.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2dee7-142">이러한 코드는 둘 다 C#을 프로그래밍 언어로 사용하지만 하나는 <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>를 사용하고 다른 하나는 <xref:Microsoft.CSharp.Activities.CSharpValue%601>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-142">Note that both of these code are examples are using C# as the programming language, but one uses a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and one uses a <xref:Microsoft.CSharp.Activities.CSharpValue%601>.</span></span> <span data-ttu-id="2dee7-143"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> 및 <xref:Microsoft.CSharp.Activities.CSharpValue%601>는 Visual Basic 및 C# 프로젝트 모두에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-143"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and <xref:Microsoft.CSharp.Activities.CSharpValue%601> can be used in both Visual Basic and C# projects.</span></span> <span data-ttu-id="2dee7-144">기본적으로 워크플로 디자이너에서 만든 식은 호스팅 프로젝트의 언어와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-144">By default, expressions created in the workflow designer match the language of the hosting project.</span></span> <span data-ttu-id="2dee7-145">코드에서 워크플로를 작성할 때는 워크플로 작성자가 원하는 언어를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-145">When creating workflows in code, the desired language is at the discretion of the workflow author.</span></span>  
  
 <span data-ttu-id="2dee7-146">이러한 예제에서 식의 결과는 워크플로 변수 `n`에 할당되고 이 결과는 워크플로의 다음 활동에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-146">In these examples the result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="2dee7-147">런타임에 워크플로 변수 `n`에 액세스하려면 <xref:System.Activities.ActivityContext>가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-147">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="2dee7-148">다음 람다 식을 사용하여 이 변수에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-148">This can be accessed by using the following lambda expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#52](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#52)]  
  
 <span data-ttu-id="2dee7-149">람다 식에 대 한 자세한 내용은 [람다 식 (c # 참조)](../../csharp/language-reference/operators/lambda-expressions.md) 또는 [람다 식 (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-149">For more information about lambda expressions, see [Lambda Expressions (C# reference)](../../csharp/language-reference/operators/lambda-expressions.md) or [Lambda Expressions (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md).</span></span>  
  
 <span data-ttu-id="2dee7-150">람다 식은 XAML 형식으로 serialize할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-150">Lambda expressions are not serializable to XAML format.</span></span> <span data-ttu-id="2dee7-151">람다 식을 사용하여 워크플로를 serialize하려고 시도하면 <xref:System.Activities.Expressions.LambdaSerializationException>이 throw되고 "이 워크플로에는 코드에 지정된 람다 식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-151">If an attempt to serialize a workflow with lambda expressions is made, a <xref:System.Activities.Expressions.LambdaSerializationException> is thrown with the following message: "This workflow contains lambda expressions specified in code.</span></span> <span data-ttu-id="2dee7-152">이러한 식은 직렬화할 수 있는 XAML 식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-152">These expressions are not XAML serializable.</span></span> <span data-ttu-id="2dee7-153">워크플로를 직렬화할 수 있는 XAML로 만들려면 VisualBasicValue/VisualBasicReference 또는 ExpressionServices.Convert(lambda)를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-153">In order to make your workflow XAML-serializable, either use VisualBasicValue/VisualBasicReference or ExpressionServices.Convert(lambda).</span></span> <span data-ttu-id="2dee7-154">그러면 람다 식이 식 작업으로 변환됩니다."라는 메시지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-154">This will convert your lambda expressions into expression activities."</span></span> <span data-ttu-id="2dee7-155">이 식을 XAML과 호환 가능하게 만들려면 다음 예와 같이 <xref:System.Activities.Expressions.ExpressionServices>와 <xref:System.Activities.Expressions.ExpressionServices.Convert%2A>을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-155">To make this expression compatible with XAML, use <xref:System.Activities.Expressions.ExpressionServices> and <xref:System.Activities.Expressions.ExpressionServices.Convert%2A>, as shown in the following example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#53](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#53)]  
  
 <span data-ttu-id="2dee7-156"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-156">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> could also be used.</span></span> <span data-ttu-id="2dee7-157">Visual Basic 식을 사용할 때는 람다 식이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-157">Note that no lambda expression is required when using a Visual Basic expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#54](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#54)]  
  
 <span data-ttu-id="2dee7-158">런타임에 Visual Basic 식은 LINQ 식으로 컴파일됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-158">At run time, Visual Basic expressions are compiled into LINQ expressions.</span></span> <span data-ttu-id="2dee7-159">이전의 두 예제는 XAML로 serialize할 수 있지만 serialize한 XAML을 Workflow Designer에서 보고 편집하려는 경우에는 식에 <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-159">Both of the previous examples are serializable to XAML, but if the serialized XAML is intended to be viewed and edited in the workflow designer, use <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> for your expressions.</span></span> <span data-ttu-id="2dee7-160">`ExpressionServices.Convert`를 사용하는 serialize된 워크플로는 디자이너에서 열 수 있지만 식의 값은 비게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-160">Serialized workflows that use `ExpressionServices.Convert` can be opened in the designer, but the value of the expression will be blank.</span></span> <span data-ttu-id="2dee7-161">워크플로를 XAML로 serialize 하는 방법에 대 한 자세한 내용은 [xaml로 워크플로 및 활동 직렬화](serializing-workflows-and-activities-to-and-from-xaml.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-161">For more information about serializing workflows to XAML, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
#### <a name="literal-expressions-and-reference-types"></a><span data-ttu-id="2dee7-162">리터럴 식 및 참조 형식</span><span class="sxs-lookup"><span data-stu-id="2dee7-162">Literal Expressions and Reference Types</span></span>  

 <span data-ttu-id="2dee7-163">리터럴 식은 워크플로에서 <xref:System.Activities.Expressions.Literal%601> 활동으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-163">Literal expressions are represented in workflows by the <xref:System.Activities.Expressions.Literal%601> activity.</span></span> <span data-ttu-id="2dee7-164">다음 <xref:System.Activities.Statements.WriteLine> 활동은 기능이 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-164">The following <xref:System.Activities.Statements.WriteLine> activities are functionally equivalent.</span></span>  
  
```csharp  
new WriteLine  
{  
    Text = "Hello World."  
},  
new WriteLine  
{  
    Text = new Literal<string>("Hello World.")  
}  
```  
  
 <span data-ttu-id="2dee7-165">리터럴 식은 <xref:System.String>을 제외한 참조 형식으로 초기화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-165">It is invalid to initialize a literal expression with any reference type except <xref:System.String>.</span></span> <span data-ttu-id="2dee7-166">다음 예제에서 <xref:System.Activities.Statements.Assign> 활동의 <xref:System.Activities.Statements.Assign.Value%2A> 속성은 `List<string>`을 사용한 리터럴 식으로 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-166">In the following example, an <xref:System.Activities.Statements.Assign> activity's <xref:System.Activities.Statements.Assign.Value%2A> property is initialized with a literal expression using a `List<string>`.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new List<string>())  
},  
```  
  
 <span data-ttu-id="2dee7-167">이 활동이 포함된 워크플로의 유효성을 검사하면 "리터럴은 값 형식과 불변 형식 System.String만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-167">When the workflow containing this activity is validated, the following validation error is returned: "Literal only supports value types and the immutable type System.String.</span></span> <span data-ttu-id="2dee7-168">System.Collections.Generic.List\`1[System.String] 형식은 리터럴로 사용할 수 없습니다."라는 유효성 검사 오류가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-168">The type System.Collections.Generic.List\`1[System.String] cannot be used as a literal."</span></span> <span data-ttu-id="2dee7-169">워크플로가 호출되면 유효성 검사 오류 텍스트가 포함된 <xref:System.Activities.InvalidWorkflowException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-169">If the workflow is invoked, an <xref:System.Activities.InvalidWorkflowException> is thrown that contains the text of the validation error.</span></span> <span data-ttu-id="2dee7-170">참조 형식을 사용하여 리터럴 식을 만들 경우 워크플로의 각 인스턴스에 대해 참조 형식의 새 인스턴스가 만들어지지 않으므로 이 오류는 유효성 검사 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-170">This is a validation error because creating a literal expression with a reference type does not create a new instance of the reference type for each instance of the workflow.</span></span> <span data-ttu-id="2dee7-171">이 문제를 해결하려면 리터럴 식을 참조 형식의 새 인스턴스를 만들어 반환하는 식으로 바꾸세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-171">To resolve this, replace the literal expression with one that creates and returns a new instance of the reference type.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new VisualBasicValue<List<string>>("New List(Of String)"))  
},  
```  
  
 <span data-ttu-id="2dee7-172">식에 대 한 자세한 내용은 [식](expressions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-172">For more information about expressions, see [Expressions](expressions.md).</span></span>  
  
#### <a name="invoking-methods-on-objects-using-expressions-and-the-invokemethod-activity"></a><span data-ttu-id="2dee7-173">식 및 InvokeMethod 활동을 사용하여 개체에 대한 메서드 호출</span><span class="sxs-lookup"><span data-stu-id="2dee7-173">Invoking Methods on Objects using Expressions and the InvokeMethod Activity</span></span>  

 <span data-ttu-id="2dee7-174"><xref:System.Activities.Expressions.InvokeMethod%601> 활동은 .NET Framework에서 클래스의 정적 및 인스턴스 메서드를 호출하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-174">The <xref:System.Activities.Expressions.InvokeMethod%601> activity can be used to invoke static and instance methods of classes in the .NET Framework.</span></span> <span data-ttu-id="2dee7-175">이 항목의 이전 예제에서는 <xref:System.Random> 클래스를 사용하여 난수를 생성했습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-175">In a previous example in this topic, a random number was generated using the <xref:System.Random> class.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="2dee7-176"><xref:System.Activities.Expressions.InvokeMethod%601> 활동을 사용하여 <xref:System.Random.Next%2A> 클래스의 <xref:System.Random> 메서드를 이미 호출했을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-176">The <xref:System.Activities.Expressions.InvokeMethod%601> activity could also have been used to call the <xref:System.Random.Next%2A> method of the <xref:System.Random> class.</span></span>  
  
```csharp  
new InvokeMethod<int>  
{  
    TargetObject = new InArgument<Random>(new VisualBasicValue<Random>("New Random()")),  
    MethodName = "Next",  
    Parameters =
    {  
        new InArgument<int>(1),  
        new InArgument<int>(101)  
    },  
    Result = n  
}  
```  
  
 <span data-ttu-id="2dee7-177"><xref:System.Random.Next%2A>는 정적 메서드가 아니기 때문에 <xref:System.Random> 속성에 대해 <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A> 클래스의 인스턴스가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-177">Since <xref:System.Random.Next%2A> is not a static method, an instance of the <xref:System.Random> class is supplied for the <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A> property.</span></span> <span data-ttu-id="2dee7-178">이 예제에서는 Visual Basic 식을 사용하여 새 인스턴스를 만들지만 새 인스턴스가 이미 만들어져 워크플로 변수에 저장되었을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-178">In this example a new instance is created using a Visual Basic expression, but it could also have been created previously and stored in a workflow variable.</span></span> <span data-ttu-id="2dee7-179">이 예제에서는 <xref:System.Activities.Statements.Assign%601> 활동 대신 <xref:System.Activities.Expressions.InvokeMethod%601> 활동을 사용하는 것이 더욱 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-179">In this example, it would be simpler to use the <xref:System.Activities.Statements.Assign%601> activity instead of the <xref:System.Activities.Expressions.InvokeMethod%601> activity.</span></span> <span data-ttu-id="2dee7-180"><xref:System.Activities.Statements.Assign%601> 또는 <xref:System.Activities.Expressions.InvokeMethod%601> 활동에 의해 최종적으로 호출된 메서드 호출이 오래 실행되는 경우 <xref:System.Activities.Expressions.InvokeMethod%601>는 <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A> 속성이 있기 때문에 보다 편리합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-180">If the method call ultimately invoked by either the <xref:System.Activities.Statements.Assign%601> or <xref:System.Activities.Expressions.InvokeMethod%601> activities is long running, <xref:System.Activities.Expressions.InvokeMethod%601> has an advantage since it has a <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A> property.</span></span> <span data-ttu-id="2dee7-181">이 속성이 `true`로 설정된 경우 호출된 메서드는 워크플로에 대해 비동기적으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-181">When this property is set to `true`, the invoked method will run asynchronously with regard to the workflow.</span></span> <span data-ttu-id="2dee7-182">다른 활동이 병렬로 실행되더라도 메서드가 비동기적으로 실행되는 동안에는 이러한 활동이 차단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-182">If other activities are in parallel, they will not be blocked while the method is asynchronously executing.</span></span> <span data-ttu-id="2dee7-183">또한 호출되는 메서드에 반환 값이 없는 경우에는 <xref:System.Activities.Expressions.InvokeMethod%601>를 사용하여 메서드를 호출하는 것이 적절한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-183">Also, if the method to be invoked has no return value, then <xref:System.Activities.Expressions.InvokeMethod%601> is the appropriate way to invoke the method.</span></span>  
  
## <a name="arguments-and-dynamic-activities"></a><span data-ttu-id="2dee7-184">인수 및 동적 활동</span><span class="sxs-lookup"><span data-stu-id="2dee7-184">Arguments and Dynamic Activities</span></span>  

 <span data-ttu-id="2dee7-185">워크플로 정의는 코드에서 활동을 활동 트리로 어셈블하고 속성과 인수를 구성하여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-185">A workflow definition is created in code by assembling activities into an activity tree and configuring any properties and arguments.</span></span> <span data-ttu-id="2dee7-186">기존 인수를 바인딩할 수 있지만, 새 인수를 활동에 추가할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-186">Existing arguments can be bound, but new arguments cannot be added to activities.</span></span> <span data-ttu-id="2dee7-187">여기에는 루트 활동에 전달된 워크플로 인수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-187">This includes workflow arguments passed to the root activity.</span></span> <span data-ttu-id="2dee7-188">명령적 코드에서는 워크플로 인수가 새 CLR 형식에 대한 속성으로 지정되고 XAML에서는 `x:Class` 및 `x:Member`를 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-188">In imperative code, workflow arguments are specified as properties on a new CLR type, and in XAML they are declared by using `x:Class` and `x:Member`.</span></span> <span data-ttu-id="2dee7-189">메모리 내 개체 트리로 워크플로 정의를 만들 때 새 CLR 형식이 만들어지지 않았기 때문에 인수를 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-189">Because there is no new CLR type created when a workflow definition is created as a tree of in-memory objects, arguments cannot be added.</span></span> <span data-ttu-id="2dee7-190">하지만 <xref:System.Activities.DynamicActivity>에 인수를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-190">However, arguments can be added to a <xref:System.Activities.DynamicActivity>.</span></span> <span data-ttu-id="2dee7-191">이 예제에서는 정수 인수 두 개를 취하여 이를 더한 다음 그 결과를 반환하는 <xref:System.Activities.DynamicActivity%601>을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-191">In this example, a <xref:System.Activities.DynamicActivity%601> is created that takes two integer arguments, adds them together, and returns the result.</span></span> <span data-ttu-id="2dee7-192">각 인수에 대해 <xref:System.Activities.DynamicActivityProperty>를 만들고, 작업 결과를 <xref:System.Activities.Activity%601.Result%2A>의 <xref:System.Activities.DynamicActivity%601> 인수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-192">A <xref:System.Activities.DynamicActivityProperty> is created for each argument, and the result of the operation is assigned to the <xref:System.Activities.Activity%601.Result%2A> argument of the <xref:System.Activities.DynamicActivity%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#55](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#55)]  
  
 <span data-ttu-id="2dee7-193">동적 작업에 대 한 자세한 내용은 [런타임에 작업 만들기](creating-an-activity-at-runtime-with-dynamicactivity.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-193">For more information about dynamic activities, see [Creating an Activity at Runtime](creating-an-activity-at-runtime-with-dynamicactivity.md).</span></span>  
  
## <a name="compiled-activities"></a><span data-ttu-id="2dee7-194">컴파일된 활동</span><span class="sxs-lookup"><span data-stu-id="2dee7-194">Compiled Activities</span></span>  

 <span data-ttu-id="2dee7-195">동적 활동은 코드를 사용하여 인수가 포함된 활동을 정의하는 한 방법이지만 활동을 코드에서 만들어 형식으로 컴파일할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-195">Dynamic activities are one way to define an activity that contains arguments using code, but activities can also be created in code and compiled into types.</span></span> <span data-ttu-id="2dee7-196"><xref:System.Activities.CodeActivity>에서 파생되는 간단한 활동과 <xref:System.Activities.AsyncCodeActivity>에서 파생되는 비동기 활동을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-196">Simple activities can be created that derive from <xref:System.Activities.CodeActivity>, and asynchronous activities that derive from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="2dee7-197">이러한 활동은 인수를 사용하고, 값을 반환하며, 명령적 코드를 사용하여 논리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-197">These activities can have arguments, return values, and define their logic using imperative code.</span></span> <span data-ttu-id="2dee7-198">이러한 형식의 활동을 만드는 예제는 [CodeActivity 기본 클래스](workflow-activity-authoring-using-the-codeactivity-class.md) 및 [비동기 활동 만들기](creating-asynchronous-activities-in-wf.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-198">For examples of creating these types of activities, see [CodeActivity Base Class](workflow-activity-authoring-using-the-codeactivity-class.md) and [Creating Asynchronous Activities](creating-asynchronous-activities-in-wf.md).</span></span>  
  
 <span data-ttu-id="2dee7-199"><xref:System.Activities.NativeActivity>에서 파생되는 활동은 명령적 코드를 사용하여 논리를 정의할 수 있으며 논리를 정의하는 자식 활동을 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-199">Activities that derive from <xref:System.Activities.NativeActivity> can define their logic using imperative code and they can also contain child activities that define the logic.</span></span> <span data-ttu-id="2dee7-200">또한 책갈피 만들기 같은 런타임 기능에도 완벽하게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-200">They also have full access to the features of the runtime such as creating bookmarks.</span></span> <span data-ttu-id="2dee7-201">기반 활동 만들기에 대 한 예제는 <xref:System.Activities.NativeActivity> [NativeActivity 기본 클래스](nativeactivity-base-class.md), [방법: 활동 만들기](how-to-create-an-activity.md)및 [Native Activity를 사용 하 여 사용자 지정 복합](./samples/custom-composite-using-native-activity.md) 샘플을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2dee7-201">For examples of creating a <xref:System.Activities.NativeActivity>-based activity, see [NativeActivity Base Class](nativeactivity-base-class.md), [How to: Create an Activity](how-to-create-an-activity.md), and the [Custom Composite using Native Activity](./samples/custom-composite-using-native-activity.md) sample.</span></span>  
  
 <span data-ttu-id="2dee7-202"><xref:System.Activities.Activity>에서 파생되는 활동은 자식 활동을 통해서만 논리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-202">Activities that derive from <xref:System.Activities.Activity> define their logic solely through the use of child activities.</span></span> <span data-ttu-id="2dee7-203">이러한 활동은 일반적으로 워크플로 디자이너를 사용하여 만들지만 코드를 사용하여 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-203">These activities are typically created by using the workflow designer, but can also be defined by using code.</span></span> <span data-ttu-id="2dee7-204">다음 예제에서는 `Square`에서 파생되는 `Activity<int>` 활동을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-204">In the following example, a `Square` activity is defined that derives from `Activity<int>`.</span></span> <span data-ttu-id="2dee7-205">`Square` 활동은 <xref:System.Activities.InArgument%601>라는 단일 `Value`를 사용하며, <xref:System.Activities.Statements.Sequence> 속성을 사용하여 <xref:System.Activities.Activity.Implementation%2A> 활동을 지정함으로써 논리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-205">The `Square` activity has a single <xref:System.Activities.InArgument%601> named `Value`, and defines its logic by specifying a <xref:System.Activities.Statements.Sequence> activity using the <xref:System.Activities.Activity.Implementation%2A> property.</span></span> <span data-ttu-id="2dee7-206"><xref:System.Activities.Statements.Sequence> 활동에는 <xref:System.Activities.Statements.WriteLine> 활동과 <xref:System.Activities.Statements.Assign%601> 활동이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-206">The <xref:System.Activities.Statements.Sequence> activity contains a <xref:System.Activities.Statements.WriteLine> activity and an <xref:System.Activities.Statements.Assign%601> activity.</span></span> <span data-ttu-id="2dee7-207">이러한 세 가지 활동이 함께 `Square` 활동의 논리를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-207">Together, these three activities implement the logic of the `Square` activity.</span></span>  
  
```csharp  
class Square : Activity<int>  
{  
    [RequiredArgument]  
    public InArgument<int> Value { get; set; }  
  
    public Square()  
    {  
        this.Implementation = () => new Sequence  
        {  
            Activities =  
            {  
                new WriteLine  
                {  
                    Text = new InArgument<string>((env) => "Squaring the value: " + this.Value.Get(env))  
                },  
                new Assign<int>  
                {  
                    To = new OutArgument<int>((env) => this.Result.Get(env)),  
                    Value = new InArgument<int>((env) => this.Value.Get(env) * this.Value.Get(env))  
                }  
            }  
        };  
    }  
}  
```  
  
 <span data-ttu-id="2dee7-208">다음 예제에서는 단일 `Square` 활동으로 구성된 워크플로 정의를 <xref:System.Activities.WorkflowInvoker>를 사용하여 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-208">In the following example, a workflow definition consisting of a single `Square` activity is invoked using <xref:System.Activities.WorkflowInvoker>.</span></span>  
  
```csharp  
Dictionary<string, object> inputs = new Dictionary<string, object> {{ "Value", 5}};  
int result = WorkflowInvoker.Invoke(new Square(), inputs);  
Console.WriteLine("Result: {0}", result);  
```  
  
 <span data-ttu-id="2dee7-209">워크플로가 호출되면 다음 출력이 콘솔에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dee7-209">When the workflow is invoked, the following output is displayed to the console:</span></span>  
  
 <span data-ttu-id="2dee7-210">**Squaring the value: 5**</span><span class="sxs-lookup"><span data-stu-id="2dee7-210">**Squaring the value: 5**</span></span>  
<span data-ttu-id="2dee7-211">**Result: 25**</span><span class="sxs-lookup"><span data-stu-id="2dee7-211">**Result: 25**</span></span>
