---
title: C# 프로그램의 구성 요소
description: C# 멤버, 식 및 문에 대해 알아봅니다. 형식에는 사용자가 작성하는 멤버가 포함됩니다. 이러한 멤버는 문과 식에서 빌드됩니다.
ms.date: 08/06/2020
ms.openlocfilehash: e4350f2c2b6005fb59dd868f0f7f628bd07b0053
ms.sourcegitcommit: 0802ac583585110022beb6af8ea0b39188b77c43
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/26/2020
ms.locfileid: "93342698"
---
# <a name="program-building-blocks"></a><span data-ttu-id="9716d-105">프로그램 구성 요소</span><span class="sxs-lookup"><span data-stu-id="9716d-105">Program building blocks</span></span>

<span data-ttu-id="9716d-106">이전 문서에 설명된 형식은 [\***멤버** _](../programming-guide/classes-and-structs/members.md), [_\*_식_\*_, _\*_문_\*_](../programming-guide/statements-expressions-operators/index.md)이라는 구성 요소를 사용하여 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _*_statements_*_](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="9716d-107">멤버</span><span class="sxs-lookup"><span data-stu-id="9716d-107">Members</span></span>

<span data-ttu-id="9716d-108">`class`의 멤버는 정적 멤버 또는 인스턴스 멤버입니다. </span><span class="sxs-lookup"><span data-stu-id="9716d-108">The members of a `class` are either _*_static members_*_ or _*_instance members_*_.</span></span> <span data-ttu-id="9716d-109">정적 멤버는 클래스에 속하며 인스턴스 멤버는 개체(클래스의 인스턴스)에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="9716d-110">다음은 클래스가 포함할 수는 멤버의 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="9716d-111">상수: 클래스와 연결된 상수 값</span><span class="sxs-lookup"><span data-stu-id="9716d-111">_\*Constants\*\*: Constant values associated with the class</span></span>
- <span data-ttu-id="9716d-112">**필드**:  클래스와 연결된 변수</span><span class="sxs-lookup"><span data-stu-id="9716d-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="9716d-113">**메서드**:  클래스가 수행할 수 있는 작업</span><span class="sxs-lookup"><span data-stu-id="9716d-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="9716d-114">**Properties**: 클래스의 명명된 속성에 대한 읽기 및 쓰기와 관련된 작업</span><span class="sxs-lookup"><span data-stu-id="9716d-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="9716d-115">**인덱서**: 클래스 인스턴스를 배열처럼 인덱싱하는 것과 관련된 작업</span><span class="sxs-lookup"><span data-stu-id="9716d-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="9716d-116">**이벤트**: 클래스에 의해 생성될 수 있는 알림</span><span class="sxs-lookup"><span data-stu-id="9716d-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="9716d-117">**연산자**: 클래스가 지원하는 변환 및 식 연산자</span><span class="sxs-lookup"><span data-stu-id="9716d-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="9716d-118">**생성자**: 클래스의 인스턴스 또는 클래스 자체를 초기화하는 데 필요한 작업</span><span class="sxs-lookup"><span data-stu-id="9716d-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="9716d-119">**종료자**: 클래스의 인스턴스가 영구적으로 삭제되기 전에 수행한 작업</span><span class="sxs-lookup"><span data-stu-id="9716d-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="9716d-120">**형식**: 클래스에 의해 선언된 중첩 형식</span><span class="sxs-lookup"><span data-stu-id="9716d-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="9716d-121">접근성</span><span class="sxs-lookup"><span data-stu-id="9716d-121">Accessibility</span></span>

<span data-ttu-id="9716d-122">클래스의 각 멤버에는 해당 멤버에 액세스할 수 있는 프로그램 텍스트의 영역을 제어하는 액세스 수준이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="9716d-123">액세스 가능성은 여섯 가지 형태로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="9716d-124">다음은 액세스 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="9716d-125">`public`: 액세스가 제한되지 않음</span><span class="sxs-lookup"><span data-stu-id="9716d-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="9716d-126">`private`: 이 클래스로만 액세스가 제한됨</span><span class="sxs-lookup"><span data-stu-id="9716d-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="9716d-127">`protected`: 이 클래스 또는 이 클래스에서 파생된 클래스로만 액세스가 제한됨</span><span class="sxs-lookup"><span data-stu-id="9716d-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="9716d-128">`internal`: 액세스가 현재 어셈블리(`.exe` 또는 `.dll`)로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="9716d-129">`protected internal`: 액세스가 이 클래스, 이 클래스에서 파생된 클래스 또는 동일한 어셈블리 내의 클래스로만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="9716d-130">`private protected`: 액세스가 이 클래스 또는 동일한 어셈블리 내의 이 형식에서 파생된 클래스로만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="9716d-131">필드</span><span class="sxs-lookup"><span data-stu-id="9716d-131">Fields</span></span>

<span data-ttu-id="9716d-132">*필드* 는 클래스 또는 클래스의 인스턴스와 연결된 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="9716d-133">static 한정자를 사용하여 선언된 필드는 정적 필드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="9716d-134">정적 필드는 정확히 하나의 스토리지 위치를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="9716d-135">클래스의 인스턴스가 몇 개나 만들어졌는지에 관계없이 정적 필드의 복사본은 하나뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="9716d-136">static 한정자 없이 선언된 필드는 인스턴스 필드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="9716d-137">클래스의 모든 인스턴스는 해당 클래스의 모든 인스턴스 필드의 별도 복사본을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="9716d-138">다음 예제에서 `Color` 클래스의 각 인스턴스는 `R`, `G` 및 `B` 인스턴스 필드의 별도 복사본을 갖지만 `Black`, `White`, `Red`, `Green` 및 `Blue` 정적 필드의 복사본은 하나뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="9716d-139">앞의 예제와 같이 *읽기 전용 필드* 는 `readonly` 한정자를 사용하여 선언될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="9716d-140">읽기 전용 필드에 대한 할당은 필드 선언의 일부로 또는 동일한 클래스의 생성자에서만 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="9716d-141">메서드</span><span class="sxs-lookup"><span data-stu-id="9716d-141">Methods</span></span>

<span data-ttu-id="9716d-142">*메서드* 는 개체 또는 클래스에서 수행할 수 있는 계산이나 작업을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="9716d-143">*정적 메서드* 는 클래스를 통해 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="9716d-144">*인스턴스 메서드* 는 클래스의 인스턴스를 통해 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="9716d-145">메서드에는 메서드로 전달되는 값 또는 변수 참조를 나타내는 ‘매개 변수’ 목록이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="9716d-146">메서드에는 메서드에 의해 계산되고 반환되는 값의 형식을 지정하는 ‘반환 형식’이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="9716d-147">메서드가 값을 반환하지 않을 경우 반환 형식은 `void`입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="9716d-148">형식과 마찬가지로 메서드에는 메서드가 호출될 때 형식 인수가 지정되어야 하는 형식 매개 변수 집합도 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="9716d-149">형식과 달리 형식 인수는 종종 메서드 호출의 인수에서 유추될 수 있으므로 명시적으로 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="9716d-150">메서드의 *시그니처* 는 메서드가 선언되는 클래스에서 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="9716d-151">메서드 시그니처는 메서드의 이름, 형식 매개 변수의 수, 해당 매개 변수의 수, 한정자 및 형식으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="9716d-152">메서드 시그니처는 반환 형식을 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="9716d-153">메서드 본문이 단일 식인 경우 메서드는 다음 예제와 같이 간결한 식 형식을 사용하여 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="9716d-154">매개 변수</span><span class="sxs-lookup"><span data-stu-id="9716d-154">Parameters</span></span>

<span data-ttu-id="9716d-155">매개 변수는 메서드에 값 또는 변수 참조를 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="9716d-156">메서드의 매개 변수는 메서드가 호출될 때 지정된 *인수* 에서 실제 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="9716d-157">매개 변수에는 값 매개 변수, 참조 매개 변수, 출력 매개 변수 및 매개 변수 배열의 네 가지 종류가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="9716d-158">*값 매개 변수* 는 입력 매개 변수를 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="9716d-159">값 매개 변수는 매개 변수에 전달된 인수에서 초기 값을 가져오는 지역 변수에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="9716d-160">값 매개 변수를 수정해도 해당 매개 변수에 전달된 인수에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="9716d-161">해당 인수를 생략할 수 있도록 기본값을 지정하면 값 매개 변수는 선택적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="9716d-162">*참조 매개 변수* 는 인수를 참조로 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="9716d-163">참조 매개 변수에 전달되는 인수는 한정된 값을 가진 변수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="9716d-164">메서드를 실행하는 동안 참조 매개 변수는 인수 변수와 동일한 스토리지 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="9716d-165">참조 매개 변수는 `ref` 한정자를 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="9716d-166">다음 예제에서는 `ref` 매개 변수를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="9716d-167">*출력 매개 변수* 는 인수를 참조로 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="9716d-168">호출자가 제공한 인수에 값을 명시적으로 할당할 필요가 없다는 점을 제외하고 참조 매개 변수와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="9716d-169">출력 매개 변수는 `out` 한정자를 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="9716d-170">다음 예제에서는 C# 7에서 도입된 구문으로 `out` 매개 변수를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="9716d-171">*매개 변수 배열* 은 다양한 개수의 인수가 메서드에 전달되도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="9716d-172">매개 변수 배열은 `params` 한정자를 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="9716d-173">메서드의 마지막 매개 변수만 매개 변수 배열일 수 있으며 매개 변수 배열의 형식은 1차원 배열 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="9716d-174"><xref:System.Console?displayProperty=nameWithType> 클래스의 `Write` 및 `WriteLine` 메서드는 매개 변수 배열 사용의 좋은 예입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="9716d-175">이러한 메서드는 다음과 같이 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="9716d-176">매개 변수 배열을 사용하는 메서드 내에서 매개 변수 배열은 배열 형식의 일반 매개 변수와 정확히 동일하게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="9716d-177">그러나 매개 변수 배열을 사용한 메서드 호출에서 매개 변수 배열 형식의 단일 인수 또는 매개 변수 배열에 있는 임의 개수의 요소 형식 인수를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="9716d-178">후자의 경우 지정된 인수를 사용하여 배열 인스턴스가 자동으로 만들어지고 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="9716d-179">다음 예제는</span><span class="sxs-lookup"><span data-stu-id="9716d-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="9716d-180">다음을 작성하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="9716d-181">메서드 본문 및 지역 변수</span><span class="sxs-lookup"><span data-stu-id="9716d-181">Method body and local variables</span></span>

<span data-ttu-id="9716d-182">메서드의 본문은 메서드가 호출될 때 실행할 문을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="9716d-183">메서드 본문은 메서드 호출과 관련된 변수를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="9716d-184">이러한 변수를 *지역 변수* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="9716d-185">지역 변수 선언은 형식 이름, 변수 이름을 지정하며 초기 값을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="9716d-186">다음 예제에서는 초기 값이 0인 지역 변수 `i`와 초기 값이 없는 지역 변수 `j`를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="9716d-187">C#에서는 해당 값을 얻기 위해 먼저 로컬 변수를 *명확 하게 할당* 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="9716d-188">예를 들어 이전 `i`의 선언이 초기 값을 포함하지 않으면 컴파일러는 `i`의 후속 사용에 대해 오류를 보고합니다. `i`는 프로그램에서 해당 시점에 명확하게 할당되지 않은 것이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="9716d-189">메서드는 `return` 문을 사용하여 해당 호출자에게 컨트롤을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="9716d-190">`void`를 반환하는 메서드에서 `return` 문은 식을 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="9716d-191">void 이외의 값을 반환하는 메서드에서 `return` 문은 반환 값을 계산하는 식을 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="9716d-192">정적 및 인스턴스 메서드</span><span class="sxs-lookup"><span data-stu-id="9716d-192">Static and instance methods</span></span>

<span data-ttu-id="9716d-193">`static` 한정자를 사용하여 선언된 메서드는 ‘정적 메서드’입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="9716d-194">정적 메서드는 특정 인스턴스에 작동하지 않고 정적 멤버에 직접적으로만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="9716d-195">`static` 한정자를 사용하지 않고 선언된 메서드는 ‘인스턴스 메서드’입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="9716d-196">인스턴스 메서드는 특정 인스턴스에 작동하며 정적 및 인스턴스 멤버 둘 다에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="9716d-197">인스턴스 메서드가 호출된 인스턴스는 `this`로 명시적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="9716d-198">정적 메서드에서 `this`를 참조하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="9716d-199">다음 `Entity` 클래스에는 정적 멤버와 인스턴스 멤버가 모두 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="9716d-200">각 `Entity` 인스턴스에는 일련 번호(및 여기에 표시되지 않는 몇몇 정보)가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="9716d-201">`Entity` 생성자(인스턴스 메서드와 유사함)는 사용 가능한 다음 일련 번호를 사용하여 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="9716d-202">생성자가 인스턴스 멤버이기 때문에 `_serialNo` 인스턴스 필드 및 `s_nextSerialNo` 정적 필드 둘 다에 액세스하도록 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="9716d-203">`GetNextSerialNo` 및 `SetNextSerialNo` 정적 메서드는 `s_nextSerialNo` 정적 필드에 액세스할 수 있지만 `_serialNo` 인스턴스 필드에 직접 액세스하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="9716d-204">다음 예제에서는 사용 된 `Entity` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="9716d-205">`SetNextSerialNo` 및 `GetNextSerialNo` 정적 메서드는 클래스에 대해 호출되지만 `GetSerialNo` 인스턴스 메서드는 클래스의 인스턴스에 대해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="9716d-206">가상, 재정의 및 추상 메서드</span><span class="sxs-lookup"><span data-stu-id="9716d-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="9716d-207">인스턴스 메서드 선언에 `virtual` 한정자가 포함되면 해당 메서드를 *가상 메서드* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="9716d-208">가상 한정자가 없으면 해당 메서드를 *비가상 메서드* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="9716d-209">가상 메서드가 호출되면 호출이 발생하는 인스턴스의 *런타임 형식* 에 따라 호출할 실제 메서드 구현이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="9716d-210">비가상 메서드 호출에서는 인스턴스의 *컴파일 타임 형식* 이 결정 요인입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="9716d-211">가상 메서드는 파생된 클래스에서 *재정의* 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="9716d-212">인스턴스 메서드 선언에 재정의 한정자가 포함될 경우 메서드는 동일한 시그니처로 상속된 가상 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="9716d-213">가상 메서드 선언은 새 메서드를 도입합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="9716d-214">재정의 메서드 선언은 해당 메서드의 새 구현을 제공하여 기존의 상속된 가상 메서드를 특수화합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="9716d-215">*추상 메서드* 는 구현이 없는 가상 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="9716d-216">추상 메서드는 `abstract` 한정자를 사용하여 선언되며 추상 클래스에서만 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="9716d-217">추상 메서드는 모든 비추상 파생 클래스에서 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="9716d-218">다음 예제에서는 식 트리 노드를 나타내는 추상 클래스 `Expression`와 상수, 변수 참조 및 산술 연산에 대한 식 트리 노드를 구현하는 세 개의 파생 클래스 `Constant`, `VariableReference` 및 `Operation`을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="9716d-219">(이 예제는 식 트리 형식과 비슷하지만 관련은 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="9716d-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="9716d-220">이전의 4개 클래스는 산술 연산자를 모델링하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="9716d-221">예를 들어 이러한 클래스의 인스턴스를 사용할 경우 식 `x + 3`을 다음과 같이 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="9716d-222">`Expression` 인스턴스의 `Evaluate` 메서드는 지정된 식을 계산하고 `double` 값을 생성하기 위해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="9716d-223">이 메서드는 변수 이름(항목의 키)과 값(항목의 값)을 포함하는 `Dictionary` 인수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="9716d-224">`Evaluate`가 추상 메서드이기 때문에 `Expression`에서 파생된 비추상 클래스는 `Evaluate`를 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="9716d-225">`Evaluate`의 `Constant` 구현은 단순히 저장된 상수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="9716d-226">`VariableReference`의 구현은 사전에서 변수 이름을 조회하고 결과 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="9716d-227">`Operation`의 구현은 먼저 왼쪽 및 오른쪽 피연산자를 계산하고(재귀적으로 해당 `Evaluate` 메서드 호출) 지정된 산술 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="9716d-228">다음 프로그램에서는 `Expression` 클래스를 사용하여 `x` 및 `y`의 다른 값에 대해 식 `x * (y + 2)`를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="9716d-229">메서드 오버로드</span><span class="sxs-lookup"><span data-stu-id="9716d-229">Method overloading</span></span>

<span data-ttu-id="9716d-230">메서드 *오버로드* 는 동일한 클래스가 고유한 시그니처를 갖는 한, 동일한 이름을 갖도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="9716d-231">오버로드된 메서드의 호출을 컴파일할 때 컴파일러는 *오버로드 확인* 을 사용하여 호출할 특정 메서드를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="9716d-232">오버로드 확인은 인수와 가장 적합하게 일치하는 단일 메서드를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="9716d-233">최상의 일치 메서드를 찾을 수 있는 경우 오류를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="9716d-234">다음 예제에서는 실제로 진행되는 오버로드 확인을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="9716d-235">`UsageExample` 메서드의 각 호출에 대한 주석은 어느 메서드가 호출되었는지 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="9716d-236">예제와 같이, 인수를 정확한 매개 변수 형식과 형식 인수로 명시적으로 캐스팅하여 항상 특정 메서드를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="9716d-237">기타 함수 멤버</span><span class="sxs-lookup"><span data-stu-id="9716d-237">Other function members</span></span>

<span data-ttu-id="9716d-238">실행 코드를 포함하는 멤버를 통칭하여 클래스의 *함수 멤버* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="9716d-239">이전 섹션에서는 함수 멤버의 기본 종류인 메서드에 대해 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="9716d-240">이 섹션에서는 C#에서 지원하는 다른 종류의 함수 멤버인 생성자, 속성, 인덱서, 이벤트, 연산자 및 종료자에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="9716d-241">다음 예제에서는 늘어날 수 있는 개체 목록을 구현하는 `MyList<T>`라는 제네릭 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="9716d-242">이 클래스는 함수 멤버의 가장 일반적인 몇 가지 예제를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="9716d-243">생성자</span><span class="sxs-lookup"><span data-stu-id="9716d-243">Constructors</span></span>

<span data-ttu-id="9716d-244">C#은 인스턴스 및 정적 생성자를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="9716d-245">*인스턴스 생성자* 는 클래스의 인스턴스를 초기화하는 데 필요한 작업을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="9716d-246">‘정적 생성자’는 처음 로드될 때 클래스 자체를 초기화하는 데 필요한 동작을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="9716d-247">생성자는 반환 형식이 없고 포함하는 클래스와 동일한 이름을 갖는 메서드처럼 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="9716d-248">생성자 선언에 `static` 한정자가 포함될 경우 정적 생성자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="9716d-249">그렇지 않으면 인스턴스 생성자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="9716d-250">인스턴스 생성자는 오버로드될 수 있으며 선택적 매개 변수를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="9716d-251">예를 들어 `MyList<T>` 클래스는 단일 선택적 `int` 매개 변수를 사용하여 하나의 인스턴스 생성자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="9716d-252">인스턴스 생성자는 `new` 연산자를 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="9716d-253">다음 문은 각각 선택적 인수를 사용하거나 사용하지 않고 `MyList<string>` 클래스의 생성자를 사용하여 2가지 `MyList` 인스턴스를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="9716d-254">다른 멤버와 달리 인스턴스 생성자는 상속되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="9716d-255">클래스에는 클래스에서 실제로 선언된 인스턴스 생성자 외에는 인스턴스 생성자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="9716d-256">클래스에 대해 인스턴스 생성자가 제공되지 않으면 매개 변수가 없는 빈 인스턴스 생성자가 자동으로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="9716d-257">속성</span><span class="sxs-lookup"><span data-stu-id="9716d-257">Properties</span></span>

<span data-ttu-id="9716d-258">*속성* 은 필드의 기본 확장입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="9716d-259">둘 다 연결된 형식으로 명명되는 멤버이며, 필드 및 속성에 액세스하는 구문은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="9716d-260">그러나 필드와 달리 속성은 스토리지 위치를 명시하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="9716d-261">대신, 속성에는 해당 값을 읽거나 쓸 때 실행될 문을 지정하는 ‘접근자’가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="9716d-262">속성은 필드처럼 선언되지만, 선언이 세미콜론으로 끝나지 않고, 구분 기호 `{` 및 `}` 사이에 쓴 get 접근자 또는 set 접근자로 끝난다는 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="9716d-263">get 접근자 및 set 접근자가 둘 다 있는 속성은 *읽기/쓰기 속성* 이고, get 접근자만 있는 속성은 *읽기 전용 속성* 이고, set 접근자만 있는 속성은 *쓰기 전용 속성* 입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="9716d-264">get 접근자는 속성 형식의 반환 값을 갖는 매개 변수 없는 메서드에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="9716d-265">set 접근자는 value라는 단일 매개 변수를 가지며 반환 형식이 없는 메서드에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="9716d-266">get 접근자는 속성의 값을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="9716d-267">set 접근자는 속성에 새 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="9716d-268">속성이 할당의 대상이거나 `++` 또는 `--`의 피연산자인 경우 set 접근자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="9716d-269">속성이 참조되는 그 밖의 경우에는 get 접근자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="9716d-270">`MyList<T>` 클래스는 각각 읽기 전용 및 읽기/쓰기 특성을 갖는 두 개의 속성 `Count` 및 `Capacity`를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-270">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="9716d-271">다음 코드는 이러한 속성을 사용하는 예입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-271">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="9716d-272">필드 및 메서드와 마찬가지로, C#은 인스턴스 속성 및 정적 속성을 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-272">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="9716d-273">정적 속성은 static 한정자를 사용하여 선언되고 인스턴스 속성은 이 한정자를 사용하지 않고 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-273">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="9716d-274">속성의 접근자는 가상일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-274">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="9716d-275">속성 선언에 `virtual`, `abstract`, 또는 `override` 한정자가 포함되면 속성의 접근자에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-275">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="9716d-276">인덱서</span><span class="sxs-lookup"><span data-stu-id="9716d-276">Indexers</span></span>

<span data-ttu-id="9716d-277">*인덱서* 는 개체가 배열과 같은 방식으로 인덱싱될 수 있도록 하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-277">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="9716d-278">인덱서는 `this`과(와) 구분 기호 `[` 및 `]` 사이에 작성된 매개 변수 목록을 합쳐서 구성원 이름으로 사용한다는 점을 제외하고 속성처럼 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-278">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="9716d-279">매개 변수는 인덱서의 접근자에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-279">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="9716d-280">속성과 마찬가지로 인덱서는 읽기/쓰기, 읽기 전용 및 쓰기 전용일 수 있으며 인덱서의 접근자는 가상일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-280">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="9716d-281">`MyList<T>` 클래스는 `int` 매개 변수를 사용하는 단일 읽기/쓰기 인덱서를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-281">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="9716d-282">인덱서는 `MyList<T>` 인스턴스를 `int` 값으로 인덱싱할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-282">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="9716d-283">예를 들어 다음과 같은 가치를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-283">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="9716d-284">인덱서는 오버로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-284">Indexers can be overloaded.</span></span> <span data-ttu-id="9716d-285">하나의 클래스는 매개 변수의 수와 형식이 다른 여러 인덱서를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-285">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="9716d-286">이벤트</span><span class="sxs-lookup"><span data-stu-id="9716d-286">Events</span></span>

<span data-ttu-id="9716d-287">*이벤트* 는 클래스 또는 개체가 알림을 제공할 수 있도록 하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-287">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="9716d-288">이벤트는 선언에 `event` 키워드가 포함되고 형식이 대리자 형식이어야 한다는 점을 제외하고 필드처럼 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-288">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="9716d-289">이벤트 멤버를 선언하는 클래스 내에서 이벤트는 대리자 형식의 필드처럼 동작합니다(이벤트가 추상이 아니고 접근자를 선언하지 않을 경우).</span><span class="sxs-lookup"><span data-stu-id="9716d-289">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="9716d-290">필드는 이벤트에 추가된 이벤트 처리기를 나타내는 대리자에 대한 참조를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-290">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="9716d-291">이벤트 처리기가 없는 경우 필드는 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-291">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="9716d-292">`MyList<T>` 클래스는 `Changed`라는 단일 이벤트 멤버를 선언합니다. 이것은 새 항목이 목록에 추가되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-292">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="9716d-293">Changed 이벤트는 `OnChanged` 가상 메서드에 의해 발생합니다. 이 메서드는 먼저 이벤트가 `null`인지 확인합니다(처리기가 없음을 의미함).</span><span class="sxs-lookup"><span data-stu-id="9716d-293">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="9716d-294">이벤트 발생 개념은 이벤트가 나타내는 대리자를 호출하는 것과 정확히 동일하므로</span><span class="sxs-lookup"><span data-stu-id="9716d-294">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="9716d-295">이벤트 발생을 위한 특수한 언어 구문은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-295">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="9716d-296">클라이언트는 *이벤트 처리기* 를 통해 이벤트에 반응합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-296">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="9716d-297">이벤트 처리기는 `+=` 연산자를 사용하여 추가되고, `-=` 연산자를 사용하여 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-297">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="9716d-298">다음 예제에서는 이벤트 처리기를 `MyList<string>`의 `Changed` 이벤트에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-298">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="9716d-299">이벤트의 기본 스토리지를 제어하려고 하는 고급 시나리오의 경우 이벤트 선언에서 속성의 `set` 접근자와 비슷한 `add` 및 `remove` 접근자를 명시적으로 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-299">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="9716d-300">연산자</span><span class="sxs-lookup"><span data-stu-id="9716d-300">Operators</span></span>

<span data-ttu-id="9716d-301">*연산자* 는 클래스 인스턴스에 특정 식 연산자를 적용하는 것의 의미를 정의하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-301">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="9716d-302">세 가지 종류의 연산자, 즉, 단항 연산자, 이항 연산자 및 변환 연산자를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-302">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="9716d-303">모든 연산자는 `public` 및 `static`으로 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-303">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="9716d-304">`MyList<T>` 클래스는 두 개의 연산자 `operator ==` 및 `operator !=`를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-304">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="9716d-305">이들 재정의된 연산자는 해당 연산자를 `MyList` 인스턴스에 적용하는 식에 새로운 의미를 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-305">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="9716d-306">특히, 이러한 연산자는 해당 `Equals` 메서드를 사용하여 포함된 각 개체를 비교할 때 두 `MyList<T>` 인스턴스의 같음을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-306">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="9716d-307">다음 예제에서는 `==` 연산자를 사용하여 두 `MyList<int>` 인스턴스를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-307">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="9716d-308">두 목록은 같은 순서로 같은 값을 갖는 동일한 수의 개체를 포함하므로 첫 번째 `Console.WriteLine`은 `True`를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-308">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="9716d-309">`MyList<T>`에서 `operator ==`이 정의되지 않았으면 `a` 및 `b`은 다른 `MyList<int>` 인스턴스를 참조하므로 첫 번째 `Console.WriteLine`은 `False`를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-309">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="9716d-310">종료자</span><span class="sxs-lookup"><span data-stu-id="9716d-310">Finalizers</span></span>

<span data-ttu-id="9716d-311">*종료자* 는 클래스의 인스턴스를 종결하는 데 필요한 작업을 구현하는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-311">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="9716d-312">종료자는 일반적으로 관리되지 않는 리소스를 해제하는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-312">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="9716d-313">종료자는 매개 변수를 가질 수 없고, 액세스 수준 한정자를 가질 수 없으며, 명시적으로 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-313">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="9716d-314">인스턴스에 대한 종료자는 가비지 수집 중에 자동으로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-314">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="9716d-315">자세한 내용은 [종료자](../programming-guide/classes-and-structs/destructors.md) 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9716d-315">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="9716d-316">가비지 수집기는 개체를 수집하고 종료자를 실행할 시기를 유연하게 결정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-316">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="9716d-317">특히, 종료자 호출 타이밍은 결정적이 아니며, 모든 스레드에서 종료자를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-317">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="9716d-318">이러한 이유 및 기타 이유로 클래스는 가능한 다른 솔루션이 없을 때만 종료자를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-318">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="9716d-319">`using` 문은 개체 소멸을 위한 더 나은 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-319">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="9716d-320">표현식</span><span class="sxs-lookup"><span data-stu-id="9716d-320">Expressions</span></span>

<span data-ttu-id="9716d-321">*식* 은 *피연산자* 및 *연산자* 로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-321">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="9716d-322">식의 연산자는 피연산자에 적용할 연산을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-322">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="9716d-323">연산자의 예로 `+`, `-`, `*`, `/` 및 `new`가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-323">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="9716d-324">피연산자의 예로는 리터럴, 필드, 지역 변수 및 식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-324">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="9716d-325">식에 여러 연산자가 포함된 경우 연산자의 ‘우선 순위’는 개별 연산자가 평가되는 순서를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-325">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="9716d-326">예를 들어 `*` 연산자는 `+` 연산자보다 우선 순위가 더 높기 때문에 식 `x + y * z`는 `x + (y * z)`로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-326">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="9716d-327">피연산자는 동일한 우선 순위를 가진 두 연산자 사이에 나올 경우 연산자의 *결합성* 에 따라 연산이 수행되는 순서가 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-327">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="9716d-328">대입 및 Null 병합 연산자를 제외하고 모든 이항 연산자는 *왼쪽 결합성* 을 갖습니다. 즉, 연산이 왼쪽에서 오른쪽으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-328">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="9716d-329">예를 들어, `x + y + z`는 `(x + y) + z`로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-329">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="9716d-330">대입 연산자, Null 병합 `??` 및 `??=` 연산자, 조건부 연산자(`?:`)는 *오른쪽 결합성* 을 갖습니다. 즉, 연산이 오른쪽에서 왼쪽으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-330">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="9716d-331">예를 들어, `x = y = z`는 `x = (y = z)`로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-331">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="9716d-332">우선 순위 및 결합성은 괄호를 사용하여 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-332">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="9716d-333">예를 들어 `x + y * z`는 먼저 `y`와 `z`를 곱한 다음 그 결과를 `x`와 더하지만 `(x + y) * z`는 먼저 `x`와 `y`를 더한 다음 그 결과에 `z`를 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-333">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="9716d-334">대부분의 연산자는 [*오버로드*](../language-reference/operators/operator-overloading.md)할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-334">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="9716d-335">연산자 오버로드는 피연산자 중 하나 또는 둘 다가 사용자 정의 클래스 또는 구조체 형식인 연산에 대해 사용자 정의 연산자 구현을 지정할 수 있도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-335">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="9716d-336">C#은 [산술](../language-reference/operators/arithmetic-operators.md), [논리](../language-reference/operators/boolean-logical-operators.md), [비트 및 시프트](../language-reference/operators/bitwise-and-shift-operators.md) 연산과 [같음](../language-reference/operators/equality-operators.md) 및 [순서](../language-reference/operators/comparison-operators.md) 비교를 수행하는 여러 연산자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-336">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="9716d-337">우선 순위 수준에 따라 정렬된 전체 연산자 목록은 [C# 연산자](../language-reference/operators/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9716d-337">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="9716d-338">문</span><span class="sxs-lookup"><span data-stu-id="9716d-338">Statements</span></span>

<span data-ttu-id="9716d-339">프로그램의 동작은 *문* 을 사용하여 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-339">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="9716d-340">C#은 여러 다른 종류의 문을 지원하며 이중 많은 문이 포함 문에 대해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-340">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="9716d-341">*블록* 은 단일 문이 허용되는 컨텍스트에서 여러 문을 쓸 수 있도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-341">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="9716d-342">블록은 구분 기호 `{`와 `}` 사이에 쓴 문 목록으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-342">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="9716d-343">*선언 문* 은 지역 변수 및 상수를 선언하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-343">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="9716d-344">*식 문* 은 식을 평가하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-344">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="9716d-345">문으로 사용할 수 있는 식에는 메서드 호출, `new` 연산자를 사용하는 개체 할당, `=` 및 복합 할당 연산자를 사용하는 대입, `++` 및 `--` 연산자를 사용하는 증가 및 감소 연산, `await` 식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-345">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="9716d-346">*선택 문* 은 일부 식 값에 따라 실행할 수 있는 다양한 문 중에서 하나를 선택하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-346">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="9716d-347">이 그룹에는 `if` 문과 `switch` 문이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-347">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="9716d-348">*반복 문* 은 포함 문을 반복해서 실행하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-348">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="9716d-349">이 그룹에는 `while` 문, `do` 문, `for` 문과 `foreach` 문이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-349">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="9716d-350">*점프 문* 은 제어를 전달하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-350">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="9716d-351">이 그룹에는 `break` 문, `continue` 문, `goto` 문, `throw` 문, `return` 문과 `yield` 문이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-351">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="9716d-352">`try`... `catch` 문은 블록 실행 중에 발생하는 예외를 catch하는 데 사용되고 `try`... `finally` 문은 예외 발생 여부에 관계 없이 항상 실행되는 종료 코드를 지정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-352">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="9716d-353">`checked` 및 `unchecked` 문은 정수 계열 형식 산술 연산 및 변환에 대한 오버플로 검사 컨텍스트를 제어하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-353">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="9716d-354">`lock` 문은 지정된 개체에 대한 상호 배타적 잠금을 획득하고, 문을 실행한 후 잠금을 해제하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-354">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="9716d-355">`using` 문은 리소스를 획득하고, 문을 실행한 후 해당 리소스를 삭제하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-355">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="9716d-356">다음은 사용할 수 있는 문 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="9716d-356">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="9716d-357">지역 변수 선언</span><span class="sxs-lookup"><span data-stu-id="9716d-357">Local variable declaration.</span></span>
* <span data-ttu-id="9716d-358">지역 상수 선언</span><span class="sxs-lookup"><span data-stu-id="9716d-358">Local constant declaration.</span></span>
* <span data-ttu-id="9716d-359">식 문</span><span class="sxs-lookup"><span data-stu-id="9716d-359">Expression statement.</span></span>
* <span data-ttu-id="9716d-360">`if` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-360">`if` statement.</span></span>
* <span data-ttu-id="9716d-361">`switch` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-361">`switch` statement.</span></span>
* <span data-ttu-id="9716d-362">`while` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-362">`while` statement.</span></span>
* <span data-ttu-id="9716d-363">`do` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-363">`do` statement.</span></span>
* <span data-ttu-id="9716d-364">`for` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-364">`for` statement.</span></span>
* <span data-ttu-id="9716d-365">`foreach` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-365">`foreach` statement.</span></span>
* <span data-ttu-id="9716d-366">`break` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-366">`break` statement.</span></span>
* <span data-ttu-id="9716d-367">`continue` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-367">`continue` statement.</span></span>
* <span data-ttu-id="9716d-368">`goto` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-368">`goto` statement.</span></span>
* <span data-ttu-id="9716d-369">`return` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-369">`return` statement.</span></span>
* <span data-ttu-id="9716d-370">`yield` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-370">`yield` statement.</span></span>
* <span data-ttu-id="9716d-371">`throw` 문과 `try` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-371">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="9716d-372">`checked` 및 `unchecked` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-372">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="9716d-373">`lock` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-373">`lock` statement.</span></span>
* <span data-ttu-id="9716d-374">`using` 문</span><span class="sxs-lookup"><span data-stu-id="9716d-374">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9716d-375">[이전](types.md)
>[다음](features.md)</span><span class="sxs-lookup"><span data-stu-id="9716d-375">[Previous](types.md)
[Next](features.md)</span></span>
