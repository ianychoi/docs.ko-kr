---
title: C#주요 언어 영역 둘러보기
description: C#을 처음 사용하시나요? 언어의 기본 사항에 대해 알아봅니다. 이 문서에는 주 언어 기능에 대한 설문 조사가 포함되어 있습니다.
ms.date: 08/06/2020
ms.openlocfilehash: 943701b544dd3495fa2286e804e2566da146cb45
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216657"
---
# <a name="major-language-areas"></a><span data-ttu-id="9d7a9-105">주 언어 영역</span><span class="sxs-lookup"><span data-stu-id="9d7a9-105">Major language areas</span></span>

## <a name="arrays-collections-and-linq"></a><span data-ttu-id="9d7a9-106">배열, 컬렉션 및 LINQ</span><span class="sxs-lookup"><span data-stu-id="9d7a9-106">Arrays, collections, and LINQ</span></span>

<span data-ttu-id="9d7a9-107">C#과 .NET은 여러 컬렉션 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-107">C# and .NET provide many different collection types.</span></span> <span data-ttu-id="9d7a9-108">배열에는 언어에 의해 정의된 구문이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-108">Arrays have syntax defined by the language.</span></span> <span data-ttu-id="9d7a9-109">제네릭 컬렉션 형식은 <xref:System.Collections.Generic?displayProperty=fullName> 네임스페이스에 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-109">Generic collection types are listed in the <xref:System.Collections.Generic?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="9d7a9-110">특수 컬렉션에는 스택 프레임에서 연속 메모리에 액세스하기 위한 <xref:System.Span%601?displayProperty=nameWithType>와 관리되는 힙에서 연속 메모리에 액세스하기 위한 <xref:System.Memory%601?displayProperty=nameWithType>가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-110">Specialized collections include <xref:System.Span%601?displayProperty=nameWithType> for accessing continuous memory on the stack frame, and <xref:System.Memory%601?displayProperty=nameWithType> for accessing continuous memory on the managed heap.</span></span> <span data-ttu-id="9d7a9-111">배열, <xref:System.Span%601>, <xref:System.Memory%601>를 포함하는 모든 컬렉션은 반복을 위한 통일된 원칙을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-111">All collections, including arrays, <xref:System.Span%601>, and <xref:System.Memory%601> share a unifying principle for iteration.</span></span> <span data-ttu-id="9d7a9-112">사용자는 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-112">You use the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="9d7a9-113">이 통일된 원칙은 모든 컬렉션 형식을 LINQ 쿼리 또는 기타 알고리즘과 함께 사용할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-113">This unifying principle means that any of the collection types can be used with LINQ queries or other algorithms.</span></span> <span data-ttu-id="9d7a9-114">메서드는 <xref:System.Collections.Generic.IEnumerable%601>를 사용하여 작성하며, 이러한 알고리즘은 모든 컬렉션에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-114">You write methods using <xref:System.Collections.Generic.IEnumerable%601> and those algorithms work with any collection.</span></span>

### <a name="arrays"></a><span data-ttu-id="9d7a9-115">배열</span><span class="sxs-lookup"><span data-stu-id="9d7a9-115">Arrays</span></span>

<span data-ttu-id="9d7a9-116">[**배열**](../programming-guide/arrays/index.md)은 계산된 인덱스를 통해 액세스되는 여러 변수를 포함하는 데이터 구조입니다.\*</span><span class="sxs-lookup"><span data-stu-id="9d7a9-116">An [\***array** _](../programming-guide/arrays/index.md) is a data structure that contains a number of variables that are accessed through computed indices.</span></span> <span data-ttu-id="9d7a9-117">배열에 포함된 변수, 즉 배열의 요소라고도 하는 배열은 모두 같은 형식이며,</span><span class="sxs-lookup"><span data-stu-id="9d7a9-117">The variables contained in an array, also called the _*_elements_*_ of the array, are all of the same type.</span></span> <span data-ttu-id="9d7a9-118">이 형식을 배열의 요소 형식이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-118">This type is called the _*_element type_*_ of the array.</span></span>

<span data-ttu-id="9d7a9-119">배열 형식은 참조 형식이고 배열 변수의 선언은 배열 인스턴스에 대한 참조를 위한 공간을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-119">Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance.</span></span> <span data-ttu-id="9d7a9-120">실제 배열 인스턴스는 `new` 연산자를 사용하여 런타임에 동적으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-120">Actual array instances are created dynamically at runtime using the `new` operator.</span></span> <span data-ttu-id="9d7a9-121">`new` 연산은 새 배열 인스턴스의 길이(인스턴스 수명 동안 고정됨)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-121">The `new` operation specifies the _*_length_*_ of the new array instance, which is then fixed for the lifetime of the instance.</span></span> <span data-ttu-id="9d7a9-122">배열 요소의 인덱스 범위는 `0`에서 `Length - 1` 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-122">The indices of the elements of an array range from `0` to `Length - 1`.</span></span> <span data-ttu-id="9d7a9-123">`new` 연산자는 배열의 요소를 모든 숫자 형식에 대해 0이고, 모든 참조 형식에 대해 `null`인 기본값으로 자동으로 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-123">The `new` operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and `null` for all reference types.</span></span>

<span data-ttu-id="9d7a9-124">다음 예제에서는 `int` 요소의 배열을 만들고 배열을 초기화하고 배열의 콘텐츠를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-124">The following example creates an array of `int` elements, initializes the array, and prints the contents of the array.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArraysSample":::

<span data-ttu-id="9d7a9-125">이 예제에서는 1차원 배열을 만들고 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-125">This example creates and operates on a _*_single-dimensional array_*_.</span></span> <span data-ttu-id="9d7a9-126">C#에서는 다차원 배열도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-126">C# also supports _*_multi-dimensional arrays_*_.</span></span> <span data-ttu-id="9d7a9-127">배열 형식의 ‘순위’라고도 하는 배열 형식의 차원 수는 배열 형식의 대괄호 사이에 사용된 쉼표 수에 1을 더한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-127">The number of dimensions of an array type, also known as the _*_rank_*_ of the array type, is one plus the number of commas between the square brackets of the array type.</span></span> <span data-ttu-id="9d7a9-128">다음 예제에서는 1차원, 2차원 및 3차원 배열을 각각 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-128">The following example allocates a single-dimensional, a two-dimensional, and a three-dimensional array, respectively.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DeclareArrays":::

<span data-ttu-id="9d7a9-129">`a1` 배열에는 10개의 요소가 들어 있고 `a2` 배열에는 50(10 × 5)개의 요소가 들어 있고 `a3` 배열에는 100(10 × 5 × 2)개 요소가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-129">The `a1` array contains 10 elements, the `a2` array contains 50 (10 × 5) elements, and the `a3` array contains 100 (10 × 5 × 2) elements.</span></span>
<span data-ttu-id="9d7a9-130">배열의 요소 형식은 배열 형식을 비롯한 어떤 형식도 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-130">The element type of an array can be any type, including an array type.</span></span> <span data-ttu-id="9d7a9-131">배열 형식의 요소가 있는 배열을 가변 배열이라고도 합니다. 요소 배열의 길이가 항상 동일할 필요는 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-131">An array with elements of an array type is sometimes called a _*_jagged array_*_ because the lengths of the element arrays don't all have to be the same.</span></span> <span data-ttu-id="9d7a9-132">다음 예제에서는 `int` 배열의 배열을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-132">The following example allocates an array of arrays of `int`:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArrayOfArrays":::

<span data-ttu-id="9d7a9-133">첫 번째 줄은 형식이 `int[]`이고 초기 값이 `null`인 3개 요소가 있는 배열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-133">The first line creates an array with three elements, each of type `int[]` and each with an initial value of `null`.</span></span> <span data-ttu-id="9d7a9-134">다음 줄은 가변 길이의 개별 배열 인스턴스에 대한 참조로 3개 요소를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-134">The next lines then initialize the three elements with references to individual array instances of varying lengths.</span></span>

<span data-ttu-id="9d7a9-135">`new` 연산자는 구분 기호 `{`와 `}` 사이에 쓰인 식 목록인 배열 이니셜라이저를 사용하여 배열 요소의 초기 값이 지정되도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-135">The `new` operator permits the initial values of the array elements to be specified using an _*_array initializer_*_, which is a list of expressions written between the delimiters `{` and `}`.</span></span> <span data-ttu-id="9d7a9-136">다음 예제에서는 3개 요소로 `int[]`를 할당하고 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-136">The following example allocates and initializes an `int[]` with three elements.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeArray":::

<span data-ttu-id="9d7a9-137">배열의 길이는 `{`와 `}` 사이에 있는 식의 개수에서 유추됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-137">The length of the array is inferred from the number of expressions between `{` and `}`.</span></span> <span data-ttu-id="9d7a9-138">배열 형식을 다시 시작할 필요가 없도록 배열 초기화를 더 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-138">Array initialization can be shortened further such that the array type doesn't have to be restated.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeShortened":::

<span data-ttu-id="9d7a9-139">앞의 두 예제는 다음 코드와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-139">Both of the previous examples are equivalent to the following code:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeGenerated":::

<span data-ttu-id="9d7a9-140">`foreach` 문은 컬렉션의 요소를 열거하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-140">The `foreach` statement can be used to enumerate the elements of any collection.</span></span> <span data-ttu-id="9d7a9-141">다음 코드는 앞에 나온 예제의 배열을 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-141">The following code enumerates the array from the preceding example:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="EnumerateArray":::

<span data-ttu-id="9d7a9-142">`foreach` 문은 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스를 사용하므로 모든 컬렉션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-142">The `foreach` statement uses the <xref:System.Collections.Generic.IEnumerable%601> interface, so can work with any collection.</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="9d7a9-143">문자열 보간</span><span class="sxs-lookup"><span data-stu-id="9d7a9-143">String interpolation</span></span>

<span data-ttu-id="9d7a9-144">C# [문자열 보간](../language-reference/tokens/interpolated.md)을 사용하면 결과가 서식 문자열에 배치되는 식을 정의하여 문자열에 서식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-144">C# [_*_string interpolation_*_](../language-reference/tokens/interpolated.md) enables you to format strings by defining expressions whose results are placed in a format string.</span></span> <span data-ttu-id="9d7a9-145">예를 들어 다음 예제에서는 날씨 데이터 세트에서 지정된 날짜의 온도를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-145">For example, the following example prints the temperature on a given day from a set of weather data:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="StringInterpolation":::

<span data-ttu-id="9d7a9-146">보간된 문자열은 `$` 토큰을 사용하여 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-146">An interpolated string is declared using the `$` token.</span></span> <span data-ttu-id="9d7a9-147">문자열 보간은 `{`와 `}` 사이의 식을 계산한 다음 결과를 `string`으로 변환하고 대괄호 사이에 있는 텍스트를 식의 문자열 결과로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-147">String interpolation evaluates the expressions between `{` and `}`, then converts the result to a `string`, and replaces the text between the brackets with the string result of the expression.</span></span> <span data-ttu-id="9d7a9-148">첫 번째 식 `{weatherData.Date:MM-DD-YYYY}`의 `:`은 서식 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-148">The `:` in the first expression, `{weatherData.Date:MM-DD-YYYY}` specifies the _format string\*.</span></span> <span data-ttu-id="9d7a9-149">앞의 예제에서는 “MM-DD_YYYY” 형식으로 출력해야 할 날짜를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-149">In the preceding example, it specifies that the date should be printed in "MM-DD-YYYY" format.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="9d7a9-150">패턴 일치</span><span class="sxs-lookup"><span data-stu-id="9d7a9-150">Pattern matching</span></span>

<span data-ttu-id="9d7a9-151">C# 언어는 개체 상태를 쿼리하고 이 상태에 따라 코드를 실행하는 [**패턴 일치**](../pattern-matching.md) 식을 제공합니다.\*</span><span class="sxs-lookup"><span data-stu-id="9d7a9-151">The C# language provides [\***pattern matching** _](../pattern-matching.md) expressions to query the state of an object and execute code based on that state.</span></span> <span data-ttu-id="9d7a9-152">형식과 속성 및 필드의 값을 검사하여 수행할 동작을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-152">You can inspect types and the values of properties and fields to determine which action to take.</span></span> <span data-ttu-id="9d7a9-153">`switch` 식은 패턴 일치를 위한 기본 식입니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-153">The `switch` expression is the primary expression for pattern matching.</span></span>

## <a name="delegates-and-lambda-expressions"></a><span data-ttu-id="9d7a9-154">대리자와 람다 식</span><span class="sxs-lookup"><span data-stu-id="9d7a9-154">Delegates and lambda expressions</span></span>

<span data-ttu-id="9d7a9-155">[대리자 형식](../delegates-overview.md)은 특정 매개 변수 목록 및 반환 형식이 있는 메서드에 대한 참조를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-155">A [_*_delegate type_*_](../delegates-overview.md) represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="9d7a9-156">대리자는 메서드를 변수에 할당되고 매개 변수로 전달될 수 있는 엔터티로 취급할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-156">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="9d7a9-157">대리자는 다른 언어의 함수 포인터와 개념이 비슷하지만</span><span class="sxs-lookup"><span data-stu-id="9d7a9-157">Delegates are similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="9d7a9-158">함수 포인터와 달리 대리자는 개체 지향적이며 형식이 안전한 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-158">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="9d7a9-159">다음 예제에서는 `Function`라는 대리자 형식을 선언하고 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-159">The following example declares and uses a delegate type named `Function`.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DelegateExample":::

<span data-ttu-id="9d7a9-160">`Function` 대리자 형식의 인스턴스는 `double` 인수를 사용하고 `double` 값을 반환하는 메서드를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-160">An instance of the `Function` delegate type can reference any method that takes a `double` argument and returns a `double` value.</span></span> <span data-ttu-id="9d7a9-161">`Apply` 메서드는 `double[]`의 요소에 지정된 `Function`을 적용하여 결과가 있는 `double[]`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-161">The `Apply` method applies a given `Function` to the elements of a `double[]`, returning a `double[]` with the results.</span></span> <span data-ttu-id="9d7a9-162">`Main` 메서드에서 `Apply`는 세 가지 다른 함수를 `double[]`에 적용하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-162">In the `Main` method, `Apply` is used to apply three different functions to a `double[]`.</span></span>

<span data-ttu-id="9d7a9-163">대리자는 정적 메서드(예: 이전 예제의 `Square` 또는 `Math.Sin`) 또는 인스턴스 메서드(예: 이전 예제의 `m.Multiply`)를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-163">A delegate can reference either a static method (such as `Square` or `Math.Sin` in the previous example) or an instance method (such as `m.Multiply` in the previous example).</span></span> <span data-ttu-id="9d7a9-164">인스턴스 메서드를 참조하는 대리자는 특정 개체도 참조하며, 인스턴스 메서드가 대리자를 통해 호출되는 경우 해당 개체도 이 호출에서 `this`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-164">A delegate that references an instance method also references a particular object, and when the instance method is invoked through the delegate, that object becomes `this` in the invocation.</span></span>

<span data-ttu-id="9d7a9-165">선언 즉시 만들어지는 “인라인 메서드”인 익명 함수를 사용하여 대리자를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-165">Delegates can also be created using anonymous functions, which are "inline methods" that are created when declared.</span></span> <span data-ttu-id="9d7a9-166">익명 함수는 주변 메서드의 지역 변수를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-166">Anonymous functions can see the local variables of the surrounding methods.</span></span> <span data-ttu-id="9d7a9-167">다음 예제에서는 클래스를 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-167">The following example doesn't create a class:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseDelegate":::

<span data-ttu-id="9d7a9-168">대리자는 해당 대리자가 참조하는 메서드의 클래스를 알지 못하고 클래스가 무엇인지와 관계없이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-168">A delegate doesn't know or care about the class of the method it references.</span></span> <span data-ttu-id="9d7a9-169">중요한 것은 참조되는 메서드가 대리자와 동일한 매개 변수와 반환 형식을 갖는다는 사실입니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-169">All that matters is that the referenced method has the same parameters and return type as the delegate.</span></span>

## <a name="async--await"></a><span data-ttu-id="9d7a9-170">async / await</span><span class="sxs-lookup"><span data-stu-id="9d7a9-170">async / await</span></span>

<span data-ttu-id="9d7a9-171">C#은 두 개의 키워드 `async`와 `await`로 비동기 프로그램을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-171">C# supports asynchronous programs with two keywords: `async` and `await`.</span></span> <span data-ttu-id="9d7a9-172">메서드를 비동기로 선언하려면 메서드 선언에 `async` 한정자를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-172">You add the `async` modifier to a method declaration to declare the method is asynchronous.</span></span> <span data-ttu-id="9d7a9-173">`await` 연산자는 컴파일러에 결과가 완료될 때까지 비동기적으로 대기하도록 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-173">The `await` operator tells the compiler to asynchronously await for a result to finish.</span></span> <span data-ttu-id="9d7a9-174">제어는 호출자에게 반환되고, 메서드는 비동기 작업의 상태를 관리하는 구조체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-174">Control is returned to the caller, and the method returns a structure that manages the state of the asynchronous work.</span></span> <span data-ttu-id="9d7a9-175">구조체는 일반적으로 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>이지만, awaiter 패턴을 지원하는 어떤 형식도 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-175">The structure is typically a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, but can be any type that supports the awaiter pattern.</span></span> <span data-ttu-id="9d7a9-176">이러한 기능을 사용하면 동기식으로 읽히지만 비동기적으로 실행되는 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-176">These features enable you to write code that reads as its synchronous counterpart, but executes asynchronously.</span></span> <span data-ttu-id="9d7a9-177">예를 들어 다음 코드는 [Microsoft docs](/)의 홈페이지를 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-177">For example, the following code downloads the home page for [Microsoft docs](/):</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="AsyncExample":::

<span data-ttu-id="9d7a9-178">이 작은 샘플은 비동기 프로그래밍의 주요 특징을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-178">This small sample shows the major features for asynchronous programming:</span></span>

- <span data-ttu-id="9d7a9-179">메서드 선언에는 `async` 한정자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-179">The method declaration includes the `async` modifier.</span></span>
- <span data-ttu-id="9d7a9-180">메서드의 본문은 `GetByteArrayAsync` 메서드의 반환을 `await`합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-180">The body of the method `await`s the return of the `GetByteArrayAsync` method.</span></span>
- <span data-ttu-id="9d7a9-181">`return` 문에 지정된 형식은 메서드의 `Task<T>` 선언에 있는 형식 인수와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-181">The type specified in the `return` statement matches the type argument in the `Task<T>` declaration for the method.</span></span> <span data-ttu-id="9d7a9-182">(`Task`를 반환하는 메서드는 `return` 문을 인수 없이 사용합니다.)</span><span class="sxs-lookup"><span data-stu-id="9d7a9-182">(A method that returns a `Task` would use `return` statements without any argument).</span></span>

## <a name="attributes"></a><span data-ttu-id="9d7a9-183">특성</span><span class="sxs-lookup"><span data-stu-id="9d7a9-183">Attributes</span></span>

<span data-ttu-id="9d7a9-184">C# 프로그램의 형식, 멤버 및 기타 엔터티는 동작의 특정 측면을 제어하는 한정자를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-184">Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior.</span></span> <span data-ttu-id="9d7a9-185">예를 들어 메서드의 액세스 가능성은 `public`, `protected`, `internal` 및 `private` 한정자를 사용하여 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-185">For example, the accessibility of a method is controlled using the `public`, `protected`, `internal`, and `private` modifiers.</span></span> <span data-ttu-id="9d7a9-186">C#은 선언적 정보의 사용자 정의 형식을 프로그램 엔터티에 연결하고 런타임에 검색할 수 있도록 이러한 기능을 일반화합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-186">C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time.</span></span> <span data-ttu-id="9d7a9-187">프로그램은 [특성\*](../programming-guide/concepts/attributes/index.md)을 정의하고 사용하여 이러한 추가적인 선언적 정보를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-187">Programs specify this additional declarative information by defining and using [_ *_attributes_*\*](../programming-guide/concepts/attributes/index.md).</span></span>

<span data-ttu-id="9d7a9-188">다음 예제에서는 관련 설명서에 대한 링크를 제공하기 위해 프로그램 엔터티에 배치될 수 있는 `HelpAttribute` 특성을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-188">The following example declares a `HelpAttribute` attribute that can be placed on program entities to provide links to their associated documentation.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DefineAttribute":::

<span data-ttu-id="9d7a9-189">모든 특성 클래스는 .NET 라이브러리에서 제공하는 <xref:System.Attribute> 기본 클래스에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-189">All attribute classes derive from the <xref:System.Attribute> base class provided by the .NET library.</span></span> <span data-ttu-id="9d7a9-190">연결된 선언 바로 앞에 대괄호로 묶은 특성 이름을 인수와 함께 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-190">Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration.</span></span> <span data-ttu-id="9d7a9-191">특성 이름이 `Attribute`로 끝나는 경우 특성이 참조될 때 이름의 해당 부분을 생략해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-191">If an attribute’s name ends in `Attribute`, that part of the name can be omitted when the attribute is referenced.</span></span> <span data-ttu-id="9d7a9-192">예를 들어 `HelpAttribute`는 다음과 같이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-192">For example, the `HelpAttribute` can be used as follows.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseAttributes":::

<span data-ttu-id="9d7a9-193">이 예제에서는 `HelpAttribute`를 `Widget` 클래스에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-193">This example attaches a `HelpAttribute` to the `Widget` class.</span></span> <span data-ttu-id="9d7a9-194">그런 후 다른 `HelpAttribute`를 클래스의 `Display` 메서드에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-194">It adds another `HelpAttribute` to the `Display` method in the class.</span></span> <span data-ttu-id="9d7a9-195">특성 클래스의 공용 생성자는 프로그램 엔터티에 특성을 추가할 때 제공해야 하는 정보를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-195">The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity.</span></span> <span data-ttu-id="9d7a9-196">특성 클래스의 공용 읽기/쓰기 속성을 참조하여 추가 정보를 제공할 수 있습니다(예: 앞에 나온 `Topic` 속성 참조).</span><span class="sxs-lookup"><span data-stu-id="9d7a9-196">Additional information can be provided by referencing public read-write properties of the attribute class (such as the reference to the `Topic` property previously).</span></span>

<span data-ttu-id="9d7a9-197">특성에 의해 정의된 메타데이터는 리플렉션을 사용하여 런타임 시 읽고 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-197">The metadata defined by attributes can be read and manipulated at runtime using reflection.</span></span> <span data-ttu-id="9d7a9-198">이 기술을 사용하여 특정 특성이 요청되면 특성 클래스에 대한 생성자가 프로그램 소스에 제공된 정보와 함께 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-198">When a particular attribute is requested using this technique, the constructor for the attribute class is invoked with the information provided in the program source.</span></span> <span data-ttu-id="9d7a9-199">결과 특성 인스턴스가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-199">The resulting attribute instance is returned.</span></span> <span data-ttu-id="9d7a9-200">속성을 통해 추가 정보를 제공한 경우 해당 속성은 특성 인스턴스가 반환되기 전에 지정된 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-200">If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.</span></span>

<span data-ttu-id="9d7a9-201">다음 코드 샘플에서는 `Widget` 클래스와 해당 `Display` 메서드에 연결된 `HelpAttribute` 인스턴스를 가져오는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-201">The following code sample demonstrates how to get the `HelpAttribute` instances associated to the `Widget` class and its `Display` method.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ReadAttributes":::

## <a name="learn-more"></a><span data-ttu-id="9d7a9-202">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="9d7a9-202">Learn more</span></span>

<span data-ttu-id="9d7a9-203">여러 [자습서](../tutorials/index.md)를 통해 C#에 대해 자세히 알아볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9d7a9-203">You can explore more about C# by trying one of our [tutorials](../tutorials/index.md).</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="9d7a9-204">이전</span><span class="sxs-lookup"><span data-stu-id="9d7a9-204">Previous</span></span>](program-building-blocks.md)
