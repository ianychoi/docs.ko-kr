---
title: C# 9.0의 새로운 기능 - C# 가이드
description: C# 9.0의 새로운 기능을 살펴봅니다.
ms.date: 09/04/2020
ms.openlocfilehash: 5b3695dee8fc26f69e713d1d6811acdf0cfa9764
ms.sourcegitcommit: f99115e12a5eb75638abe45072e023a3ce3351ac
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/12/2020
ms.locfileid: "94557222"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="3ad6e-103">C# 9.0의 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="3ad6e-103">What's new in C# 9.0</span></span>

<span data-ttu-id="3ad6e-104">C# 9.0은 다음 기능과 개선 사항을 C# 언어에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="3ad6e-105">레코드</span><span class="sxs-lookup"><span data-stu-id="3ad6e-105">Records</span></span>](#record-types)
- [<span data-ttu-id="3ad6e-106">Init 전용 setter</span><span class="sxs-lookup"><span data-stu-id="3ad6e-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="3ad6e-107">최상위 문</span><span class="sxs-lookup"><span data-stu-id="3ad6e-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="3ad6e-108">패턴 일치 개선 사항</span><span class="sxs-lookup"><span data-stu-id="3ad6e-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="3ad6e-109">원시 크기 정수</span><span class="sxs-lookup"><span data-stu-id="3ad6e-109">Native sized integers</span></span>
- <span data-ttu-id="3ad6e-110">함수 포인터</span><span class="sxs-lookup"><span data-stu-id="3ad6e-110">Function pointers</span></span>
- <span data-ttu-id="3ad6e-111">localsinit 플래그 내보내기 무시</span><span class="sxs-lookup"><span data-stu-id="3ad6e-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="3ad6e-112">대상으로 형식화된 새 식</span><span class="sxs-lookup"><span data-stu-id="3ad6e-112">Target-typed new expressions</span></span>
- <span data-ttu-id="3ad6e-113">정적 무명 함수</span><span class="sxs-lookup"><span data-stu-id="3ad6e-113">static anonymous functions</span></span>
- <span data-ttu-id="3ad6e-114">대상으로 형식화된 조건식</span><span class="sxs-lookup"><span data-stu-id="3ad6e-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="3ad6e-115">공변 반환 형식</span><span class="sxs-lookup"><span data-stu-id="3ad6e-115">Covariant return types</span></span>
- <span data-ttu-id="3ad6e-116">`foreach` 루프에 대한 확장 `GetEnumerator` 지원</span><span class="sxs-lookup"><span data-stu-id="3ad6e-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="3ad6e-117">람다 무시 항목 매개 변수</span><span class="sxs-lookup"><span data-stu-id="3ad6e-117">Lambda discard parameters</span></span>
- <span data-ttu-id="3ad6e-118">로컬 함수의 특성</span><span class="sxs-lookup"><span data-stu-id="3ad6e-118">Attributes on local functions</span></span>
- <span data-ttu-id="3ad6e-119">모듈 이니셜라이저</span><span class="sxs-lookup"><span data-stu-id="3ad6e-119">Module initializers</span></span>
- <span data-ttu-id="3ad6e-120">부분 메서드에 대한 새로운 기능</span><span class="sxs-lookup"><span data-stu-id="3ad6e-120">New features for partial methods</span></span>

<span data-ttu-id="3ad6e-121">C# 9.0은 **.NET 5** 에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="3ad6e-122">자세한 내용은 [C# 언어 버전 관리](../language-reference/configure-language-version.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="3ad6e-123">[.NET 다운로드 페이지](https://dotnet.microsoft.com/download)에서 최신 .NET SDK를 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-123">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="3ad6e-124">레코드 유형</span><span class="sxs-lookup"><span data-stu-id="3ad6e-124">Record types</span></span>

<span data-ttu-id="3ad6e-125">C# 9.0에서는 같음에 대한 값 의미 체계를 제공하는 합성 메서드를 제공하는 참조 형식인 \*’레코드 종류’_가 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-125">C# 9.0 introduces \**_record types_* _, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="3ad6e-126">레코드는 기본적으로 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-126">Records are immutable by default.</span></span>

<span data-ttu-id="3ad6e-127">레코드 종류를 사용하면 .NET에서 변경할 수 없는 참조 형식을 쉽게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-127">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="3ad6e-128">지금까지 .NET 형식은 크게 참조 형식(클래스 및 무명 형식 포함)과 값 형식(구조체 및 튜플 포함)으로 분류되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-128">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="3ad6e-129">변경할 수 없는 값 형식이 권장되지만, 변경 가능한 값 형식을 사용해도 오류가 자주 발생하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-129">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="3ad6e-130">값 형식 변수에는 값이 포함되므로 값 형식을 메서드에 전달할 때 원래 데이터의 복사본이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-130">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="3ad6e-131">변경할 수 없는 참조 형식에도 많은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-131">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="3ad6e-132">이러한 이점은 공유 데이터를 사용하는 동시 프로그램에서 더욱 두드러지게 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-132">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="3ad6e-133">아쉽게도 C#에서는 변경할 수 없는 참조 형식을 만들기 위한 상당한 추가 코드를 작성해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-133">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="3ad6e-134">레코드는 같음에 대한 값 의미 체계를 사용하는, 변경할 수 없는 참조 형식의 형식 선언을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-134">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="3ad6e-135">같음 및 해시 코드에 대한 합성 메서드는 해당 속성이 모두 동일한 경우 두 레코드가 같다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-135">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="3ad6e-136">다음과 같은 정의를 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-136">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="3ad6e-137">레코드 정의에서 `FirstName` 및 `LastName`이라는 두 개의 읽기 전용 속성을 포함하는 `Person` 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-137">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="3ad6e-138">`Person` 형식은 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-138">The `Person` type is a reference type.</span></span> <span data-ttu-id="3ad6e-139">IL을 확인했다면 이 형식은 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-139">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="3ad6e-140">생성된 후에는 속성을 수정할 수 없다는 점에서 변경할 수 없는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-140">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="3ad6e-141">레코드 종류를 정의하면 컴파일러에서 다른 여러 메서드를 자동으로 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-141">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="3ad6e-142">값 기반 같음 비교 메서드</span><span class="sxs-lookup"><span data-stu-id="3ad6e-142">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="3ad6e-143"><xref:System.Object.GetHashCode> 재정의</span><span class="sxs-lookup"><span data-stu-id="3ad6e-143">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="3ad6e-144">멤버 복사 및 복제</span><span class="sxs-lookup"><span data-stu-id="3ad6e-144">Copy and Clone members</span></span>
- <span data-ttu-id="3ad6e-145">`PrintMembers` 및 <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="3ad6e-145">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="3ad6e-146">레코드는 상속을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-146">Records support inheritance.</span></span> <span data-ttu-id="3ad6e-147">`Person`에서 파생된 새 레코드를 다음과 같이 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-147">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="3ad6e-148">추가 파생을 방지하기 위해 레코드를 봉인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-148">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="3ad6e-149">컴파일러는 위 메서드의 여러 버전을 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-149">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="3ad6e-150">메서드 시그니처는 레코드 종류가 sealed인지 여부와 직접 기본 클래스가 object인지 여부에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-150">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="3ad6e-151">레코드에는 다음 기능이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-151">Records should have the following capabilities:</span></span>

- <span data-ttu-id="3ad6e-152">같음은 값을 기반으로 하며 형식 일치 검사를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-152">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="3ad6e-153">예를 들어 `Student`는 두 레코드가 동일한 이름을 공유하는 경우에도 `Person`과 같을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-153">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="3ad6e-154">레코드의 문자열 표현이 일관성 있게 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-154">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="3ad6e-155">레코드에서 복사본 생성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-155">Records support copy construction.</span></span> <span data-ttu-id="3ad6e-156">올바른 복사본 생성에는 상속 계층 구조와 개발자가 추가한 속성이 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-156">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="3ad6e-157">수정 내용과 함께 레코드를 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-157">Records can be copied with modification.</span></span> <span data-ttu-id="3ad6e-158">복사 및 수정 작업에서 비파괴적 변경을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-158">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="3ad6e-159">컴파일러는 익숙한 `Equals` 오버로드, `operator ==`, `operator !=` 외에도 새 `EqualityContract` 속성을 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="3ad6e-160">이 속성은 레코드 종류와 일치하는 `Type` 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="3ad6e-161">기본 형식이 `object`이면 속성은 `virtual`이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="3ad6e-162">기본 형식이 다른 레코드 종류이면 속성은 `override`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="3ad6e-163">레코드 종류가 `sealed`이면 속성은 `sealed`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="3ad6e-164">합성된 `GetHashCode`는 기본 형식 및 레코드 종류에 선언된 모든 속성과 필드의 `GetHashCode`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="3ad6e-165">해당 합성 메서드는 상속 계층 구조 전체에 값 기반 같음을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="3ad6e-166">즉, `Student`는 동일한 이름을 가진 `Person`과 같다고 간주하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="3ad6e-167">레코드 종류 간에 공유되는 모든 속성이 같을 뿐 아니라 두 레코드 종류도 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="3ad6e-168">또한 레코드에는 합성 생성자와 복사본을 만들기 위한 “clone” 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="3ad6e-169">합성 생성자에는 레코드 형식의 단일 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-169">The synthesized constructor has a single parameter of the record type.</span></span> <span data-ttu-id="3ad6e-170">합성 생성자는 레코드의 모든 속성에 동일한 값을 사용하여 새 레코드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="3ad6e-171">레코드가 sealed이면 해당 생성자는 private이 되고, 그렇지 않으면 protected가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="3ad6e-172">합성된 “clone” 메서드는 레코드 계층 구조의 복사본 생성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="3ad6e-173">실제 이름이 컴파일러에서 생성되기 때문에 “clone” 용어는 따옴표 안에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="3ad6e-174">레코드 종류에 `Clone`이라는 메서드를 만들 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="3ad6e-175">합성된 “clone” 메서드는 가상 디스패치를 사용하여 복사되는 레코드 종류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="3ad6e-176">컴파일러는 `record`의 액세스 한정자에 따라 “clone” 메서드에 대해 다른 한정자를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="3ad6e-177">레코드 종류가 `abstract`이면 “clone” 메서드도 `abstract`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="3ad6e-178">기본 형식이 `object`가 아니면 메서드도 `override`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="3ad6e-179">기본 형식이 `object`일 때 `abstract`가 아닌 레코드 종류의 경우:</span><span class="sxs-lookup"><span data-stu-id="3ad6e-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="3ad6e-180">레코드가 `sealed`이면 “clone” 메서드에 한정자가 추가되지 않습니다(즉, `virtual`이 아님).</span><span class="sxs-lookup"><span data-stu-id="3ad6e-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="3ad6e-181">레코드가 `sealed`가 아니면 “clone” 메서드는 `virtual`이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="3ad6e-182">기본 형식이 `object`가 아닐 때 `abstract`가 아닌 레코드 종류의 경우:</span><span class="sxs-lookup"><span data-stu-id="3ad6e-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="3ad6e-183">레코드가 `sealed`이면 “clone” 메서드도 `sealed`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="3ad6e-184">레코드가 `sealed`가 아니면 “clone” 메서드는 `override`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="3ad6e-185">모든 규칙의 결과로, 모든 레코드 종류 계층 구조에서 같음이 일관되게 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="3ad6e-186">다음 예제와 같이 해당 속성과 종류가 동일하면 두 레코드는 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="3ad6e-187">컴파일러는 인쇄 출력을 지원하는 두 가지 메서드인 <xref:System.Object.ToString> 재정의와 `PrintMembers`를 합성합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="3ad6e-188">`PrintMembers`는 <xref:System.Text.StringBuilder?displayProperty=nameWithType>을 인수로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="3ad6e-189">레코드 종류의 모든 속성에 대해 쉼표로 구분된 속성 이름 및 값 목록이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="3ad6e-190">`PrintMembers`는 다른 레코드에서 파생된 모든 레코드에 대해 기본 구현을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="3ad6e-191"><xref:System.Object.ToString> 재정의는 `PrintMembers`에서 생성된 문자열을 `{` 및 `}`로 묶어 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="3ad6e-192">예를 들어 `Student`의 <xref:System.Object.ToString> 메서드는 다음 코드와 같이 `string`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="3ad6e-193">지금까지 살펴본 예제에서는 일반적인 구문을 사용하여 속성을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="3ad6e-194">‘위치 레코드’라는 보다 간결한 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-194">There's a more concise form called _*_positional records_*_.</span></span>  <span data-ttu-id="3ad6e-195">다음은 앞에서 위치 레코드로 정의된 세 가지 레코드 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="3ad6e-196">이 선언에서는 이전 버전과 동일한 기능을 만듭니다(다음 섹션에서 설명하는 몇 가지 추가 기능 포함).</span><span class="sxs-lookup"><span data-stu-id="3ad6e-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="3ad6e-197">레코드에서 메서드를 추가하지 않으므로 이 선언은 대괄호가 아닌 세미콜론으로 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="3ad6e-198">본문을 추가하고 다른 메서드도 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="3ad6e-199">컴파일러는 위치 레코드의 `Deconstruct` 메서드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="3ad6e-200">`Deconstruct` 메서드에는 레코드 종류의 모든 public 속성 이름과 일치하는 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="3ad6e-201">`Deconstruct` 메서드를 사용하여 레코드를 구성 요소 속성으로 분해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="3ad6e-202">마지막으로 레코드는 [`with` 식](../language-reference/operators/with-expression.md)을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-202">Finally, records support [`with` expressions](../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="3ad6e-203">_\*_ `with` expression_ *_은 레코드 복사본을 만들지만 _with* 에 지정된 속성을 수정하도록 컴파일러에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-203">A _\*_`with` expression_ *_ instructs the compiler to create a copy of a record, but _with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="3ad6e-204">위 줄은 `LastName` 속성은 `person`의 복사본이고 `FirstName`은 `"Paul"`인 새 `Person` 레코드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-204">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is `"Paul"`.</span></span> <span data-ttu-id="3ad6e-205">`with` 식에서는 속성을 원하는 개수만큼 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-205">You can set any number of properties in a `with` expression.</span></span>

<span data-ttu-id="3ad6e-206">“clone” 메서드를 제외한 모든 합성 멤버를 직접 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-206">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="3ad6e-207">레코드 종류에 합성 메서드의 시그니처와 일치하는 메서드가 있는 경우 해당 메서드는 컴파일러에서 합성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-207">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="3ad6e-208">앞의 `Dog` 레코드 예제에는 수동 코딩된 <xref:System.String.ToString> 메서드가 예제로 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-208">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="3ad6e-209">Init 전용 setter</span><span class="sxs-lookup"><span data-stu-id="3ad6e-209">Init only setters</span></span>

<span data-ttu-id="3ad6e-210">‘**Init 전용 setter**’는 개체의 멤버를 초기화하는 일관성 있는 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-210">\***Init only setters** _ provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="3ad6e-211">속성 이니셜라이저를 사용하면 어떤 값이 어떤 속성을 설정하는지 명확하게 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-211">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="3ad6e-212">단점은 해당 속성이 설정 가능해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-212">The downside is that those properties must be settable.</span></span> <span data-ttu-id="3ad6e-213">C# 9.0부터 속성 및 인덱서에 대해 `set` 접근자 대신 `init` 접근자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-213">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="3ad6e-214">호출자는 속성 이니셜라이저 구문을 사용하여 생성 식에서 해당 값을 설정할 수 있지만, 생성이 완료되고 나면 readonly 속성이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-214">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="3ad6e-215">Init 전용 setter는 상태 변경 창을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-215">Init only setters provide a window to change state.</span></span> <span data-ttu-id="3ad6e-216">이 창은 생성 단계가 끝날 때 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-216">That window closes when the construction phase ends.</span></span> <span data-ttu-id="3ad6e-217">속성 이니셜라이저 및 with-expression을 비롯한 모든 초기화가 완료되면 생성 단계가 사실상 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-217">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="3ad6e-218">작성하는 모든 형식에서 `init` 전용 setter를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-218">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="3ad6e-219">예를 들어 다음 구조체는 기상 관측 구조체를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-219">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="3ad6e-220">호출자는 불변성을 유지하면서 속성 이니셜라이저 구문을 사용하여 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-220">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="3ad6e-221">하지만 초기화 후 관측을 변경할 경우 초기화 외부에서 init 전용 속성에 할당하여 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-221">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="3ad6e-222">init 전용 setter는 파생 클래스에서 기본 클래스 속성을 설정하는 데 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-222">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="3ad6e-223">기본 클래스의 도우미를 통해 파생 속성을 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-223">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="3ad6e-224">위치 레코드는 init 전용 setter를 사용하여 속성을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-224">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="3ad6e-225">해당 setter는 with-expression에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-225">Those setters are used in with-expressions.</span></span> <span data-ttu-id="3ad6e-226">정의하는 모든 `class` 또는 `struct`에 대해 Init 전용 setter를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-226">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="3ad6e-227">최상위 문</span><span class="sxs-lookup"><span data-stu-id="3ad6e-227">Top-level statements</span></span>

<span data-ttu-id="3ad6e-228">‘최상위 문’은 많은 애플리케이션에서 불필요한 공식 절차를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-228">_*_Top-level statements_*_ remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="3ad6e-229">정식 “Hello World!”</span><span class="sxs-lookup"><span data-stu-id="3ad6e-229">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="3ad6e-230">프로그램을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-230">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="3ad6e-231">작업을 수행하는 코드 줄은 1줄뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-231">There’s only one line of code that does anything.</span></span> <span data-ttu-id="3ad6e-232">최상위 문을 사용하면 모든 상용구를 `using` 문과 작업을 수행하는 1줄로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-232">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="3ad6e-233">1줄 프로그램을 원하는 경우 `using` 지시문을 제거하고 정규화된 형식 이름을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-233">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="3ad6e-234">애플리케이션의 한 파일에서만 최상위 문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-234">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="3ad6e-235">컴파일러가 여러 소스 파일에서 최상위 문을 발견할 경우 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-235">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="3ad6e-236">일반적으로 `Main` 메서드인 선언된 프로그램 진입점 메서드와 최상위 문을 결합하는 경우에도 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-236">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="3ad6e-237">따라서 일반적으로 `Program` 클래스의 `Main` 메서드에 있는 문이 한 파일에 포함되어 있다고 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-237">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="3ad6e-238">이 기능의 가장 일반적인 용도 중 하나는 교육 자료를 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-238">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="3ad6e-239">초급 C# 개발자가 1~2줄의 코드로 정식 “Hello World!”를</span><span class="sxs-lookup"><span data-stu-id="3ad6e-239">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="3ad6e-240">작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-240">in one or two lines of code.</span></span> <span data-ttu-id="3ad6e-241">추가 공식 절차가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-241">None of the extra ceremony is needed.</span></span> <span data-ttu-id="3ad6e-242">그러나 숙련된 개발자도 이 기능의 다양한 용도를 발견하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-242">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="3ad6e-243">최상위 수준 문을 통해 Jupyter Notebook에서 제공하는 것과 비슷한 스크립트 유사 환경을 실험용으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-243">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="3ad6e-244">최상위 수준 문은 작은 콘솔 프로그램 및 유틸리티에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-244">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="3ad6e-245">Azure Functions는 최상위 문에 이상적인 사용 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-245">Azure Functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="3ad6e-246">가장 중요한 점은 최상위 문이 애플리케이션의 범위나 복잡성을 제한하지 않는다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-246">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="3ad6e-247">해당 문은 모든 .NET 클래스에 액세스하거나 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-247">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="3ad6e-248">또한 명령줄 인수나 반환 값의 사용을 제한하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-248">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="3ad6e-249">최상위 문은 args라는 문자열 배열에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-249">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="3ad6e-250">최상위 문에서 정수 값을 반환하는 경우 해당 값은 합성된 `Main` 메서드의 정수 반환 코드가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-250">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="3ad6e-251">최상위 문에 비동기 식을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-251">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="3ad6e-252">이 경우 합성 진입점은 `Task` 또는 `Task<int>`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-252">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="3ad6e-253">패턴 일치 개선 사항</span><span class="sxs-lookup"><span data-stu-id="3ad6e-253">Pattern matching enhancements</span></span>

<span data-ttu-id="3ad6e-254">C# 9에는 새로운 패턴 일치 개선 사항이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-254">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="3ad6e-255">‘형식 패턴’은 변수를 형식과 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-255">_*_Type patterns_*_ match a variable is a type</span></span>
- <span data-ttu-id="3ad6e-256">‘괄호로 묶인 패턴’은 패턴 조합의 우선 순위를 적용하거나 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-256">_*_Parenthesized patterns_*_ enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="3ad6e-257">‘결합’ `and` ‘패턴’에서는 두 패턴이 모두 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-257">_*_Conjunctive `and` patterns_*_ require both patterns to match</span></span>
- <span data-ttu-id="3ad6e-258">‘분리’ `or` ‘패턴’에서는 패턴 중 하나가 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-258">_*_Disjunctive `or` patterns_*_ require either pattern to match</span></span>
- <span data-ttu-id="3ad6e-259">‘부정’ `not` ‘패턴’에서는 패턴이 일치하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-259">_*_Negated `not` patterns_*_ require that a pattern doesn’t match</span></span>
- <span data-ttu-id="3ad6e-260">‘관계형 패턴’에서는 입력과 지정된 상수 간에 보다 작음, 보다 큼, 작거나 같음, 크거나 같음 관계가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-260">_*_Relational patterns_*_ require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="3ad6e-261">새로운 패턴은 패턴 구문을 보강합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-261">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="3ad6e-262">이 예제를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-262">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="3ad6e-263">또는 선택적 괄호를 사용하여 `and`에 `or`보다 높은 우선 순위가 있음을 명확하게 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-263">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="3ad6e-264">가장 일반적인 용도 중 하나는 새로운 null 검사 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-264">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="3ad6e-265">`is` 패턴 식, `switch` 식, 중첩 패턴, `switch` 문의 `case` 레이블 패턴 등 패턴이 허용되는 모든 컨텍스트에서 새로운 패턴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-265">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="3ad6e-266">성능 및 interop</span><span class="sxs-lookup"><span data-stu-id="3ad6e-266">Performance and interop</span></span>

<span data-ttu-id="3ad6e-267">원시 크기 정수, 함수 포인터, `localsinit` 플래그 생략의 세 가지 새로운 기능을 통해 고성능이 필요한 하위 수준 라이브러리 및 네이티브 interop 지원이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-267">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="3ad6e-268">원시 크기 정수인 `nint` 및 `nuint`는 정수 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-268">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="3ad6e-269">기본 형식 <xref:System.IntPtr?displayProperty=nameWithType> 및 <xref:System.UIntPtr?displayProperty=nameWithType>으로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-269">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3ad6e-270">컴파일러는 해당 형식의 추가 변환과 연산을 네이티브 정수 형식으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-270">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="3ad6e-271">원시 크기 정수는 `MaxValue` 또는 `MinValue`의 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-271">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="3ad6e-272">이러한 값은 대상 머신의 정수 원시 크기에 따라 달라지므로 컴파일 시간 상수로 표현할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-272">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="3ad6e-273">이러한 값은 런타임에 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-273">Those values are readonly at runtime.</span></span> <span data-ttu-id="3ad6e-274">다음 범위에서 `nint`의 상수 값을 사용할 수 있습니다. [`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="3ad6e-274">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="3ad6e-275">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="3ad6e-275">`int.MaxValue`].</span></span> <span data-ttu-id="3ad6e-276">다음 범위에서 `nuint`의 상수 값을 사용할 수 있습니다. [`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="3ad6e-276">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="3ad6e-277">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="3ad6e-277">`uint.MaxValue`].</span></span> <span data-ttu-id="3ad6e-278">컴파일러는 <xref:System.Int32?displayProperty=nameWithType> 및 <xref:System.UInt32?displayProperty=nameWithType> 형식을 사용하여 모든 단항 및 이진 연산자에 대해 상수 정리를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-278">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="3ad6e-279">결과가 32비트에 맞지 않으면 런타임에 연산이 실행되고 상수로 간주하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-279">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="3ad6e-280">정수 연산이 광범위하게 사용되고 가장 빠른 성능이 필요한 시나리오에서는 원시 크기 정수를 사용하여 성능을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-280">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="3ad6e-281">함수 포인터는 IL opcode `ldftn` 및 `calli`에 액세스하는 편리한 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-281">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="3ad6e-282">새로운 `delegate_` 구문을 사용하여 함수 포인터를 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-282">You can declare function pointers using new `delegate_` syntax.</span></span> <span data-ttu-id="3ad6e-283">`delegate*` 형식은 포인터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-283">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="3ad6e-284">`delegate*` 형식을 호출하면 `Invoke()` 메서드에서 `callvirt`를 사용하는 대리자와는 달리 `calli`가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-284">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="3ad6e-285">호출 구문은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-285">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="3ad6e-286">함수 포인터 호출은 `managed` 호출 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-286">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="3ad6e-287">`delegate*` 구문 뒤에 `unmanaged` 키워드를 추가하여 `unmanaged` 호출 규칙을 사용하도록 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-287">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="3ad6e-288">`delegate*` 선언에서 특성을 사용하여 다른 호출 규칙을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-288">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="3ad6e-289">마지막으로, <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType>을 추가하여 컴파일러에 `localsinit` 플래그를 내보내지 않도록 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-289">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="3ad6e-290">이 플래그는 모든 지역 변수를 0으로 초기화하도록 CLR에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-290">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="3ad6e-291">`localsinit` 플래그는 1.0부터 C#의 기본 동작이었습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-291">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="3ad6e-292">그러나 0으로 초기화를 추가로 수행할 경우 일부 시나리오에서 성능에 상당한 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-292">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="3ad6e-293">특히, `stackalloc`를 사용하는 경우에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-293">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="3ad6e-294">이 경우에는 <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-294">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="3ad6e-295">단일 메서드 또는 속성이나 `class`, `struct`, `interface` 또는 모듈에 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-295">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="3ad6e-296">이 특성은 `abstract` 메서드에는 영향을 주지 않고, 구현과 관련해서 생성된 코드에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-296">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="3ad6e-297">위의 기능은 일부 시나리오에서 성능을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-297">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="3ad6e-298">채택 전과 후에 모두 신중하게 벤치마킹한 후에만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-298">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="3ad6e-299">원시 크기 정수를 사용하는 코드는 여러 대상 플랫폼에서 여러 정수 크기로 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-299">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="3ad6e-300">다른 기능에는 안전하지 않은 코드가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-300">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="3ad6e-301">기능 마무리</span><span class="sxs-lookup"><span data-stu-id="3ad6e-301">Fit and finish features</span></span>

<span data-ttu-id="3ad6e-302">다른 많은 기능을 통해 코드를 보다 효율적으로 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-302">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="3ad6e-303">C# 9.0에서는 만든 개체의 형식을 이미 알고 있는 경우 [`new` 식](../language-reference/operators/new-operator.md)에서 형식을 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-303">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="3ad6e-304">가장 일반적인 용도는 필드 선언입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-304">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="3ad6e-305">인수로 메서드에 전달할 새 개체를 만들어야 하는 경우 대상으로 형식화된 `new`를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-305">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="3ad6e-306">다음 시그니처를 사용하는 `ForecastFor()` 메서드를 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-306">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="3ad6e-307">다음과 같이 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-307">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="3ad6e-308">이 기능의 다른 유용한 용도는 init 전용 속성과 결합하여 새 개체를 초기화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-308">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="3ad6e-309">`return new();` 문을 사용하여 기본 생성자가 만든 인스턴스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-309">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="3ad6e-310">유사한 기능은 [조건식](../language-reference/operators/conditional-operator.md)의 대상 유형 확인을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-310">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="3ad6e-311">이 변경 내용이 도입되면서 두 식 간에 암시적 변환을 포함할 수는 없지만 두 식에 모두 대상 유형으로의 암시적 변환을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-311">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="3ad6e-312">이 변경 내용을 발견하지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-312">You likely won’t notice this change.</span></span> <span data-ttu-id="3ad6e-313">이전에 캐스트가 필요했거나 컴파일되지 않던 일부 조건식이 이제 작동할 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-313">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="3ad6e-314">C# 9.0부터 [람다](../language-reference/operators/lambda-expressions.md) 식 또는 [무명 메서드](../language-reference/operators/delegate-operator.md)에 `static` 한정자를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-314">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="3ad6e-315">정적 람다 식은 `static` 로컬 함수와 유사합니다. 정적 람다 또는 무명 메서드는 지역 변수나 인스턴스 상태를 캡처할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-315">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="3ad6e-316">`static` 한정자는 실수에 의한 다른 변수 캡처를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-316">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="3ad6e-317">공변 반환 형식은 [재정의](../language-reference/keywords/override.md) 메서드의 반환 형식에 유연성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-317">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="3ad6e-318">재정의 메서드는 재정의된 기본 메서드의 반환 형식에서 파생된 형식을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-318">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="3ad6e-319">이 메서드는 레코드나 가상 클론 또는 팩터리 메서드를 지원하는 기타 형식에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-319">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="3ad6e-320">또한 [`foreach` 루프](../language-reference/keywords/foreach-in.md)는 `foreach` 패턴을 충족하는 확장 메서드 `GetEnumerator`를 인식하고 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-320">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="3ad6e-321">이렇게 변경함으로써 `foreach`는 비동기 패턴과 같은 다른 패턴 기반 생성 및 패턴 기반 분해와 일치하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-321">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="3ad6e-322">실제로 이 변경은 모든 형식에 `foreach` 지원을 추가할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-322">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="3ad6e-323">설계상 개체를 열거하는 것이 적합한 경우로 사용을 제한해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-323">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="3ad6e-324">다음으로, 무시 항목을 람다 식에 대한 매개 변수로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-324">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="3ad6e-325">이 편리한 기능을 사용하면 인수 이름을 지정할 필요가 없으며, 컴파일러에서 인수를 사용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-325">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="3ad6e-326">모든 인수에 `_`을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-326">You use the `_` for any argument.</span></span> <span data-ttu-id="3ad6e-327">자세한 내용은 [람다 식](../language-reference/operators/lambda-expressions.md) 문서의 [람다 식 입력 매개 변수](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-327">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="3ad6e-328">마지막으로, 이제 [로컬 함수](../programming-guide/classes-and-structs/local-functions.md)에 특성을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-328">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="3ad6e-329">예를 들어 로컬 함수에 [null 허용 특성 주석](../language-reference/attributes/nullable-analysis.md)을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-329">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="3ad6e-330">코드 생성기 지원</span><span class="sxs-lookup"><span data-stu-id="3ad6e-330">Support for code generators</span></span>

<span data-ttu-id="3ad6e-331">두 가지 최종 기능은 C# 코드 생성기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-331">Two final features support C# code generators.</span></span> <span data-ttu-id="3ad6e-332">C# 코드 생성기는 Roslyn 분석기나 코드 수정 사항과 유사하게, 직접 작성할 수 있는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-332">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="3ad6e-333">차이점은 코드 생성기의 경우 컴파일 프로세스의 일부로 코드를 분석하고 새 소스 코드 파일을 작성한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-333">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="3ad6e-334">일반적인 코드 생성기는 코드에서 특성이나 다른 규칙을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-334">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="3ad6e-335">코드 생성기는 Roslyn 분석 API를 사용하여 특성이나 다른 코드 요소를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-335">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="3ad6e-336">해당 정보를 통해 컴파일에 새 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-336">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="3ad6e-337">소스 생성기는 코드를 추가할 수만 있고 컴파일의 기존 코드를 수정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-337">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="3ad6e-338">코드 생성기에 대해 추가된 두 가지 기능은 ‘**부분 메서드 구문**’에 대한 확장과 ‘모듈 이니셜라이저’입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-338">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*_.</span></span> <span data-ttu-id="3ad6e-339">먼저 부분 메서드 변경 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-339">First, the changes to partial methods.</span></span> <span data-ttu-id="3ad6e-340">C# 9.0 이전에는 부분 메서드가 `private`이지만 액세스 한정자를 지정하거나 `void` 반환 또는 `out` 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-340">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="3ad6e-341">이 제한 사항 때문에, 메서드 구현을 제공하지 않을 경우 컴파일러에서 부분 메서드 호출을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-341">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="3ad6e-342">C# 9.0에서는 해당 제한 사항이 제거되었지만 부분 메서드 선언에 구현이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-342">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="3ad6e-343">코드 생성기에서 이 구현을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-343">Code generators can provide that implementation.</span></span> <span data-ttu-id="3ad6e-344">호환성이 손상되는 변경을 방지하기 위해 컴파일러에서 액세스 한정자가 없는 부분 메서드는 이전 규칙을 따른다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-344">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="3ad6e-345">부분 메서드에 `private` 액세스 한정자가 포함되어 있으면 새 규칙에 따라 부분 메서드가 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-345">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="3ad6e-346">코드 생성기의 두 번째 새로운 기능은 _\*_모듈 이니셜라이저_\*\*입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-346">The second new feature for code generators is _\*_module initializers_\*\*.</span></span> <span data-ttu-id="3ad6e-347">모듈 이니셜라이저는 <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> 특성이 연결된 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-347">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="3ad6e-348">이러한 메서드는 전체 모듈 내의 다른 필드 액세스 또는 메서드 호출 전에 런타임에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-348">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="3ad6e-349">모듈 이니셜라이저 메서드는 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-349">A module initializer method:</span></span>

- <span data-ttu-id="3ad6e-350">정적이어야 함</span><span class="sxs-lookup"><span data-stu-id="3ad6e-350">Must be static</span></span>
- <span data-ttu-id="3ad6e-351">매개 변수가 없어야 함</span><span class="sxs-lookup"><span data-stu-id="3ad6e-351">Must be parameterless</span></span>
- <span data-ttu-id="3ad6e-352">void를 반환해야 함</span><span class="sxs-lookup"><span data-stu-id="3ad6e-352">Must return void</span></span>
- <span data-ttu-id="3ad6e-353">제네릭 메서드가 아니어야 함</span><span class="sxs-lookup"><span data-stu-id="3ad6e-353">Must not be a generic method</span></span>
- <span data-ttu-id="3ad6e-354">제네릭 클래스에 포함되지 않아야 함</span><span class="sxs-lookup"><span data-stu-id="3ad6e-354">Must not be contained in a generic class</span></span>
- <span data-ttu-id="3ad6e-355">포함하는 모듈에서 액세스할 수 있어야 함</span><span class="sxs-lookup"><span data-stu-id="3ad6e-355">Must be accessible from the containing module</span></span>

<span data-ttu-id="3ad6e-356">마지막 글머리 기호 사항은 사실상, 메서드와 메서드를 포함하는 클래스가 internal 또는 public이어야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-356">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="3ad6e-357">메서드는 로컬 함수가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ad6e-357">The method can't be a local function.</span></span>
