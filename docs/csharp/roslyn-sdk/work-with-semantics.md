---
title: .NET Compiler Platform SDK 의미 체계 모델 사용
description: 이 개요에서는 코드의 의미 체계 모델을 이해하고 조작하는 데 사용하는 형식에 대한 이해를 제공합니다.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: f0d254045a168f82888c5cc77a34f194a68aed0e
ms.sourcegitcommit: 8299abfbd5c49b596d61f1e4d09bc6b8ba055b36
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/27/2021
ms.locfileid: "98899128"
---
# <a name="work-with-semantics"></a><span data-ttu-id="e8c33-103">의미 체계 작업</span><span class="sxs-lookup"><span data-stu-id="e8c33-103">Work with semantics</span></span>

<span data-ttu-id="e8c33-104">[구문 트리](work-with-syntax.md)는 소스 코드의 어휘 및 구문 구조를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-104">[Syntax trees](work-with-syntax.md) represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="e8c33-105">이 정보만으로 원본의 모든 선언 및 논리를 설명하기에 충분하지만 참조되는 것을 식별하는 데 충분한 정보가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-105">Although this information alone is enough to describe all the declarations and logic in the source, it is not enough information to identify what is being referenced.</span></span> <span data-ttu-id="e8c33-106">이름은 다음을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-106">A name may represent:</span></span>

- <span data-ttu-id="e8c33-107">형식</span><span class="sxs-lookup"><span data-stu-id="e8c33-107">a type</span></span>
- <span data-ttu-id="e8c33-108">필드</span><span class="sxs-lookup"><span data-stu-id="e8c33-108">a field</span></span>
- <span data-ttu-id="e8c33-109">메서드</span><span class="sxs-lookup"><span data-stu-id="e8c33-109">a method</span></span>
- <span data-ttu-id="e8c33-110">지역 변수</span><span class="sxs-lookup"><span data-stu-id="e8c33-110">a local variable</span></span>

<span data-ttu-id="e8c33-111">이러한 각각은 고유하게 다르지만 식별자에서 실제로 참조하는 것을 결정하는 데 종종 언어 규칙에 대한 심층적 이해가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-111">Although each of these is uniquely different, determining which one an identifier actually refers to often requires a deep understanding of the language rules.</span></span>

<span data-ttu-id="e8c33-112">소스 코드에서 표현되는 프로그램 요소가 있으며 프로그램은 어셈블리 파일에서 패키지된 이전에 컴파일된 라이브러리를 참조할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-112">There are program elements represented in source code, and programs can also refer to previously compiled libraries, packaged in assembly files.</span></span> <span data-ttu-id="e8c33-113">어셈블리에서 사용할 수 있는 소스 코드, 구문 노드 또는 트리가 없음에도 불구하고 프로그램은 여전히 내부의 요소를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-113">Although no source code, and therefore no syntax nodes or trees, are available for assemblies, programs can still refer to elements inside them.</span></span>

<span data-ttu-id="e8c33-114">이러한 작업의 경우 **의미 체계 모델** 이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-114">For those tasks, you need the **Semantic model**.</span></span>

<span data-ttu-id="e8c33-115">소스 코드의 구문 모델 외에도 의미 체계 모델은 식별자를 참조되는 올바른 프로그램 요소와 올바르게 일치시키는 쉬운 방법을 제공하여 언어 규칙을 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-115">In addition to a syntactic model of the source code, a semantic model encapsulates the language rules, giving you an easy way to correctly match identifiers with the correct program element being referenced.</span></span>

## <a name="compilation"></a><span data-ttu-id="e8c33-116">컴파일</span><span class="sxs-lookup"><span data-stu-id="e8c33-116">Compilation</span></span>

<span data-ttu-id="e8c33-117">컴파일은 어셈블리 참조, 컴파일러 옵션 및 원본 파일을 포함하는 C# 또는 Visual Basic 프로그램을 컴파일하는 데 필요한 모든 항목의 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-117">A compilation is a representation of everything needed to compile a C# or Visual Basic program, which includes all the assembly references, compiler options, and source files.</span></span>

<span data-ttu-id="e8c33-118">이 정보는 모두 한 곳에 있기 때문에 소스 코드에 포함된 요소를 더 자세히 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-118">Because all this information is in one place, the elements contained in the source code can be described in more detail.</span></span> <span data-ttu-id="e8c33-119">컴파일은 기호로 각 선언된 형식, 멤버 또는 변수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-119">The compilation represents each declared type, member, or variable as a symbol.</span></span> <span data-ttu-id="e8c33-120">컴파일은 소스 코드에서 선언되었거나 어셈블리에서 메타데이터로 가져온 기호를 찾거나 관련시키는 데 도움이 되는 다양한 메서드를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-120">The compilation contains a variety of methods that help you find and relate the symbols that have either been declared in the source code or imported as metadata from an assembly.</span></span>

<span data-ttu-id="e8c33-121">구문 트리와 마찬가지로, 컴파일은 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-121">Similar to syntax trees, compilations are immutable.</span></span> <span data-ttu-id="e8c33-122">컴파일을 만든 후에 사용자나 공유하는 사용자가 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-122">After you create a compilation, it cannot be changed by you or anyone else you might be sharing it with.</span></span> <span data-ttu-id="e8c33-123">그러나 그렇게 수행하는 대로 변경 내용을 지정하여 기존 컴파일에서 새 컴파일을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-123">However, you can create a new compilation from an existing compilation, specifying a change as you do so.</span></span> <span data-ttu-id="e8c33-124">예를 들어 추가 원본 파일 또는 어셈블리 참조를 포함할 수 있는 것을 제외하고 기존 컴파일과 모든 방식에서 동일한 컴파일을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-124">For example, you might create a compilation that is the same in every way as an existing compilation, except it may include an additional source file or assembly reference.</span></span>

## <a name="symbols"></a><span data-ttu-id="e8c33-125">기호</span><span class="sxs-lookup"><span data-stu-id="e8c33-125">Symbols</span></span>

<span data-ttu-id="e8c33-126">기호는 소스 코드에 의해 선언되거나 메타데이터로 어셈블리에서 가져온 고유한 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-126">A symbol represents a distinct element declared by the source code or imported from an assembly as metadata.</span></span> <span data-ttu-id="e8c33-127">모든 네임스페이스, 형식, 메서드, 속성, 필드, 이벤트, 매개 변수 또는 지역 변수는 기호로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-127">Every namespace, type, method, property, field, event, parameter, or local variable is represented by a symbol.</span></span>

<span data-ttu-id="e8c33-128"><xref:Microsoft.CodeAnalysis.Compilation> 형식의 다양한 메서드 및 속성은 기호를 찾는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-128">A variety of methods and properties on the <xref:Microsoft.CodeAnalysis.Compilation> type help you find symbols.</span></span> <span data-ttu-id="e8c33-129">예를 들어 일반적인 메타데이터 이름별로 선언된 형식에 대한 기호를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-129">For example, you can find a symbol for a declared type by its common metadata name.</span></span> <span data-ttu-id="e8c33-130">전역 네임스페이스로 루트된 기호의 트리로 전체 기호 테이블에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-130">You can also access the entire symbol table as a tree of symbols rooted by the global namespace.</span></span>

<span data-ttu-id="e8c33-131">기호는 또한 컴파일이 다른 참조된 기호와 같은 원본 또는 메타데이터에서 결정하는 추가 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-131">Symbols also contain additional information that the compiler determines from the source or metadata, such as other referenced symbols.</span></span> <span data-ttu-id="e8c33-132">각 종류의 기호는 컴파일러에서 수집한 정보를 자세히 설명하는 고유한 메서드 및 속성이 있는 각 <xref:Microsoft.CodeAnalysis.ISymbol>에서 파생된 별도 인터페이스로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-132">Each kind of symbol is represented by a separate interface derived from <xref:Microsoft.CodeAnalysis.ISymbol>, each with its own methods and properties detailing the information the compiler has gathered.</span></span> <span data-ttu-id="e8c33-133">이러한 속성의 상당수는 다른 기호를 직접 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-133">Many of these properties directly reference other symbols.</span></span> <span data-ttu-id="e8c33-134">예를 들어 <xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType> 속성은 메서드가 반환하는 실제 형식 기호를 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-134">For example, the <xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType> property tells you the actual type symbol that the method returns.</span></span>

<span data-ttu-id="e8c33-135">기호는 소스 코드와 메타데이터 간의 네임스페이스, 형식 및 멤버의 일반적인 표현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-135">Symbols present a common representation of namespaces, types, and members, between source code and metadata.</span></span> <span data-ttu-id="e8c33-136">예를 들어 소스 코드에 선언된 메서드 및 메타데이터에서 가져온 메서드는 모두 동일한 속성이 있는 <xref:Microsoft.CodeAnalysis.IMethodSymbol>로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-136">For example, a method that was declared in source code and a method that was imported from metadata are both represented by an <xref:Microsoft.CodeAnalysis.IMethodSymbol> with the same properties.</span></span>

<span data-ttu-id="e8c33-137">기호는 <xref:System.Reflection> API로 표시된 CLR 형식 시스템과 개념상 비슷하지만 형식 이상을 모델링하므로 더 다양합니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-137">Symbols are similar in concept to the CLR type system as represented by the <xref:System.Reflection> API, yet they are richer in that they model more than just types.</span></span> <span data-ttu-id="e8c33-138">네임스페이스, 지역 변수 및 레이블은 모두 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-138">Namespaces, local variables, and labels are all symbols.</span></span> <span data-ttu-id="e8c33-139">또한 기호는 CLR 개념이 아닌 언어 개념의 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-139">In addition, symbols are a representation of language concepts, not CLR concepts.</span></span> <span data-ttu-id="e8c33-140">겹치는 경우가 많지만 의미 있는 차이도 많습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-140">There is a lot of overlap, but there are many meaningful distinctions as well.</span></span> <span data-ttu-id="e8c33-141">예를 들어 C# 또는 Visual Basic의 반복기 메서드는 단일 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-141">For instance, an iterator method in C# or Visual Basic is a single symbol.</span></span> <span data-ttu-id="e8c33-142">그러나 반복기 메서드가 CLR 메타데이터로 번역되는 경우 이는 형식 및 여러 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-142">However, when the iterator method is translated to CLR metadata, it is a type and multiple methods.</span></span>

## <a name="semantic-model"></a><span data-ttu-id="e8c33-143">의미 체계 모델</span><span class="sxs-lookup"><span data-stu-id="e8c33-143">Semantic model</span></span>

<span data-ttu-id="e8c33-144">의미 체계 모델은 단일 원본 파일에 대한 모든 의미 체계 정보를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-144">A semantic model represents all the semantic information for a single source file.</span></span> <span data-ttu-id="e8c33-145">다음 검색에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8c33-145">You can use it to discover the following:</span></span>

- <span data-ttu-id="e8c33-146">원본의 특정 위치에서 참조되는 기호</span><span class="sxs-lookup"><span data-stu-id="e8c33-146">The symbols referenced at a specific location in source.</span></span>
- <span data-ttu-id="e8c33-147">모든 식의 결과 형식</span><span class="sxs-lookup"><span data-stu-id="e8c33-147">The resultant type of any expression.</span></span>
- <span data-ttu-id="e8c33-148">오류 및 경고인 모든 진단</span><span class="sxs-lookup"><span data-stu-id="e8c33-148">All diagnostics, which are errors and warnings.</span></span>
- <span data-ttu-id="e8c33-149">원본 영역 내부 및 외부의 변수 흐름 방식</span><span class="sxs-lookup"><span data-stu-id="e8c33-149">How variables flow in and out of regions of source.</span></span>
- <span data-ttu-id="e8c33-150">더 가상적인 질문에 대한 대답</span><span class="sxs-lookup"><span data-stu-id="e8c33-150">The answers to more speculative questions.</span></span>
