---
title: 컨테이너에서 진단 정보 수집
description: 이 문서에서는 Docker 컨테이너에서 .NET Core 진단 도구를 사용하는 방법에 대해 알아봅니다.
ms.date: 09/01/2020
ms.openlocfilehash: cf4bbdf75e943f093a2202f91303a2eea7125487
ms.sourcegitcommit: 5114e7847e0ff8ddb8c266802d47af78567949cf
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/19/2020
ms.locfileid: "94916211"
---
# <a name="collect-diagnostics-in-containers"></a><span data-ttu-id="e0355-103">컨테이너에서 진단 정보 수집</span><span class="sxs-lookup"><span data-stu-id="e0355-103">Collect diagnostics in containers</span></span>

<span data-ttu-id="e0355-104">다른 시나리오에서 .NET Core 문제를 진단하는 데 유용한 진단 도구를 Docker 컨테이너에서도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-104">The same diagnostics tools that are useful for diagnosing .NET Core issues in other scenarios also work in Docker containers.</span></span> <span data-ttu-id="e0355-105">다만 일부 도구를 컨테이너에서 사용하려면 특별한 단계가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-105">However, some of the tools require special steps to work in a container.</span></span> <span data-ttu-id="e0355-106">이 문서에서는 Docker 컨테이너에서 성능 추적을 수집하고 덤프를 수집하는 도구를 사용하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-106">This article covers how tools for gathering performance traces and collecting dumps can be used in Docker containers.</span></span>

## <a name="using-net-core-cli-tools-in-a-container"></a><span data-ttu-id="e0355-107">컨테이너에서 .NET Core CLI 도구 사용</span><span class="sxs-lookup"><span data-stu-id="e0355-107">Using .NET Core CLI tools in a container</span></span>

<span data-ttu-id="e0355-108">**이 문서의 적용 대상: ✔️** .NET Core 3.0 SDK 이상 버전</span><span class="sxs-lookup"><span data-stu-id="e0355-108">**These tools apply to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="e0355-109">.NET Core 전역 CLI 진단 도구([`dotnet-counters`](dotnet-counters.md), [`dotnet-dump`](dotnet-dump.md), [`dotnet-gcdump`](dotnet-gcdump.md), [`dotnet-trace`](dotnet-trace.md))는 다양한 환경에서 작동하도록 설계되었으며, Docker 컨테이너에서 직접 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-109">The .NET Core global CLI diagnostic tools ([`dotnet-counters`](dotnet-counters.md), [`dotnet-dump`](dotnet-dump.md), [`dotnet-gcdump`](dotnet-gcdump.md), and [`dotnet-trace`](dotnet-trace.md)) are designed to work in a wide variety of environments and should all work directly in Docker containers.</span></span> <span data-ttu-id="e0355-110">따라서 이러한 도구는 컨테이너에서 .NET Core 3.0 이상(또는 `dotnet-gcdump`의 경우 3.1 이상)을 대상으로 하는 .NET Core 시나리오에서 진단 정보를 수집하는 기본 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-110">Because of this, these tools are the preferred method of collecting diagnostic information for .NET Core scenarios targeting .NET Core 3.0 or above (or 3.1 or above in the case of `dotnet-gcdump`) in containers.</span></span>

<span data-ttu-id="e0355-111">컨테이너에서 이러한 도구를 사용할 때 복잡한 점은 이러한 도구는 .NET Core SDK와 함께 설치되는데, 많은 Docker 컨테이너가 .NET Core SDK가 없는 상태에서 실행된다는 것뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-111">The only complicating factor of using these tools in a container is that they are installed with the .NET Core SDK and many Docker containers run without the .NET Core SDK present.</span></span> <span data-ttu-id="e0355-112">이 문제의 한 가지 간단한 해결책은 초기 Docker 이미지에 도구를 설치하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-112">One easy solution to this problem is to install the tools in the initial Docker image.</span></span> <span data-ttu-id="e0355-113">.NET Core SDK가 실행될 필요는 없고 설치만 되어 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-113">The tools don't need the .NET Core SDK to run, only to be installed.</span></span> <span data-ttu-id="e0355-114">따라서 빌드 단계(.NET Core SDK가 있는)에서 도구를 설치한 다음 이진 파일을 최종 이미지에 복사하는 [다단계 빌드](https://docs.docker.com/develop/develop-images/multistage-build/)를 사용하여 Dockefile을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-114">Therefore, it's possible to create a Dockerfile with a [multi-stage build](https://docs.docker.com/develop/develop-images/multistage-build/) that installs the tools in a build stage (where the .NET Core SDK is present) and then copies the binaries into the final image.</span></span> <span data-ttu-id="e0355-115">이 방법의 유일한 단점은 Docker 이미지 크기가 늘어난다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-115">The only downside to this approach is increased Docker image size.</span></span>

```dockerfile
# In build stage
# Install desired .NET CLI diagnostics tools
RUN dotnet tool install --tool-path /tools dotnet-trace
RUN dotnet tool install --tool-path /tools dotnet-counters
RUN dotnet tool install --tool-path /tools dotnet-dump

...

# In final stage
# Copy diagnostics tools
WORKDIR /tools
COPY --from=build /tools .
```

<span data-ttu-id="e0355-116">또는 CLI 도구를 설치하기 위해 필요한 경우 컨테이너에 .NET Core SDK를 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-116">Alternatively, the .NET Core SDK can be installed in a container when needed in order to install the CLI tools.</span></span> <span data-ttu-id="e0355-117">.NET Core SDK를 설치하면 .NET Core 런타임을 다시 설치해야 하는 부작용이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-117">Be aware that installing the .NET Core SDK will have the side-effect of reinstalling the .NET Core runtime.</span></span> <span data-ttu-id="e0355-118">따라서 컨테이너에 있는 런타임과 일치하는 SDK 버전을 설치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-118">So be sure to install the version of the SDK that matches the runtime present in the container.</span></span>

### <a name="using-net-core-global-cli-tools-in-a-sidecar-container"></a><span data-ttu-id="e0355-119">사이드카 컨테이너에서 .NET Core 전역 CLI 도구 사용</span><span class="sxs-lookup"><span data-stu-id="e0355-119">Using .NET Core global CLI tools in a sidecar container</span></span>

<span data-ttu-id="e0355-120">.NET Core 전역 CLI 진단 도구를 사용하여 다른 컨테이너의 프로세스를 진단하려면 다음과 같은 추가 요구 사항을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-120">If you would like to use .NET Core global CLI diagnostic tools to diagnose processes in a different container, bear the following additional requirements in mind:</span></span>

1. <span data-ttu-id="e0355-121">사이드카 컨테이너의 도구가 대상 컨테이너의 프로세스에 액세스할 수 있도록 컨테이너가 [프로세스 네임스페이스를 공유](https://docs.docker.com/engine/reference/run/#pid-settings---pid)해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-121">The containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid) (so that tools in the sidecar container can access processes in the target container).</span></span>
2. <span data-ttu-id="e0355-122">.NET Core 전역 CLI 진단 도구는 .NET Core 런타임이 /tmp 디렉터리에 쓰는 파일에 액세스해야 하므로 볼륨 탑재를 통해 대상 컨테이너와 사이드카 컨테이너가 /tmp 디렉터리를 공유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-122">The .NET Core global CLI diagnostic tools need access to files the .NET Core runtime writes to the /tmp directory, so the /tmp directory must be shared between the target and sidecar container via a volume mount.</span></span> <span data-ttu-id="e0355-123">이것은 예를 들어 컨테이너가 공통 [볼륨](https://docs.docker.com/storage/volumes/#create-and-manage-volumes) 또는 Kubernetes [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) 볼륨을 공유하도록 하면 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-123">This could be done, for example, by having the containers share a common [volume](https://docs.docker.com/storage/volumes/#create-and-manage-volumes) or a Kubernetes [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) volume.</span></span> <span data-ttu-id="e0355-124">/tmp 디렉터리를 공유하지 않고 사이드카 컨테이너에서 진단 도구를 사용하려고 하면 “호환되는 .NET 런타임 실행 중 아님”이라는 프로세스에 대한 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-124">If you attempt to use the diagnostic tools from a sidecar container without sharing the /tmp directory, you will get an error about the process "not running compatible .NET runtime."</span></span>

## <a name="using-perfcollect-in-a-container"></a><span data-ttu-id="e0355-125">컨테이너에서 `PerfCollect` 사용</span><span class="sxs-lookup"><span data-stu-id="e0355-125">Using `PerfCollect` in a container</span></span>

<span data-ttu-id="e0355-126">**이 도구의 적용 대상: ✔️** .NET Core 2.1 이상 버전</span><span class="sxs-lookup"><span data-stu-id="e0355-126">**This tool applies to: ✔️** .NET Core 2.1 and later versions</span></span>

<span data-ttu-id="e0355-127">[`PerfCollect`](./trace-perfcollect-lttng.md) 스크립트는 성능 추적을 수집하는 데 유용하며, .NET Core 3.0 이전에 추적을 수집하는 데 권장되는 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-127">The [`PerfCollect`](./trace-perfcollect-lttng.md) script is useful for collecting performance traces and is the recommended tool for collecting traces prior to .NET Core 3.0.</span></span> <span data-ttu-id="e0355-128">컨테이너에서 `PerfCollect`를 사용하는 경우 다음 요구 사항을 염두에 두세요.</span><span class="sxs-lookup"><span data-stu-id="e0355-128">If using `PerfCollect` in a container, keep the following requirements in mind:</span></span>

1. <span data-ttu-id="e0355-129">`PerfCollect`는 `perf` 도구를 실행하기 위해 [`SYS_ADMIN` 기능](https://man7.org/linux/man-pages/man7/capabilities.7.html)이 필요하므로 컨테이너가 [해당 기능으로 시작](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-129">`PerfCollect` requires the [`SYS_ADMIN` capability](https://man7.org/linux/man-pages/man7/capabilities.7.html) (in order to run the `perf` tool), so be sure the container is [started with that capability](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span></span>
2. <span data-ttu-id="e0355-130">`PerfCollect`는 프로파일링하는 앱이 시작하기 전에 일부 환경 변수를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-130">`PerfCollect` requires some environment variables be set prior to the app it is profiling starting.</span></span> <span data-ttu-id="e0355-131">이러한 변수는 [Dockerfile](https://docs.docker.com/engine/reference/builder/#env)에서 또는 [컨테이너를 시작](https://docs.docker.com/engine/reference/run/#env-environment-variables)할 때 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-131">These can be set either in a [Dockerfile](https://docs.docker.com/engine/reference/builder/#env) or when [starting the container](https://docs.docker.com/engine/reference/run/#env-environment-variables).</span></span> <span data-ttu-id="e0355-132">이러한 변수는 일반적인 프로덕션 환경에서 설정하면 안 되므로 프로파일링될 컨테이너를 시작할 때 추가하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-132">Because these variables shouldn't be set in normal production environments, it's common to just add them when starting a container that will be profiled.</span></span> <span data-ttu-id="e0355-133">PerfCollect에 필요한 두 변수는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-133">The two variables which PerfCollect requires are:</span></span>
    1. <span data-ttu-id="e0355-134">COMPlus_PerfMapEnabled=1</span><span class="sxs-lookup"><span data-stu-id="e0355-134">COMPlus_PerfMapEnabled=1</span></span>
    1. <span data-ttu-id="e0355-135">COMPlus_EnableEventLog=1</span><span class="sxs-lookup"><span data-stu-id="e0355-135">COMPlus_EnableEventLog=1</span></span>

### <a name="using-perfcollect-in-a-sidecar-container"></a><span data-ttu-id="e0355-136">사이드카 컨테이너에서 `PerfCollect` 사용</span><span class="sxs-lookup"><span data-stu-id="e0355-136">Using `PerfCollect` in a sidecar container</span></span>

<span data-ttu-id="e0355-137">한 컨테이너에서 `PerfCollect`를 실행하여 다른 컨테이너의 .NET Core 프로세스를 프로파일링하려는 경우 다음 차이를 제외하면 환경은 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-137">If you would like to run `PerfCollect` in one container to profile a .NET Core process in a different container, the experience is almost the same except for these differences:</span></span>

1. <span data-ttu-id="e0355-138">위에 언급한 환경 변수(COMPlus_PerfMapEnabled 및 COMPlus_EnableEventLog)를 대상 컨테이너(`PerfCollect`를 실행하는 컨테이너가 아님)에 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-138">The environment variables mentioned previously (COMPlus_PerfMapEnabled and COMPlus_EnableEventLog) must be set for the target container (not the one running `PerfCollect`).</span></span>
2. <span data-ttu-id="e0355-139">`PerfCollect`를 실행하는 컨테이너에는 `SYS_ADMIN` 기능이 있어야 합니다(대상 컨테이너가 아님).</span><span class="sxs-lookup"><span data-stu-id="e0355-139">The container running `PerfCollect` must have the `SYS_ADMIN` capability (not the target container).</span></span>
3. <span data-ttu-id="e0355-140">두 컨테이너는 [프로세스 네임스페이스를 공유](https://docs.docker.com/engine/reference/run/#pid-settings---pid)해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-140">The two containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span></span>

## <a name="using-createdump-in-a-container"></a><span data-ttu-id="e0355-141">컨테이너에서 `createdump` 사용</span><span class="sxs-lookup"><span data-stu-id="e0355-141">Using `createdump` in a container</span></span>

<span data-ttu-id="e0355-142">**이 도구의 적용 대상: ✔️** .NET Core 2.1 이상 버전</span><span class="sxs-lookup"><span data-stu-id="e0355-142">**This tool applies to: ✔️** .NET Core 2.1 and later versions</span></span>

<span data-ttu-id="e0355-143">`dotnet-dump`의 대안인 [`createdump`](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/xplat-minidump-generation.md)를 사용하여 네이티브 및 관리되는 정보를 모두 포함하는 코어 덤프를 Linux에서 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-143">An alternative to `dotnet-dump`, [`createdump`](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/xplat-minidump-generation.md) can be used for creating core dumps on Linux containing both native and managed information.</span></span> <span data-ttu-id="e0355-144">`createdump` 도구는 .NET Core 런타임과 함께 설치되며 libcoreclr.so 옆에(일반적으로 “/usr/share/dotnet/shared/Microsoft.NETCore.App/[version]”에) 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-144">The `createdump` tool is installed with the .NET Core runtime and can be found next to libcoreclr.so (typically in "/usr/share/dotnet/shared/Microsoft.NETCore.App/[version]").</span></span> <span data-ttu-id="e0355-145">이 도구는 [`SYS_PTRACE` 기능](https://man7.org/linux/man-pages/man7/capabilities.7.html)이 필요하다는 점만 제외하면 컨테이너에서도 컨테이너화되지 않은 Linux 환경에서와 동일하게 작동하므로 Docker 컨테이너는 [해당 기능으로 시작](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-145">The tool works the same in a container as it does in non-containerized Linux environments with the single exception that the tool requires the [`SYS_PTRACE` capability](https://man7.org/linux/man-pages/man7/capabilities.7.html), so the Docker container must be [started with that capability](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span></span>

### <a name="using-createdump-in-a-sidecar-container"></a><span data-ttu-id="e0355-146">사이드카 컨테이너에서 `createdump` 사용</span><span class="sxs-lookup"><span data-stu-id="e0355-146">Using `createdump` in a sidecar container</span></span>

<span data-ttu-id="e0355-147">`createdump`를 사용하여 다른 컨테이너의 프로세스에서 덤프를 만드려는 경우 다음 차이를 제외하면 환경은 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-147">If you would like to use `createdump` to create a dump from a process in a different container, the experience is almost the same except for these differences:</span></span>

1. <span data-ttu-id="e0355-148">`createdump`를 실행하는 컨테이너에는 `SYS_PTRACE` 기능이 있어야 합니다(대상 컨테이너가 아님).</span><span class="sxs-lookup"><span data-stu-id="e0355-148">The container running `createdump` must have the `SYS_PTRACE` capability (not the target container).</span></span>
2. <span data-ttu-id="e0355-149">두 컨테이너는 [프로세스 네임스페이스를 공유](https://docs.docker.com/engine/reference/run/#pid-settings---pid)해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0355-149">The two containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span></span>
