---
title: 전역화
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- globalization [.NET], about globalization
- global applications, globalization
- international applications [.NET], globalization
- world-ready applications, globalization
- application development [.NET], globalization
- culture, globalization
ms.assetid: 4e919934-6b19-42f2-b770-275a4fae87c9
ms.openlocfilehash: 055bdfa82ea0e1721a6125ba14d7b6340dc254b9
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829871"
---
# <a name="globalization"></a><span data-ttu-id="012ef-102">전역화</span><span class="sxs-lookup"><span data-stu-id="012ef-102">Globalization</span></span>

<span data-ttu-id="012ef-103">전역화는 다양한 문화권의 사용자를 위해 현지화된 인터페이스와 국가별 데이터를 지원하는 지역화 대비 응용 프로그램을 디자인하고 개발하는 작업을 수반합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-103">Globalization involves designing and developing a world-ready app that supports localized interfaces and regional data for users in multiple cultures.</span></span> <span data-ttu-id="012ef-104">디자인 단계를 시작하기 전에 앱에서 지원할 문화권을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-104">Before beginning the design phase, you should determine which cultures your app will support.</span></span> <span data-ttu-id="012ef-105">앱이 기본적으로 단일 문화권이나 국가를 대상으로 하더라도, 다른 문화권이나 국가의 사용자에게 쉽게 확장될 수 있도록 디자인하고 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-105">Although an app targets a single culture or region as its default, you can design and write it so that it can easily be extended to users in other cultures or regions.</span></span>

<span data-ttu-id="012ef-106">모든 개발자는 각 문화권에 의해 형성된 사용자 인터페이스와 데이터에 대해 가정하는 부분이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-106">As developers, we all have assumptions about user interfaces and data that are formed by our cultures.</span></span> <span data-ttu-id="012ef-107">예를 들어, 미국에서 영어를 사용하는 개발자가 날짜 및 시간 데이터를 `MM/dd/yyyy hh:mm:ss` 서식의 문자열로 serialize하는 것은 매우 합당해 보입니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-107">For example, for an English-speaking developer in the United States, serializing date and time data as a string in the format `MM/dd/yyyy hh:mm:ss` seems perfectly reasonable.</span></span> <span data-ttu-id="012ef-108">하지만 그 문자열을 다른 문화권의 시스템에서 역직렬화하면 <xref:System.FormatException> 예외를 throw하거나 정확하지 않은 데이터를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-108">However, deserializing that string on a system in a different culture is likely to throw a <xref:System.FormatException> exception or produce inaccurate data.</span></span> <span data-ttu-id="012ef-109">전역화는 문화권별 가정을 식별하고 그것이 앱의 디자인이나 코드에 영향을 미치지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-109">Globalization enables us to identify such culture-specific assumptions and ensure that they do not affect our app's design or code.</span></span>

<span data-ttu-id="012ef-110">이 문서에서는 세계화된 앱에서 고려해야 할 몇 가지 주요 문제와 문자열, 날짜, 시간 값과 숫자 값을 처리할 때 따를 수 있는 모범 사례를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-110">This article discusses some of the major issues you should consider and the best practices you can follow when handling strings, date and time values, and numeric values in a globalized app.</span></span>

## <a name="strings"></a><span data-ttu-id="012ef-111">문자열</span><span class="sxs-lookup"><span data-stu-id="012ef-111">Strings</span></span>

<span data-ttu-id="012ef-112">각 문화권이나 국가는 다양한 문자 및 문자 집합을 사용하고 다양한 방식으로 문자를 정렬하기 때문에 문자와 문자열 처리는 전역화의 중심점입니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-112">The handling of characters and strings is a central focus of globalization, because each culture or region may use different characters and character sets and sort them differently.</span></span> <span data-ttu-id="012ef-113">이 섹션에서는 전역화된 앱에서 문자열 사용에 대한 권장 사항을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-113">This section provides recommendations for using strings in globalized apps.</span></span>

### <a name="use-unicode-internally"></a><span data-ttu-id="012ef-114">내부적으로 유니코드 사용</span><span class="sxs-lookup"><span data-stu-id="012ef-114">Use Unicode internally</span></span>

<span data-ttu-id="012ef-115">기본적으로 .NET에서는 유니코드 문자열을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-115">By default, .NET uses Unicode strings.</span></span> <span data-ttu-id="012ef-116">유니코드 문자열은 0 또는 하나 이상의 <xref:System.Char> 개체로 구성되며, 각 개체는 UTF-16 코드 단위를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-116">A Unicode string consists of zero, one, or more <xref:System.Char> objects, each of which represents a UTF-16 code unit.</span></span> <span data-ttu-id="012ef-117">전세계에서 사용되는 모든 문자 집합의 거의 모든 문자에 대해서는 유니코드 표현이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-117">There is a Unicode representation for almost every character in every character set in use throughout the world.</span></span>

<span data-ttu-id="012ef-118">Windows 운영 체제를 비롯한 많은 애플리케이션과 운영 체제는 코드 페이지를 사용하여 문자 집합을 나타낼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-118">Many applications and operating systems, including the Windows operating system, can use also use code pages to represent character sets.</span></span> <span data-ttu-id="012ef-119">일반적으로 코드 페이지는 0x00부터 0x7F까지 표준 ASCII 값을 포함하며 다른 문자를 0x80부터 0xFF까지 나머지 값에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-119">Code pages typically contain the standard ASCII values from 0x00 through 0x7F and map other characters to the remaining values from 0x80 through 0xFF.</span></span> <span data-ttu-id="012ef-120">0x80부터 0xFF까지 값에 대한 해석은 특정 코드 페이지에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-120">The interpretation of values from 0x80 through 0xFF depends on the specific code page.</span></span> <span data-ttu-id="012ef-121">이 때문에 전역화된 앱에서 가능하면 코드 페이지 사용을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-121">Because of this, you should avoid using code pages in a globalized app if possible.</span></span>

<span data-ttu-id="012ef-122">다음 예제는 시스템의 기본 코드 페이지가 데이터가 저장된 코드 페이지와 다른 경우 코드 페이지 데이터 해석의 위험을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-122">The following example illustrates the dangers of interpreting code page data when the default code page on a system is different from the code page on which the data was saved.</span></span> <span data-ttu-id="012ef-123">(이 시나리오를 시뮬레이션하기 위해, 예제에 다른 코드 페이지를 명시적으로 지정합니다.) 우선, 예제에 그리스어 알파벳의 대문자로 구성된 배열을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-123">(To simulate this scenario, the example explicitly specifies different code pages.) First, the example defines an array that consists of the uppercase characters of the Greek alphabet.</span></span> <span data-ttu-id="012ef-124">이것을 코드 페이지 737(MS-DOS Greek이라고도 함)을 사용하여 바이트 배열로 인코딩하고 바이트 배열을 파일로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-124">It encodes them into a byte array by using code page 737 (also known as MS-DOS Greek) and saves the byte array to a file.</span></span> <span data-ttu-id="012ef-125">파일을 가져와서 코드 페이지 737을 사용하여 바이트 배열을 디코딩하면, 원래 문자가 복원됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-125">If the file is retrieved and its byte array is decoded by using code page 737, the original characters are restored.</span></span> <span data-ttu-id="012ef-126">하지만, 파일을 가져와서 코드 페이지 1252(또는 라틴 알파벳 문자를 나타내는Windows-1252)를 사용하여 바이트 배열을 디코딩하면, 원래 문자가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-126">However, if the file is retrieved and its byte array is decoded by using code page 1252 (or Windows-1252, which represents characters in the Latin alphabet), the original characters are lost.</span></span>

[!code-csharp[Conceptual.Globalization#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/codepages1.cs#1)]
[!code-vb[Conceptual.Globalization#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/codepages1.vb#1)]

<span data-ttu-id="012ef-127">유니코드를 사용하면 동일한 코드 단위가 항상 동일한 문자에 매핑되고, 동일한 문자가 항상 동일한 바이트 배열에 매핑되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-127">The use of Unicode ensures that the same code units always map to the same characters, and that the same characters always map to the same byte arrays.</span></span>

### <a name="use-resource-files"></a><span data-ttu-id="012ef-128">리소스 파일 사용</span><span class="sxs-lookup"><span data-stu-id="012ef-128">Use resource files</span></span>

<span data-ttu-id="012ef-129">단일 문화권이나 국가를 대상하는 하는 앱을 개발하더라도 사용자 인터페이스로 표시되는 문자열 및 기타 리소스를 저장하는 리소스 파일을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-129">Even if you are developing an app that targets a single culture or region, you should use resource files to store strings and other resources that are displayed in the user interface.</span></span> <span data-ttu-id="012ef-130">이러한 리소스는 절대로 코드에 직접 추가하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-130">You should never add them directly to your code.</span></span> <span data-ttu-id="012ef-131">리소스 파일을 사용하면 많은 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-131">Using resource files has a number of advantages:</span></span>

- <span data-ttu-id="012ef-132">모든 문자열이 단일 위치에 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-132">All the strings are in a single location.</span></span> <span data-ttu-id="012ef-133">특정 언어나 문화권에 대해 수정하기 위해 문자열을 식별하려고 소스 코드 전체를 검색할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-133">You don't have to search throughout your source code to identify strings to modify for a specific language or culture.</span></span>

- <span data-ttu-id="012ef-134">문자열을 중복할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-134">There is no need to duplicate strings.</span></span> <span data-ttu-id="012ef-135">리소스 파일을 자주 사용하지 않는 개발자는 동일한 문자열을 여러 소스 코드 파일에 정의하곤 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-135">Developers who don't use resource files often define the same string in multiple source code files.</span></span> <span data-ttu-id="012ef-136">이렇게 중복하면 문자열을 수정할 때 하나 이상의 인스턴스를 간과할 가능성이 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-136">This duplication increases the probability that one or more instances will be overlooked when a string is modified.</span></span>

- <span data-ttu-id="012ef-137">이미지 또는 이진 데이터와 같이 문자열이 아닌 리소스를 별도의 독립 실행형 파일 대신 리소스 파일에 포함시키면 쉽게 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-137">You can include non-string resources, such as images or binary data, in the resource file instead of storing them in a separate standalone file, so they can be retrieved easily.</span></span>

<span data-ttu-id="012ef-138">리소스 파일을 사용하면 특히 현지화된 앱을 만드는 경우에 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-138">Using resource files has particular advantages if you are creating a localized app.</span></span> <span data-ttu-id="012ef-139">위성 어셈블리로 리소스를 배포하는 경우, 공용 언어 런타임은 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> 속성에 의해 정의된 사용자의 현재 UI 문화권을 기반으로 적절한 문화권의 리소스를 자동으로 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-139">When you deploy resources in satellite assemblies, the common language runtime automatically selects a culture-appropriate resource based on the user's current UI culture as defined by the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="012ef-140">문화권별로 적절한 리소스를 제공하고 <xref:System.Resources.ResourceManager> 개체를 제대로 인스턴스화하거나 강력한 형식 리소스 클래스를 사용하기만 한다면, 런타임에서 적절한 리소스를 가져오는 세부 정보를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-140">As long as you provide an appropriate culture-specific resource and correctly instantiate a <xref:System.Resources.ResourceManager> object or use a strongly typed resource class, the runtime handles the details of retrieving the appropriate resources.</span></span>

<span data-ttu-id="012ef-141">리소스 파일을 만드는 방법에 대한 자세한 내용은 [리소스 파일 만들기](../../framework/resources/creating-resource-files-for-desktop-apps.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="012ef-141">For more information about creating resource files, see [Creating Resource Files](../../framework/resources/creating-resource-files-for-desktop-apps.md).</span></span> <span data-ttu-id="012ef-142">위성 어셈블리를 만들고 배포하는 방법에 대한 자세한 내용은 [위성 어셈블리 만들기](../../framework/resources/creating-satellite-assemblies-for-desktop-apps.md) 및 [리소스 패키징 및 배포](../../framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="012ef-142">For information about creating and deploying satellite assemblies, see [Creating Satellite Assemblies](../../framework/resources/creating-satellite-assemblies-for-desktop-apps.md) and [Packaging and Deploying Resources](../../framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).</span></span>

### <a name="search-and-compare-strings"></a><span data-ttu-id="012ef-143">문자열 검색 및 비교</span><span class="sxs-lookup"><span data-stu-id="012ef-143">Search and compare strings</span></span>

<span data-ttu-id="012ef-144">가능하면 문자열을 일련의 개별 문자로 처리하는 대신 전체 문자열로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-144">Whenever possible, you should handle strings as entire strings instead of handling them as a series of individual characters.</span></span> <span data-ttu-id="012ef-145">이것은 부분 문자열을 정렬하거나 검색하는 경우, 결합된 문자의 구문 분석과 관련된 문제를 방지하는 데 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-145">This is especially important when you sort or search for substrings, to prevent problems associated with parsing combined characters.</span></span>

> [!TIP]
> <span data-ttu-id="012ef-146">문자열의 개별 문자 보다는 텍스트 요소에 <xref:System.Globalization.StringInfo> 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-146">You can use the <xref:System.Globalization.StringInfo> class to work with the text elements rather than the individual characters in a string.</span></span>

<span data-ttu-id="012ef-147">문자열 검색 및 비교 시 일반적인 실수는 문자열을 각각 <xref:System.Char> 개체로 표시되는 문자의 컬렉션으로 다루는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-147">In string searches and comparisons, a common mistake is to treat the string as a collection of characters, each of which is represented by a <xref:System.Char> object.</span></span> <span data-ttu-id="012ef-148">실제, 단일 문자는 하나, 둘, 또는 그 이상의 <xref:System.Char> 개체로 형성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-148">In fact, a single character may be formed by one, two, or more <xref:System.Char> objects.</span></span> <span data-ttu-id="012ef-149">이러한 문자는 알파벳이 유니코드 기본 라틴 문자의 범위(U+0021 ~ U+007E)에 속하지 않는 문자로 구성된 문화권의 문자열에서 가장 빈번하게 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-149">Such characters are found most frequently in strings from cultures whose alphabets consist of characters outside the Unicode Basic Latin character range (U+0021 through U+007E).</span></span> <span data-ttu-id="012ef-150">다음 예제는 문자열에서 LATIN CAPITAL LETTER A WITH GRAVE 문자(U+00C0)의 인덱스를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-150">The following example tries to find the index of the LATIN CAPITAL LETTER A WITH GRAVE character (U+00C0) in a string.</span></span> <span data-ttu-id="012ef-151">하지만 이 문자는 단일 코드 단위(U+00C0) 또는 복합 문자(두 코드 단위: U+0041 및 U+0300)라는 두 방법으로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-151">However, this character can be represented in two different ways: as a single code unit (U+00C0) or as a composite character (two code units: U+0041 and U+0300).</span></span> <span data-ttu-id="012ef-152">이런 경우, 문자는 2개의 <xref:System.Char> 개체 즉, U+0041 및 U+0300을 통해 문자열 인스턴스로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-152">In this case, the character is represented in the string instance by two <xref:System.Char> objects, U+0041 and U+0300.</span></span> <span data-ttu-id="012ef-153">예제 코드는 문자열 인스턴스 내에서 이 문자의 위치를 찾기 위해 <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> 및 <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> 오버로드를 호출하지만 이것은 다른 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-153">The example code calls the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> overloads to find the position of this character in the string instance, but these return different results.</span></span> <span data-ttu-id="012ef-154">첫 번째 메서드 호출에는 <xref:System.Char> 인수가 있고, 이것이 서수 비교를 수행하기 때문에 일치하는 값을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-154">The first method call has a <xref:System.Char> argument; it performs an ordinal comparison and therefore cannot find a match.</span></span> <span data-ttu-id="012ef-155">두 번째 호출에는 <xref:System.String> 인수가 있고, 이것은 문화권구분 비교를 수행하기 때문에 일치하는 값을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-155">The second call has a <xref:System.String> argument; it performs a culture-sensitive comparison and therefore finds a match.</span></span>

[!code-csharp[Conceptual.Globalization#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/search1.cs#18)]
[!code-vb[Conceptual.Globalization#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/search1.vb#18)]

<span data-ttu-id="012ef-156"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 또는 <xref:System.String.LastIndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 메서드와 같이 <xref:System.StringComparison> 매개 변수를 포함하는 오버로드를 호출하면 이 예제(다른 결과를 반환하는 메서드의 두 가지 유사한 오버로드에 대한 호출)의 모호성을 피할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-156">You can avoid some of the ambiguity of this example (calls to two similar overloads of a method returning different results) by calling an overload that includes a <xref:System.StringComparison> parameter, such as the <xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> or <xref:System.String.LastIndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="012ef-157">하지만 검색에 항상 문화권을 구분하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-157">However, searches are not always culture-sensitive.</span></span> <span data-ttu-id="012ef-158">검색의 목적이 보안 결정을 내리거나 리소스에 대한 액세스를 허용하거나 허용하지 않는 것이라면, 비교는 다음 섹션의 설명처럼 서수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-158">If the purpose of the search is to make a security decision or to allow or disallow access to some resource, the comparison should be ordinal, as discussed in the next section.</span></span>

### <a name="test-strings-for-equality"></a><span data-ttu-id="012ef-159">문자열이 같은지 테스트</span><span class="sxs-lookup"><span data-stu-id="012ef-159">Test strings for equality</span></span>

<span data-ttu-id="012ef-160">두 개 문자열의 정렬 순서를 비교하는 방법을 결정하는 게 아니라 문자열 두 개가 같은지를 테스트하려면 <xref:System.String.Compare%2A?displayProperty=nameWithType> 또는 <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>와 같은 문자열 비교 메서드 대신 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-160">If you want to test two strings for equality rather than determine how they compare in the sort order, use the <xref:System.String.Equals%2A?displayProperty=nameWithType> method instead of a string comparison method such as <xref:System.String.Compare%2A?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="012ef-161">같음 비교는 조건부로 일부 리소스에 액세스하기 위해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-161">Comparisons for equality are typically performed to access some resource conditionally.</span></span> <span data-ttu-id="012ef-162">예를 들어, 암호를 확인하거나 파일이 있는지 확인하기 위해 같음 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-162">For example, you might perform a comparison for equality to verify a password or to confirm that a file exists.</span></span> <span data-ttu-id="012ef-163">이러한 비언어적인 비교는 문화권을 구분하지 않고 항상 서수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-163">Such non-linguistic comparisons should always be ordinal rather than culture-sensitive.</span></span> <span data-ttu-id="012ef-164">일반적으로 암호와 같은 문자열에 대해서는 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 값으로, 파일 이름 또는 URI와 같은 문자열에 대해서는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 값으로, 인스턴스 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 메서드 또는 정적 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 메서드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-164">In general, you should call the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method with a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for strings such as passwords, and a value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for strings such as file names or URIs.</span></span>

<span data-ttu-id="012ef-165">같음 비교에 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드에 대한 호출이 아닌 검색 또는 부분 문자열 비교를 수반하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-165">Comparisons for equality sometimes involve searches or substring comparisons rather than calls to the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="012ef-166">경우에 따라, 부분 문자열이 다른 문자열과 같은지를 판단하기 위해 부분 문자열 검색을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-166">In some cases, you may use a substring search to determine whether that substring equals another string.</span></span> <span data-ttu-id="012ef-167">비교의 목적이 비언어적인 경우, 검색은 문화권 구분이 아닌 서수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-167">If the purpose of this comparison is non-linguistic, the search should also be ordinal rather than culture-sensitive.</span></span>

<span data-ttu-id="012ef-168">다음 예제는 비언어적인 데이터에 대한 문화권 구분 검색의 위험을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-168">The following example illustrates the danger of a culture-sensitive search on non-linguistic data.</span></span> <span data-ttu-id="012ef-169">`AccessesFileSystem` 메서드는 "FILE"이라는 부분 문자열로 시작되는 URI에 대한 파일 시스템 액세스를 금지하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-169">The `AccessesFileSystem` method is designed to prohibit file system access for URIs that begin with the substring "FILE".</span></span> <span data-ttu-id="012ef-170">이를 위해, URI의 시작 부분을 "FILE"이라는 문자열과 문화권을 구분하고 대/소문자를 구분하지 않는 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-170">To do this, it performs a culture-sensitive, case-insensitive comparison of the beginning of the URI with the string "FILE".</span></span> <span data-ttu-id="012ef-171">파일 시스템에 액세스하는 URI는 “FILE:” 또는 “file:”로 시작되기 때문에 “i”(U+0069)는 언제나 “I”(U+0049)에 해당하는 소문자라는 암묵적인 가정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-171">Because a URI that accesses the file system can begin with either "FILE:" or "file:", the implicit assumption is that "i" (U+0069) is always the lowercase equivalent of "I" (U+0049).</span></span> <span data-ttu-id="012ef-172">하지만 터키어 및 아제르바이잔어에서 "i"의 대문자 버전은 "İ"(U+0130)입니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-172">However, in Turkish and Azerbaijani, the uppercase version of "i" is "İ" (U+0130).</span></span> <span data-ttu-id="012ef-173">이러한 불일치로 인해, 문화권 구분 비교는 파일 시스템 액세스를 금지해야 하는 경우에 액세스를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-173">Because of this discrepancy, the culture-sensitive comparison allows file system access when it should be prohibited.</span></span>

[!code-csharp[Conceptual.Globalization#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals1.cs#12)]
[!code-vb[Conceptual.Globalization#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals1.vb#12)]

<span data-ttu-id="012ef-174">다음 예제와 같은 대/소문자를 무시하는 서수 비교를 수행하여 이러한 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-174">You can avoid this problem by performing an ordinal comparison that ignores case, as the following example shows.</span></span>

[!code-csharp[Conceptual.Globalization#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals2.cs#13)]
[!code-vb[Conceptual.Globalization#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals2.vb#13)]

### <a name="order-and-sort-strings"></a><span data-ttu-id="012ef-175">문자열 순서 및 정렬</span><span class="sxs-lookup"><span data-stu-id="012ef-175">Order and sort strings</span></span>

<span data-ttu-id="012ef-176">일반적으로 사용자 인터페이스로 표시되는 순서가 지정된 문자열은 문화권을 기반으로 정렬되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-176">Typically, ordered strings that are to be displayed in the user interface should be sorted based on culture.</span></span> <span data-ttu-id="012ef-177">대부분의 경우, 이러한 문자열 비교는 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 또는 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>와 같이 문자열을 정렬하는 메서드를 호출할 때 .NET에 의해 암시적으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-177">For the most part, such string comparisons are handled implicitly by .NET when you call a method that sorts strings, such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="012ef-178">기본적으로 문자열은 현재 문화권의 정렬 규칙을 사용하여 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-178">By default, strings are sorted by using the sorting conventions of the current culture.</span></span> <span data-ttu-id="012ef-179">다음 예제는 문자열 배열이 영어(미국) 문화권과 스웨덴어(스웨덴) 문화권의 규칙을 사용하여 정렬되는 경우 차이점을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-179">The following example illustrates the difference when an array of strings is sorted by using the conventions of the English (United States) culture and the Swedish (Sweden) culture.</span></span>

[!code-csharp[Conceptual.Globalization#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sort1.cs#14)]
[!code-vb[Conceptual.Globalization#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sort1.vb#14)]

<span data-ttu-id="012ef-180">문화권 구분 문자열 비교는 <xref:System.Globalization.CompareInfo> 개체로 정의되며, 이것은 각 문화권의 <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-180">Culture-sensitive string comparison is defined by the <xref:System.Globalization.CompareInfo> object, which is returned by each culture's <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="012ef-181"><xref:System.String.Compare%2A?displayProperty=nameWithType> 메서드 오버로드를 사용하는 문화권 구분 문자열 비교는 <xref:System.Globalization.CompareInfo> 개체도 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-181">Culture-sensitive string comparisons that use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method overloads also use the <xref:System.Globalization.CompareInfo> object.</span></span>

<span data-ttu-id="012ef-182">.NET에서는 테이블을 사용하여 문자열 데이터에 대해 문화권 구분 정렬을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-182">.NET uses tables to perform culture-sensitive sorts on string data.</span></span> <span data-ttu-id="012ef-183">이러한 테이블의 내용에는 정렬 가중치 및 문자열 정규화에 대한 데이터가 포함되며, 이것은 특정한 .NET 버전에서 구현되는 유니코드 표준 버전에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-183">The content of these tables, which contain data on sort weights and string normalization, is determined by the version of the Unicode standard implemented by a particular version of .NET.</span></span> <span data-ttu-id="012ef-184">다음 테이블에는 지정된 .NET 버전으로 구현되는 유니코드 버전이 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-184">The following table lists the versions of Unicode implemented by the specified versions of .NET.</span></span> <span data-ttu-id="012ef-185">지원되는 유니코드 버전 목록은 문자 비교 및 정렬에만 적용되며 범주에 따른 유니코드 문자의 분류에는 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-185">This list of supported Unicode versions applies to character comparison and sorting only; it does not apply to classification of Unicode characters by category.</span></span> <span data-ttu-id="012ef-186">자세한 내용은 <xref:System.String> 항목의 “문자열과 유니코드 표준” 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="012ef-186">For more information, see the "Strings and The Unicode Standard" section in the <xref:System.String> article.</span></span>

|<span data-ttu-id="012ef-187">.NET Framework 버전</span><span class="sxs-lookup"><span data-stu-id="012ef-187">.NET Framework version</span></span>|<span data-ttu-id="012ef-188">운영 체제</span><span class="sxs-lookup"><span data-stu-id="012ef-188">Operating system</span></span>|<span data-ttu-id="012ef-189">유니코드 버전</span><span class="sxs-lookup"><span data-stu-id="012ef-189">Unicode version</span></span>|
|----------------------------|----------------------|---------------------|
|<span data-ttu-id="012ef-190">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="012ef-190">.NET Framework 2.0</span></span>|<span data-ttu-id="012ef-191">모든 운영 체제</span><span class="sxs-lookup"><span data-stu-id="012ef-191">All operating systems</span></span>|<span data-ttu-id="012ef-192">Unicode 4.1</span><span class="sxs-lookup"><span data-stu-id="012ef-192">Unicode 4.1</span></span>|
|<span data-ttu-id="012ef-193">.NET Framework 3.0</span><span class="sxs-lookup"><span data-stu-id="012ef-193">.NET Framework 3.0</span></span>|<span data-ttu-id="012ef-194">모든 운영 체제</span><span class="sxs-lookup"><span data-stu-id="012ef-194">All operating systems</span></span>|<span data-ttu-id="012ef-195">Unicode 4.1</span><span class="sxs-lookup"><span data-stu-id="012ef-195">Unicode 4.1</span></span>|
|<span data-ttu-id="012ef-196">.NET Framework 3.5</span><span class="sxs-lookup"><span data-stu-id="012ef-196">.NET Framework 3.5</span></span>|<span data-ttu-id="012ef-197">모든 운영 체제</span><span class="sxs-lookup"><span data-stu-id="012ef-197">All operating systems</span></span>|<span data-ttu-id="012ef-198">Unicode 4.1</span><span class="sxs-lookup"><span data-stu-id="012ef-198">Unicode 4.1</span></span>|
|<span data-ttu-id="012ef-199">.NET Framework 4</span><span class="sxs-lookup"><span data-stu-id="012ef-199">.NET Framework 4</span></span>|<span data-ttu-id="012ef-200">모든 운영 체제</span><span class="sxs-lookup"><span data-stu-id="012ef-200">All operating systems</span></span>|<span data-ttu-id="012ef-201">Unicode 5.0</span><span class="sxs-lookup"><span data-stu-id="012ef-201">Unicode 5.0</span></span>|
|<span data-ttu-id="012ef-202">Windows 7의 .NET Framework 4.5 이상</span><span class="sxs-lookup"><span data-stu-id="012ef-202">.NET Framework 4.5 and later on Windows 7</span></span>|<span data-ttu-id="012ef-203">Unicode 5.0</span><span class="sxs-lookup"><span data-stu-id="012ef-203">Unicode 5.0</span></span>|
|<span data-ttu-id="012ef-204">Windows 8 이상 운영 체제의 .NET Framework 4.5 이상</span><span class="sxs-lookup"><span data-stu-id="012ef-204">.NET Framework 4.5 and later on Windows 8 and later operating systems</span></span>|<span data-ttu-id="012ef-205">유니코드 6.3.0</span><span class="sxs-lookup"><span data-stu-id="012ef-205">Unicode 6.3.0</span></span>|
|<span data-ttu-id="012ef-206">.NET Core 및 .NET 5 이상</span><span class="sxs-lookup"><span data-stu-id="012ef-206">.NET Core and .NET 5+</span></span>|<span data-ttu-id="012ef-207">기본 운영 체제에서 지원되는 유니코드 표준의 버전에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-207">Depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>|

<span data-ttu-id="012ef-208">.NET Framework 4.5부터 모든 버전의 .NET Core 및 .NET 5 이상에서 문자열 비교와 정렬은 운영 체제에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-208">Starting with .NET Framework 4.5 and in all versions of .NET Core and .NET 5+, string comparison and sorting depends on the operating system.</span></span> <span data-ttu-id="012ef-209">Windows 7에서 실행되는 .NET Framework 4.5 이상은 유니코드 5.0을 구현하는 자체 테이블의 데이터를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-209">.NET Framework 4.5 and later running on Windows 7 retrieves data from its own tables that implement Unicode 5.0.</span></span> <span data-ttu-id="012ef-210">Windows 8 이상에서 실행되는 .NET Framework 4.5 이상은 유니코드 6.3을 구현하는 운영 체제 테이블의 데이터를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-210">.NET Framework 4.5 and later running on Windows 8 and later retrieves data from operating system tables that implement Unicode 6.3.</span></span> <span data-ttu-id="012ef-211">.NET Core 및 .NET 5 이상에서 지원되는 유니코드의 버전은 기본 운영 체제에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-211">On .NET Core and .NET 5+, the supported version of Unicode depends on the underlying operating system.</span></span> <span data-ttu-id="012ef-212">문화권 구분 정렬 데이터를 직렬화하면 <xref:System.Globalization.SortVersion> 클래스를 사용하여 직렬화된 데이터가 .NET 및 운영 체제의 정렬 순서와 일치하도록 정렬되어야 하는 시기를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-212">If you serialize culture-sensitive sorted data, you can use the <xref:System.Globalization.SortVersion> class to determine when your serialized data needs to be sorted so that it is consistent with .NET and the operating system's sort order.</span></span> <span data-ttu-id="012ef-213">예제는 <xref:System.Globalization.SortVersion> 클래스 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="012ef-213">For an example, see the <xref:System.Globalization.SortVersion> class topic.</span></span>

<span data-ttu-id="012ef-214">앱에서 문자열 데이터의 광범위한 문화권별 정렬을 수행하는 경우, <xref:System.Globalization.SortKey> 클래스를 사용하여 문자열을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-214">If your app performs extensive culture-specific sorts of string data, you can work with the <xref:System.Globalization.SortKey> class to compare strings.</span></span> <span data-ttu-id="012ef-215">정렬 키는 알파벳, 대/소문자, 특정 문자열의 분음 부호 가중치를 비롯한 문화권별 정렬 가중치를 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-215">A sort key reflects the culture-specific sort weights, including the alphabetic, case, and diacritic weights of a particular string.</span></span> <span data-ttu-id="012ef-216">정렬 키를 사용한 비교는 이진이기 때문에 암시적 또는 명시적으로 <xref:System.Globalization.CompareInfo> 개체를 사용하는 비교보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-216">Because comparisons using sort keys are binary, they are faster than comparisons that use a <xref:System.Globalization.CompareInfo> object either implicitly or explicitly.</span></span> <span data-ttu-id="012ef-217">문자열을 <xref:System.Globalization.CompareInfo.GetSortKey%2A?displayProperty=nameWithType> 메서드에 전달하여 특정 문자열에 대한 문화권별 정렬 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-217">You create a culture-specific sort key for a particular string by passing the string to the <xref:System.Globalization.CompareInfo.GetSortKey%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="012ef-218">다음 예제는 이전 예제와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-218">The following example is similar to the previous example.</span></span> <span data-ttu-id="012ef-219">하지만 <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> 메서드를 암시적으로 호출하는 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 메서드를 호출하는 대신, 정렬 키를 비교하는 <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> 구현을 정의하고, 인스턴스화하여 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 메서드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-219">However, instead of calling the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method, which implicitly calls the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method, it defines an <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implementation that compares sort keys, which it instantiates and passes to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span>

[!code-csharp[Conceptual.Globalization#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sortkey1.cs#15)]
[!code-vb[Conceptual.Globalization#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sortkey1.vb#15)]

### <a name="avoid-string-concatenation"></a><span data-ttu-id="012ef-220">문자열 연결 사용하지 않기</span><span class="sxs-lookup"><span data-stu-id="012ef-220">Avoid string concatenation</span></span>

<span data-ttu-id="012ef-221">만약 가능하다면, 연결된 구에서 런타임에 작성된 복합 문자열을 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="012ef-221">If at all possible, avoid using composite strings that are built at run time from concatenated phrases.</span></span> <span data-ttu-id="012ef-222">복합 문자열은 다른 현지화된 언어에 적용되지 않는 앱의 원래 언어로 문법적인 순서를 가정하는 경우가 많기 때문에 현지화하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-222">Composite strings are difficult to localize, because they often assume a grammatical order in the app's original language that does not apply to other localized languages.</span></span>

## <a name="handle-dates-and-times"></a><span data-ttu-id="012ef-223">날짜 및 시간 처리</span><span class="sxs-lookup"><span data-stu-id="012ef-223">Handle dates and times</span></span>

<span data-ttu-id="012ef-224">날짜 및 시간 값을 처리하는 방법은 사용자 인터페이스로 표시되거나 지속되는 여부에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-224">How you handle date and time values depends on whether they are displayed in the user interface or persisted.</span></span> <span data-ttu-id="012ef-225">이 섹션은 두 가지 사용법 모두를 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-225">This section examines both usages.</span></span> <span data-ttu-id="012ef-226">날짜 및 시간을 작업할 때 표준 시간대 차이 및 산술 연산을 처리하는 방법도 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-226">It also discusses how you can handle time zone differences and arithmetic operations when working with dates and times.</span></span>

### <a name="display-dates-and-times"></a><span data-ttu-id="012ef-227">날짜 및 시간 표시</span><span class="sxs-lookup"><span data-stu-id="012ef-227">Display dates and times</span></span>

<span data-ttu-id="012ef-228">일반적으로 날짜 및 시간이 사용자 인터페이스로 표시되는 경우, 사용자 문화권의 서식 규칙을 사용해야 합니다. 이것은 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성 및 `CultureInfo.CurrentCulture.DateTimeFormat` 속성에 의해 반환되는 <xref:System.Globalization.DateTimeFormatInfo> 개체에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-228">Typically, when dates and times are displayed in the user interface, you should use the formatting conventions of the user's culture, which is defined by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property and by the <xref:System.Globalization.DateTimeFormatInfo> object returned by the `CultureInfo.CurrentCulture.DateTimeFormat` property.</span></span> <span data-ttu-id="012ef-229">현재 문화권의 서식 규칙은 다음 메서드 중 하나를 사용하여 날짜의 서식을 지정할 때 자동으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-229">The formatting conventions of the current culture are automatically used when you format a date by using any of these methods:</span></span>

- <span data-ttu-id="012ef-230">매개 변수가 없는 <xref:System.DateTime.ToString?displayProperty=nameWithType> 메서드</span><span class="sxs-lookup"><span data-stu-id="012ef-230">The parameterless <xref:System.DateTime.ToString?displayProperty=nameWithType> method</span></span>

- <span data-ttu-id="012ef-231">서식 문자열을 포함하는 <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> 메서드</span><span class="sxs-lookup"><span data-stu-id="012ef-231">The <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> method, which includes a format string</span></span>

- <span data-ttu-id="012ef-232">매개 변수가 없는 <xref:System.DateTimeOffset.ToString?displayProperty=nameWithType> 메서드</span><span class="sxs-lookup"><span data-stu-id="012ef-232">The parameterless <xref:System.DateTimeOffset.ToString?displayProperty=nameWithType> method</span></span>

- <span data-ttu-id="012ef-233">서식 문자열을 포함하는 <xref:System.DateTimeOffset.ToString%28System.String%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="012ef-233">The <xref:System.DateTimeOffset.ToString%28System.String%29?displayProperty=nameWithType>, which includes a format string</span></span>

- <span data-ttu-id="012ef-234">날짜에 사용되는 경우, [복합 서식 지정](../base-types/composite-formatting.md) 기능</span><span class="sxs-lookup"><span data-stu-id="012ef-234">The [composite formatting](../base-types/composite-formatting.md) feature, when it is used with dates</span></span>

<span data-ttu-id="012ef-235">다음 예제는 2012년 10월 11일에 대한 일출 및 일몰 데이터를 두 번 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-235">The following example displays sunrise and sunset data twice for October 11, 2012.</span></span> <span data-ttu-id="012ef-236">처음에는 현재 문화권을 크로아티아어(크로아티아)로 설정하고 다음에는 영어(영국)로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-236">It first sets the current culture to Croatian (Croatia), and then to English (Great Britain).</span></span> <span data-ttu-id="012ef-237">각각의 경우, 날짜 및 시간이 해당 문화권에 적절한 서식으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-237">In each case, the dates and times are displayed in the format that is appropriate for that culture.</span></span>

[!code-csharp[Conceptual.Globalization#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates1.cs#2)]
[!code-vb[Conceptual.Globalization#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates1.vb#2)]

### <a name="persist-dates-and-times"></a><span data-ttu-id="012ef-238">날짜 및 시간 유지</span><span class="sxs-lookup"><span data-stu-id="012ef-238">Persist dates and times</span></span>

<span data-ttu-id="012ef-239">문화권에 따라 달라질 수 있는 서식으로 날짜 및 시간 데이터를 유지하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-239">You should never persist date and time data in a format that can vary by culture.</span></span> <span data-ttu-id="012ef-240">이것은 일반적인 프로그래밍 오류이며, 손상된 데이터 또는 런타임 예외를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-240">This is a common programming error that results in either corrupted data or a run-time exception.</span></span> <span data-ttu-id="012ef-241">다음 예제는 2013년 1월 9일 및 2013년 8월 18일이라는 두 개의 날짜를 영어(미국) 문화권의 서식 규칙을 사용하여 문자열로 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-241">The following example serializes two dates, January 9, 2013 and August 18, 2013, as strings by using the formatting conventions of the English (United States) culture.</span></span> <span data-ttu-id="012ef-242">영어(미국) 문화권의 형식을 사용하여 데이터를 가져와서 구문을 분석하면, 성공적으로 복원됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-242">When the data is retrieved and parsed by using the conventions of the English (United States) culture, it is successfully restored.</span></span> <span data-ttu-id="012ef-243">하지만, 영어(영국) 문화권의 규칙을 사용하여 데이터를 가져와서 구문을 분석하면, 첫 번째 날짜는 9월 1일로 잘못 해석되고 두 번째는 일반 달력에 18번째 달이 없기 때문에 구문 분석에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-243">However, when it is retrieved and parsed by using the conventions of the English (United Kingdom) culture, the first date is wrongly interpreted as September 1, and the second fails to parse because the Gregorian calendar does not have an eighteenth month.</span></span>

[!code-csharp[Conceptual.Globalization#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates2.cs#3)]
[!code-vb[Conceptual.Globalization#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates2.vb#3)]

<span data-ttu-id="012ef-244">세 가지 방법 중 하나를 통해 이러한 문제를 피할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-244">You can avoid this problem in any of three ways:</span></span>

- <span data-ttu-id="012ef-245">날짜 및 시간을 문자열이 아닌 이진 형식으로 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-245">Serialize the date and time in binary format rather than as a string.</span></span>

- <span data-ttu-id="012ef-246">사용자의 문화권과 상관없이 동일한 사용자 지정 서식 문자열을 사용하여 날짜와 시간의 문자열 표현을 저장하고 구문 분석합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-246">Save and parse the string representation of the date and time by using a custom format string that is the same regardless of the user's culture.</span></span>

- <span data-ttu-id="012ef-247">고정 문화권의 서식 규칙을 사용하여 문자열을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-247">Save the string by using the formatting conventions of the invariant culture.</span></span>

<span data-ttu-id="012ef-248">다음 예제에서 마지막 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-248">The following example illustrates the last approach.</span></span> <span data-ttu-id="012ef-249">정적 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성에 의해 반환되는 고정 문화권의 서식 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-249">It uses the formatting conventions of the invariant culture returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

[!code-csharp[Conceptual.Globalization#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates3.cs#4)]
[!code-vb[Conceptual.Globalization#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates3.vb#4)]

### <a name="serialization-and-time-zone-awareness"></a><span data-ttu-id="012ef-250">Serialization 및 표준 시간대 인식</span><span class="sxs-lookup"><span data-stu-id="012ef-250">Serialization and time zone awareness</span></span>

<span data-ttu-id="012ef-251">날짜 및 시간 값은 일반 시간("매장은 2013년 1월 2일 오전 9:00에 개장합니다.")에서 특정한 순간("생년월일: 2013년 1월 2일 오전 6:32:00")에 이르기까지 다수의 해석이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-251">A date and time value can have multiple interpretations, ranging from a general time ("The stores open on January 2, 2013, at 9:00 A.M.") to a specific moment in time ("Date of birth: January 2, 2013 6:32:00 A.M.").</span></span> <span data-ttu-id="012ef-252">시간 값이 특정한 순간을 나타내는 경우 serialize된 값으로부터 복원하며, 사용자의 지리적 위치 또는 표준 시간대와 상관없이 동일한 순간을 나타내도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-252">When a time value represents a specific moment in time and you restore it from a serialized value, you should ensure that it represents the same moment in time regardless of the user's geographical location or time zone.</span></span>

<span data-ttu-id="012ef-253">다음 예제에서는 이 문제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-253">The following example illustrates this problem.</span></span> <span data-ttu-id="012ef-254">단일 지역 날짜 및 시간 값을 세 가지 [표준 서식](../base-types/standard-date-and-time-format-strings.md)(“G”는 일반 날짜 자세한 시간, “s”는 정렬 가능한 날짜/시간, “o”는 날짜/시간 값 라운드트립)은 물론 이진 형식의 문자열로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-254">It saves a single local date and time value as a string in three [standard formats](../base-types/standard-date-and-time-format-strings.md) ("G" for general date long time, "s" for sortable date/time, and "o" for round-trip date/time) as well as in binary format.</span></span>

[!code-csharp[Conceptual.Globalization#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates4.cs#10)]
[!code-vb[Conceptual.Globalization#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates4.vb#10)]

<span data-ttu-id="012ef-255">데이터가 serialize된 시스템과 표준 시간대가 같은 시스템에서 데이터가 복원되면, 역직렬화된 날짜 및 시간 값이 원래 값을 정확하게 반영하고 다음과 같이 출력됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-255">When the data is restored on a system in the same time zone as the system on which it was serialized, the deserialized date and time values accurately reflect the original value, as the output shows:</span></span>

```console
'3/30/2013 6:00:00 PM' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00.0000000-07:00' --> 3/30/2013 6:00:00 PM Local

3/30/2013 6:00:00 PM Local
```

<span data-ttu-id="012ef-256">하지만, 표준 시간대가 다른 시스템에서 데이터를 복원하면, "o"(라운드트립) 표준 서식 문자열로 서식이 지정된 날짜 및 시간 값만 표준 시간대 정보를 유지하기 때문에 동일한 시점을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-256">However, if you restore the data on a system in a different time zone, only the date and time value that was formatted with the "o" (round-trip) standard format string preserves time zone information and therefore represents the same instant in time.</span></span> <span data-ttu-id="012ef-257">날짜 및 시간 데이터를 로망스 표준 시간대 시스템에서 복원하면 다음과 같이 출력됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-257">Here's the output when the date and time data is restored on a system in the Romance Standard Time zone:</span></span>

```console
'3/30/2013 6:00:00 PM' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00.0000000-07:00' --> 3/31/2013 3:00:00 AM Local

3/30/2013 6:00:00 PM Local
```

<span data-ttu-id="012ef-258">데이터가 역직렬화된 시스템의 표준 시간대와 상관없이 단일 순간을 나타내는 날짜 및 시간 값을 정확하게 반영하려면 다음 중 하나를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-258">To accurately reflect a date and time value that represents a single moment of time regardless of the time zone of the system on which the data is deserialized, you can do any of the following:</span></span>

- <span data-ttu-id="012ef-259">"o"(라운드트립) 표준 서식 문자열을 사용하여 값을 문자열로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-259">Save the value as a string by using the "o" (round-trip) standard format string.</span></span> <span data-ttu-id="012ef-260">그런 다음 대상 시스템에서 값을 역직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-260">Then deserialize it on the target system.</span></span>

- <span data-ttu-id="012ef-261">값을 UTC로 변환하고 "r"(RFC1123) 표준 서식 문자열을 사용하여 문자열로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-261">Convert it to UTC and save it as a string by using the "r" (RFC1123) standard format string.</span></span> <span data-ttu-id="012ef-262">그런 다음 대상 시스템에서 값을 역직렬화하고 현지 시간으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-262">Then deserialize it on the target system and convert it to local time.</span></span>

- <span data-ttu-id="012ef-263">값을 UTC로 변환하고 "u"(정렬 가능한 유니버설) 표준 서식 문자열을 사용하여 문자열로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-263">Convert it to UTC and save it as a string by using the "u" (universal sortable) standard format string.</span></span> <span data-ttu-id="012ef-264">그런 다음 대상 시스템에서 값을 역직렬화하고 현지 시간으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-264">Then deserialize it on the target system and convert it to local time.</span></span>

- <span data-ttu-id="012ef-265">값을 UTC로 변환하고 이진 형식으로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-265">Convert it to UTC and save it in binary format.</span></span> <span data-ttu-id="012ef-266">그런 다음 대상 시스템에서 값을 역직렬화하고 현지 시간으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-266">Then deserialize it on the target system and convert it to local time.</span></span>

<span data-ttu-id="012ef-267">다음 예제는 각 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-267">The following example illustrates each technique.</span></span>

[!code-csharp[Conceptual.Globalization#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates8.cs#11)]
[!code-vb[Conceptual.Globalization#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates8.vb#11)]

<span data-ttu-id="012ef-268">데이터가 태평양 표준 시간대 시스템에서 직렬화되고 로망스 표준 시간대 시스템에서 역직렬화되는 경우에, 예제는 다음과 같이 출력됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-268">When the data is serialized on a system in the Pacific Standard Time zone and deserialized on a system in the Romance Standard Time zone, the example displays the following output:</span></span>

```console
'2013-03-30T18:00:00.0000000-07:00' --> 3/31/2013 3:00:00 AM Local
'Sun, 31 Mar 2013 01:00:00 GMT' --> 3/31/2013 3:00:00 AM Local
'2013-03-31 01:00:00Z' --> 3/31/2013 3:00:00 AM Local

3/31/2013 3:00:00 AM Local
```

<span data-ttu-id="012ef-269">자세한 내용은 [표준 시간대 간에 시간 변환](../datetime/converting-between-time-zones.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="012ef-269">For more information, see [Converting Times Between Time Zones](../datetime/converting-between-time-zones.md).</span></span>

### <a name="perform-date-and-time-arithmetic"></a><span data-ttu-id="012ef-270">날짜 및 시간 연산 수행</span><span class="sxs-lookup"><span data-stu-id="012ef-270">Perform date and time arithmetic</span></span>

<span data-ttu-id="012ef-271"><xref:System.DateTime> 및 <xref:System.DateTimeOffset> 형식 모두 산술 연산을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-271">Both the <xref:System.DateTime> and <xref:System.DateTimeOffset> types support arithmetic operations.</span></span> <span data-ttu-id="012ef-272">두 날짜 값 사이의 차이를 계산하거나 날짜 값에서 특정한 시간 간격을 빼거나 더할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-272">You can calculate the difference between two date values, or you can add or subtract particular time intervals to or from a date value.</span></span> <span data-ttu-id="012ef-273">하지만 날짜 및 시간 값에 대한 산술 연산은 표준 시간대 및 표준 시간대 조정 규칙을 감안하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-273">However, arithmetic operations on date and time values do not take time zones and time zone adjustment rules into account.</span></span> <span data-ttu-id="012ef-274">이 때문에, 순간을 나타내는 값에 대한 날짜 및 시간 연산은 부정확한 결과를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-274">Because of this, date and time arithmetic on values that represent moments in time can return inaccurate results.</span></span>

<span data-ttu-id="012ef-275">예를 들어, 태평양 표준시는 3월 둘째 주 일요일 즉, 2013년 3월 10일에 태평양 일광 절약 시간으로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-275">For example, the transition from Pacific Standard Time to Pacific Daylight Time occurs on the second Sunday of March, which is March 10 for the year 2013.</span></span> <span data-ttu-id="012ef-276">다음 예제에 나와 있듯이 태평양 표준 시간대의 시스템상 시간인 2013년 3월 9일 오전 10시 30분의 48시간 이후인 날짜 및 시간을 계산하면</span><span class="sxs-lookup"><span data-stu-id="012ef-276">As the following example shows, if you calculate the date and time that is 48 hours after March 9, 2013 at 10:30 A.M.</span></span> <span data-ttu-id="012ef-277">그 결과가 2013년 3월 11일 오전 10시 30분으로, 중간의 시간대 조정이 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-277">on a system in the Pacific Standard Time zone, the result, March 11, 2013 at 10:30 A.M., does not take the intervening time adjustment into account.</span></span>

[!code-csharp[Conceptual.Globalization#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates5.cs#8)]
[!code-vb[Conceptual.Globalization#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates5.vb#8)]

<span data-ttu-id="012ef-278">날짜 및 시간 값에 대한 산술 연산이 정확한 결과를 생성하도록 보장하려면 다음 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-278">To ensure that an arithmetic operation on date and time values produces accurate results, follow these steps:</span></span>

1. <span data-ttu-id="012ef-279">소스 표준 시간대의 시간을 UTC로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-279">Convert the time in the source time zone to UTC.</span></span>

2. <span data-ttu-id="012ef-280">산술 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-280">Perform the arithmetic operation.</span></span>

3. <span data-ttu-id="012ef-281">결과가 날짜 및 시간 값이면, UTC에서 소스 표준 시간대의 시간으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-281">If the result is a date and time value, convert it from UTC to the time in the source time zone.</span></span>

<span data-ttu-id="012ef-282">다음 예제는 2013년 3월 9일 오전 10시 30분에 48시간을 제대로 더하기 위하여 이러한 세 가지 단계를 수행한 것을 제외하면 이전 예제와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-282">The following example is similar to the previous example, except that it follows these three steps to correctly add 48 hours to March 9, 2013 at 10:30 A.M.</span></span>

[!code-csharp[Conceptual.Globalization#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates6.cs#9)]
[!code-vb[Conceptual.Globalization#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates6.vb#9)]

<span data-ttu-id="012ef-283">자세한 내용은 [날짜 및 시간에 대한 산술 연산 수행](../datetime/performing-arithmetic-operations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="012ef-283">For more information, see [Performing Arithmetic Operations with Dates and Times](../datetime/performing-arithmetic-operations.md).</span></span>

### <a name="use-culture-sensitive-names-for-date-elements"></a><span data-ttu-id="012ef-284">날짜 요소에서 문화권 구분 이름 사용</span><span class="sxs-lookup"><span data-stu-id="012ef-284">Use culture-sensitive names for date elements</span></span>

<span data-ttu-id="012ef-285">앱에 월 이름 또는 요일을 표시해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-285">Your app may need to display the name of the month or the day of the week.</span></span> <span data-ttu-id="012ef-286">이를 위해서는, 다음과 같은 코드가 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-286">To do this, code such as the following is common.</span></span>

[!code-csharp[Conceptual.Globalization#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname1.cs#19)]
[!code-vb[Conceptual.Globalization#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname1.vb#19)]

<span data-ttu-id="012ef-287">하지만 이 코드는 요일의 이름을 항상 영어로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-287">However, this code always returns the names of the days of the week in English.</span></span> <span data-ttu-id="012ef-288">월 이름을 추출하는 코드는 훨씬 더 유연한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-288">Code that extracts the name of the month is often even more inflexible.</span></span> <span data-ttu-id="012ef-289">특정 언어에 월 이름과 12개월 달력이 있을 것으로 가정하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-289">It frequently assumes a twelve-month calendar with names of months in a specific language.</span></span>

<span data-ttu-id="012ef-290">다음 예제에서 볼 수 있듯이, [사용자 지정 날짜 및 시간 형식 문자열](../base-types/custom-date-and-time-format-strings.md) 또는 <xref:System.Globalization.DateTimeFormatInfo> 개체의 속성을 사용하면 사용자 문화권의 월 또는 요일 이름을 반영하는 문자열을 쉽게 추출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-290">By using [custom date and time format strings](../base-types/custom-date-and-time-format-strings.md) or the properties of the <xref:System.Globalization.DateTimeFormatInfo> object, it is easy to extract strings that reflect the names of days of the week or months in the user's culture, as the following example illustrates.</span></span> <span data-ttu-id="012ef-291">현재 문화권을 프랑스어(프랑스)로 변경하고 2013년 7월 1일에 대한 월 이름과 요일 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-291">It changes the current culture to French (France) and displays the name of the day of the week and the name of the month for July 1, 2013.</span></span>

[!code-csharp[Conceptual.Globalization#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname2.cs#20)]
[!code-vb[Conceptual.Globalization#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname2.vb#20)]

## <a name="numeric-values"></a><span data-ttu-id="012ef-292">숫자 값</span><span class="sxs-lookup"><span data-stu-id="012ef-292">Numeric values</span></span>

<span data-ttu-id="012ef-293">숫자 처리는 숫자가 사용자 인터페이스로 표시되거나 지속되는 여부에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-293">The handling of numbers depends on whether they are displayed in the user interface or persisted.</span></span> <span data-ttu-id="012ef-294">이 섹션은 두 가지 사용법 모두를 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-294">This section examines both usages.</span></span>

> [!NOTE]
> <span data-ttu-id="012ef-295">구문 분석 및 서식 지정 작업에서 .NET은 0에서 9까지(U+0030 ~ U+0039)의 기본 라틴 문자를 숫자로만 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-295">In parsing and formatting operations, .NET recognizes only the Basic Latin characters 0 through 9 (U+0030 through U+0039) as numeric digits.</span></span>

### <a name="display-numeric-values"></a><span data-ttu-id="012ef-296">숫자 값 표시</span><span class="sxs-lookup"><span data-stu-id="012ef-296">Display numeric values</span></span>

<span data-ttu-id="012ef-297">일반적으로 숫자가 사용자 인터페이스로 표시되는 경우, 사용자 문화권의 서식 규칙을 사용해야 합니다. 이것은 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성 및 `CultureInfo.CurrentCulture.NumberFormat` 속성에 의해 반환되는 <xref:System.Globalization.NumberFormatInfo> 개체에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-297">Typically, when numbers are displayed in the user interface, you should use the formatting conventions of the user's culture, which is defined by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property and by the <xref:System.Globalization.NumberFormatInfo> object returned by the `CultureInfo.CurrentCulture.NumberFormat` property.</span></span> <span data-ttu-id="012ef-298">현재 문화권의 서식 규칙은 다음 메서드 중 하나를 사용하여 날짜의 서식을 지정할 때 자동으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-298">The formatting conventions of the current culture are automatically used when you format a date by using any of the following methods:</span></span>

- <span data-ttu-id="012ef-299">숫자 형식의 매개 변수가 없는 `ToString` 메서드</span><span class="sxs-lookup"><span data-stu-id="012ef-299">The parameterless `ToString` method of any numeric type</span></span>

- <span data-ttu-id="012ef-300">서식 문자열을 인수로 포함하는, 숫자 형식의 `ToString(String)` 메서드</span><span class="sxs-lookup"><span data-stu-id="012ef-300">The `ToString(String)` method of any numeric type, which includes a format string as an argument</span></span>

- <span data-ttu-id="012ef-301">숫자 값에 사용되는 경우, [복합 서식 지정](../base-types/composite-formatting.md) 기능</span><span class="sxs-lookup"><span data-stu-id="012ef-301">The [composite formatting](../base-types/composite-formatting.md) feature, when it is used with numeric values</span></span>

<span data-ttu-id="012ef-302">다음 예제는 프랑스 파일의 월별 평균 온도를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-302">The following example displays the average temperature per month in Paris, France.</span></span> <span data-ttu-id="012ef-303">우선 데이터를 표시하기 전에 현재 문화권을 프랑스어(프랑스)로 설정하고 그 다음 영어(미국)로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-303">It first sets the current culture to French (France) before displaying the data, and then sets it to English (United States).</span></span> <span data-ttu-id="012ef-304">각각의 경우, 월 이름 및 온도가 해당 문화권에 적합한 서식으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-304">In each case, the month names and temperatures are displayed in the format that is appropriate for that culture.</span></span> <span data-ttu-id="012ef-305">두 문화권을 온도 값에 다른 소수 구분 기호를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-305">Note that the two cultures use different decimal separators in the temperature value.</span></span> <span data-ttu-id="012ef-306">또한, 월 이름 전체를 표시하기 위해 "MMMM" 사용자 지정 날짜 및 시간 서식 문자열이 예제에 사용되었고, 이를 통해 <xref:System.Globalization.DateTimeFormatInfo.MonthNames%2A?displayProperty=nameWithType> 배열에서 가장 긴 월 이름의 길이를 판단하여 결과 문자열에 월 이름을 나타내기에 적합한 공간이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-306">Also note that the example uses the "MMMM" custom date and time format string to display the full month name, and that it allocates the appropriate amount of space for the month name in the result string by determining the length of the longest month name in the <xref:System.Globalization.DateTimeFormatInfo.MonthNames%2A?displayProperty=nameWithType> array.</span></span>

[!code-csharp[Conceptual.Globalization#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers1.cs#5)]
[!code-vb[Conceptual.Globalization#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers1.vb#5)]

### <a name="persist-numeric-values"></a><span data-ttu-id="012ef-307">숫자 값 유지</span><span class="sxs-lookup"><span data-stu-id="012ef-307">Persist numeric values</span></span>

<span data-ttu-id="012ef-308">숫자 데이터를 문화권별 서식으로 유지하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-308">You should never persist numeric data in a culture-specific format.</span></span> <span data-ttu-id="012ef-309">이것은 일반적인 프로그래밍 오류이며, 손상된 데이터 또는 런타임 예외를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-309">This is a common programming error that results in either corrupted data or a run-time exception.</span></span> <span data-ttu-id="012ef-310">다음 예제는 10개의 부동 소수점 난수를 생성한 다음 영어(미국) 문화권의 서식 규칙을 사용하여 문자열로 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-310">The following example generates ten random floating-point numbers, and then serializes them as strings by using the formatting conventions of the English (United States) culture.</span></span> <span data-ttu-id="012ef-311">영어(미국) 문화권의 형식을 사용하여 데이터를 가져와서 구문을 분석하면, 성공적으로 복원됩니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-311">When the data is retrieved and parsed by using the conventions of the English (United States) culture, it is successfully restored.</span></span> <span data-ttu-id="012ef-312">하지만, 이것을 가져와서 프랑스어(프랑스) 문화권 규칙을 사용하여 구문 분석을 수행하면, 이 문화권에서 다른 소수 구분 기호를 사용하기 때문에 숫자를 구문 분석할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-312">However, when it is retrieved and parsed by using the conventions of the French (France) culture, none of the numbers can be parsed because the cultures use different decimal separators.</span></span>

[!code-csharp[Conceptual.Globalization#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers2.cs#6)]
[!code-vb[Conceptual.Globalization#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers2.vb#6)]

<span data-ttu-id="012ef-313">이 문제를 피하려면, 다음 방법 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-313">To avoid this problem, you can use one of these techniques:</span></span>

- <span data-ttu-id="012ef-314">사용자의 문화권과 상관없이 동일한 사용자 지정 서식 문자열을 사용하여 숫자의 문자열 표현을 저장하고 구문 분석합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-314">Save and parse the string representation of the number by using a custom format string that is the same regardless of the user's culture.</span></span>

- <span data-ttu-id="012ef-315"><xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성에 의해 반환되는 고정 문화권의 서식 규칙을 사용하여 숫자를 문자열로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-315">Save the number as a string by using the formatting conventions of the invariant culture, which is returned by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

- <span data-ttu-id="012ef-316">숫자를 이진 형식이 아닌 문자열 형식으로 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-316">Serialize the number in binary instead of string format.</span></span>

<span data-ttu-id="012ef-317">다음 예제에서 마지막 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-317">The following example illustrates the last approach.</span></span> <span data-ttu-id="012ef-318"><xref:System.Double> 값의 배열을 직렬화한 다음 역직렬화하고 영어(미국) 및 프랑스어(프랑스) 문화권의 서식 규칙을 사용하여 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-318">It serializes the array of <xref:System.Double> values, and then deserializes and displays them by using the formatting conventions of the English (United States) and French (France) cultures.</span></span>

[!code-csharp[Conceptual.Globalization#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers3.cs#7)]
[!code-vb[Conceptual.Globalization#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers3.vb#7)]

<span data-ttu-id="012ef-319">통화 값 serialize는 특별한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-319">Serializing currency values is a special case.</span></span> <span data-ttu-id="012ef-320">통화 값은 값이 표현되는 통화의 단위에 따라 달라지므로, 이것을 독립적인 숫자 값으로 처리하는 것은 합당하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-320">Because a currency value depends on the unit of currency in which it is expressed; it makes little sense to treat it as an independent numeric value.</span></span> <span data-ttu-id="012ef-321">하지만, 통화 값을 통화 기호를 포함하는 서식이 지정된 문자열로 저장하면, 다음 예제에서 볼 수 있듯이, 다른 통화 기호를 사용하는 기본 문화권의 시스템에서 역직렬화될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-321">However, if you save a currency value as a formatted string that includes a currency symbol, it cannot be deserialized on a system whose default culture uses a different currency symbol, as the following example shows.</span></span>

[!code-csharp[Conceptual.Globalization#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency1.cs#16)]
[!code-vb[Conceptual.Globalization#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency1.vb#16)]

<span data-ttu-id="012ef-322">대신, 값과 그에 대한 통화 기호가 현재 문화권과 관계 없이 역직렬화될 수 있도록, 숫자 값을 문화권 정보(예: 문화권의 이름)와 함께 serialize해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-322">Instead, you should serialize the numeric value along with some cultural information, such as the name of the culture, so that the value and its currency symbol can be deserialized independently of the current culture.</span></span> <span data-ttu-id="012ef-323">다음 예제에서는 두 가지 멤버 즉, <xref:System.Decimal> 값과 그 값이 속하는 문화권의 이름으로 `CurrencyValue` 구조를 정의하여 이것을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-323">The following example does that by defining a `CurrencyValue` structure with two members: the <xref:System.Decimal> value and the name of the culture to which the value belongs.</span></span>

[!code-csharp[Conceptual.Globalization#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency2.cs#17)]
[!code-vb[Conceptual.Globalization#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency2.vb#17)]

## <a name="work-with-culture-specific-settings"></a><span data-ttu-id="012ef-324">문화권별 설정 작업</span><span class="sxs-lookup"><span data-stu-id="012ef-324">Work with culture-specific settings</span></span>

<span data-ttu-id="012ef-325">.NET에서 <xref:System.Globalization.CultureInfo> 클래스는 특정 문화권 또는 국가를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-325">In .NET, the <xref:System.Globalization.CultureInfo> class represents a particular culture or region.</span></span> <span data-ttu-id="012ef-326">이들 속성 중 일부는 문화의 일부 측면에 대한 구체적인 정보를 제공하는 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-326">Some of its properties return objects that provide specific information about some aspect of a culture:</span></span>

- <span data-ttu-id="012ef-327"><xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> 속성은 문화권에서 문자열을 비교하고 정렬하는 방법에 대한 정보를 포함하는 <xref:System.Globalization.CompareInfo> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-327">The <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.CompareInfo> object that contains information about how the culture compares and orders strings.</span></span>

- <span data-ttu-id="012ef-328"><xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> 속성은 날짜 및 시간 데이터의 서식 지정에 사용되는 문화권별 정보를 제공하는 <xref:System.Globalization.DateTimeFormatInfo> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-328">The <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.DateTimeFormatInfo> object that provides culture-specific information used in formatting date and time data.</span></span>

- <span data-ttu-id="012ef-329"><xref:System.Globalization.CultureInfo.NumberFormat%2A?displayProperty=nameWithType> 속성은 숫자 데이터의 서식 지정에 사용되는 문화권별 정보를 제공하는 <xref:System.Globalization.NumberFormatInfo> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-329">The <xref:System.Globalization.CultureInfo.NumberFormat%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information used in formatting numeric data.</span></span>

- <span data-ttu-id="012ef-330"><xref:System.Globalization.CultureInfo.TextInfo%2A?displayProperty=nameWithType> 속성은 문화권의 쓰기 시스템에 대한 정보를 제공하는 <xref:System.Globalization.TextInfo> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-330">The <xref:System.Globalization.CultureInfo.TextInfo%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.TextInfo> object that provides information about the culture's writing system.</span></span>

<span data-ttu-id="012ef-331">일반적으로 특정한 <xref:System.Globalization.CultureInfo> 속성의 값 및 그와 관련된 개체에 대한 가정을 하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-331">In general, do not make any assumptions about the values of specific <xref:System.Globalization.CultureInfo> properties and their related objects.</span></span> <span data-ttu-id="012ef-332">대신, 문화권별 데이터를 변경의 대상으로 봐야 합니다. 그 이유는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-332">Instead, you should view culture-specific data as subject to change, for these reasons:</span></span>

- <span data-ttu-id="012ef-333">개별적인 속성 값은 데이터가 수정되거나, 더 나은 데이터를 사용할 수 있게 되거나, 문화권별 규칙이 변경되면서, 시간이 지남에 따라 변경 및 개정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-333">Individual property values are subject to change and revision over time, as data is corrected, better data becomes available, or culture-specific conventions change.</span></span>

- <span data-ttu-id="012ef-334">개별적인 속성 값은 .NET 버전 또는 운영 체제 버전에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-334">Individual property values may vary across versions of .NET or operating system versions.</span></span>

- <span data-ttu-id="012ef-335">.NET은 대체 문화권을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-335">.NET supports replacement cultures.</span></span> <span data-ttu-id="012ef-336">이 때문에 기존의 표준 문화권을 보완하거나 완전히 대체하는 새로운 사용자 지정 문화권을 정의하는 것이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-336">This makes it possible to define a new custom culture that either supplements existing standard cultures or completely replaces an existing standard culture.</span></span>

- <span data-ttu-id="012ef-337">Windows 시스템에서 사용자는 제어판의 **국가 및 언어** 앱을 사용하여 문화권별 설정을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-337">On Windows systems, the user can customize culture-specific settings by using the **Region and Language** app in Control Panel.</span></span> <span data-ttu-id="012ef-338"><xref:System.Globalization.CultureInfo> 개체를 인스턴스화할 때, <xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29> 생성자를 호출하여 사용자 지정을 반영할지 여부를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-338">When you instantiate a <xref:System.Globalization.CultureInfo> object, you can determine whether it reflects these user customizations by calling the <xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29> constructor.</span></span> <span data-ttu-id="012ef-339">일반적으로 최종 사용자 앱에 대해서는 사용자가 예상하는 서식으로 사용자에게 데이터가 표시되도록 사용자 기본 설정을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="012ef-339">Typically, for end-user apps, you should respect user preferences so that the user is presented with data in a format that they expect.</span></span>

## <a name="see-also"></a><span data-ttu-id="012ef-340">참조</span><span class="sxs-lookup"><span data-stu-id="012ef-340">See also</span></span>

- [<span data-ttu-id="012ef-341">전역화 및 지역화</span><span class="sxs-lookup"><span data-stu-id="012ef-341">Globalization and Localization</span></span>](index.md)
- [<span data-ttu-id="012ef-342">문자열 사용에 대한 모범 사례</span><span class="sxs-lookup"><span data-stu-id="012ef-342">Best Practices for Using Strings</span></span>](../base-types/best-practices-strings.md)
