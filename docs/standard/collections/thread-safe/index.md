---
title: 스레드로부터 안전한 컬렉션
description: 스레드로부터 안전하고 확장성 있는 컬렉션 클래스를 포함하는 .NET의 System.Collections.Concurrent 네임스페이스를 사용해 스레드로부터 안전한 컬렉션을 시작합니다.
ms.date: 03/30/2017
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: f04dff1918bcb51cb48075336b69ff31f1850e68
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95725094"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="e01aa-103">스레드로부터 안전한 컬렉션</span><span class="sxs-lookup"><span data-stu-id="e01aa-103">Thread-Safe Collections</span></span>

<span data-ttu-id="e01aa-104">.NET Framework 4에서는 네임스페이스는 스레드로부터 안전하면서 확장 가능한 몇 가지 컬렉션 클래스를 포함하는 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 네임스페이스를 도입합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-104">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="e01aa-105">여러 스레드는 사용자 코드에서 추가로 동기화할 필요없이 이러한 컬렉션으로부터 안전하고 효율적으로 항목을 추가하거나 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-105">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="e01aa-106">새 코드를 작성하는 경우 여러 스레드가 컬렉션에 동시에 작성될 때마다 동시 컬렉션 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-106">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="e01aa-107">공유 컬렉션에서 읽기만 하는 경우에 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-107">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="e01aa-108">.NET Framework 1.1 또는 이전 런타임을 대상으로 해야 하는 경우가 아니면 1.0 컬렉션 클래스를 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-108">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="e01aa-109">.NET Framework 1.0 및 2.0 컬렉션에서 스레드 동기화</span><span class="sxs-lookup"><span data-stu-id="e01aa-109">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  

 <span data-ttu-id="e01aa-110">.NET Framework 1.0에 도입된 컬렉션은 <xref:System.Collections?displayProperty=nameWithType> 네임스페이스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-110">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="e01aa-111">일반적으로 사용되는 <xref:System.Collections.ArrayList> 및 <xref:System.Collections.Hashtable>을 포함하는 이러한 컬렉션은 컬렉션 주변에서 스레드로부터 안전한 래퍼를 반환하는 `Synchronized` 속성을 통해 어느 정도 스레드로부터의 안전성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-111">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="e01aa-112">래퍼는 모든 추가 또는 제거 작업에서 전체 컬렉션을 잠그는 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-112">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="e01aa-113">따라서 컬렉션에 액세스하려고 하는 각 스레드는 잠금을 사용하기 위해 차례를 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-113">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="e01aa-114">이것은 확장할 수 없고 큰 컬렉션에 상당한 성능 저하가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-114">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="e01aa-115">또한 디자인은 경합 조건에서 완전히 보호되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-115">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="e01aa-116">자세한 내용은 [제네릭 컬렉션에서의 동기화](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e01aa-116">For more information, see [Synchronization in Generic Collections](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="e01aa-117">.NET Framework 2.0에 도입된 컬렉션 클래스는 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-117">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="e01aa-118">여기에는 <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> 등이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-118">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="e01aa-119">이러한 클래스는 .NET Framework 1.0 클래스에 비해 형식 안정성 및 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-119">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="e01aa-120">그러나 .NET Framework 2.0 컬렉션 클래스는 스레드 동기화를 제공하지 않습니다. 여러 스레드에서 동시에 항목이 추가되거나 제거되는 경우 사용자 코드에서는 모든 동기화를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-120">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="e01aa-121">.NET Framework 4의 동시 컬렉션 클래스는 .NET Framework 2.0 컬렉션 클래스의 형식 안전성을 제공할 뿐만 아니라 .NET Framework 1.0 컬렉션이 제공하는 스레드로부터의 안전성보다 더 효율적이고 안전하기 때문에 권장됩니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-121">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="e01aa-122">세부적인 잠금 및 잠금 해제 메커니즘</span><span class="sxs-lookup"><span data-stu-id="e01aa-122">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  

 <span data-ttu-id="e01aa-123">동시 컬렉션 형식의 일부에서는 .NET Framework 4에 새로 도입된 <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> 및 <xref:System.Threading.CountdownEvent>와 같은 간단한 동기화 메커니즘을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-123">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="e01aa-124">실제로 이러한 동기화 형식이 스레드를 Wait 상태로 전환하기 전 짧은 기간 동안에는 일반적으로 *사용 중인 회전* 을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-124">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="e01aa-125">대기 시간이 매우 짧을 경우 회전은 비용이 많이 드는 커널 전환을 포함하는 대기보다 훨씬 계산 비용이 적습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-125">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="e01aa-126">회전을 사용하는 컬렉션 클래스의 경우 이 효율성 덕분에 여러 스레드가 매우 빠른 속도로 항목을 추가하고 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-126">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="e01aa-127">회전 및 차단에 대한 자세한 내용은 [SpinLock](../../threading/spinlock.md) 및 [SpinWait](../../threading/spinwait.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e01aa-127">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="e01aa-128"><xref:System.Collections.Concurrent.ConcurrentQueue%601> 및 <xref:System.Collections.Concurrent.ConcurrentStack%601> 클래스는 잠금을 전혀 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-128">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="e01aa-129">대신, 스레드로부터의 안전성을 달성하기 위해 <xref:System.Threading.Interlocked> 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-129">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e01aa-130">동시 컬렉션 클래스가 <xref:System.Collections.ICollection>을 지원하기 때문에 이러한 속성이 관련되지 않은 경우에도 <xref:System.Collections.ICollection.IsSynchronized%2A> 및 <xref:System.Collections.ICollection.SyncRoot%2A> 속성에 대한 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-130">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="e01aa-131">`IsSynchronized`는 항상 `false`를 반환하고 `SyncRoot`는 항상 `null`(Visual Basic의 `Nothing`)입니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-131">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="e01aa-132">다음 테이블에서는 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 네임스페이스의 컬렉션 형식을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-132">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="e01aa-133">형식</span><span class="sxs-lookup"><span data-stu-id="e01aa-133">Type</span></span>|<span data-ttu-id="e01aa-134">설명</span><span class="sxs-lookup"><span data-stu-id="e01aa-134">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="e01aa-135"><xref:System.Collections.Concurrent.IProducerConsumerCollection%601>을 구현하는 모든 형식에 대해 경계 및 차단 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-135">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="e01aa-136">자세한 내용은 [BlockingCollection 개요](blockingcollection-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e01aa-136">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="e01aa-137">키-값 쌍의 사전을 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-137">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="e01aa-138">FIFO(선입선출) 큐를 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-138">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="e01aa-139">LIFO(후입선출) 스택을 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-139">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="e01aa-140">요소의 순서 없는 컬렉션을 스레드로부터 안전하게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-140">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="e01aa-141">형식이 `BlockingCollection`에 사용하도록 구현해야 하는 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-141">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="e01aa-142">관련 항목</span><span class="sxs-lookup"><span data-stu-id="e01aa-142">Related Topics</span></span>  
  
|<span data-ttu-id="e01aa-143">제목</span><span class="sxs-lookup"><span data-stu-id="e01aa-143">Title</span></span>|<span data-ttu-id="e01aa-144">설명</span><span class="sxs-lookup"><span data-stu-id="e01aa-144">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="e01aa-145">BlockingCollection 개요</span><span class="sxs-lookup"><span data-stu-id="e01aa-145">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="e01aa-146"><xref:System.Collections.Concurrent.BlockingCollection%601> 형식에서 제공하는 기능에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-146">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="e01aa-147">방법: ConcurrentDictionary에서 항목 추가 및 제거</span><span class="sxs-lookup"><span data-stu-id="e01aa-147">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="e01aa-148"><xref:System.Collections.Concurrent.ConcurrentDictionary%602>에서 요소를 추가하고 제거하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-148">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="e01aa-149">방법: BlockingCollection에서 개별적으로 항목 추가 및 가져오기</span><span class="sxs-lookup"><span data-stu-id="e01aa-149">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="e01aa-150">읽기 전용 열거자를 사용하지 않고 차단 컬렉션에서 항목을 추가하고 검색하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-150">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="e01aa-151">방법: 컬렉션에 한계 지정 및 차단 기능 추가</span><span class="sxs-lookup"><span data-stu-id="e01aa-151">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="e01aa-152">컬렉션 클래스를 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 컬렉션에 대한 기본 스토리지 메커니즘으로 사용하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-152">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="e01aa-153">방법: ForEach를 사용하여 BlockingCollection의 항목 제거</span><span class="sxs-lookup"><span data-stu-id="e01aa-153">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="e01aa-154">`foreach`(Visual Basic의 `For Each`)를 사용하여 차단 컬렉션에서 모든 항목을 제거하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-154">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="e01aa-155">방법: 파이프라인에서 차단 컬렉션 배열 사용</span><span class="sxs-lookup"><span data-stu-id="e01aa-155">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="e01aa-156">파이프라인을 구현하는 동시에 여러 차단 컬렉션을 사용하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-156">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="e01aa-157">방법: ConcurrentBag을 사용하여 개체 풀 만들기</span><span class="sxs-lookup"><span data-stu-id="e01aa-157">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="e01aa-158">개체를 끊임없이 새로 만드는 대신 다시 사용할 수 있는 시나리오에서 동시 모음을 사용하고 성능을 향상시키는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e01aa-158">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="e01aa-159">참고</span><span class="sxs-lookup"><span data-stu-id="e01aa-159">Reference</span></span>  

 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
