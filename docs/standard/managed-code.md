---
title: 관리 코드란?
description: 관리 코드가 CLR(공용 언어 런타임) 런타임에서 해당 실행이 관리되는 코드임을 알아봅니다.
ms.date: 06/20/2016
ms.assetid: 20bb7ea8-192e-4a96-8ef3-e10e1950fd3d
ms.openlocfilehash: 3e2a6576f84890afd35d74b2f0f5fb352a90236a
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94825899"
---
# <a name="what-is-managed-code"></a><span data-ttu-id="2ef86-103">"관리 코드"란?</span><span class="sxs-lookup"><span data-stu-id="2ef86-103">What is "managed code"?</span></span>

<span data-ttu-id="2ef86-104">.NET으로 작업하는 경우 "관리 코드"라는 용어를 자주 발견하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-104">When working with .NET, you will often encounter the term "managed code".</span></span> <span data-ttu-id="2ef86-105">이 문서에서는 이 용어의 의미 및 관련된 추가 정보를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-105">This document will explain what this term means and additional information around it.</span></span>

<span data-ttu-id="2ef86-106">간단히 말해서, 관리 코드란 런타임에서 실행이 관리되는 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-106">To put it very simply, managed code is just that: code whose execution is managed by a runtime.</span></span> <span data-ttu-id="2ef86-107">이 경우 해당 런타임을 구현(예: [Mono](https://www.mono-project.com/), .NET Framework 또는 .NET Core/.NET 5+)에 관계없이 **공용 언어 런타임** 또는 CLR이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-107">In this case, the runtime in question is called the **Common Language Runtime** or CLR, regardless of the implementation (for example, [Mono](https://www.mono-project.com/), .NET Framework, or .NET Core/.NET 5+).</span></span> <span data-ttu-id="2ef86-108">CLR은 관리 코드를 가져와서 기계어 코드로 컴파일한 다음 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-108">CLR is in charge of taking the managed code, compiling it into machine code and then executing it.</span></span> <span data-ttu-id="2ef86-109">이 외에도 런타임에서는 자동 메모리 관리, 보안 경계, 형식 안전성 등 몇 가지 중요한 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-109">On top of that, runtime provides several important services such as automatic memory management, security boundaries, type safety etc.</span></span>

<span data-ttu-id="2ef86-110">“비관리 코드”라고도 하는 C/C++ 프로그램 실행 방법과 이를 대조해 보세요.</span><span class="sxs-lookup"><span data-stu-id="2ef86-110">Contrast this to the way you would run a C/C++ program, also called "unmanaged code".</span></span> <span data-ttu-id="2ef86-111">관리되지 않는 환경에서는 프로그래머가 거의 모든 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-111">In the unmanaged world, the programmer is in charge of pretty much everything.</span></span> <span data-ttu-id="2ef86-112">실제 프로그램은 기본적으로 OS(운영 체제)에서 메모리에 로드하고 시작하는 이진 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-112">The actual program is, essentially, a binary that the operating system (OS) loads into memory and starts.</span></span> <span data-ttu-id="2ef86-113">메모리 관리에서 보안 고려 사항에 이르기까지 다른 모든 작업은 프로그래머의 몫입니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-113">Everything else, from memory management to security considerations are a burden of the programmer.</span></span>

<span data-ttu-id="2ef86-114">관리 코드는 C#, Visual Basic, F# 등 .NET에서 실행할 수 있는 고급 언어 중 하나로 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-114">Managed code is written in one of the high-level languages that can be run on top of .NET, such as C#, Visual Basic, F# and others.</span></span> <span data-ttu-id="2ef86-115">이러한 언어로 작성된 코드를 해당 컴파일러로 컴파일할 때는 기계어 코드가 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-115">When you compile code written in those languages with their respective compiler, you don't get machine code.</span></span> <span data-ttu-id="2ef86-116">**중간 언어** 코드가 생성되며, 런타임에서 이 코드를 컴파일하고 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-116">You get **Intermediate Language** code which the runtime then compiles and executes.</span></span> <span data-ttu-id="2ef86-117">단, C++는 이 규칙의 유일한 예외이며 Windows에서 실행되는 관리되지 않는 네이티브 이진 파일을 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-117">C++ is the one exception to this rule, as it can also produce native, unmanaged binaries that run on Windows.</span></span>

## <a name="intermediate-language--execution"></a><span data-ttu-id="2ef86-118">중간 언어 및 실행</span><span class="sxs-lookup"><span data-stu-id="2ef86-118">Intermediate Language & execution</span></span>

<span data-ttu-id="2ef86-119">“중간 언어”(또는 줄여서 IL)란?</span><span class="sxs-lookup"><span data-stu-id="2ef86-119">What is "Intermediate Language" (or IL for short)?</span></span> <span data-ttu-id="2ef86-120">고급 .NET 언어로 작성된 코드를 컴파일하여 생성된 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-120">It is a product of compilation of code written in high-level .NET languages.</span></span> <span data-ttu-id="2ef86-121">이러한 언어 중 하나로 작성된 코드를 컴파일하면 IL로 작성된 이진 파일을 얻게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-121">Once you compile your code written in one of these languages, you will get a binary that is made out of IL.</span></span> <span data-ttu-id="2ef86-122">IL은 런타임에서 실행되는 모든 특정 언어에 독립적입니다. 필요한 경우 읽을 수 있는 별도의 사양도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-122">It is important to note that the IL is independent from any specific language that runs on top of the runtime; there is even a separate specification for it that you can read if you're so inclined.</span></span>

<span data-ttu-id="2ef86-123">고급 코드에서 IL을 생성한 후에는 대부분 실행하려고 할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-123">Once you produce IL from your high-level code, you will most likely want to run it.</span></span> <span data-ttu-id="2ef86-124">이때 CLR이 사용되며 IL 상태의 코드를 **Just-In-Time** 컴파일 또는 **JIT 처리** 하여 실제로 CPU에서 실행할 수 있는 기계어 코드로 변환하는 프로세스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-124">This is where the CLR takes over and starts the process of **Just-In-Time** compiling, or **JIT-ing** your code from IL to machine code that can actually be run on a CPU.</span></span> <span data-ttu-id="2ef86-125">이러한 방식에서는 CLR이 코드에서 수행하는 작업을 정확히 알고 효과적으로 _관리_ 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-125">In this way, the CLR knows exactly what your code is doing and can effectively _manage_ it.</span></span>

<span data-ttu-id="2ef86-126">중간 언어를 CIL(공용 중간 언어) 또는 MSIL(Microsoft 중간 언어)이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-126">Intermediate Language is sometimes also called Common Intermediate Language (CIL) or Microsoft Intermediate Language (MSIL).</span></span>

## <a name="unmanaged-code-interoperability"></a><span data-ttu-id="2ef86-127">비관리 코드와의 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="2ef86-127">Unmanaged code interoperability</span></span>

<span data-ttu-id="2ef86-128">물론, CLR에서 관리되는 환경과 관리되지 않는 환경 사이의 경계를 건널 수 있으며 [기본 클래스 라이브러리](framework-libraries.md)에도 이 작업을 수행하는 많은 코드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-128">Of course, the CLR allows passing the boundaries between managed and unmanaged world, and there is a lot of code that does that, even in the [Base Class Libraries](framework-libraries.md).</span></span> <span data-ttu-id="2ef86-129">이를 **상호 운용성** 또는 줄여서 **interop** 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-129">This is called **interoperability** or just **interop** for short.</span></span> <span data-ttu-id="2ef86-130">예를 들어 이러한 프로비전을 통해 관리되지 않는 라이브러리를 래핑하고 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-130">These provisions would allow you to, for example, wrap up an unmanaged library and call into it.</span></span> <span data-ttu-id="2ef86-131">그러나 이렇게 할 경우 코드가 런타임의 경계를 건널 때 실제 실행 관리가 다시 비관리 코드로 넘어가므로 동일한 제한이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-131">However, it is important to note that once you do this, when the code passes the boundaries of the runtime, the actual management of the execution is again in the hand of unmanaged code, and thus falls under the same restrictions.</span></span>

<span data-ttu-id="2ef86-132">이와 마찬가지로, C#은 CLR에서 실행이 관리되지 않는 코드 조각을 지정하는 **안전하지 않은 컨텍스트** 를 활용하여 코드에서 직접 포인터 등의 관리되지 않는 구문을 사용할 수 있도록 하는 언어 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="2ef86-132">Similar to this, C# is one language that allows you to use unmanaged constructs such as pointers directly in code by utilizing what is known as **unsafe context** which designates a piece of code for which the execution is not managed by the CLR.</span></span>

## <a name="more-resources"></a><span data-ttu-id="2ef86-133">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="2ef86-133">More resources</span></span>

* [<span data-ttu-id="2ef86-134">.NET Framework의 개요</span><span class="sxs-lookup"><span data-stu-id="2ef86-134">Overview of .NET Framework</span></span>](../framework/get-started/overview.md)
* [<span data-ttu-id="2ef86-135">안전하지 않은 코드 및 포인터</span><span class="sxs-lookup"><span data-stu-id="2ef86-135">Unsafe Code and Pointers</span></span>](../csharp/programming-guide/unsafe-code-pointers/index.md)
* [<span data-ttu-id="2ef86-136">기본 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="2ef86-136">Native interoperability</span></span>](./native-interop/index.md)
