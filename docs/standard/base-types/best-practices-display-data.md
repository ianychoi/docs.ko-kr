---
title: .NET에서 형식이 지정된 데이터 표시 및 유지 모범 사례
description: .NET 애플리케이션에서 숫자 및 날짜 데이터를 효율적으로 표시하고 유지하는 방법을 알아봅니다.
ms.date: 05/01/2019
dev_langs:
- csharp
- vb
ms.openlocfilehash: 1748363089a80538a19e91b1955fe9257de39a4e
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94825145"
---
# <a name="best-practices-for-displaying-and-persisting-formatted-data"></a><span data-ttu-id="3cd3e-103">형식이 지정된 데이터 표시 및 유지 모범 사례</span><span class="sxs-lookup"><span data-stu-id="3cd3e-103">Best practices for displaying and persisting formatted data</span></span>

<span data-ttu-id="3cd3e-104">이 문서에서는 숫자 데이터 및 날짜/시간 데이터와 같은 형식이 지정된 데이터를 표시 및 스토리지를 위해 처리하는 방법을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-104">This article examines how formatted data, such as numeric data and date-and-time data, is handled for display and for storage.</span></span>

<span data-ttu-id="3cd3e-105">.NET을 사용하여 개발할 때는 문화권이 구분되는 형식 지정을 사용하여 사용자 인터페이스에서 숫자 및 날짜와 같이 문자열이 아닌 데이터를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-105">When you develop with .NET, use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</span></span> <span data-ttu-id="3cd3e-106">[고정 문화권](xref:System.Globalization.CultureInfo.InvariantCulture)과 함께 형식 지정을 사용하여 문자열 양식에서 문자열이 아닌 데이터를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-106">Use formatting with the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) to persist non-string data in string form.</span></span> <span data-ttu-id="3cd3e-107">문자열 양식에서 숫자 또는 날짜 및 시간 데이터를 유지하는 데 문화권이 구분되는 형식 지정을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-107">Do not use culture-sensitive formatting to persist numeric or date-and-time data in string form.</span></span>

## <a name="displaying-formatted-data"></a><span data-ttu-id="3cd3e-108">형식이 지정된 데이터 표시</span><span class="sxs-lookup"><span data-stu-id="3cd3e-108">Displaying formatted data</span></span>

<span data-ttu-id="3cd3e-109">숫자와 날짜 및 시간과 같은 문자열이 아닌 데이터를 사용자에게 표시할 때 사용자의 문화권 설정을 사용하여 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-109">When you display non-string data such as numbers and dates and times to users, format them by using the user's cultural settings.</span></span> <span data-ttu-id="3cd3e-110">기본적으로 다음 항목은 모두 서식 지정 작업에서 현재 스레드 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-110">By default, the following all use the current thread culture in formatting operations:</span></span>

- <span data-ttu-id="3cd3e-111">[C#](../../csharp/language-reference/tokens/interpolated.md) 및 [Visual Basic](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md) 컴파일러에서 지원하는 보간된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-111">Interpolated strings supported by the [C#](../../csharp/language-reference/tokens/interpolated.md) and [Visual Basic](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md) compilers.</span></span>
- <span data-ttu-id="3cd3e-112">[C#](../../csharp/language-reference/operators/addition-operator.md#string-concatenation) 또는 [Visual Basic](../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md) 연결 연산자를 사용하거나 직접 <xref:System.String.Concat%2A?displayProperty=nameWithType> 메서드를 호출하는 문자열 연결 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-112">String concatenation operations that use the [C#](../../csharp/language-reference/operators/addition-operator.md#string-concatenation) or [Visual Basic](../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md) concatenation operators or that call the <xref:System.String.Concat%2A?displayProperty=nameWithType> method directly.</span></span>
- <span data-ttu-id="3cd3e-113"><xref:System.String.Format%2A?displayProperty=nameWithType> 메서드</span><span class="sxs-lookup"><span data-stu-id="3cd3e-113">The <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>
- <span data-ttu-id="3cd3e-114">숫자 형식과 날짜 및 시간 형식의 `ToString` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-114">The `ToString` methods of the numeric types and the date and time types.</span></span>

<span data-ttu-id="3cd3e-115">지정된 문화권의 규칙 또는 [고정 문화권](xref:System.Globalization.CultureInfo.InvariantCulture)을 사용하여 문자열의 서식을 지정해야 함을 명시적으로 지정하려면 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-115">To explicitly specify that a string should be formatted by using the conventions of a designated culture or the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture), you can do the following:</span></span>

- <span data-ttu-id="3cd3e-116"><xref:System.String.Format%2A?displayProperty=nameWithType> 및 `ToString` 메서드를 사용하는 경우 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 또는 <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>과 같이 `provider` 매개 변수가 있는 오버로드를 호출하고 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성, 원하는 문화권을 나타내는 <xref:System.Globalization.CultureInfo> 인스턴스 또는 <xref:System.Globalization.CultureInfo.InvariantCulture?displayProperty=nameWithType> 속성을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-116">When using the <xref:System.String.Format%2A?displayProperty=nameWithType> and `ToString` methods, call an overload that has a `provider` parameter, such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> or <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, and pass it the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property, a <xref:System.Globalization.CultureInfo> instance that represents the desired culture, or the <xref:System.Globalization.CultureInfo.InvariantCulture?displayProperty=nameWithType> property.</span></span>

- <span data-ttu-id="3cd3e-117">문자열 연결의 경우 컴파일러에서 암시적 변환을 수행하지 못하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-117">For string concatenation, do not allow the compiler to perform any implicit conversions.</span></span> <span data-ttu-id="3cd3e-118">대신 `provider` 매개 변수가 있는 `ToString` 오버로드를 호출하여 명시적 변환을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-118">Instead, perform an explicit conversion by calling a `ToString` overload that has a `provider` parameter.</span></span> <span data-ttu-id="3cd3e-119">예를 들어 컴파일러는 다음 코드에서 <xref:System.Double> 값을 문자열로 변환할 때 암시적으로 현재 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-119">For example, the compiler implicitly uses the current culture when converting a <xref:System.Double> value to a string in the following code:</span></span>

  [!code-csharp[Implicit String Conversion](./snippets/best-practices-strings/csharp/tostring/Program.cs#1)]
  [!code-vb[Implicit String Conversion](./snippets/best-practices-strings/vb/tostring/Program.vb#1)]

  <span data-ttu-id="3cd3e-120">대신, 다음 코드와 같이 <xref:System.Double.ToString(System.IFormatProvider)?displayProperty=nameWithType> 메서드를 호출하여 변환에 사용되는 서식 지정 규칙을 사용하는 문화권을 명시적으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-120">Instead, you can explicitly specify the culture whose formatting conventions are used in the conversion by calling the <xref:System.Double.ToString(System.IFormatProvider)?displayProperty=nameWithType> method, as the following code does:</span></span>

  [!code-csharp[Explicit String Conversion](./snippets/best-practices-strings/csharp/tostring/Program.cs#2)]
  [!code-vb[Implicit String Conversion](./snippets/best-practices-strings/vb/tostring/Program.vb#2)]

- <span data-ttu-id="3cd3e-121">문자열 보간의 경우, 보간된 문자열을 <xref:System.String> 인스턴스에 할당하는 대신 <xref:System.FormattableString>에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-121">For string interpolation, rather than assigning an interpolated string to a <xref:System.String> instance, assign it to a <xref:System.FormattableString>.</span></span> <span data-ttu-id="3cd3e-122">그런 다음, 해당 <xref:System.FormattableString.ToString?displayProperty=nameWithType> 메서드를 호출하여 현재 문화권의 규칙을 반영하는 결과 문자열을 생성하거나 <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> 메서드를 호출하여 지정된 문화권의 규칙을 반영하는 결과 문자열을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-122">You can then call its <xref:System.FormattableString.ToString?displayProperty=nameWithType> method produce a result string that reflects the conventions of the current culture, or you can call the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to produce a result string that reflects the conventions of a specified culture.</span></span> <span data-ttu-id="3cd3e-123">서식 지정 가능 문자열을 정적 <xref:System.FormattableString.Invariant%2A?displayProperty=nameWithType> 메서드에 전달하여 고정 문화권의 규칙을 반영하는 결과 문자열을 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-123">You can also pass the formattable string to the static <xref:System.FormattableString.Invariant%2A?displayProperty=nameWithType> method to produce a result string that reflects the conventions of the invariant culture.</span></span> <span data-ttu-id="3cd3e-124">다음 예제에서 이 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-124">The following example illustrates this approach.</span></span> <span data-ttu-id="3cd3e-125">(이 예제의 출력에는 en-US의 현재 문화권이 반영됩니다.)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-125">(The output from the example reflects a current culture of en-US.)</span></span>

  [!code-csharp[String interpolation](./snippets/best-practices-strings/csharp/formattable/Program.cs)]
  [!code-vb[String interpolation](./snippets/best-practices-strings/vb/formattable/Program.vb)]

## <a name="persisting-formatted-data"></a><span data-ttu-id="3cd3e-126">형식이 지정된 데이터 유지</span><span class="sxs-lookup"><span data-stu-id="3cd3e-126">Persisting formatted data</span></span>

<span data-ttu-id="3cd3e-127">문자열이 아닌 데이터를 이진 데이터 또는 형식이 지정된 데이터로 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-127">You can persist non-string data either as binary data or as formatted data.</span></span> <span data-ttu-id="3cd3e-128">서식이 지정된 데이터로 저장하는 경우 `provider` 매개 변수를 포함하는 서식 지정 메서드 오버로드를 호출하고 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성에 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-128">If you choose to save it as formatted data, you should call a formatting method overload that includes a `provider` parameter and pass it the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3cd3e-129">고정 문화권은 문화권 및 컴퓨터와 관계없는 형식이 지정된 데이터에 대해 일관된 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-129">The invariant culture provides a consistent format for formatted data that is independent of culture and machine.</span></span> <span data-ttu-id="3cd3e-130">반대로 고정 문화권이 아닌 문화권을 사용하여 형식이 지정된 영구 데이터에는 많은 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-130">In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations:</span></span>

- <span data-ttu-id="3cd3e-131">다른 문화권이 포함된 시스템에서 데이터를 검색하거나 현재 시스템의 사용자가 현재 문화권을 변경하고 데이터를 검색하려고 하면 데이터를 사용하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-131">The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data.</span></span>
- <span data-ttu-id="3cd3e-132">특정 컴퓨터의 문화권 속성은 표준 값과 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-132">The properties of a culture on a specific computer can differ from standard values.</span></span> <span data-ttu-id="3cd3e-133">언제든지 사용자가 문화권 구분 표시 설정을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-133">At any time, a user can customize culture-sensitive display settings.</span></span> <span data-ttu-id="3cd3e-134">이로 인해 사용자가 문화권 설정을 사용자 지정한 후에는 시스템에 저장된 형식이 지정된 데이터를 읽지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-134">Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings.</span></span> <span data-ttu-id="3cd3e-135">컴퓨터 간에 형식이 지정된 데이터의 이식성은 훨씬 더 제한적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-135">The portability of formatted data across computers is likely to be even more limited.</span></span>
- <span data-ttu-id="3cd3e-136">숫자 또는 날짜/시간의 형식 지정을 관리하는 국제, 지역 또는 국가 표준은 시간에 지나면서 변경되고 이들 변경은 Windows 운영 체제 업데이트에 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-136">International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into Windows operating system updates.</span></span> <span data-ttu-id="3cd3e-137">형식 지정 규칙이 변경될 때 이전 규칙을 사용하여 형식이 지정된 데이터를 읽지 못하게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-137">When formatting conventions change, data that was formatted by using the previous conventions may become unreadable.</span></span>

<span data-ttu-id="3cd3e-138">다음 예제에서는 문화권 구분 형식 지정을 사용하여 데이터를 유지함으로 인해 제한된 이식성을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-138">The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data.</span></span> <span data-ttu-id="3cd3e-139">예제에서는 날짜 및 시간 값 배열을 파일에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-139">The example saves an array of date and time values to a file.</span></span> <span data-ttu-id="3cd3e-140">이들 값은 영어(미국) 문화권의 규칙을 사용하여 형식이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-140">These are formatted by using the conventions of the English (United States) culture.</span></span> <span data-ttu-id="3cd3e-141">애플리케이션이 현재 스레드 문화권을 프랑스어(스위스)로 변경하고 나면 현재 문화권의 형식 지정 규칙을 사용하여 저장된 값을 읽으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-141">After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture.</span></span> <span data-ttu-id="3cd3e-142">두 데이터 항목을 읽으려는 시도로 인해 <xref:System.FormatException> 예외가 throw되고 날짜 배열에는 <xref:System.DateTime.MinValue>와 같은 잘못된 두 가지 요소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-142">The attempt to read two of the data items throws a <xref:System.FormatException> exception, and the array of dates now contains two incorrect elements that are equal to <xref:System.DateTime.MinValue>.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#21](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/persistence.cs#21)]
[!code-vb[Conceptual.Strings.BestPractices#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/persistence.vb#21)]

<span data-ttu-id="3cd3e-143">그러나 <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 및 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>에 대한 호출에서 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성을 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>로 바꾸면 다음 출력과 같이 영구 날짜 및 시간 데이터가 성공적으로 복원됩니다.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-143">However, if you replace the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property with <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> in the calls to <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> and <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, the persisted date and time data is successfully restored, as the following output shows:</span></span>

```console
06.05.1758 21:26
05.05.1818 07:19
22.04.1870 23:54
08.09.1890 06:47
18.02.1905 15:12
```
