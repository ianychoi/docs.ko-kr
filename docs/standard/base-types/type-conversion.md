---
title: .NET에서 형식 변환
description: 이전 형식의 값에 해당하는 새로운 형식의 값을 만들지만 원본의 ID는 유지할 수 없는 .NET의 형식 변환에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- widening conversions
- explicit conversions
- narrowing conversions
- type conversion, about type conversion
- type conversion
- converting types
- narrowing coercion
- Explicit operator
- IConvertible interface
- base types, converting
- op_Implicit method
- widening coercion
- op_Explicit method
- Convert class
- implicit conversions
- Implicit operator
- data types [.NET], converting
ms.assetid: ba36154f-064c-47d3-9f05-72f93a7ca96d
ms.openlocfilehash: 8e1ea153ccd65de967a34e79d4a26c96e678c4ad
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94831028"
---
# <a name="type-conversion-in-net"></a><span data-ttu-id="26ddf-103">.NET에서 형식 변환</span><span class="sxs-lookup"><span data-stu-id="26ddf-103">Type conversion in .NET</span></span>

<span data-ttu-id="26ddf-104">모든 값에는 연결된 형식이 있으며, 이러한 형식은 값에 할당되는 공간, 포함할 수 있는 값의 범위, 값을 통해 사용할 수 있는 멤버 등의 특성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-104">Every value has an associated type, which defines attributes such as the amount of space allocated to the value, the range of possible values it can have, and the members that it makes available.</span></span> <span data-ttu-id="26ddf-105">대부분의 값들은 하나 이상의 형식으로 표현될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-105">Many values can be expressed as more than one type.</span></span> <span data-ttu-id="26ddf-106">예를 들어, 4라는 값은 정수 값 또는 부동 소수점 값으로 표현될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-106">For example, the value 4 can be expressed as an integer or a floating-point value.</span></span> <span data-ttu-id="26ddf-107">형식 변환을 수행하면 이전 형식과 동일한 값을 가지는 새 형식이 만들어지지만, 원래 개체의 ID(또는 실제 값)가 항상 동일하게 유지되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-107">Type conversion creates a value in a new type that is equivalent to the value of an old type, but does not necessarily preserve the identity (or exact value) of the original object.</span></span>  
  
<span data-ttu-id="26ddf-108">.NET는 다음과 같은 변환을 자동으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-108">.NET automatically supports the following conversions:</span></span>  
  
- <span data-ttu-id="26ddf-109">파생 클래스에서 기본 클래스로 변환.</span><span class="sxs-lookup"><span data-stu-id="26ddf-109">Conversion from a derived class to a base class.</span></span> <span data-ttu-id="26ddf-110">예를 들어, 클래스 또는 구조체 인스턴스가 <xref:System.Object> 인스턴스로 변환될 수 있다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-110">This means, for example, that an instance of any class or structure can be converted to an <xref:System.Object> instance.</span></span>  <span data-ttu-id="26ddf-111">이러한 변환에는 캐스팅 또는 변환 연산자가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-111">This conversion does not require a casting or conversion operator.</span></span>  
  
- <span data-ttu-id="26ddf-112">기본 클래스에서 원본 파생 클래스로 다시 변환.</span><span class="sxs-lookup"><span data-stu-id="26ddf-112">Conversion from a base class back to the original derived class.</span></span> <span data-ttu-id="26ddf-113">C#에서는 이러한 변환에 캐스팅 연산자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-113">In C#, this conversion requires a casting operator.</span></span> <span data-ttu-id="26ddf-114">Visual Basic에서는 `Option Strict`가 on이면 `CType` 연산자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-114">In Visual Basic, it requires the `CType` operator if `Option Strict` is on.</span></span>  
  
- <span data-ttu-id="26ddf-115">인터페이스를 구현하는 형식에서 그 인터페이스를 나타내는 인터페이스 개체로 변환.</span><span class="sxs-lookup"><span data-stu-id="26ddf-115">Conversion from a type that implements an interface to an interface object that represents that interface.</span></span> <span data-ttu-id="26ddf-116">이러한 변환에는 캐스팅 또는 변환 연산자가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-116">This conversion does not require a casting or conversion operator.</span></span>  
  
- <span data-ttu-id="26ddf-117">인터페이스 개체에서 그 인터페이스를 구현하는 원래 형식으로 다시 변환.</span><span class="sxs-lookup"><span data-stu-id="26ddf-117">Conversion from an interface object back to the original type that implements that interface.</span></span>  <span data-ttu-id="26ddf-118">C#에서는 이러한 변환에 캐스팅 연산자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-118">In C#, this conversion requires a casting operator.</span></span> <span data-ttu-id="26ddf-119">Visual Basic에서는 `Option Strict`가 on이면 `CType` 연산자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-119">In Visual Basic, it requires the `CType` operator if `Option Strict` is on.</span></span>  
  
<span data-ttu-id="26ddf-120">이러한 자동 변환 외에 .NET는 사용자 지정 형식 변환을 지원하는 몇 가지 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-120">In addition to these automatic conversions, .NET provides several features that support custom type conversion.</span></span> <span data-ttu-id="26ddf-121">이러한 요구 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-121">These include the following:</span></span>  
  
- <span data-ttu-id="26ddf-122">사용 가능한 형식 간 확대 변환을 정의하는 `Implicit` 연산자.</span><span class="sxs-lookup"><span data-stu-id="26ddf-122">The `Implicit` operator, which defines the available widening conversions between types.</span></span> <span data-ttu-id="26ddf-123">자세한 내용은 [암시적 연산자를 사용한 암시적 변환](#implicit-conversion-with-the-implicit-operator) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-123">For more information, see the [Implicit Conversion with the Implicit Operator](#implicit-conversion-with-the-implicit-operator) section.</span></span>  
  
- <span data-ttu-id="26ddf-124">사용 가능한 형식 간 축소 변환을 정의하는 `Explicit` 연산자.</span><span class="sxs-lookup"><span data-stu-id="26ddf-124">The `Explicit` operator, which defines the available narrowing conversions between types.</span></span> <span data-ttu-id="26ddf-125">자세한 내용은 [명시적 연산자를 사용한 명시적 변환](#explicit-conversion-with-the-explicit-operator) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-125">For more information, see the [Explicit Conversion with the Explicit Operator](#explicit-conversion-with-the-explicit-operator) section.</span></span>  
  
- <span data-ttu-id="26ddf-126">기본 .NET 데이터 형식 각각에 대한 변환을 정의하는 <xref:System.IConvertible> 인터페이스.</span><span class="sxs-lookup"><span data-stu-id="26ddf-126">The <xref:System.IConvertible> interface, which defines conversions to each of the base .NET data types.</span></span> <span data-ttu-id="26ddf-127">자세한 내용은 [IConvertible 인터페이스](#the-iconvertible-interface) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-127">For more information, see [The IConvertible Interface](#the-iconvertible-interface) section.</span></span>  
  
- <span data-ttu-id="26ddf-128"><xref:System.Convert> 인터페이스의 메서드를 구현하는 메서드 집합을 제공하는 <xref:System.IConvertible> 클래스.</span><span class="sxs-lookup"><span data-stu-id="26ddf-128">The <xref:System.Convert> class, which provides a set of methods that implement the methods in the <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="26ddf-129">자세한 내용은 [Convert 클래스](#the-convert-class) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-129">For more information, see [The Convert Class](#the-convert-class) section.</span></span>  
  
- <span data-ttu-id="26ddf-130">지정된 형식을 임의의 형식으로 변환하는 작업을 지원하도록 확장될 수 있는 기본 클래스인 <xref:System.ComponentModel.TypeConverter> 클래스.</span><span class="sxs-lookup"><span data-stu-id="26ddf-130">The <xref:System.ComponentModel.TypeConverter> class, which is a base class that can be extended to support the conversion of a specified type to any other type.</span></span> <span data-ttu-id="26ddf-131">자세한 내용은 [TypeConverter 클래스](#the-typeconverter-class) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-131">For more information, see [The TypeConverter Class](#the-typeconverter-class) section.</span></span>  

## <a name="implicit-conversion-with-the-implicit-operator"></a><span data-ttu-id="26ddf-132">암시적 연산자를 사용한 암시적 변환</span><span class="sxs-lookup"><span data-stu-id="26ddf-132">Implicit conversion with the implicit operator</span></span>

<span data-ttu-id="26ddf-133">확대 변환에는 대상 형식보다 제한적인 범위나 제한적인 멤버 목록이 있는 기존 형식의 값에서 새 값을 만드는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-133">Widening conversions involve the creation of a new value from the value of an existing type that has either a more restrictive range or a more restricted member list than the target type.</span></span> <span data-ttu-id="26ddf-134">확대 변환을 수행하면 정밀도 손실은 발생할 수 있어도 데이터 손실은 발생할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-134">Widening conversions cannot result in data loss (although they may result in a loss of precision).</span></span> <span data-ttu-id="26ddf-135">데이터 손실이 발생할 수 없기 때문에 컴파일러에서 명시적 변환 메서드나 캐스팅 연산자를 사용할 필요 없이 변환을 암시적이나 투명하게 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-135">Because data cannot be lost, compilers can handle the conversion implicitly or transparently, without requiring the use of an explicit conversion method or a casting operator.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="26ddf-136">암시적 변환을 수행하는 코드에서 변환 메서드를 호출하거나 캐스팅 연산자를 사용할 수 있지만 암시적 변환을 지원하는 컴파일러에서는 이렇게 할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-136">Although code that performs an implicit conversion can call a conversion method or use a casting operator, their use is not required by compilers that support implicit conversions.</span></span>  
  
 <span data-ttu-id="26ddf-137">예를 들어, <xref:System.Decimal> 형식은 <xref:System.Byte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32> 및 <xref:System.UInt64> 값에서의 암시적 변환을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-137">For example, the <xref:System.Decimal> type supports implicit conversions from <xref:System.Byte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64> values.</span></span> <span data-ttu-id="26ddf-138">다음 예제에서는 값을 <xref:System.Decimal> 변수에 할당할 때의 이러한 암시적 변환을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-138">The following example illustrates some of these implicit conversions in assigning values to a <xref:System.Decimal> variable.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/implicit1.cs#1)]
 [!code-vb[Conceptual.Conversion#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/implicit1.vb#1)]  
  
 <span data-ttu-id="26ddf-139">특정 언어 컴파일러에서 오버로드된 사용자 지정 연산자를 지원하는 경우 고유한 사용자 지정 형식에서 암시적 변환을 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-139">If a particular language compiler supports custom operators, you can also define implicit conversions in your own custom types.</span></span> <span data-ttu-id="26ddf-140">다음 예제에서는 부호 및 크기 표현을 사용하는 `ByteWithSign`이라는 부호 있는 바이트 데이터 형식을 부분적으로 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-140">The following example provides a partial implementation of a signed byte data type named `ByteWithSign` that uses sign-and-magnitude representation.</span></span> <span data-ttu-id="26ddf-141">이 예제에서는 <xref:System.Byte> 및 <xref:System.SByte> 값을 `ByteWithSign` 값으로 암시적으로 변환하는 작업을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-141">It supports implicit conversion of <xref:System.Byte> and <xref:System.SByte> values to `ByteWithSign` values.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/implicit1.cs#2)]
 [!code-vb[Conceptual.Conversion#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/implicit1.vb#2)]  
  
 <span data-ttu-id="26ddf-142">클라이언트 코드에서는 다음 예제와 같이 명시적 변환을 수행하거나 캐스팅 연산자를 사용하지 않고 `ByteWithSign` 변수를 선언하여 <xref:System.Byte> 및 <xref:System.SByte> 값에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-142">Client code can then declare a `ByteWithSign` variable and assign it <xref:System.Byte> and <xref:System.SByte> values without performing any explicit conversions or using any casting operators, as the following example shows.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/implicit1.cs#3)]
 [!code-vb[Conceptual.Conversion#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/implicit1.vb#3)]  

## <a name="explicit-conversion-with-the-explicit-operator"></a><span data-ttu-id="26ddf-143">명시적 연산자를 사용한 명시적 변환</span><span class="sxs-lookup"><span data-stu-id="26ddf-143">Explicit conversion with the explicit operator</span></span>

<span data-ttu-id="26ddf-144">축소 변환에는 대상 형식보다 큰 범위나 큰 멤버 목록이 있는 기존 형식의 값에서 새 값을 만드는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-144">Narrowing conversions involve the creation of a new value from the value of an existing type that has either a greater range or a larger member list than the target type.</span></span> <span data-ttu-id="26ddf-145">축소 변환을 수행하면 데이터 손실이 발생할 수 있기 때문에 컴파일러에서 변환 메서드 호출이나 캐스팅 연산자를 통해 명시적으로 변환을 수행하도록 요구하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-145">Because a narrowing conversion can result in a loss of data, compilers often require that the conversion be made explicit through a call to a conversion method or a casting operator.</span></span> <span data-ttu-id="26ddf-146">즉, 개발자 코드에서 변환이 명시적으로 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-146">That is, the conversion must be handled explicitly in developer code.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="26ddf-147">축소 변환에 변환 메서드나 캐스팅 연산자를 요구하는 주요 목적은 개발자가 데이터 손실이나 <xref:System.OverflowException>의 가능성을 인식하여 코드에서 처리할 수 있게 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-147">The major purpose of requiring a conversion method or casting operator for narrowing conversions is to make the developer aware of the possibility of data loss or an <xref:System.OverflowException> so that it can be handled in code.</span></span> <span data-ttu-id="26ddf-148">그러나 일부 컴파일러에서는 이 요구 사항을 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-148">However, some compilers can relax this requirement.</span></span> <span data-ttu-id="26ddf-149">예를 들어, Visual Basic에서 `Option Strict`가 해제(기본 설정)되면 Visual Basic 컴파일러에서 축소 변환을 암시적으로 수행하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-149">For example, in Visual Basic, if `Option Strict` is off (its default setting), the Visual Basic compiler tries to perform narrowing conversions implicitly.</span></span>  
  
 <span data-ttu-id="26ddf-150">예를 들어, 다음 표와 같이 <xref:System.UInt32>, <xref:System.Int64> 및 <xref:System.UInt64> 데이터 형식은 <xref:System.Int32> 데이터 형식을 초과하는 범위를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-150">For example, the <xref:System.UInt32>, <xref:System.Int64>, and <xref:System.UInt64> data types have ranges that exceed that the <xref:System.Int32> data type, as the following table shows.</span></span>  
  
|<span data-ttu-id="26ddf-151">형식</span><span class="sxs-lookup"><span data-stu-id="26ddf-151">Type</span></span>|<span data-ttu-id="26ddf-152">Int32 범위와 비교</span><span class="sxs-lookup"><span data-stu-id="26ddf-152">Comparison with range of Int32</span></span>|  
|----------|------------------------------------|  
|<xref:System.Int64>|<span data-ttu-id="26ddf-153"><xref:System.Int64.MaxValue?displayProperty=nameWithType>가 <xref:System.Int32.MaxValue?displayProperty=nameWithType>보다 크고 <xref:System.Int64.MinValue?displayProperty=nameWithType>가 <xref:System.Int32.MinValue?displayProperty=nameWithType>보다 작은 경우(보다 큰 음의 범위를 포함하는 경우)</span><span class="sxs-lookup"><span data-stu-id="26ddf-153"><xref:System.Int64.MaxValue?displayProperty=nameWithType> is greater than <xref:System.Int32.MaxValue?displayProperty=nameWithType>, and <xref:System.Int64.MinValue?displayProperty=nameWithType> is less than (has a greater negative range than) <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span>|  
|<xref:System.UInt32>|<span data-ttu-id="26ddf-154"><xref:System.UInt32.MaxValue?displayProperty=nameWithType>가 <xref:System.Int32.MaxValue?displayProperty=nameWithType>보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="26ddf-154"><xref:System.UInt32.MaxValue?displayProperty=nameWithType> is greater than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>|  
|<xref:System.UInt64>|<span data-ttu-id="26ddf-155"><xref:System.UInt64.MaxValue?displayProperty=nameWithType>가 <xref:System.Int32.MaxValue?displayProperty=nameWithType>보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="26ddf-155"><xref:System.UInt64.MaxValue?displayProperty=nameWithType> is greater than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="26ddf-156">이러한 축소 변환을 처리하기 위해 .NET에서는 형식에서 `Explicit` 연산자를 정의할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-156">To handle such narrowing conversions, .NET allows types to define an `Explicit` operator.</span></span> <span data-ttu-id="26ddf-157">그러면 개별 언어 컴파일러에서 고유 구문을 사용하여 이 연산자를 구현할 수 있거나 변환을 수행하기 위해 <xref:System.Convert> 클래스의 멤버가 호출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-157">Individual language compilers can then implement this operator using their own syntax, or a member of the <xref:System.Convert> class can be called to perform the conversion.</span></span> <span data-ttu-id="26ddf-158">(<xref:System.Convert> 클래스에 대한 자세한 내용은 이 항목의 뒷부분에서 [Convert 클래스](#the-convert-class)를 참조하세요.) 다음 예제에서는 언어 기능을 사용하여 범위를 벗어날 수 있는 이러한 정수 값을 <xref:System.Int32> 값으로 명시적으로 변환하는 작업을 처리하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-158">(For more information about the <xref:System.Convert> class, see [The Convert Class](#the-convert-class) later in this topic.) The following example illustrates the use of language features to handle the explicit conversion of these potentially out-of-range integer values to <xref:System.Int32> values.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/explicit1.cs#4)]
 [!code-vb[Conceptual.Conversion#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/explicit1.vb#4)]  
  
 <span data-ttu-id="26ddf-159">명시적 변환의 결과는 언어마다 다를 수 있으며 해당 <xref:System.Convert> 메서드에서 반환하는 값에 따라서도 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-159">Explicit conversions can produce different results in different languages, and these results can differ from the value returned by the corresponding <xref:System.Convert> method.</span></span> <span data-ttu-id="26ddf-160">예를 들어 <xref:System.Double> 값 12.63251이 <xref:System.Int32>로 변환되면 Visual Basic `CInt` 메서드와 .NET <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> 메서드는 <xref:System.Double>을 반올림하여 값 13을 반환하지만 C# `(int)` 연산자는 <xref:System.Double>을 잘라 값 12를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-160">For example, if the <xref:System.Double> value 12.63251 is converted to an <xref:System.Int32>, both the Visual Basic `CInt` method and the .NET <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> method round the <xref:System.Double> to return a value of 13, but the C# `(int)` operator truncates the <xref:System.Double> to return a value of 12.</span></span> <span data-ttu-id="26ddf-161">마찬가지로 C# `(int)` 연산자는 부울을 정수로 변환하는 것을 지원하지만 Visual Basic `CInt` 메서드는 값 `true`를 -1로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-161">Similarly, the C# `(int)` operator does not support Boolean-to-integer conversion, but the Visual Basic `CInt` method converts a value of `true` to -1.</span></span> <span data-ttu-id="26ddf-162">반면에 <xref:System.Convert.ToInt32%28System.Boolean%29?displayProperty=nameWithType> 메서드는 값 `true`를 1로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-162">On the other hand, the <xref:System.Convert.ToInt32%28System.Boolean%29?displayProperty=nameWithType> method converts a value of `true` to 1.</span></span>  
  
 <span data-ttu-id="26ddf-163">대부분의 컴파일러에서는 검사 변환 방식이나 비검사 변환 방식으로 명시적 변환을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-163">Most compilers allow explicit conversions to be performed in a checked or unchecked manner.</span></span> <span data-ttu-id="26ddf-164">검사 변환을 수행하는 경우 변환할 형식의 값이 대상 형식의 범위를 벗어나면 <xref:System.OverflowException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-164">When a checked conversion is performed, an <xref:System.OverflowException> is thrown when the value of the type to be converted is outside the range of the target type.</span></span> <span data-ttu-id="26ddf-165">같은 조건에서 비검사 변환을 수행하면 예외가 throw되지는 않지만 정확한 동작이 정의되지 않으며 잘못된 결과 값이 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-165">When an unchecked conversion is performed under the same conditions, the conversion might not throw an exception, but the exact behavior becomes undefined and an incorrect value might result.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="26ddf-166">C#에서 검사 변환을 수행하려면 캐스팅 연산자와 함께 `checked` 키워드를 사용하거나 `/checked+` 컴파일러 옵션을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-166">In C#, checked conversions can be performed by using the `checked` keyword together with a casting operator, or by specifying the `/checked+` compiler option.</span></span> <span data-ttu-id="26ddf-167">반대로 비검사 변환을 수행하려면 캐스팅 연산자와 함께 `unchecked` 키워드를 사용하거나 `/checked-` 컴파일러 옵션을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-167">Conversely, unchecked conversions can be performed by using the `unchecked` keyword together with the casting operator, or by specifying the `/checked-` compiler option.</span></span> <span data-ttu-id="26ddf-168">기본적으로 명시적 변환은 검사되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-168">By default, explicit conversions are unchecked.</span></span> <span data-ttu-id="26ddf-169">Visual Basic에서 검사 변환을 수행하려면 프로젝트의 **고급 컴파일러 설정** 대화 상자에서 **정수 오버플로 검사 해제** 확인란의 선택을 취소하거나 `/removeintchecks-` 컴파일러 옵션을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-169">In Visual Basic, checked conversions can be performed by clearing the **Remove integer overflow checks** check box in the project's **Advanced Compiler Settings** dialog box, or by specifying the `/removeintchecks-` compiler option.</span></span> <span data-ttu-id="26ddf-170">반대로 비검사 변환을 수행하려면 프로젝트의 **고급 컴파일러 설정** 대화 상자에서 **정수 오버플로 검사 해제** 확인란을 선택하거나 `/removeintchecks+` 컴파일러 옵션을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-170">Conversely, unchecked conversions can be performed by selecting the **Remove integer overflow checks** check box in the project's **Advanced Compiler Settings** dialog box or by specifying the `/removeintchecks+` compiler option.</span></span> <span data-ttu-id="26ddf-171">기본적으로 명시적 변환은 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-171">By default, explicit conversions are checked.</span></span>  
  
 <span data-ttu-id="26ddf-172">다음 C# 예제에서는 `checked` 및 `unchecked` 키워드를 사용하여 <xref:System.Byte> 범위 밖에 있는 값을 <xref:System.Byte>로 변환할 때 동작이 어떻게 다른지 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-172">The following C# example uses the `checked` and `unchecked` keywords to illustrate the difference in behavior when a value outside the range of a <xref:System.Byte> is converted to a <xref:System.Byte>.</span></span> <span data-ttu-id="26ddf-173">검사 변환은 예외를 throw하지만 비검사 변환은 <xref:System.Byte.MaxValue?displayProperty=nameWithType>를 <xref:System.Byte> 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-173">The checked conversion throws an exception, but the unchecked conversion assigns <xref:System.Byte.MaxValue?displayProperty=nameWithType> to the <xref:System.Byte> variable.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/explicit1.cs#12)]  
  
 <span data-ttu-id="26ddf-174">특정 언어 컴파일러에서 오버로드된 사용자 지정 연산자를 지원하는 경우 고유한 사용자 지정 형식에서 명시적 변환을 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-174">If a particular language compiler supports custom overloaded operators, you can also define explicit conversions in your own custom types.</span></span> <span data-ttu-id="26ddf-175">다음 예제에서는 부호 및 크기 표현을 사용하는 `ByteWithSign`이라는 부호 있는 바이트 데이터 형식을 부분적으로 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-175">The following example provides a partial implementation of a signed byte data type named `ByteWithSign` that uses sign-and-magnitude representation.</span></span> <span data-ttu-id="26ddf-176">이 예제에서는 <xref:System.Int32> 및 <xref:System.UInt32> 값을 `ByteWithSign` 값으로 명시적으로 변환하는 작업을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-176">It supports explicit conversion of <xref:System.Int32> and <xref:System.UInt32> values to `ByteWithSign` values.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/explicit1.cs#5)]
 [!code-vb[Conceptual.Conversion#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/explicit1.vb#5)]  
  
 <span data-ttu-id="26ddf-177">클라이언트 코드에서는 할당에 캐스팅 연산자나 변환 메서드가 포함된 경우 다음 예제와 같이 `ByteWithSign` 변수를 선언하여 <xref:System.Int32> 및 <xref:System.UInt32> 값에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-177">Client code can then declare a `ByteWithSign` variable and assign it <xref:System.Int32> and <xref:System.UInt32> values if the assignments include a casting operator or a conversion method, as the following example shows.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/explicit1.cs#6)]
 [!code-vb[Conceptual.Conversion#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/explicit1.vb#6)]  

## <a name="the-iconvertible-interface"></a><span data-ttu-id="26ddf-178">IConvertible 인터페이스</span><span class="sxs-lookup"><span data-stu-id="26ddf-178">The IConvertible interface</span></span>

<span data-ttu-id="26ddf-179">형식을 공용 언어 런타임 기본 형식으로 변환하는 작업을 지원하기 위해 .NET에서는 <xref:System.IConvertible> 인터페이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-179">To support the conversion of any type to a common language runtime base type, .NET provides the <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="26ddf-180">구현하는 형식은 다음을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-180">The implementing type is required to provide the following:</span></span>  
  
- <span data-ttu-id="26ddf-181">구현하는 형식의 <xref:System.TypeCode>를 반환하는 메서드</span><span class="sxs-lookup"><span data-stu-id="26ddf-181">A method that returns the <xref:System.TypeCode> of the implementing type.</span></span>  
  
- <span data-ttu-id="26ddf-182">구현하는 형식을 각 공용 언어 런타임 기본 형식(<xref:System.Boolean>, <xref:System.Byte>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double> 등)으로 변환하는 메서드</span><span class="sxs-lookup"><span data-stu-id="26ddf-182">Methods to convert the implementing type to each common language runtime base type (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, and so on).</span></span>  
  
- <span data-ttu-id="26ddf-183">구현하는 형식의 인스턴스를 다른 지정된 형식으로 변환하는 일반화된 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="26ddf-183">A generalized conversion method to convert an instance of the implementing type to another specified type.</span></span> <span data-ttu-id="26ddf-184">지원되지 않는 변환은 <xref:System.InvalidCastException>을 throw해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-184">Conversions that are not supported should throw an <xref:System.InvalidCastException>.</span></span>  
  
 <span data-ttu-id="26ddf-185">각 공용 언어 런타임 기본 형식(즉, <xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.Single>, <xref:System.String>, <xref:System.UInt16>, <xref:System.UInt32> 및 <xref:System.UInt64>)과 <xref:System.DBNull> 및 <xref:System.Enum> 형식은 <xref:System.IConvertible> 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-185">Each common language runtime base type (that is, the <xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.Single>, <xref:System.String>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64>), as well as the <xref:System.DBNull> and <xref:System.Enum> types, implement the <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="26ddf-186">그러나 이러한 구현은 명시적 인터페이스 구현입니다. 변환 메서드는 다음 예제와 같이 <xref:System.IConvertible> 인터페이스 변수를 통해서만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-186">However, these are explicit interface implementations; the conversion method can be called only through an <xref:System.IConvertible> interface variable, as the following example shows.</span></span> <span data-ttu-id="26ddf-187">이 예제에서는 <xref:System.Int32> 값을 해당하는 <xref:System.Char> 값으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-187">This example converts an <xref:System.Int32> value to its equivalent <xref:System.Char> value.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/iconvertible1.cs#7)]
 [!code-vb[Conceptual.Conversion#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/iconvertible1.vb#7)]  
  
 <span data-ttu-id="26ddf-188">구현하는 형식이 아니라 인터페이스에 대해 변환 메서드를 호출해야 하기 때문에 명시적 인터페이스 구현 비용이 비교적 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-188">The requirement to call the conversion method on its interface rather than on the implementing type makes explicit interface implementations relatively expensive.</span></span> <span data-ttu-id="26ddf-189">따라서 공용 언어 런타임 기본 형식 간에 변환하려면 이 방법 대신 <xref:System.Convert> 클래스의 적절한 멤버를 호출하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-189">Instead, we recommend that you call the appropriate member of the <xref:System.Convert> class to convert between common language runtime base types.</span></span> <span data-ttu-id="26ddf-190">자세한 내용은 다음에 나오는 [Convert 클래스](#the-convert-class) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-190">For more information, see the next section, [The Convert Class](#the-convert-class).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="26ddf-191">.NET에서 제공하는 <xref:System.Convert> 클래스와 <xref:System.IConvertible> 인터페이스 외에도 개별 언어에서 변환을 수행하는 방법을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-191">In addition to the <xref:System.IConvertible> interface and the <xref:System.Convert> class provided by .NET, individual languages may also provide ways to perform conversions.</span></span> <span data-ttu-id="26ddf-192">예를 들어, C#에서는 캐스팅 연산자가 사용되고, Visual Basic에서는 `CType`, `CInt` 및 `DirectCast` 등의 컴파일러 구현 변환 함수가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-192">For example, C# uses casting operators; Visual Basic uses compiler-implemented conversion functions such as `CType`, `CInt`, and `DirectCast`.</span></span>  
  
 <span data-ttu-id="26ddf-193">대부분의 경우 <xref:System.IConvertible> 인터페이스는 .NET에서 기본 형식 간의 변환을 지원하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-193">For the most part, the <xref:System.IConvertible> interface is designed to support conversion between the base types in .NET.</span></span> <span data-ttu-id="26ddf-194">그러나 사용자 지정 형식에서도 이 인터페이스를 구현하여 해당 사용자 지정 형식을 다른 사용자 지정 형식으로 변환하는 작업을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-194">However, the interface can also be implemented by a custom type to support conversion of that type to other custom types.</span></span> <span data-ttu-id="26ddf-195">자세한 내용은 이 항목의 뒷부분에 나오는 [ChangeType 메서드를 사용한 사용자 지정 변환](#custom-conversions-with-the-changetype-method) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-195">For more information, see the section [Custom Conversions with the ChangeType Method](#custom-conversions-with-the-changetype-method) later in this topic.</span></span>

## <a name="the-convert-class"></a><span data-ttu-id="26ddf-196">Convert 클래스</span><span class="sxs-lookup"><span data-stu-id="26ddf-196">The Convert class</span></span>

<span data-ttu-id="26ddf-197">각 기본 형식의 <xref:System.IConvertible> 인터페이스 구현을 호출하여 형식 변환을 수행할 수 있지만 <xref:System.Convert?displayProperty=nameWithType> 클래스의 메서드를 호출하는 것이 한 기본 형식에서 다른 형식으로 변환하는 데 권장되는 언어와 무관한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-197">Although each base type's <xref:System.IConvertible> interface implementation can be called to perform a type conversion, calling the methods of the <xref:System.Convert?displayProperty=nameWithType> class is the recommended language-neutral way to convert from one base type to another.</span></span> <span data-ttu-id="26ddf-198">또한 <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드를 사용하여 지정된 사용자 지정 형식을 다른 형식으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-198">In addition, the <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method can be used to convert from a specified custom type to another type.</span></span>  
  
### <a name="conversions-between-base-types"></a><span data-ttu-id="26ddf-199">기본 형식 간 변환</span><span class="sxs-lookup"><span data-stu-id="26ddf-199">Conversions between base types</span></span>

<span data-ttu-id="26ddf-200"><xref:System.Convert> 클래스를 사용하여 언어와 무관하게 기본 형식 간의 변환을 수행할 수 있으므로 공용 언어 런타임을 대상으로 하는 모든 언어에서 이 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-200">The <xref:System.Convert> class provides a language-neutral way to perform conversions between base types and is available to all languages that target the common language runtime.</span></span> <span data-ttu-id="26ddf-201">이 클래스는 확대 및 축소 변환을 위한 전체 메서드 집합을 제공하며 지원되지 않는 변환(<xref:System.InvalidCastException> 값을 정수 값으로 변환하는 등)의 경우 <xref:System.DateTime>을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-201">It provides a complete set of methods for both widening and narrowing conversions, and throws an <xref:System.InvalidCastException> for conversions that are not supported (such as the conversion of a <xref:System.DateTime> value to an integer value).</span></span> <span data-ttu-id="26ddf-202">축소 변환은 checked 컨텍스트에서 수행되며 변환이 실패하는 경우 <xref:System.OverflowException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-202">Narrowing conversions are performed in a checked context, and an <xref:System.OverflowException> is thrown if the conversion fails.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="26ddf-203"><xref:System.Convert> 클래스에 각 기본 형식으로 변환하거나 각 기본 형식에서 변환하는 메서드가 포함되어 있기 때문에 각 기본 형식의 <xref:System.IConvertible> 명시적 인터페이스 구현을 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-203">Because the <xref:System.Convert> class includes methods to convert to and from each base type, it eliminates the need to call each base type's <xref:System.IConvertible> explicit interface implementation.</span></span>  
  
 <span data-ttu-id="26ddf-204">다음 예제에서는 <xref:System.Convert?displayProperty=nameWithType> 클래스를 사용하여 .NET 기본 형식 간의 몇 가지 확대 및 축소 변환을 수행하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-204">The following example illustrates the use of the <xref:System.Convert?displayProperty=nameWithType> class to perform several widening and narrowing conversions between .NET base types.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/convert1.cs#8)]
 [!code-vb[Conceptual.Conversion#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/convert1.vb#8)]  
  
 <span data-ttu-id="26ddf-205">부동 소수점 값으로 변환하거나 부동 소수점 값에서 변환하는 등의 경우에는 변환을 수행할 때 <xref:System.OverflowException>이 throw되지 않아도 정밀도가 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-205">In some cases, particularly when converting to and from floating-point values, a conversion may involve a loss of precision, even though it does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="26ddf-206">다음 예제에서는 이러한 정밀도 손실을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-206">The following example illustrates this loss of precision.</span></span> <span data-ttu-id="26ddf-207">첫 번째 경우에 <xref:System.Decimal> 값은 <xref:System.Double>로 변환될 때 정밀도가 낮아집니다(유효 자릿수가 적어짐).</span><span class="sxs-lookup"><span data-stu-id="26ddf-207">In the first case, a <xref:System.Decimal> value has less precision (fewer significant digits) when it is converted to a <xref:System.Double>.</span></span> <span data-ttu-id="26ddf-208">두 번째 경우에 <xref:System.Double> 값은 변환을 완료하기 위해 42.72에서 43으로 반올림됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-208">In the second case, a <xref:System.Double> value is rounded from 42.72 to 43 in order to complete the conversion.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/convert1.cs#9)]
 [!code-vb[Conceptual.Conversion#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/convert1.vb#9)]  
  
 <span data-ttu-id="26ddf-209"><xref:System.Convert> 클래스에서 지원하는 확대 및 축소 변환의 목록이 포함된 표는 [형식 변환표](conversion-tables.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="26ddf-209">For a table that lists both the widening and narrowing conversions supported by the <xref:System.Convert> class, see [Type Conversion Tables](conversion-tables.md).</span></span>  

### <a name="custom-conversions-with-the-changetype-method"></a><span data-ttu-id="26ddf-210">ChangeType 메서드를 사용한 사용자 지정 변환</span><span class="sxs-lookup"><span data-stu-id="26ddf-210">Custom conversions with the ChangeType method</span></span>

<span data-ttu-id="26ddf-211">각 기본 형식에 대한 변환을 지원하는 것 외에도 <xref:System.Convert> 클래스를 사용하여 사용자 지정 형식을 하나 이상의 미리 정의된 형식으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-211">In addition to supporting conversions to each of the base types, the <xref:System.Convert> class can be used to convert a custom type to one or more predefined types.</span></span> <span data-ttu-id="26ddf-212">이 변환은 <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드로 수행됩니다. 이 메서드는 <xref:System.IConvertible.ToType%2A?displayProperty=nameWithType> 매개 변수의 `value` 메서드에 대한 호출을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-212">This conversion is performed by the <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method, which in turn wraps a call to the <xref:System.IConvertible.ToType%2A?displayProperty=nameWithType> method of the `value` parameter.</span></span> <span data-ttu-id="26ddf-213">즉, `value` 매개 변수가 나타내는 개체가 <xref:System.IConvertible> 인터페이스의 구현을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-213">This means that the object represented by the `value` parameter must provide an implementation of the <xref:System.IConvertible> interface.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="26ddf-214"><xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%29?displayProperty=nameWithType> 및 <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드는 <xref:System.Type> 개체를 사용하여 `value`가 변환되는 대상 값을 지정하기 때문에, 이런 메서드를 사용하여 컴파일 타임에 형식을 알 수 없는 개체로 동적 변환을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-214">Because the <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%29?displayProperty=nameWithType> and <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29?displayProperty=nameWithType> methods use a <xref:System.Type> object to specify the target type to which `value` is converted, they can be used to perform a dynamic conversion to an object whose type is not known at compile time.</span></span> <span data-ttu-id="26ddf-215">하지만, <xref:System.IConvertible>의 `value` 구현에서는 이 변환을 계속 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-215">However, note that the <xref:System.IConvertible> implementation of `value` must still support this conversion.</span></span>  
  
 <span data-ttu-id="26ddf-216">다음 예제에서는 <xref:System.IConvertible> 개체와 `TemperatureCelsius` 개체 간을 변환할 수 있게 하는 `TemperatureFahrenheit` 인터페이스의 가능한 구현을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-216">The following example illustrates a possible implementation of the <xref:System.IConvertible> interface that allows a `TemperatureCelsius` object to be converted to a `TemperatureFahrenheit` object and vice versa.</span></span> <span data-ttu-id="26ddf-217">이 예제에서는 `Temperature` 인터페이스를 구현하고 <xref:System.IConvertible> 메서드를 재정의하는 기본 클래스 <xref:System.Object.ToString%2A?displayProperty=nameWithType>를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-217">The example defines a base class, `Temperature`, that implements the <xref:System.IConvertible> interface and overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="26ddf-218">파생된 `TemperatureCelsius` 및 `TemperatureFahrenheit` 클래스는 기본 클래스의 `ToType` 및 `ToString` 메서드를 각각 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-218">The derived `TemperatureCelsius` and `TemperatureFahrenheit` classes each override the `ToType` and the `ToString` methods of the base class.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/iconvertible2.cs#10)]
 [!code-vb[Conceptual.Conversion#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/iconvertible2.vb#10)]  
  
 <span data-ttu-id="26ddf-219">다음 예제에서는 이러한 <xref:System.IConvertible> 구현을 몇 번 호출하여 `TemperatureCelsius` 개체와 `TemperatureFahrenheit` 개체 간에 변환하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-219">The following example illustrates several calls to these <xref:System.IConvertible> implementations to convert `TemperatureCelsius` objects to `TemperatureFahrenheit` objects and vice versa.</span></span>  
  
 [!code-csharp[Conceptual.Conversion#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.conversion/cs/iconvertible2.cs#11)]
 [!code-vb[Conceptual.Conversion#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.conversion/vb/iconvertible2.vb#11)]  

## <a name="the-typeconverter-class"></a><span data-ttu-id="26ddf-220">TypeConverter 클래스</span><span class="sxs-lookup"><span data-stu-id="26ddf-220">The TypeConverter class</span></span>

<span data-ttu-id="26ddf-221">.NET에서는 <xref:System.ComponentModel.TypeConverter?displayProperty=nameWithType> 클래스를 확장하고 <xref:System.ComponentModel.TypeConverterAttribute?displayProperty=nameWithType> 특성을 통해 형식 변환기를 해당 형식과 연결하여 사용자 지정 형식에 대한 형식 변환기를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-221">.NET also allows you to define a type converter for a custom type by extending the <xref:System.ComponentModel.TypeConverter?displayProperty=nameWithType> class and associating the type converter with the type through a <xref:System.ComponentModel.TypeConverterAttribute?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="26ddf-222">다음 표에는 이 방법과 사용자 지정 형식에 대한 <xref:System.IConvertible> 인터페이스를 구현하는 방법의 차이점이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-222">The following table highlights the differences between this approach and implementing the <xref:System.IConvertible> interface for a custom type.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="26ddf-223">사용자 지정 형식에 대해 형식 변환기가 정의되어 있는 경우에만 사용자 지정 형식에 디자인 타임 지원이 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-223">Design-time support can be provided for a custom type only if it has a type converter defined for it.</span></span>  
  
|<span data-ttu-id="26ddf-224">TypeConverter를 사용한 변환</span><span class="sxs-lookup"><span data-stu-id="26ddf-224">Conversion using TypeConverter</span></span>|<span data-ttu-id="26ddf-225">IConvertible를 사용한 변환</span><span class="sxs-lookup"><span data-stu-id="26ddf-225">Conversion using IConvertible</span></span>|  
|------------------------------------|-----------------------------------|  
|<span data-ttu-id="26ddf-226"><xref:System.ComponentModel.TypeConverter>에서 별도의 클래스를 파생시켜 사용자 지정 형식에 대해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-226">Is implemented for a custom type by deriving a separate class from <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="26ddf-227">이 파생 클래스는 <xref:System.ComponentModel.TypeConverterAttribute> 특성을 적용하여 사용자 지정 형식과 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-227">This derived class is associated with the custom type by applying a <xref:System.ComponentModel.TypeConverterAttribute> attribute.</span></span>|<span data-ttu-id="26ddf-228">변환을 수행하기 위해 사용자 지정 형식에 의해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-228">Is implemented by a custom type to perform conversion.</span></span> <span data-ttu-id="26ddf-229">형식의 사용자가 해당 형식에 대해 <xref:System.IConvertible> 변환 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-229">A user of the type invokes an <xref:System.IConvertible> conversion method on the type.</span></span>|  
|<span data-ttu-id="26ddf-230">디자인 타임 및 런타임 모두에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-230">Can be used both at design time and at run time.</span></span>|<span data-ttu-id="26ddf-231">런타임에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-231">Can be used only at run time.</span></span>|  
|<span data-ttu-id="26ddf-232">리플렉션을 사용합니다. 따라서 <xref:System.IConvertible>로 활성화된 변환보다 느립니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-232">Uses reflection; therefore, is slower than conversion enabled by <xref:System.IConvertible>.</span></span>|<span data-ttu-id="26ddf-233">리플렉션을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-233">Does not use reflection.</span></span>|  
|<span data-ttu-id="26ddf-234">사용자 지정 형식에서 다른 데이터 형식으로, 다른 데이터 형식에서 사용자 지정 형식으로의 양방향 형식 변환을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-234">Allows two-way type conversions from the custom type to other data types, and from other data types to the custom type.</span></span> <span data-ttu-id="26ddf-235">예를 들어, <xref:System.ComponentModel.TypeConverter>에 대해 정의된 `MyType`를 사용하여 `MyType`에서 <xref:System.String>으로 변환하고 <xref:System.String>에서 `MyType`으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-235">For example, a <xref:System.ComponentModel.TypeConverter> defined for `MyType` allows conversions from `MyType` to <xref:System.String>, and from <xref:System.String> to `MyType`.</span></span>|<span data-ttu-id="26ddf-236">사용자 지정 형식에서 다른 데이터 형식으로의 변환은 허용하지만, 다른 데이터 형식에서 사용자 지정 형식으로의 변환은 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26ddf-236">Allows conversion from a custom type to other data types, but not from other data types to the custom type.</span></span>|  
  
 <span data-ttu-id="26ddf-237">변환기를 사용하여 변환을 수행하는 방법에 대한 자세한 내용은 <xref:System.ComponentModel.TypeConverter?displayProperty=nameWithType>를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="26ddf-237">For more information about using type converters to perform conversions, see <xref:System.ComponentModel.TypeConverter?displayProperty=nameWithType>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="26ddf-238">참조</span><span class="sxs-lookup"><span data-stu-id="26ddf-238">See also</span></span>

- <xref:System.Convert?displayProperty=nameWithType>
- <xref:System.IConvertible>
- [<span data-ttu-id="26ddf-239">형식 변환표</span><span class="sxs-lookup"><span data-stu-id="26ddf-239">Type Conversion Tables</span></span>](conversion-tables.md)
