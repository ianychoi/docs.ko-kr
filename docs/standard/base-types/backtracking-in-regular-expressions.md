---
title: .NET 정규식의 역행 검사
description: 정규식 패턴 일치에서 역추적을 제어하는 방법을 알아봅니다.
ms.date: 11/12/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET], backtracking
- strings [.NET], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
ms.openlocfilehash: 5c6d9d2e048c2dd89cf18ff7148050ddb6813f40
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95699705"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="2df63-103">정규식의 역행 검사</span><span class="sxs-lookup"><span data-stu-id="2df63-103">Backtracking in Regular Expressions</span></span>

<span data-ttu-id="2df63-104">역추적은 정규식 패턴에 선택적인 [수량자](quantifiers-in-regular-expressions.md) 또는 [교체 구문](alternation-constructs-in-regular-expressions.md)이 포함되어 있고 정규식 엔진이 일치 항목을 계속 검색하기 위해 이전에 저장한 상태로 되돌아갈 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](quantifiers-in-regular-expressions.md) or [alternation constructs](alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="2df63-105">역추적은 정규식 성능의 핵심입니다. 역추적을 사용하면 식의 성능과 유연성을 높일 수 있으며 매우 복잡한 패턴도 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="2df63-106">하지만 이러한 장점에는 단점이 수반됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="2df63-107">역추적은 종종 정규식 엔진의 성능에 영향을 주는 가장 중요한 단일 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="2df63-108">다행히도 개발자는 정규식 엔진의 동작과 역추적 사용 방식을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="2df63-109">이 항목에서는 역추적의 작동 방식 및 역추적을 제어할 수 있는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2df63-110">일반적으로 .NET 정규식 엔진과 같은 NFA(Nondeterministic Finite Automaton) 엔진에서는 개발자가 효율적이고 속도가 빠른 정규식을 작성하도록 노력해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  

## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="2df63-111">역추적을 사용하지 않는 선형 비교</span><span class="sxs-lookup"><span data-stu-id="2df63-111">Linear Comparison Without Backtracking</span></span>  

 <span data-ttu-id="2df63-112">정규식 패턴에 선택적인 수량자 또는 교체 구문이 없으면 정규식 엔진이 선형 시간으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-112">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="2df63-113">즉, 정규식 엔진은 패턴에서 입력 문자열의 텍스트와 일치하는 첫 번째 언어 요소를 검색한 후 다시 패턴에서 입력 문자열의 다음 문자 또는 문자 그룹과 일치하는 다음 언어 요소를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-113">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="2df63-114">이 작업은 검색이 성공할 때까지 계속되고, 그렇지 않으면 검색이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-114">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="2df63-115">어느 경우에든 정규식 엔진은 입력 문자열에서 한 번에 한 글자씩 검색을 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-115">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="2df63-116">다음 예제에서 이에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-116">The following example provides an illustration.</span></span> <span data-ttu-id="2df63-117">정규식 `e{2}\w\b` 는 모든 단어 문자에서 단어 경계까지 "e"가 두 번 나오는 단어를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-117">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="2df63-118">이 정규식은 수량자 `{2}`가 있더라도 선형 방식으로 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-118">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="2df63-119">`{2}` 는 선택적인 수량자가 아니기 때문에 정규식 엔진이 역추적을 수행하지 않습니다. 이 수량자는 정확한 숫자를 지정하며 이전 하위 식이 검색해야 하는 가변 횟수가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-119">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="2df63-120">따라서 정규식 엔진은 다음 표에서와 같이 입력 문자열에서 정규식 패턴과 일치하는 항목을 검색하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-120">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="2df63-121">연산</span><span class="sxs-lookup"><span data-stu-id="2df63-121">Operation</span></span>|<span data-ttu-id="2df63-122">패턴 내 위치</span><span class="sxs-lookup"><span data-stu-id="2df63-122">Position in pattern</span></span>|<span data-ttu-id="2df63-123">문자열 내 위치</span><span class="sxs-lookup"><span data-stu-id="2df63-123">Position in string</span></span>|<span data-ttu-id="2df63-124">결과</span><span class="sxs-lookup"><span data-stu-id="2df63-124">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="2df63-125">1</span><span class="sxs-lookup"><span data-stu-id="2df63-125">1</span></span>|<span data-ttu-id="2df63-126">e</span><span class="sxs-lookup"><span data-stu-id="2df63-126">e</span></span>|<span data-ttu-id="2df63-127">"needing a reed"(인덱스 0)</span><span class="sxs-lookup"><span data-stu-id="2df63-127">"needing a reed" (index 0)</span></span>|<span data-ttu-id="2df63-128">일치하는 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-128">No match.</span></span>|  
|<span data-ttu-id="2df63-129">2</span><span class="sxs-lookup"><span data-stu-id="2df63-129">2</span></span>|<span data-ttu-id="2df63-130">e</span><span class="sxs-lookup"><span data-stu-id="2df63-130">e</span></span>|<span data-ttu-id="2df63-131">"eeding a reed"(인덱스 1)</span><span class="sxs-lookup"><span data-stu-id="2df63-131">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="2df63-132">일치 가능</span><span class="sxs-lookup"><span data-stu-id="2df63-132">Possible match.</span></span>|  
|<span data-ttu-id="2df63-133">3</span><span class="sxs-lookup"><span data-stu-id="2df63-133">3</span></span>|<span data-ttu-id="2df63-134">e{2}</span><span class="sxs-lookup"><span data-stu-id="2df63-134">e{2}</span></span>|<span data-ttu-id="2df63-135">"eding a reed"(인덱스 2)</span><span class="sxs-lookup"><span data-stu-id="2df63-135">"eding a reed" (index 2)</span></span>|<span data-ttu-id="2df63-136">일치 가능</span><span class="sxs-lookup"><span data-stu-id="2df63-136">Possible match.</span></span>|  
|<span data-ttu-id="2df63-137">4</span><span class="sxs-lookup"><span data-stu-id="2df63-137">4</span></span>|<span data-ttu-id="2df63-138">\w</span><span class="sxs-lookup"><span data-stu-id="2df63-138">\w</span></span>|<span data-ttu-id="2df63-139">"ding a reed"(인덱스 3)</span><span class="sxs-lookup"><span data-stu-id="2df63-139">"ding a reed" (index 3)</span></span>|<span data-ttu-id="2df63-140">일치 가능</span><span class="sxs-lookup"><span data-stu-id="2df63-140">Possible match.</span></span>|  
|<span data-ttu-id="2df63-141">5</span><span class="sxs-lookup"><span data-stu-id="2df63-141">5</span></span>|<span data-ttu-id="2df63-142">\b</span><span class="sxs-lookup"><span data-stu-id="2df63-142">\b</span></span>|<span data-ttu-id="2df63-143">"ing a reed"(인덱스 4)</span><span class="sxs-lookup"><span data-stu-id="2df63-143">"ing a reed" (index 4)</span></span>|<span data-ttu-id="2df63-144">일치 가능 실패</span><span class="sxs-lookup"><span data-stu-id="2df63-144">Possible match fails.</span></span>|  
|<span data-ttu-id="2df63-145">6</span><span class="sxs-lookup"><span data-stu-id="2df63-145">6</span></span>|<span data-ttu-id="2df63-146">e</span><span class="sxs-lookup"><span data-stu-id="2df63-146">e</span></span>|<span data-ttu-id="2df63-147">"eding a reed"(인덱스 2)</span><span class="sxs-lookup"><span data-stu-id="2df63-147">"eding a reed" (index 2)</span></span>|<span data-ttu-id="2df63-148">일치 가능</span><span class="sxs-lookup"><span data-stu-id="2df63-148">Possible match.</span></span>|  
|<span data-ttu-id="2df63-149">7</span><span class="sxs-lookup"><span data-stu-id="2df63-149">7</span></span>|<span data-ttu-id="2df63-150">e{2}</span><span class="sxs-lookup"><span data-stu-id="2df63-150">e{2}</span></span>|<span data-ttu-id="2df63-151">"ding a reed"(인덱스 3)</span><span class="sxs-lookup"><span data-stu-id="2df63-151">"ding a reed" (index 3)</span></span>|<span data-ttu-id="2df63-152">일치 가능 실패</span><span class="sxs-lookup"><span data-stu-id="2df63-152">Possible match fails.</span></span>|  
|<span data-ttu-id="2df63-153">8</span><span class="sxs-lookup"><span data-stu-id="2df63-153">8</span></span>|<span data-ttu-id="2df63-154">e</span><span class="sxs-lookup"><span data-stu-id="2df63-154">e</span></span>|<span data-ttu-id="2df63-155">"ding a reed"(인덱스 3)</span><span class="sxs-lookup"><span data-stu-id="2df63-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="2df63-156">검색이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-156">Match fails.</span></span>|  
|<span data-ttu-id="2df63-157">9</span><span class="sxs-lookup"><span data-stu-id="2df63-157">9</span></span>|<span data-ttu-id="2df63-158">e</span><span class="sxs-lookup"><span data-stu-id="2df63-158">e</span></span>|<span data-ttu-id="2df63-159">"ing a reed"(인덱스 4)</span><span class="sxs-lookup"><span data-stu-id="2df63-159">"ing a reed" (index 4)</span></span>|<span data-ttu-id="2df63-160">일치하는 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-160">No match.</span></span>|  
|<span data-ttu-id="2df63-161">10</span><span class="sxs-lookup"><span data-stu-id="2df63-161">10</span></span>|<span data-ttu-id="2df63-162">e</span><span class="sxs-lookup"><span data-stu-id="2df63-162">e</span></span>|<span data-ttu-id="2df63-163">"ng a reed"(인덱스 5)</span><span class="sxs-lookup"><span data-stu-id="2df63-163">"ng a reed" (index 5)</span></span>|<span data-ttu-id="2df63-164">일치하는 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-164">No match.</span></span>|  
|<span data-ttu-id="2df63-165">11</span><span class="sxs-lookup"><span data-stu-id="2df63-165">11</span></span>|<span data-ttu-id="2df63-166">e</span><span class="sxs-lookup"><span data-stu-id="2df63-166">e</span></span>|<span data-ttu-id="2df63-167">"g a reed"(인덱스 6)</span><span class="sxs-lookup"><span data-stu-id="2df63-167">"g a reed" (index 6)</span></span>|<span data-ttu-id="2df63-168">일치하는 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-168">No match.</span></span>|  
|<span data-ttu-id="2df63-169">12</span><span class="sxs-lookup"><span data-stu-id="2df63-169">12</span></span>|<span data-ttu-id="2df63-170">e</span><span class="sxs-lookup"><span data-stu-id="2df63-170">e</span></span>|<span data-ttu-id="2df63-171">" a reed"(인덱스 7)</span><span class="sxs-lookup"><span data-stu-id="2df63-171">" a reed" (index 7)</span></span>|<span data-ttu-id="2df63-172">일치하는 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-172">No match.</span></span>|  
|<span data-ttu-id="2df63-173">13</span><span class="sxs-lookup"><span data-stu-id="2df63-173">13</span></span>|<span data-ttu-id="2df63-174">e</span><span class="sxs-lookup"><span data-stu-id="2df63-174">e</span></span>|<span data-ttu-id="2df63-175">"a reed"(인덱스 8)</span><span class="sxs-lookup"><span data-stu-id="2df63-175">"a reed" (index 8)</span></span>|<span data-ttu-id="2df63-176">일치하는 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-176">No match.</span></span>|  
|<span data-ttu-id="2df63-177">14</span><span class="sxs-lookup"><span data-stu-id="2df63-177">14</span></span>|<span data-ttu-id="2df63-178">e</span><span class="sxs-lookup"><span data-stu-id="2df63-178">e</span></span>|<span data-ttu-id="2df63-179">" reed"(인덱스 9)</span><span class="sxs-lookup"><span data-stu-id="2df63-179">" reed" (index 9)</span></span>|<span data-ttu-id="2df63-180">일치하는 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-180">No match.</span></span>|  
|<span data-ttu-id="2df63-181">15</span><span class="sxs-lookup"><span data-stu-id="2df63-181">15</span></span>|<span data-ttu-id="2df63-182">e</span><span class="sxs-lookup"><span data-stu-id="2df63-182">e</span></span>|<span data-ttu-id="2df63-183">"reed"(인덱스 10)</span><span class="sxs-lookup"><span data-stu-id="2df63-183">"reed" (index 10)</span></span>|<span data-ttu-id="2df63-184">일치 없음</span><span class="sxs-lookup"><span data-stu-id="2df63-184">No match</span></span>|  
|<span data-ttu-id="2df63-185">16</span><span class="sxs-lookup"><span data-stu-id="2df63-185">16</span></span>|<span data-ttu-id="2df63-186">e</span><span class="sxs-lookup"><span data-stu-id="2df63-186">e</span></span>|<span data-ttu-id="2df63-187">"eed"(인덱스 11)</span><span class="sxs-lookup"><span data-stu-id="2df63-187">"eed" (index 11)</span></span>|<span data-ttu-id="2df63-188">일치 가능</span><span class="sxs-lookup"><span data-stu-id="2df63-188">Possible match.</span></span>|  
|<span data-ttu-id="2df63-189">17</span><span class="sxs-lookup"><span data-stu-id="2df63-189">17</span></span>|<span data-ttu-id="2df63-190">e{2}</span><span class="sxs-lookup"><span data-stu-id="2df63-190">e{2}</span></span>|<span data-ttu-id="2df63-191">"ed"(인덱스 12)</span><span class="sxs-lookup"><span data-stu-id="2df63-191">"ed" (index 12)</span></span>|<span data-ttu-id="2df63-192">일치 가능</span><span class="sxs-lookup"><span data-stu-id="2df63-192">Possible match.</span></span>|  
|<span data-ttu-id="2df63-193">18</span><span class="sxs-lookup"><span data-stu-id="2df63-193">18</span></span>|<span data-ttu-id="2df63-194">\w</span><span class="sxs-lookup"><span data-stu-id="2df63-194">\w</span></span>|<span data-ttu-id="2df63-195">"d"(인덱스 13)</span><span class="sxs-lookup"><span data-stu-id="2df63-195">"d" (index 13)</span></span>|<span data-ttu-id="2df63-196">일치 가능</span><span class="sxs-lookup"><span data-stu-id="2df63-196">Possible match.</span></span>|  
|<span data-ttu-id="2df63-197">19</span><span class="sxs-lookup"><span data-stu-id="2df63-197">19</span></span>|<span data-ttu-id="2df63-198">\b</span><span class="sxs-lookup"><span data-stu-id="2df63-198">\b</span></span>|<span data-ttu-id="2df63-199">""(인덱스 14)</span><span class="sxs-lookup"><span data-stu-id="2df63-199">"" (index 14)</span></span>|<span data-ttu-id="2df63-200">일치</span><span class="sxs-lookup"><span data-stu-id="2df63-200">Match.</span></span>|  
  
 <span data-ttu-id="2df63-201">정규식 엔진에 선택적인 수량자가 없거나 교체 구문이 없는 경우 입력 문자열에서 정규식 패턴과 일치하는 항목을 찾기 위해 필요한 최대 비교 수는 입력 문자열에 있는 문자 수와 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-201">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="2df63-202">이 경우 정규식 엔진은 이 13자 길이의 문자열에서 가능한 일치 항목을 식별하기 위해 19가지를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-202">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="2df63-203">즉, 선택적인 수량자 또는 대체 생성 구문이 없는 경우 정규식 엔진이 선형에 가까운 시간으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-203">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>

## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="2df63-204">선택적인 수량자 또는 교체 구문을 사용한 역추적</span><span class="sxs-lookup"><span data-stu-id="2df63-204">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  

 <span data-ttu-id="2df63-205">정규식에 선택적인 수량자 또는 교체 구문이 포함된 경우 입력 문자열에 대한 평가는 더 이상 선형으로 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-205">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="2df63-206">NFA 엔진에서 패턴 일치는 입력 문자열에 있는 검색할 문자가 아니라 정규식의 언어 요소에 의해 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-206">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="2df63-207">따라서 정규식 엔진은 선택적인 하위 식 또는 교체 하위 식에 대해 전체 검색을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-207">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="2df63-208">하위 식의 다음 언어 요소로 진행할 때 검색이 실패하면 정규식 엔진이 성공한 일치 부분을 버리고 입력 문자열 전체에 대한 정규식 검색을 수행하기 위해 이전에 저장된 상태로 돌아갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-208">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="2df63-209">일치하는 항목을 찾기 위해 이전에 저장된 상태로 돌아가는 프로세스를 역추적이라고 부릅니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-209">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="2df63-210">예를 들어 임의의 문자로 시작해서 "es"가 포함된 항목을 검색하는 `.*(es)`라는 정규식 패턴이 있다고 가정해보십시오.</span><span class="sxs-lookup"><span data-stu-id="2df63-210">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="2df63-211">다음 예제에서와 같이 입력 문자열이 "Essential services are provided by regular expressions."인 경우 이 패턴은 "expressions"의 "es"를 포함하여 전체 문자열을 끝까지 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-211">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="2df63-212">이를 위해 정규식 엔진은 다음과 같은 방식으로 역추적을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-212">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="2df63-213">전체 입력 문자열에서 `.*` (0개 이상의 임의 문자 검색)를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-213">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="2df63-214">정규식 패턴의 "e"와 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-214">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="2df63-215">하지만 입력 문자열에는 검색에 사용할 수 있는 남은 문자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-215">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="2df63-216">마지막으로 일치한 항목인 "Essential services are provided by regular expressions"로 역추적하고 문장의 끝에 있는 마침표에서 "e"와 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-216">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="2df63-217">그러면 검색이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-217">The match fails.</span></span>  
  
- <span data-ttu-id="2df63-218">계속해서 일시적으로 일치하는 하위 문자열이 "Essential services are provided by regular expr"이 될 때까지 한 번에 한 글자씩 이전에 성공한 일치 항목으로 역추적합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-218">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="2df63-219">그런 다음 패턴에 있는 "e"와 "expressions"의 두 번째 "e"를 비교하여 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-219">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="2df63-220">패턴에 있는 "s"와 일치한 "e" 문자 다음의 "s"("expressions"의 첫 번째 "s")를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-220">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="2df63-221">그러면 검색이 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-221">The match is successful.</span></span>  
  
 <span data-ttu-id="2df63-222">역추적을 사용할 경우 길이가 55자인 입력 문자열에서 정규식 패턴과 일치하는 항목을 검색하려면 67번의 비교 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-222">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="2df63-223">일반적으로 정규식 엔진에 단일 교체 구문이 포함되었거나 선택적인 단일 수량자가 포함된 경우 패턴을 검색하는 데 필요한 비교 작업 수는 입력 문자열에 있는 문자 수의 두 배 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-223">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>

## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="2df63-224">선택적인 중첩된 수량자를 사용한 역추적</span><span class="sxs-lookup"><span data-stu-id="2df63-224">Backtracking with Nested Optional Quantifiers</span></span>  

 <span data-ttu-id="2df63-225">패턴에 교체 구문이 많이 포함되었거나 중첩된 교체 구문이 포함되었거나, 선택적인 중첩된 수량자가 포함된 경우(가장 일반적인 경우) 정규식 패턴과 일치하는 항목을 찾기 위해 필요한 비교 작업 수가 기하급수적으로 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-225">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="2df63-226">예를 들어 정규식 패턴 `^(a+)+$` 는 하나 이상의 "a" 문자가 포함된 전체 문자열을 검색하도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-226">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="2df63-227">예제에는 동일한 길이의 두 입력 문자열이 제공되지만 첫 번째 문자열만 패턴과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-227">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="2df63-228"><xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> 클래스는 일치 항목을 검색하는 작업이 수행되는 시간을 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-228">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="2df63-229">예제의 결과에서와 같이 정규식 엔진은 일치하는 문자열을 식별할 때 걸리는 시간에 비해 입력 문자열이 패턴과 일치하지 않는 것을 확인하는 데 약 두 배의 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-229">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="2df63-230">그 이유는 성공하지 못한 검색은 항상 최악의 경우를 나타내기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-230">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="2df63-231">정규식 엔진은 일치하는 항목이 없다는 결론을 내리기까지 정규식을 사용하여 데이터에서 가능한 모든 경로를 따라야 하며, 중첩된 괄호가 있으면 데이터에서 발생 가능한 경로 수가 추가로 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-231">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="2df63-232">정규식 엔진은 다음을 수행하여 두 번째 문자열이 패턴과 일치하지 않는다는 결론을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-232">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="2df63-233">문자열의 시작 위치에 있는지 확인한 후 `a+`패턴을 사용하여 문자열에서 처음 5개 문자를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-233">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="2df63-234">그런 후 문자열에 "a" 문자의 추가 그룹이 없는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-234">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="2df63-235">마지막으로 문자열의 끝인지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-235">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="2df63-236">문자열에 하나의 추가 문자가 남아 있기 때문에 검색이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-236">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="2df63-237">이 실패한 검색에는 9번의 비교 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-237">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="2df63-238">정규식 엔진은 또한 "a"(이하 매치 1이라고 부름), "aa"(매치 2), "aaa"(매치 3) 및 "aaaa"(매치 4)의 일치 항목에 대한 상태 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-238">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="2df63-239">정규식 엔진이 이전에 저장된 매치 4로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-239">It returns to the previously saved match 4.</span></span> <span data-ttu-id="2df63-240">추가 캡처 그룹에 할당할 수 있도록 "a" 문자가 추가로 하나 더 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-240">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="2df63-241">마지막으로 문자열의 끝인지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-241">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="2df63-242">문자열에 하나의 추가 문자가 남아 있기 때문에 검색이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-242">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="2df63-243">이 실패한 검색에는 4번의 비교 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-243">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="2df63-244">지금까지 총 13번의 비교 작업이 수행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-244">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="2df63-245">정규식 엔진이 이전에 저장된 매치 3으로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-245">It returns to the previously saved match 3.</span></span> <span data-ttu-id="2df63-246">추가 캡처 그룹에 할당할 수 있도록 두 개의 추가 "a" 문자가 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-246">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="2df63-247">하지만 문자열 끝 테스트가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-247">However, the end-of-string test fails.</span></span> <span data-ttu-id="2df63-248">그런 다음 매치 3으로 돌아가서 두 개의 추가 캡처 그룹에서 두 개의 추가 "a" 문자를 검색하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-248">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="2df63-249">그래도 문자열 끝 테스트가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-249">The end-of-string test still fails.</span></span> <span data-ttu-id="2df63-250">이렇게 실패한 검색 작업에는 12번의 비교 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-250">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="2df63-251">지금까지 총 25번의 비교 작업이 수행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-251">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="2df63-252">입력 문자열을 정규식 엔진에서 비교하는 작업은 정규식이 검색 작업의 모든 가능한 조합을 시도하고 일치 항목이 없다는 결론을 내릴 때까지 이러한 방식으로 계속해서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-252">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="2df63-253">중첩된 수량자로 인해 이러한 비교는 O(2 <sup>n</sup>) 또는 지수 연산으로 수행되며, 여기서 *n* 은 입력 문자열에 있는 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-253">Because of the nested quantifiers, this comparison is an O(2 <sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="2df63-254">즉, 문자 수가 30개인 입력 문자열에서는 최악의 경우 약 1,073,741,824번의 비교 작업이 필요하고, 입력 문자열의 문자 수가 40개이면 약 1,099,511,627,776번의 비교 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-254">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="2df63-255">이정도 또는 심지어 더 긴 문자열을 사용하면 정규식 메서드가 정규식 패턴과 일치하지 않는 입력을 처리할 때 완료 시간이 극단적으로 길어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-255">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>

## <a name="controlling-backtracking"></a><span data-ttu-id="2df63-256">역추적 제어</span><span class="sxs-lookup"><span data-stu-id="2df63-256">Controlling Backtracking</span></span>  

 <span data-ttu-id="2df63-257">역추적을 사용하면 강력하고 유연한 정규식을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-257">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="2df63-258">하지만 이전 단원에 설명한 것처럼 이러한 장점 외에도 성능이 매우 크게 저하될 수 있음에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-258">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="2df63-259">과도한 역추적을 방지하려면 <xref:System.Text.RegularExpressions.Regex> 개체를 인스턴스화하거나 정적 정규식 일치 메서드를 호출할 때 시간 제한 간격을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-259">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="2df63-260">이에 대해서는 다음 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-260">This is discussed in the next section.</span></span> <span data-ttu-id="2df63-261">그 밖에도, .NET에서는 역추적을 제한하거나 억제하고, 성능상의 제약이 거의 없거나 전혀 없이 복잡한 정규식을 지원하는 세 가지 정규식 언어 요소인 [원자성 그룹](#atomic-groups), [lookbehind 어설션](#lookbehind-assertions) 및 [lookahead 어설션](#lookahead-assertions)을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-261">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [atomic groups](#atomic-groups), [lookbehind assertions](#lookbehind-assertions), and [lookahead assertions](#lookahead-assertions).</span></span> <span data-ttu-id="2df63-262">각 언어 요소에 대한 자세한 내용은 [정규식의 그룹화 구문](grouping-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2df63-262">For more information about each language element, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>  

### <a name="defining-a-time-out-interval"></a><span data-ttu-id="2df63-263">시간 제한 간격 정의</span><span class="sxs-lookup"><span data-stu-id="2df63-263">Defining a Time-out Interval</span></span>  

 <span data-ttu-id="2df63-264">.NET Framework 4.5부터는 정규식 엔진이 시도를 포기하고 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외를 throw하기 전에 단일 일치 항목을 검색할 가장 긴 간격을 나타내는 시간 제한 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-264">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2df63-265"><xref:System.TimeSpan> 값을 인스턴스 정규식을 위한 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 생성자에 제공하여 시간 제한 간격을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-265">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor for instance regular expressions.</span></span> <span data-ttu-id="2df63-266">또한, 각각의 정적 패턴 일치 메서드에 시간 제한 값을 지정할 수 있게 해주는 <xref:System.TimeSpan> 매개 변수의 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-266">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="2df63-267">기본적으로, 시간 제한 간격은 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 으로 설정되고, 정규식 엔진의 시간이 초과되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-267">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="2df63-268">정규식이 역추적에 의존하는 경우에는 항상 시간 제한 간격을 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-268">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="2df63-269"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외는 정규식 엔진이 지정된 시간 제한 간격 내에 일치 항목을 찾지 못했음을 나타내지만, 예외가 throw된 이유를 나타내지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-269">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="2df63-270">과도한 역추적이 원인일 수 있지만, 예외가 throw된 시점의 시스템 부하에서 시간 제한 간격이 너무 낮게 설정되었을 가능성도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-270">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="2df63-271">예외를 처리할 때 입력 문자열을 포함한 다른 일치 항목을 버리거나 시간 제한 간격을 늘리고 일치 검사 작업을 재시도하는 방법 중에서 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-271">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="2df63-272">예를 들어, 다음 코드는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 생성자를 호출하여 1초의 시간 제한 값으로 <xref:System.Text.RegularExpressions.Regex> 개체를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-272">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="2df63-273">줄의 끝에 하나 이상의 "a" 문자가 포함된 하나 이상의 시퀀스와 일치하는 정규식 패턴 `(a+)+$`는 과도한 역추적의 대상이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-273">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="2df63-274"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 이 throw되는 경우, 이 예제에서는 시간 제한 값을 최대 간격인 3초까지 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-274">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="2df63-275">그 후에는 패턴 일치를 찾는 시도를 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-275">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  

### <a name="atomic-groups"></a><span data-ttu-id="2df63-276">원자성 그룹</span><span class="sxs-lookup"><span data-stu-id="2df63-276">Atomic groups</span></span>

 <span data-ttu-id="2df63-277">`(?>` *subexpression*`)` 언어 요소는 하위 식으로의 역추적을 억제합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-277">The `(?>` *subexpression*`)` language element suppresses backtracking into the subexpression.</span></span> <span data-ttu-id="2df63-278">일치를 찾으면 일치 항목의 일부를 후속 역추적으로 넘기지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-278">Once it has successfully matched, it will not give up any part of its match to subsequent backtracking.</span></span> <span data-ttu-id="2df63-279">예를 들어 `(?>\w*\d*)1` 패턴에서 `1`이 일치하지 않는 경우 `\d*`는 `1`을 성공적으로 일치시킬 수 있더라도 일치의 일부를 포기하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-279">For example, in the pattern `(?>\w*\d*)1`, if the `1` cannot be matched, the `\d*` will not give up any of its match even if that means it would allow the `1` to successfully match.</span></span> <span data-ttu-id="2df63-280">원자성 그룹은 실패한 검색과 연관된 성능 문제를 방지하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-280">Atomic groups can help prevent the performance problems associated with failed matches.</span></span>
  
 <span data-ttu-id="2df63-281">다음 예제에서는 역추적을 억제하여 중첩된 수량자를 사용할 때 성능을 향상시키는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-281">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="2df63-282">이 예에서는 정규식 엔진이 입력 문자열이 두 개의 정규식과 일치하지 않는지 확인하기 위해 필요한 시간을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-282">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="2df63-283">첫 번째 정규식에서는 역추적을 사용하여 하나 이상의 16진수 숫자와 일치하는 하나 이상의 항목이 포함되고 콜론과 하나 이상의 16진수 숫자 그리고 두 개의 콜론이 이어지는 문자열을 검색하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-283">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="2df63-284">두 번째 정규식은 첫 번째와 동일하지만 역추적이 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-284">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="2df63-285">예의 결과에서 보여 지듯이 역추적을 사용하지 않음으로써 얻게 되는 성능 향상 효과가 매우 큽니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-285">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  

### <a name="lookbehind-assertions"></a><span data-ttu-id="2df63-286">lookbehind 어설션</span><span class="sxs-lookup"><span data-stu-id="2df63-286">Lookbehind Assertions</span></span>  

 <span data-ttu-id="2df63-287">.NET에는 입력 문자열에서 이전 문자와 일치하는 두 가지 언어 요소인 `(?<=`*subexpression*`)` 및 `(?<!`*subexpression*`)`이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-287">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="2df63-288">두 언어 요소 모두 너비가 0인 어설션입니다. 즉, 진행 또는 역추적 없이 현재 문자 바로 앞에 있는 문자를 *subexpression* 과 일치시킬 수 있는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-288">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="2df63-289">`(?<=` *subexpression* `)`은 긍정 lookbehind 어설션입니다. 즉, 현재 위치 바로 전의 문자가 *subexpression* 과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-289">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="2df63-290">`(?<!`*subexpression*`)` 은 부정 lookbehind 어설션입니다. 즉, 현재 위치 바로 전의 문자가 *subexpression* 과 일치하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-290">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="2df63-291">긍정 및 부정 lookbehind 어설션 모두 *subexpression* 이 이전 하위 식의 하위 집합일 때 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-291">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="2df63-292">다음 예제에서는 전자 메일 주소에서 사용자 이름의 유효성을 검사하는 두 개의 동일한 정규식 패턴이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-292">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="2df63-293">첫 번째 패턴은 과도한 역추적으로 인해 성능이 크게 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-293">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="2df63-294">두 번째 패턴은 중첩된 수량자를 긍정 lookbehind 어설션으로 바꿔서 첫 번째 정규식을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-294">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="2df63-295">이 예의 결과에는 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 메서드의 실행 시간이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-295">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="2df63-296">첫 번째 정규식 패턴 `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`은(는) 다음 표와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-296">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2df63-297">무늬</span><span class="sxs-lookup"><span data-stu-id="2df63-297">Pattern</span></span>|<span data-ttu-id="2df63-298">설명</span><span class="sxs-lookup"><span data-stu-id="2df63-298">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2df63-299">문자열의 시작 부분에서 검색을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-299">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="2df63-300">일치하는 영숫자 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-300">Match an alphanumeric character.</span></span> <span data-ttu-id="2df63-301"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 메서드가 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 옵션으로 호출되므로 이 비교는 대/소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-301">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="2df63-302">하이픈, 마침표 또는 단어 문자가 0개 이상 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-302">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="2df63-303">일치하는 영숫자 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-303">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="2df63-304">영숫자 문자로 이어지는 하이픈, 마침표 또는 단어 문자가 0개 이상 조합된 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-304">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="2df63-305">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-305">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="2df63-306">"\@" 기호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-306">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="2df63-307">두 번째 정규식 패턴 `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`은 긍정 lookbehind 어설션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-307">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="2df63-308">이 패턴은 다음 표에서와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-308">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2df63-309">무늬</span><span class="sxs-lookup"><span data-stu-id="2df63-309">Pattern</span></span>|<span data-ttu-id="2df63-310">설명</span><span class="sxs-lookup"><span data-stu-id="2df63-310">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2df63-311">문자열의 시작 부분에서 검색을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-311">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="2df63-312">일치하는 영숫자 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-312">Match an alphanumeric character.</span></span> <span data-ttu-id="2df63-313"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 메서드가 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 옵션으로 호출되므로 이 비교는 대/소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-313">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="2df63-314">하이픈, 마침표 또는 단어 문자가 0개 이상 포함된 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-314">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="2df63-315">마지막으로 일치한 문자를 다시 확인하고 영숫자인 경우 검색을 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-315">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="2df63-316">영숫자 문자는 마침표, 하이픈 및 모든 단어 문자로 구성되는 집합의 하위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-316">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="2df63-317">"\@" 기호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-317">Match an at sign ("\@").</span></span>|  

### <a name="lookahead-assertions"></a><span data-ttu-id="2df63-318">lookahead 어설션</span><span class="sxs-lookup"><span data-stu-id="2df63-318">Lookahead Assertions</span></span>  

 <span data-ttu-id="2df63-319">.NET에는 입력 문자열에서 다음 문자와 일치하는 두 가지 언어 요소인 `(?=`*subexpression*`)` 및 `(?!`*subexpression*`)`이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-319">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="2df63-320">두 언어 요소 모두 너비가 0인 어설션입니다. 즉, 진행 또는 역추적 없이 현재 문자 바로 뒤에 있는 문자를 *subexpression* 과 일치시킬 수 있는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-320">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="2df63-321">`(?=` *subexpression* `)`은 긍정 lookahead 어설션입니다. 즉, 현재 위치 바로 뒤의 문자가 *subexpression* 과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-321">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="2df63-322">`(?!`*subexpression*`)` 은 부정 lookahead 어설션입니다. 즉, 현재 위치 바로 뒤의 문자가 *subexpression* 과 일치하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-322">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="2df63-323">긍정 및 부정 lookahead 어설션 모두 *subexpression* 이 다음 하위 식의 하위 집합인 경우 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-323">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="2df63-324">다음 예제에서는 정규화된 형식 이름의 유효성을 검사하는 두 개의 동일한 정규식 패턴이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-324">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="2df63-325">첫 번째 패턴은 과도한 역추적으로 인해 성능이 크게 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-325">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="2df63-326">두 번째 패턴은 중첩된 수량자를 긍정 lookahead 어설션으로 바꿔서 첫 번째 정규식을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-326">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="2df63-327">이 예의 결과에는 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 메서드의 실행 시간이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-327">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="2df63-328">첫 번째 정규식 패턴 `^(([A-Z]\w*)+\.)*[A-Z]\w*$`은(는) 다음 표와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-328">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2df63-329">무늬</span><span class="sxs-lookup"><span data-stu-id="2df63-329">Pattern</span></span>|<span data-ttu-id="2df63-330">설명</span><span class="sxs-lookup"><span data-stu-id="2df63-330">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2df63-331">문자열의 시작 부분에서 검색을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-331">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="2df63-332">0개 이상의 단어 문자와 마침표가 이어지는 영문자(A-Z)를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-332">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="2df63-333"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 메서드가 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 옵션으로 호출되므로 이 비교는 대/소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-333">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="2df63-334">이전 패턴을 0번 이상 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-334">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="2df63-335">0개 이상의 단어 문자로 이어지는 영문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-335">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="2df63-336">입력 문자열의 끝 부분에서 검색을 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-336">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="2df63-337">두 번째 정규식 패턴 `^((?=[A-Z])\w+\.)*[A-Z]\w*$`에는 긍정 lookahead 어설션이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-337">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="2df63-338">이 패턴은 다음 표에서와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-338">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2df63-339">무늬</span><span class="sxs-lookup"><span data-stu-id="2df63-339">Pattern</span></span>|<span data-ttu-id="2df63-340">설명</span><span class="sxs-lookup"><span data-stu-id="2df63-340">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2df63-341">문자열의 시작 부분에서 검색을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-341">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="2df63-342">첫 번째 문자를 검색하고 영문자(A-Z)인 경우 검색을 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-342">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="2df63-343"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 메서드가 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 옵션으로 호출되므로 이 비교는 대/소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-343">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="2df63-344">마침표로 이어지는 하나 이상의 문자를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-344">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="2df63-345">마침표가 0번 이상 이어지는 하나 이상의 단어 문자의 패턴을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-345">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="2df63-346">초기 단어 문자는 영문자여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-346">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="2df63-347">0개 이상의 단어 문자로 이어지는 영문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-347">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="2df63-348">입력 문자열의 끝 부분에서 검색을 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="2df63-348">End the match at the end of the input string.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="2df63-349">참조</span><span class="sxs-lookup"><span data-stu-id="2df63-349">See also</span></span>

- [<span data-ttu-id="2df63-350">.NET 정규식</span><span class="sxs-lookup"><span data-stu-id="2df63-350">.NET Regular Expressions</span></span>](regular-expressions.md)
- [<span data-ttu-id="2df63-351">정규식 언어 - 빠른 참조</span><span class="sxs-lookup"><span data-stu-id="2df63-351">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="2df63-352">수량자</span><span class="sxs-lookup"><span data-stu-id="2df63-352">Quantifiers</span></span>](quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="2df63-353">교체 구문</span><span class="sxs-lookup"><span data-stu-id="2df63-353">Alternation Constructs</span></span>](alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="2df63-354">정규식의 그룹화 구문</span><span class="sxs-lookup"><span data-stu-id="2df63-354">Grouping Constructs</span></span>](grouping-constructs-in-regular-expressions.md)
