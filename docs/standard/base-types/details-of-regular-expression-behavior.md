---
title: 정규식 동작
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 1e5d2d40f52220a8fff40eb19a24d8b2efd3cab5
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829702"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="09a49-102">정규식 동작 정보</span><span class="sxs-lookup"><span data-stu-id="09a49-102">Details of regular expression behavior</span></span>

<span data-ttu-id="09a49-103">.NET 정규식 엔진은 Perl, Python, Emacs 및 Tcl에서 사용하는 것과 같은 기존의 NFA(Nondeterministic Finite Automaton) 엔진을 통합하는 역추적 정규식 일치 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-103">The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="09a49-104">이를 통해 해당 awk, egrep 또는 lex와 같은 빠르지만 제한적인 순수 정규식 DFA(Deterministic Finite Automaton) 엔진과 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="09a49-105">또한 표준화되지만 느린 POSIX NFA과도 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="09a49-106">다음 섹션에서는 세 가지 유형의 정규식 엔진을 설명하고 기존 NFA 엔진을 사용하여 .NET의 정규식을 구현하는 이유를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-106">The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="09a49-107">NFA 엔진의 이점</span><span class="sxs-lookup"><span data-stu-id="09a49-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="09a49-108">DFA 엔진에서 패턴 일치를 수행하는 경우 해당 처리 순서는 입력 문자열에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="09a49-109">엔진은 입력 문자열의 처음부터 시작해서 순차적으로 다음 문자가 정규식 패턴과 일치하는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="09a49-110">가능한 가장 긴 문자열을 찾도록 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="09a49-111">동일한 문자를 두 번 테스트하지 않기 때문에 DFA 엔진은 역추적을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="09a49-112">그러나 DFA 엔진에 유한 상태만 포함되기 때문에 역참조를 사용하는 패턴과 일치하지 않으며 명시적 확장을 생성하지 않기 때문에 하위 식을 캡처할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="09a49-113">DFA 엔진과 달리 기존의 NFA 엔진이 패턴 일치를 수행할 경우 해당 처리 순서는 정규식 패턴에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="09a49-114">특정 언어 요소를 처리하는 경우와 같이 엔진은 탐욕적 일치를 사용합니다. 즉, 가능한 한 입력 문자열의 수만큼 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="09a49-115">하지만 성공적으로 하위 식을 찾은 후에 해당 상태를 저장하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="09a49-116">일치에 결국 실패하면 엔진이 추가 일치를 시도할 수 있도록 저장된 상태로 돌아갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="09a49-117">정규식에서 이후 언어 요소가 일치할 수 있도록 성공적인 하위 식 찾기를 포기하는 이 프로세스를 ‘역추적’이라고 합니다. </span><span class="sxs-lookup"><span data-stu-id="09a49-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="09a49-118">NFA 엔진은 역추적을 사용하여 특정 순서에 따라 정규식에서 가능한 모든 확장을 테스트하고 첫 번째 일치 항목을 수락합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="09a49-119">기존의 NFA 엔진이 성공적으로 일치를 수행하기 위해 정규식의 특정 확장을 구성하기 때문에 하위 식 일치 및 일치 역참조를 캡처할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="09a49-120">그러나 기존의 NFA가 역추적하기 때문에 다른 경로를 통해 그 상태가 된 경우 여러 번 동일한 상태가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="09a49-121">결과적으로 최악의 경우 상당히 느리게 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="09a49-122">기존 NFA 엔진이 발견한 첫 번째 이치를 수용하기 때문에 다른 일치 항목(더 긴 일치일 가능성이 높음)도 밝히지 않은 상태로 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="09a49-123">POSIX NFA 엔진은 가장 긴 일치 항목을 발견했다고 보장할 수 있을 때까지 역추적을 계속한다는 점을 제외하면 기존의 NFA 엔진과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="09a49-124">결과적으로 POSIX NFA 엔진은 기존 NFA 엔진보다 느립니다. 따라서 POSIX NFA 엔진을 사용하는 경우 역추적 검사의 순서를 변경하여 긴 일치 항목보다 짧은 일치 항목을 우선할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="09a49-125">기존의 NFA 엔진은 DFA 또는 POSIX NFA 엔진보다 일치하는 문자열을 효율적으로 제어하기 때문에 프로그래머로부터 선호되었습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="09a49-126">최악의 경우 실행 속도가 느려질 수 있지만 모호성을 줄이고 역추적을 제한하는 패턴을 사용하여 선형 또는 다항 시간에서 일치 항목을 찾도록 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="09a49-127">즉, NFA 엔진은 강력함과 유연성을 제공하는 대신 성능이 떨어지지만 대부분의 경우에 정규식을 잘 작성하여 역추적이 성능을 기하급수적으로 저하시키지 않도록 방지한다면 사용 가능한 적절한 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="09a49-128">과도한 역추적으로 인해 발생한 성능 저하 및 이를 해결하는 정규식을 만드는 방법에 대한 자세한 내용은 [역추적](backtracking-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>

## <a name="net-engine-capabilities"></a><span data-ttu-id="09a49-129">.NET 엔진 기능</span><span class="sxs-lookup"><span data-stu-id="09a49-129">.NET engine capabilities</span></span>

 <span data-ttu-id="09a49-130">기존 NFA 엔진의 이점을 누리려면 .NET 정규식 엔진에는 프로그래머가 역추적 엔진을 조정할 수 있는 일련의 구문이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-130">To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="09a49-131">이러한 구문을 사용하여 일치 항목을 빠르게 찾거나 다른 일치 항목에 대한 특정 확장을 우선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="09a49-132">.NET 정규식 엔진의 다른 기능은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-132">Other features of the .NET regular expression engine include the following:</span></span>

- <span data-ttu-id="09a49-133">게으른 수량자: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`</span><span class="sxs-lookup"><span data-stu-id="09a49-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="09a49-134">이러한 구문은 역추적 엔진이 최소 반복 횟수를 먼저 검색하도록 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="09a49-135">반면, 일반적인 탐욕적 수량자는 먼저 최대 반복 횟수를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="09a49-136">다음 예제에서는 둘 사이의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="09a49-137">정규식은 숫자로 끝나는 문장을 찾고 캡처링 그룹은 해당 숫자를 추출하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="09a49-138">정규식 `.+(\d+)\.`은 탐욕적 수량자 `.+`를 포함하며 이로 인해 정규식 엔진은 번호의 마지막 숫자만 캡처하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="09a49-139">반대로 정규식 `.+?(\d+)\.`은 게으른 수량자 `.+?`를 포함하며 이로 인해 정규식 엔진은 전체 번호를 캡처하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="09a49-140">이 정규식의 최대 일치 버전 및 최소 일치 버전은 다음 표와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="09a49-141">무늬</span><span class="sxs-lookup"><span data-stu-id="09a49-141">Pattern</span></span>|<span data-ttu-id="09a49-142">설명</span><span class="sxs-lookup"><span data-stu-id="09a49-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="09a49-143">`.+`(탐욕적 수량자)</span><span class="sxs-lookup"><span data-stu-id="09a49-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="09a49-144">적어도 한 번 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="09a49-145">그러면 정규식 엔진이 전체 문자열을 검색하고 필요한 패턴의 나머지 부분을 찾는 데 필요한 역추적을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="09a49-146">`.+?`(게으른 수량자)</span><span class="sxs-lookup"><span data-stu-id="09a49-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="09a49-147">적어도 한 번 문자를 찾지만 가능한 한 적게 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="09a49-148">적어도 하나의 숫자 문자를 찾아 첫 번째 캡처링 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="09a49-149">마침표를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-149">Match a period.</span></span>|

     <span data-ttu-id="09a49-150">수량자에 대한 자세한 내용은 [수량자](quantifiers-in-regular-expressions.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-150">For more information about lazy quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="09a49-151">긍정 lookahead: `(?=`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="09a49-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="09a49-152">이 기능을 사용하면 역추적 검사 엔진이 하위 식을 찾은 후에 텍스트의 동일한 지점으로 돌아오게 합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="09a49-153">동일한 위치에서 시작하는 여러 패턴을 확인하여 전체 텍스트를 검색하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="09a49-154">이를 통해 엔진은 찾은 텍스트에 부분 문자열을 포함하지 않고 부분 문자열이 일치 항목의 끝에 존재하는지 확인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="09a49-155">다음 예제에서는 긍정 lookahead를 사용하여 문장 부호 기호가 뒤에 오지 않는 문장에 있는 단어를 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="09a49-156">`\b[A-Z]+\b(?=\P{P})` 정규식은 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="09a49-157">무늬</span><span class="sxs-lookup"><span data-stu-id="09a49-157">Pattern</span></span>|<span data-ttu-id="09a49-158">설명</span><span class="sxs-lookup"><span data-stu-id="09a49-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="09a49-159">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="09a49-160">알파벳 임의의 문자를 1회 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="09a49-161"><xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> 메서드가 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 옵션으로 호출되므로 이 비교는 대/소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="09a49-162">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="09a49-163">다음 문자가 문장 부호 기호인지 확인하기 위해 앞을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="09a49-164">그렇지 않은 경우 일치가 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="09a49-165">긍정 lookahead 어설션에 대한 자세한 내용은 [그룹화 구문](grouping-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-165">For more information about positive lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="09a49-166">부정 lookahead: `(?!`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="09a49-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="09a49-167">이 기능은 하위 식이 일치에 실패하는 경우 식을 찾는 기능을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="09a49-168">이 기능은 검색 항목을 정리하는 데 유용합니다. 포함해야 하는 사례에 대한 식보다 제거해야 하는 경우에 대한 식을 제공하는 것이 더 간단하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="09a49-169">예를 들어 "non"으로 시작하지 않는 단어에 대한 식을 작성하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="09a49-170">다음 예제에서는 부정 lookahead를 사용하여 파일을 제외합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="09a49-171">정규식 패턴 `\b(?!non)\w+\b` 는 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="09a49-172">무늬</span><span class="sxs-lookup"><span data-stu-id="09a49-172">Pattern</span></span>|<span data-ttu-id="09a49-173">설명</span><span class="sxs-lookup"><span data-stu-id="09a49-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="09a49-174">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="09a49-175">현재 문자열이 "non"으로 시작하지 않으면 조회합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="09a49-176">그렇지 않으면 검색이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="09a49-177">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="09a49-178">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="09a49-179">부정 lookahead 어설션에 대한 자세한 내용은 [그룹화 구문](grouping-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-179">For more information about negative lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="09a49-180">조건부 평가: `(?(`*expression*`)`*yes*`|`*no*`)` 및 `(?(`*name*`)`*yes*`|`*no*`)`. 여기서 *expression* 은 일치시킬 하위 식이고, *name* 은 캡처 그룹의 이름이고, *yes* 는 *expression* 이 일치하거나 *name* 이 올바른 비어 있지 않은 캡처된 그룹인 경우 일치시킬 문자열이고, *no* 는 *expression* 이 일치하지 않거나 *name* 이 유효하고 비어 있지 않은 캡처된 그룹이 아닌 경우 일치시킬 하위 식입니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="09a49-181">엔진은 이 기능을 통해 이전 하위 식이 일치 결과 및 너비 0인 어설션 결과에 따라 둘 이상의 대체 패턴을 사용하여 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="09a49-182">따라서 이전 하위 식이 일치하는지 여부에 따라 하위 식을 찾도록 허용하는 더 강력한 형식의 역참조가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="09a49-183">다음 예제의 정규식은 공용으로 사용하고 내부적으로 사용하려는 단락을 모두 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="09a49-184">내부적으로 사용하려는 단락은 `<PRIVATE>` 태그로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="09a49-185">정규식 패턴 `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`은 조건부 평가를 사용하여 공용으로 사용하고 내부적으로 사용하려는 단락의 콘텐츠를 별도의 캡처링 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="09a49-186">이러한 단락은 다르게 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="09a49-187">이 정규식 패턴은 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="09a49-188">무늬</span><span class="sxs-lookup"><span data-stu-id="09a49-188">Pattern</span></span>|<span data-ttu-id="09a49-189">설명</span><span class="sxs-lookup"><span data-stu-id="09a49-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="09a49-190">줄의 시작 부분에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="09a49-191">0개 또는 1개의 뒤에 공백 문자가 있는 `<PRIVATE>` 문자열을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="09a49-192">`Pvt`로 명명된 캡처 그룹에 일치 항목을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="09a49-193">`Pvt` 캡처링 그룹이 있는 경우 뒤에 0개 이상의 문장 구분 기호와 하나의 공백 문자가 오는 하나 이상의 단어 문자를 한 번 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="09a49-194">첫 번째 캡처링 그룹에 부분 문자열을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="09a49-195">`Pvt` 캡처링 그룹이 없는 경우 뒤에 0개 이상의 문장 구분 기호와 하나의 공백 문자가 오는 하나 이상의 단어 문자를 한 번 이상 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="09a49-196">세 번째 캡처링 그룹에 부분 문자열을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="09a49-197">줄의 끝 또는 문자열의 끝을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="09a49-198">조건부 평가에 대한 자세한 내용은 [교체 구문](alternation-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-198">For more information about conditional evaluation, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="09a49-199">균형 조정 그룹 정의: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="09a49-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="09a49-200">정규식 엔진은 이 기능을 통해 괄호 또는 열고 닫는 대괄호와 같은 중첩된 구문을 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="09a49-201">예제는 [그룹화 구문](grouping-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-201">For an example, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="09a49-202">원자성 그룹: `(?>`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="09a49-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="09a49-203">식이 보유한 독립 항목을 실행하는 것처럼 역추적 엔진은 이 기능을 통해 하위 식이 보유한 첫 번째 일치 항목만을 찾는다고 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="09a49-204">이 생성자를 사용하지 않는 경우 더 큰 식의 역추적 검색은 하위 식의 동작을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="09a49-205">예를 들어 정규식 `(a+)\w`는 “a” 문자의 시퀀스를 따르는 단어 문자와 함께 하나 이상의 “a” 문자를 찾고 “a” 문자의 시퀀스를 첫 번째 캡처링 그룹에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="09a49-206">하지만 입력 문자열의 마지막 문자가 “a”인 경우 `\w` 언어 요소에 의해 찾게 되며 캡처된 그룹에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="09a49-207">정규식 `((?>a+))\w`은 이러한 동작을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="09a49-208">연속되는 모든 "a" 문자를 역추적하지 않고 찾기 때문에 첫 번째 캡처링 그룹에는 연속되는 모든 "a" 문자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="09a49-209">"a" 문자의 뒤에 "a" 이외의 문자가 적어도 하나 이상 있지 않으면 검색에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="09a49-210">원자성 그룹에 대한 자세한 내용은 [그룹화 구문](grouping-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-210">For more information about atomic groups, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="09a49-211">오른쪽에서 왼쪽 찾기는 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 옵션을 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자 또는 고정 인스턴스 일치 메서드에 제공하여 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="09a49-212">이 기능은 왼쪽에서 오른쪽이 아닌 오른쪽에서 왼쪽으로 찾는 경우에 유용하고 패턴의 왼쪽이 아닌 패턴의 오른쪽 부분에서 찾기를 시작하는 경우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="09a49-213">다음 예제와 같이 오른쪽에서 왼쪽 찾기를 사용하면 탐욕적 수량자의 동작을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="09a49-214">예제에서는 숫자로 끝나는 문장에 대해 두 개의 검색을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="09a49-215">오른쪽에서 왼쪽 검색이 6자리 모두와 일치하는 반면 탐욕적 수량자를 사용하는 왼쪽에서 오른쪽 검색 `+`은 문장에서 6자리 중 하나와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="09a49-216">정규식 패턴에 대한 설명은 이 섹션 앞부분의 게으른 수량자를 보여 주는 예제를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="09a49-217">오른쪽에서 왼쪽 찾기에 대한 자세한 내용은 [정규식 옵션](regular-expression-options.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-217">For more information about right-to-left matching, see [Regular Expression Options](regular-expression-options.md).</span></span>

- <span data-ttu-id="09a49-218">긍정 및 부정 lookbehind: 긍정 lookbehind의 경우 `(?<=`*subexpression*`)`, 부정 lookbehind의 경우 `(?<!`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="09a49-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="09a49-219">이 기능은 이 항목의 앞부분에서 설명한 lookahead와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="09a49-220">정규식 엔진을 사용하면 오른쪽에서 왼쪽 찾기를 완료할 수 있기 때문에 정규식은 무제한 lookbehind를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="09a49-221">긍정 및 부정 lookbehind는 중첩된 하위 식이 외부 식의 상위 집합인 경우 중첩된 수량자를 방지하는 데도 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="09a49-222">이러한 중첩된 수량자가 있는 정규식은 종종 성능이 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="09a49-223">예를 들어 다음 예제에서는 문자열이 영숫자 문자로 시작하고 끝나고 문자열의 다른 문자가 큰 하위 집합 중 하나임을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="09a49-224">이 식은 이메일 주소의 유효성을 검사하는 데 사용되는 정규식의 일부를 형성합니다. 자세한 내용은 [방법: 문자열이 올바른 이메일 형식인지 확인](how-to-verify-that-strings-are-in-valid-email-format.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="09a49-225">``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` 정규식은 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="09a49-226">무늬</span><span class="sxs-lookup"><span data-stu-id="09a49-226">Pattern</span></span>|<span data-ttu-id="09a49-227">설명</span><span class="sxs-lookup"><span data-stu-id="09a49-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="09a49-228">문자열의 시작 부분에서 검색을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="09a49-229">숫자 또는 영숫자 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="09a49-230">비교는 대소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="09a49-231">단어 문자 또는 -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;이나 ~의 문자로 구성된 0개 이상의 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="09a49-232">영숫자만 또는 숫자여야 하는 이전 문자를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="09a49-233">비교는 대소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="09a49-234">문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="09a49-235">긍정 및 부정 lookbehind에 대한 자세한 내용은 [그룹화 구문](grouping-constructs-in-regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="09a49-235">For more information about positive and negative lookbehind, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="09a49-236">관련 문서</span><span class="sxs-lookup"><span data-stu-id="09a49-236">Related articles</span></span>

|<span data-ttu-id="09a49-237">제목</span><span class="sxs-lookup"><span data-stu-id="09a49-237">Title</span></span>|<span data-ttu-id="09a49-238">설명</span><span class="sxs-lookup"><span data-stu-id="09a49-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="09a49-239">역추적</span><span class="sxs-lookup"><span data-stu-id="09a49-239">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="09a49-240">대체 일치 항목을 찾는 정규식 역추적 분기에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="09a49-241">컴파일 및 다시 사용</span><span class="sxs-lookup"><span data-stu-id="09a49-241">Compilation and Reuse</span></span>](compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="09a49-242">성능 향상을 위해 정규식을 컴파일하고 다시 사용하는 방법에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="09a49-243">스레드로부터의 안전성</span><span class="sxs-lookup"><span data-stu-id="09a49-243">Thread Safety</span></span>](thread-safety-in-regular-expressions.md)|<span data-ttu-id="09a49-244">정규식 스레드로부터의 안전성에 대한 정보를 제공하고 정규식 개체에 대한 액세스를 동기화해야 하는 경우를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="09a49-245">.NET 정규식</span><span class="sxs-lookup"><span data-stu-id="09a49-245">.NET Regular Expressions</span></span>](regular-expressions.md)|<span data-ttu-id="09a49-246">정규식의 프로그래밍 언어 측면에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="09a49-247">정규식 개체 모델</span><span class="sxs-lookup"><span data-stu-id="09a49-247">The Regular Expression Object Model</span></span>](the-regular-expression-object-model.md)|<span data-ttu-id="09a49-248">정규식 클래스를 사용하는 방법을 보여 주는 코드 예제 및 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="09a49-249">정규식 언어 - 빠른 참조</span><span class="sxs-lookup"><span data-stu-id="09a49-249">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="09a49-250">정규식을 정의하는 데 사용할 수 있는 문자, 연산자 및 생성자 집합에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="09a49-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="09a49-251">참고</span><span class="sxs-lookup"><span data-stu-id="09a49-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
