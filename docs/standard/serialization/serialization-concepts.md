---
title: Serialization 개념
description: Serialization을 사용하여 복사본을 만들기 위해 개체의 상태를 캡처하거나 한 애플리케이션 도메인에서 다른 애플리케이션 도메인으로 값을 기준으로 개체를 보낼 수 있습니다.
ms.date: 08/07/2017
ms.assetid: e1ff4740-20a1-4c76-a8ad-d857db307054
ms.openlocfilehash: 90fd8be54e34f1eddd773a69df7ff72f111a58c6
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95722169"
---
# <a name="serialization-concepts"></a><span data-ttu-id="b998e-103">Serialization 개념</span><span class="sxs-lookup"><span data-stu-id="b998e-103">Serialization concepts</span></span>

<span data-ttu-id="b998e-104">serialization을 사용하는 이유는 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="b998e-104">Why would you want to use serialization?</span></span> <span data-ttu-id="b998e-105">가장 중요한 두 가지 이유는 이후 단계에서 정확한 복사본을 다시 만들 수 있도록 스토리지 매체에 개체의 상태를 유지하는 것과 개체를 한 애플리케이션 도메인에서 다른 애플리케이션 도메인으로 값으로 전송하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-105">The two most important reasons are to persist the state of an object to a storage medium so an exact copy can be re-created at a later stage, and to send the object by value from one application domain to another.</span></span> <span data-ttu-id="b998e-106">예를 들어 serialization을 사용하여 세션 상태를 ASP.NET에 저장하고 개체를 Windows Forms의 클립보드로 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-106">For example, serialization is used to save session state in ASP.NET and to copy objects to the Clipboard in Windows Forms.</span></span> <span data-ttu-id="b998e-107">또한 Remoting에서 이를 사용하여 개체를 한 애플리케이션 도메인에서 다른 애플리케이션 도메인으로 값으로 전달할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-107">It is also used by remoting to pass objects by value from one application domain to another.</span></span>

[!INCLUDE [binary-serialization-warning](../../../includes/binary-serialization-warning.md)]

## <a name="persistent-storage"></a><span data-ttu-id="b998e-108">영구 스토리지</span><span class="sxs-lookup"><span data-stu-id="b998e-108">Persistent storage</span></span>

<span data-ttu-id="b998e-109">개체의 필드 값을 디스크에 저장하고 나중에 이 디스크를 검색하는 것이 필요할 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-109">It is often necessary to store the value of the fields of an object to disk and then, later, retrieve this data.</span></span> <span data-ttu-id="b998e-110">serialization을 사용하지 않고 쉽게 구현할 수 있는 기능이지만 이 방식은 불편하고 오류가 발생하기 쉬우며 개체의 계층 구조를 추적해야 할 때는 점점 더 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-110">Although this is easy to achieve without relying on serialization, this approach is often cumbersome and error prone, and becomes progressively more complex when you need to track a hierarchy of objects.</span></span> <span data-ttu-id="b998e-111">수천 개의 개체가 있으며 각 개체마다 필드와 속성을 디스크에 저장하고 복원하는 코드를 작성해야 하는 대규모 비즈니스 애플리케이션을 가정해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="b998e-111">Imagine writing a large business application, that contains thousands of objects, and having to write code to save and restore the fields and properties to and from disk for each object.</span></span> <span data-ttu-id="b998e-112">serialization을 사용하면 이러한 목표를 편리하게 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-112">Serialization provides a convenient mechanism for achieving this objective.</span></span>

<span data-ttu-id="b998e-113">공용 언어 런타임은 개체가 메모리에 저장되는 방식을 관리하며 [리플렉션](../../framework/reflection-and-codedom/reflection.md)을 사용하여 자동화된 serialization 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-113">The common language runtime manages how objects are stored in memory and provides an automated serialization mechanism by using [reflection](../../framework/reflection-and-codedom/reflection.md).</span></span> <span data-ttu-id="b998e-114">개체가 serialize될 때 클래스의 이름, 어셈블리 및 클래스 인스턴스의 모든 데이터 멤버가 스토리지에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-114">When an object is serialized, the name of the class, the assembly, and all the data members of the class instance are written to storage.</span></span> <span data-ttu-id="b998e-115">개체는 다른 인스턴스에 대한 참조를 멤버 변수에 저장할 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-115">Objects often store references to other instances in member variables.</span></span> <span data-ttu-id="b998e-116">클래스가 serialize될 때 serialization 엔진은 이미 serialize된 참조되는 개체를 추적하여 동일한 개체가 두 번 이상 serialize되는 것을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-116">When the class is serialized, the serialization engine tracks referenced objects, already serialized, to ensure that the same object is not serialized more than once.</span></span> <span data-ttu-id="b998e-117">.NET이 제공하는 직렬화 아키텍처는 개체 그래프와 순환 참조를 적절하게 자동 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-117">The serialization architecture provided by .NET correctly handles object graphs and circular references automatically.</span></span> <span data-ttu-id="b998e-118">개체 그래프에 대한 유일한 요구 사항은 직렬화된 개체가 참조하는 모든 개체도 `Serializable`로 표시되어야 한다는 점입니다. 자세한 내용은 [기본 Serialization](basic-serialization.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b998e-118">The only requirement placed on object graphs is that all objects, referenced by the serialized object, must also be marked as `Serializable` (for more information, see [Basic Serialization](basic-serialization.md)).</span></span> <span data-ttu-id="b998e-119">이렇게 되지 않으면 serializer가 표시되지 않은 개체를 serialize하려고 시도할 때 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-119">If this is not done, an exception will be thrown when the serializer attempts to serialize the unmarked object.</span></span>

<span data-ttu-id="b998e-120">직렬화된 클래스가 역직렬화될 때는 클래스가 다시 만들어지고 모든 데이터 멤버의 값이 자동으로 복원됩니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-120">When the serialized class is deserialized, the class is recreated and the values of all the data members are automatically restored.</span></span>

## <a name="marshal-by-value"></a><span data-ttu-id="b998e-121">값에 의한 마샬링</span><span class="sxs-lookup"><span data-stu-id="b998e-121">Marshal by value</span></span>

<span data-ttu-id="b998e-122">개체는 해당 개체가 만들어진 애플리케이션 도메인에서만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-122">Objects are valid only in the application domain where they are created.</span></span> <span data-ttu-id="b998e-123">개체를 매개 변수로 전달하거나 결과로 반환하려고 하는 시도는 개체가 `MarshalByRefObject`에서 파생되거나 `Serializable`로 표시된 경우 이외에는 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-123">Any attempt to pass the object as a parameter or return it as a result will fail unless the object derives from `MarshalByRefObject` or is marked as `Serializable`.</span></span> <span data-ttu-id="b998e-124">개체가 `Serializable`로 표시된 경우 개체는 자동으로 직렬화되고, 하나의 애플리케이션 도메인에서 다른 애플리케이션 도메인으로 전송된 다음, 역직렬화되어 두 번째 애플리케이션 도메인에서 개체의 정확한 복사본을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-124">If the object is marked as `Serializable`, the object will automatically be serialized, transported from the one application domain to the other, and then deserialized to produce an exact copy of the object in the second application domain.</span></span> <span data-ttu-id="b998e-125">이 프로세스를 일반적으로 값에 의한 마샬링이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-125">This process is typically referred to as marshal-by-value.</span></span>

<span data-ttu-id="b998e-126">개체가 `MarshalByRefObject`에서 파생되는 경우 개체 자체가 아니라 개체 참조가 한 애플리케이션 도메인에서 다른 애플리케이션 도메인으로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-126">When an object derives from `MarshalByRefObject`, an object reference is passed from one application domain to another, rather than the object itself.</span></span> <span data-ttu-id="b998e-127">`MarshalByRefObject`에서 파생되는 개체를 `Serializable`로 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-127">You can also mark an object that derives from `MarshalByRefObject` as `Serializable`.</span></span> <span data-ttu-id="b998e-128">이 개체를 Remoting에 사용하면 서로게이트 선택기(`SurrogateSelector`)로 미리 구성된 serialization 담당 포맷터가 serialization 프로세스를 제어하고, `MarshalByRefObject`에서 파생된 모든 개체를 프록시로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-128">When this object is used with remoting, the formatter responsible for serialization, which has been preconfigured with a surrogate selector (`SurrogateSelector`), takes control of the serialization process, and replaces all objects derived from `MarshalByRefObject` with a proxy.</span></span> <span data-ttu-id="b998e-129">`SurrogateSelector`가 없으면 serialization 아키텍처는 [Serialization 과정의 단계](steps-in-the-serialization-process.md)에서 설명하는 표준 serialization 규칙을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-129">Without the `SurrogateSelector` in place, the serialization architecture follows the standard serialization rules described in [Steps in the Serialization Process](steps-in-the-serialization-process.md).</span></span>  

## <a name="related-sections"></a><span data-ttu-id="b998e-130">관련 단원</span><span class="sxs-lookup"><span data-stu-id="b998e-130">Related sections</span></span>  

 [<span data-ttu-id="b998e-131">이진 serialization</span><span class="sxs-lookup"><span data-stu-id="b998e-131">Binary Serialization</span></span>](binary-serialization.md)  
 <span data-ttu-id="b998e-132">공용 언어 런타임에 포함된 이진 serialization 메커니즘을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-132">Describes the binary serialization mechanism that is included with the common language runtime.</span></span>
  
 [<span data-ttu-id="b998e-133">XML 및 SOAP serialization</span><span class="sxs-lookup"><span data-stu-id="b998e-133">XML and SOAP Serialization</span></span>](xml-and-soap-serialization.md)  
 <span data-ttu-id="b998e-134">공용 언어 런타임에 포함된 XML 및 SOAP serialization 메커니즘을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b998e-134">Describes the XML and SOAP serialization mechanism that is included with the common language runtime.</span></span>
