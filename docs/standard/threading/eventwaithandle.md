---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 078bda2354a6f0aec2215b0c5da2a021f53ff922
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723786"
---
# <a name="eventwaithandle"></a><span data-ttu-id="51b0c-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="51b0c-102">EventWaitHandle</span></span>

<span data-ttu-id="51b0c-103"><xref:System.Threading.EventWaitHandle> 클래스를 사용하면 여러 스레드가 신호를 보내고 신호를 대기하여 서로 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="51b0c-104">이벤트 대기 핸들(단순히 이벤트라고도 함)은 하나 이상의 대기 스레드를 해제하기 위해 신호를 보낼 수 있는 대기 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="51b0c-105">신호를 받은 후 이벤트 대기 핸들은 수동으로 또는 자동으로 다시 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="51b0c-106"><xref:System.Threading.EventWaitHandle> 클래스는 로컬 이벤트 대기 핸들(로컬 이벤트) 또는 명명된 시스템 이벤트 대기 핸들(모든 프로세스에 표시되는 명명된 이벤트 또는 시스템 이벤트)을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="51b0c-107">이벤트 대기 핸들은 .NET [이벤트](../events/index.md)가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="51b0c-108">관련된 대리자 또는 이벤트 처리기가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="51b0c-109">“이벤트”라는 단어는 기존에는 운영 체제 이벤트라고 했고 대기 핸들에 신호를 보내는 동작이 이벤트가 발생한 대기 스레드를 나타내기 때문에 이벤트를 설명하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="51b0c-110">로컬 및 명명된 이벤트 대기 핸들은 모두 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 래퍼로 보호되는 시스템 동기화 개체를 사용하여 리소스가 해제되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="51b0c-111"><xref:System.Threading.WaitHandle.Dispose%2A> 메서드를 사용하여 개체 사용을 완료했을 때 즉시 리소스를 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="51b0c-112">자동으로 다시 설정되는 이벤트 대기 핸들</span><span class="sxs-lookup"><span data-stu-id="51b0c-112">Event Wait Handles That Reset Automatically</span></span>  

 <span data-ttu-id="51b0c-113"><xref:System.Threading.EventWaitHandle> 개체를 만들 때 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>을 지정하여 자동 재설정 이벤트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="51b0c-114">이름에서 알 수 있듯이 단일 대기 스레드를 해제한 후에 신호를 받으면 이 동기화 이벤트가 자동으로 다시 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="51b0c-115"><xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 호출하여 이벤트에 신호를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="51b0c-116">자동 재설정 이벤트는 일반적으로 한 번에 하나의 스레드에만 리소스에 대한 액세스를 제공하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="51b0c-117">스레드는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 호출하여 리소스를 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="51b0c-118">다른 스레드가 대기 핸들을 보유하고 있지 않으면 메서드는 `true`를 반환하고 호출 스레드가 리소스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="51b0c-119">모든 동기화 메커니즘과 마찬가지로 보호된 리소스에 액세스하기 전에 모든 코드 경로가 적절한 대기 핸들에서 대기하도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="51b0c-120">스레드 동기화는 협조적입니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="51b0c-121">대기 중인 스레드가 없을 때 신호를 받은 자동 재설정 이벤트는 스레드가 이 이벤트에서 대기를 시도할 때까지 신호를 받은 것으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="51b0c-122">이벤트는 스레드를 해제하고 즉시 다시 설정되어 후속 스레드를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="51b0c-123">수동으로 다시 설정되는 이벤트 대기 핸들</span><span class="sxs-lookup"><span data-stu-id="51b0c-123">Event Wait Handles That Reset Manually</span></span>  

 <span data-ttu-id="51b0c-124"><xref:System.Threading.EventWaitHandle> 개체를 만들 때 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>을 지정하여 수동 재설정 이벤트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="51b0c-125">이름에서 알 수 있듯이 신호를 받은 후 이 동기화 이벤트를 수동으로 다시 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="51b0c-126">이벤트가 다시 설정될 때까지는 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드를 호출하면 이벤트 핸들에서 대기하는 스레드가 차단 없이 즉시 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="51b0c-127">수동 재설정 이벤트는 울타리 문처럼 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="51b0c-128">이벤트가 신호를 받지 않으면 울타리 안의 말처럼 이벤트에서 대기하는 스레드가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="51b0c-129">이벤트가 신호를 받은 경우 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 호출하면 모든 대기 스레드가 해제되어 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="51b0c-130">이 이벤트는 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드가 호출될 때까지 신호를 받은 것으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="51b0c-131">이 덕분에 수동 재설정 이벤트는 한 스레드가 작업을 완료할 때까지 대기해야 하는 스레드를 지연시키는 적합한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="51b0c-132">울타리를 떠나는 말들처럼 해제된 스레드가 운영 체제에 의해 예약되고 실행을 재개하는 데는 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="51b0c-133">모든 스레드가 실행을 재개하기 전에 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드가 호출되면 나머지 스레드가 다시 한번 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="51b0c-134">재개되는 스레드와 차단되는 스레드는 시스템에 대한 로드, 스케줄러를 기다리는 스레드 수 등의 임의 요소에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="51b0c-135">이는 이벤트에 신호를 보내는 스레드가 신호를 보낸 후 종료될 경우의 문제가 아니라, 가장 일반적인 사용 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="51b0c-136">이벤트에 신호를 보낸 스레드가 모든 대기 스레드가 재기된 후 새 작업을 시작하도록 하려면 해당 스레드를 모든 대기 스레드가 재개될 때까지 차단해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="51b0c-137">그렇지 않으면 경합 상태가 있어서 코드의 동작을 예측할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="51b0c-138">자동 및 수동 이벤트에 공통적인 기능</span><span class="sxs-lookup"><span data-stu-id="51b0c-138">Features Common to Automatic and Manual Events</span></span>  

 <span data-ttu-id="51b0c-139">일반적으로 차단이 해제된 스레드가 대기 스레드 중 하나(자동 재설정 이벤트의 경우) 또는 모든 대기 스레드(수동 재설정 이벤트의 경우)를 해제하는 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 호출할 때까지 하나 이상의 스레드가 <xref:System.Threading.EventWaitHandle>에서 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="51b0c-140">스레드는 <xref:System.Threading.EventWaitHandle>에 신호를 보낸 다음, 정적 <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> 메서드를 호출하여 이 개체에서 원자성 작업으로 차단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="51b0c-141"><xref:System.Threading.EventWaitHandle> 개체는 정적 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 메서드와 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="51b0c-142"><xref:System.Threading.EventWaitHandle> 및 <xref:System.Threading.Mutex> 클래스는 모두 <xref:System.Threading.WaitHandle>에서 파생되므로 두 클래스를 모두 이러한 방법으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="51b0c-143">명명된 이벤트</span><span class="sxs-lookup"><span data-stu-id="51b0c-143">Named Events</span></span>  

 <span data-ttu-id="51b0c-144">Windows 운영 체제에서는 이벤트 대기 핸들에 이름을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="51b0c-145">명명된 이벤트는 시스템 전체에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-145">A named event is system wide.</span></span> <span data-ttu-id="51b0c-146">즉, 명명된 이벤트가 만들어지면 모든 프로세스의 모든 스레드에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="51b0c-147">따라서 명명된 이벤트는 스레드뿐 아니라 프로세스의 활동을 동기화하는 데도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="51b0c-148">이벤트 이름을 지정하는 생성자 중 하나를 사용하여 명명된 시스템 이벤트를 나타내는 <xref:System.Threading.EventWaitHandle> 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="51b0c-149">명명된 이벤트는 시스템 전체 이벤트이므로 같은 명명된 이벤트를 나타내는 <xref:System.Threading.EventWaitHandle> 개체를 여러 개 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="51b0c-150">생성자 또는 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 메서드를 호출할 때마다 새 <xref:System.Threading.EventWaitHandle> 개체가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="51b0c-151">같은 이름을 반복적으로 지정하면 같은 명명된 이벤트를 나타내는 개체가 여러 개 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="51b0c-152">명명된 이벤트를 사용할 경우 주의하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-152">Caution is advised in using named events.</span></span> <span data-ttu-id="51b0c-153">이러한 이벤트는 시스템 전체 이벤트이므로 같은 이름을 사용하는 다른 프로세스가 예기치 않게 스레드를 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="51b0c-154">그러면 동일 컴퓨터에서 실행되는 악성 코드가 이를 악용해 서비스 거부 공격을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="51b0c-155">명명된 이벤트를 나타내는 <xref:System.Threading.EventWaitHandle> 개체를 보호하려면 액세스 제어 보안을 사용합니다. 이때 <xref:System.Security.AccessControl.EventWaitHandleSecurity> 개체를 지정하는 생성자를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="51b0c-156"><xref:System.Threading.EventWaitHandle.SetAccessControl%2A> 메서드를 사용하여 액세스 제어 보안을 적용할 수도 있지만 이렇게 하면 이벤트 작성 시간과 보호가 적용되는 시간 사이에 취약한 기간이 생기게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="51b0c-157">액세스 제어 보안을 통해 이벤트를 보호하면 악의적인 공격을 방지할 수는 있지만 의도하지 않은 이름 충돌 문제는 해결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="51b0c-158"><xref:System.Threading.EventWaitHandle> 클래스와 달리 파생된 클래스 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent>는 로컬 대기 핸들만 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="51b0c-159">명명된 시스템 이벤트를 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="51b0c-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="51b0c-160">참고 항목</span><span class="sxs-lookup"><span data-stu-id="51b0c-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
