---
title: 참조 어셈블리
description: 라이브러리의 공용 API 화면만 포함하는 .NET에서 특수한 형식의 어셈블리인 참조 어셈블리에 대해 알아봅니다.
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.openlocfilehash: 2f7f026c7fca4b772be85671dcc3a2a6d50a385c
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94831054"
---
# <a name="reference-assemblies"></a><span data-ttu-id="8ba9e-103">참조 어셈블리</span><span class="sxs-lookup"><span data-stu-id="8ba9e-103">Reference assemblies</span></span>

<span data-ttu-id="8ba9e-104">*참조 어셈블리* 는 라이브러리의 공용 API 화면을 나타내는 데 필요한 최소한의 메타데이터만 포함하는 특수한 형식의 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="8ba9e-105">빌드 도구에서 어셈블리를 참조할 때 중요한 모든 멤버에 대한 선언을 포함하지만, 해당 API 계약에 영향을 미치지 않는 프라이빗 멤버의 선언과 모든 멤버 구현은 제외됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="8ba9e-106">반면 일반 어셈블리는 *구현 어셈블리* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="8ba9e-107">참조 어셈블리는 실행을 위해 로드할 수 없지만 구현 어셈블리와 동일한 방식으로 컴파일러 입력으로 전달될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="8ba9e-108">참조 어셈블리는 일반적으로 특정 플랫폼 또는 라이브러리의 SDK(소프트웨어 개발 키트)를 사용하여 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="8ba9e-109">참조 어셈블리를 사용하면 개발자는 해당 버전에 대한 전체 구현 어셈블리 없이도 특정 라이브러리 버전을 대상으로 하는 프로그램을 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="8ba9e-110">컴퓨터에 최신 버전의 라이브러리만 있지만 해당 라이브러리의 이전 버전을 대상으로 하는 프로그램을 빌드하려고 한다고 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="8ba9e-111">구현 어셈블리에 대해 직접 컴파일하는 경우 이전 버전에서 사용할 수 없는 API 멤버를 예기치 않게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="8ba9e-112">대상 컴퓨터에서 프로그램을 테스트하는 경우에만 이 오류를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="8ba9e-113">이전 버전의 참조 어셈블리에 대해 컴파일하는 경우 컴파일 시간 오류가 즉시 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="8ba9e-114">또한, 참조 어셈블리는 계약, 즉 구체적인 구현 어셈블리에 해당하지 않는 API 집합을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="8ba9e-115">*계약 어셈블리* 라고 하는 이러한 참조 어셈블리는 동일한 API 집합을 지원하는 여러 플랫폼을 대상으로 지정하는 데 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="8ba9e-116">예를 들어 .NET Standard는 서로 다른 .NET 플랫폼 간에 공유되는 공통 API 집합을 나타내는 계약 어셈블리 *netstandard.dll* 을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="8ba9e-117">이러한 API의 구현은 .NET Framework의 *mscorlib.dll* 또는 .NET Core의 *System.Private.CoreLib.dll* 과 같이 다른 플랫폼의 다른 어셈블리에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="8ba9e-118">.NET Standard를 대상으로 하는 라이브러리는 .NET Standard를 지원하는 모든 플랫폼에서 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="8ba9e-119">참조 어셈블리 사용</span><span class="sxs-lookup"><span data-stu-id="8ba9e-119">Using reference assemblies</span></span>

<span data-ttu-id="8ba9e-120">프로젝트에서 특정 API를 사용하려면 해당 어셈블리에 대한 참조를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="8ba9e-121">구현 어셈블리 또는 참조 어셈블리에 참조를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="8ba9e-122">참조 어셈블리를 사용할 수 있을 때마다 이 어셈블리를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="8ba9e-123">이렇게 하면 API 디자이너가 사용하도록 지정된 대상 버전에서 지원되는 API 멤버만 사용하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="8ba9e-124">참조 어셈블리를 사용하면 구현 세부 정보에 대한 종속성을 사용하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="8ba9e-125">.NET Framework 라이브러리의 참조 어셈블리는 대상 팩과 함께 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="8ba9e-126">독립 실행형 설치 관리자를 다운로드하거나 Visual Studio 설치 관리자에서 구성 요소를 선택하여 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="8ba9e-127">자세한 내용은 [개발자용 .NET Framework 설치](../../framework/install/guide-for-developers.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="8ba9e-128">.NET Core 및 .NET Standard의 경우 참조 어셈블리는 필요에 따라(NuGet을 통해) 자동으로 다운로드되고 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="8ba9e-129">.NET Core 3.0 이상의 경우 핵심 프레임워크의 참조 어셈블리는 [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) 패키지에 있습니다([Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) 패키지는 3.0 이전 버전에 대신 사용됨).</span><span class="sxs-lookup"><span data-stu-id="8ba9e-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span>

<span data-ttu-id="8ba9e-130">**참조 추가** 대화 상자를 사용하여 Visual Studio에서 .NET Framework 어셈블리에 대한 참조를 추가하는 경우 목록에서 어셈블리를 선택하면 Visual Studio는 프로젝트에서 선택한 대상 프레임워크 버전에 해당하는 참조 어셈블리를 자동으로 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-130">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="8ba9e-131">[참조](/visualstudio/msbuild/common-msbuild-project-items#reference) 프로젝트 항목을 사용하여 MSBuild 프로젝트에 참조를 직접 추가하는 경우에도 동일하게 적용됩니다. 전체 파일 경로가 아닌 어셈블리 이름만 지정하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-131">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="8ba9e-132">`-reference` 컴파일러 옵션([C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) 및 [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md))을 사용하거나 Roslyn API의 <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> 메서드를 사용하여 명령줄에서 이러한 어셈블리에 대한 참조를 추가할 때 올바른 대상 플랫폼 버전에 대한 참조 어셈블리 파일을 수동으로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-132">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="8ba9e-133">.NET Framework 참조 어셈블리 파일은 *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* 디렉터리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-133">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="8ba9e-134">.NET Core의 경우 `PreserveCompilationContext` 프로젝트 속성을 `true`로 설정하여 게시 작업이 대상 플랫폼의 참조 어셈블리를 출력 디렉터리의 *publish/refs* 하위 디렉터리로 복사하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-134">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="8ba9e-135">그런 다음 이러한 참조 어셈블리 파일을 컴파일러에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-135">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="8ba9e-136">[Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) 패키지에서 `DependencyContext`를 사용하면 해당 경로를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-136">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="8ba9e-137">여기에는 구현이 포함되어 있지 않으므로 참조 어셈블리를 로드하여 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-137">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="8ba9e-138">실행하려고 하면 <xref:System.BadImageFormatException?displayProperty=nameWithType>이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-138">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8ba9e-139">참조 어셈블리의 내용을 검사하려면 .NET Framework(<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 메서드 사용)의 리플렉션 전용 컨텍스트나 .NET Core의 <xref:System.Reflection.MetadataLoadContext>에 로드하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-139">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="8ba9e-140">참조 어셈블리 생성</span><span class="sxs-lookup"><span data-stu-id="8ba9e-140">Generating reference assemblies</span></span>

<span data-ttu-id="8ba9e-141">라이브러리 사용자가 여러 버전의 라이브러리에 대해 프로그램을 빌드해야 하는 경우 라이브러리의 참조 어셈블리를 생성하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="8ba9e-142">이러한 모든 버전에 대한 구현 어셈블리를 배포하는 것은 크기가 크기 때문에 실용적이지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="8ba9e-143">참조 어셈블리는 크기가 작으므로 라이브러리 SDK의 일부로 배포하면 다운로드 크기가 줄어들고 디스크 공간이 절약됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="8ba9e-144">여러 클래스 라이브러리로 구성된 대규모 솔루션의 경우 IDE와 빌드 도구는 참조 어셈블리를 활용하여 빌드 시간을 단축할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="8ba9e-145">일반적으로 증분 빌드 시나리오에서는 프로젝트가 종속된 어셈블리를 포함하여 입력 파일이 변경될 때 프로젝트가 다시 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="8ba9e-146">구현 어셈블리는 프로그래머가 모든 멤버의 구현을 변경할 때마다 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="8ba9e-147">참조 어셈블리는 공용 API가 영향을 받는 경우에만 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="8ba9e-148">따라서 구현 어셈블리 대신 참조 어셈블리를 입력 파일로 사용하면 경우에 따라 종속 프로젝트의 빌드를 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="8ba9e-149">다음과 같이 참조 어셈블리를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="8ba9e-150">MSBuild 프로젝트에서 [`ProduceReferenceAssembly`프로젝트 속성](/visualstudio/msbuild/common-msbuild-project-properties)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="8ba9e-151">명령줄에서 프로그램을 컴파일하는 경우 `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md)) 또는 `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) 컴파일러 옵션을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="8ba9e-152">Roslyn API를 사용하는 경우 <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> 메서드에 전달된 개체의 <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType>를 `true`로 설정하고 <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType>를 `false`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="8ba9e-153">NuGet 패키지와 함께 참조 어셈블리를 배포하려는 경우 구현 어셈블리에 사용된 *lib\\* 하위 디렉터리 대신 패키지 디렉터리 아래의 *ref\\* 하위 디렉터리에 참조 어셈블리를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="8ba9e-154">참조 어셈블리 구조</span><span class="sxs-lookup"><span data-stu-id="8ba9e-154">Reference assemblies structure</span></span>

<span data-ttu-id="8ba9e-155">참조 어셈블리는 관련 개념인 *메타데이터 전용 어셈블리* 의 확장입니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="8ba9e-156">메타데이터 전용 어셈블리에는 단일 `throw null` 본문으로 대체되는 메서드 본문이 있지만 익명 형식을 제외한 모든 멤버가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="8ba9e-157">본문이 없는 경우와 대조적으로 `throw null` 본문을 사용하는 이유는 **PEVerify** 가 실행 및 전달될 수 있도록 하여 메타데이터의 완전성을 검증하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="8ba9e-158">참조 어셈블리는 메타데이터 프라이빗 어셈블리에서 메타데이터(전용 멤버)를 추가로 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="8ba9e-159">참조 어셈블리에는 API 화면에 있어야 하는 항목에 대한 참조만 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="8ba9e-160">실제 어셈블리에는 특정 구현에 관련된 추가 참조가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="8ba9e-161">예를 들어, `class C { private void M() { dynamic d = 1; ... } }`에 대한 참조 어셈블리는 `dynamic`에 필요한 형식을 참조하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="8ba9e-162">제거가 컴파일에 눈에 띄는 영향을 미치지 않을 경우 전용 함수-멤버(메서드, 속성 및 이벤트)가 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="8ba9e-163">[InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) 특성이 없으면 내부 함수 멤버도 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="8ba9e-164">참조 어셈블리의 메타데이터는 다음 정보를 계속 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="8ba9e-165">비공개 및 중첩 형식을 포함한 모든 형식.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="8ba9e-166">모든 특성(내부 특성인 경우에도 해당).</span><span class="sxs-lookup"><span data-stu-id="8ba9e-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="8ba9e-167">모든 가상 메서드.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-167">All virtual methods.</span></span>
- <span data-ttu-id="8ba9e-168">명시적 인터페이스 구현.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="8ba9e-169">명시적으로 구현된 속성 및 이벤트(해당 접근자가 가상이기 때문).</span><span class="sxs-lookup"><span data-stu-id="8ba9e-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="8ba9e-170">구조체의 모든 필드.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-170">All fields of structures.</span></span>

<span data-ttu-id="8ba9e-171">참조 어셈블리에는 어셈블리 수준 [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) 특성이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="8ba9e-172">이 특성을 소스에서 지정할 수 있습니다. 이렇게 하면 컴파일러가 특성을 합성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="8ba9e-173">이 특성으로 인해 런타임은 실행용 참조 어셈블리 로드를 거부합니다. 그러나 리플렉션 전용 모드에서 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="8ba9e-174">정확한 참조 어셈블리 구조 정보는 컴파일러 버전에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="8ba9e-175">최신 버전은 공용 API 화면에 영향을 미치지 않는 것으로 확인되는 경우 더 많은 메타데이터를 제외하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="8ba9e-176">이 섹션의 정보는 C# 버전 7.1 또는 Visual Basic 버전 15.3부터 Roslyn 컴파일러가 생성한 참조 어셈블리에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="8ba9e-177">.NET Framework 및 .NET Core 라이브러리의 참조 어셈블리 구조는 자체적으로 참조 어셈블리를 생성하는 메커니즘을 사용하므로 일부 세부 정보가 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="8ba9e-178">예를 들어 `throw null` 본문이 아닌 완전히 빈 메서드 본문이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="8ba9e-179">그러나 일반적인 원칙은 여전히 적용됩니다. 사용 가능한 메서드 구현이 없고 공개 API 관점에서 관찰 가능한 영향을 미치는 멤버에 대한 메타데이터만 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="8ba9e-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="8ba9e-180">참조</span><span class="sxs-lookup"><span data-stu-id="8ba9e-180">See also</span></span>

- [<span data-ttu-id="8ba9e-181">.NET 어셈블리</span><span class="sxs-lookup"><span data-stu-id="8ba9e-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="8ba9e-182">Framework 대상 지정 개요</span><span class="sxs-lookup"><span data-stu-id="8ba9e-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="8ba9e-183">방법: 참조 관리자를 사용하여 참조 추가 또는 제거</span><span class="sxs-lookup"><span data-stu-id="8ba9e-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
