---
title: 데이터 흐름(작업 병렬 라이브러리)
description: TPL(작업 병렬 라이브러리)에서 데이터 흐름 구성 요소를 사용하여 동시성 사용 애플리케이션을 더 견고하게 하는 방법을 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 67b5cfaa987b3f37d68597d22ad5f87e8d1bd018
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95728695"
---
# <a name="dataflow-task-parallel-library"></a><span data-ttu-id="d6e25-103">데이터 흐름(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="d6e25-103">Dataflow (Task Parallel Library)</span></span>

<span data-ttu-id="d6e25-104">TPL(작업 병렬 라이브러리)은 동시성 사용 애플리케이션의 견고성을 높이는 데 도움이 되는 데이터 흐름 구성 요소를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-104">The Task Parallel Library (TPL) provides dataflow components to help increase the robustness of concurrency-enabled applications.</span></span> <span data-ttu-id="d6e25-105">이러한 데이터 흐름 구성 요소를 통칭하여 *TPL 데이터 흐름 라이브러리* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-105">These dataflow components are collectively referred to as the *TPL Dataflow Library*.</span></span> <span data-ttu-id="d6e25-106">이 데이터 흐름 모델은 정교하지 않은 데이터 흐름 및 파이프라인 작업을 위해 in-process 메시지 전달을 제공하여 행위자 기반 프로그래밍을 촉진합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-106">This dataflow model promotes actor-based programming by providing in-process message passing for coarse-grained dataflow and pipelining tasks.</span></span> <span data-ttu-id="d6e25-107">데이터 흐름 구성 요소는 TPL의 형식 및 예약 인프라를 바탕으로 빌드되며 비동기 프로그래밍에 대한 C#, Visual Basic 및 F# 언어 지원과 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-107">The dataflow components build on the types and scheduling infrastructure of the TPL and integrate with the C#, Visual Basic, and F# language support for asynchronous programming.</span></span> <span data-ttu-id="d6e25-108">이러한 데이터 흐름 구성 요소는 비동기적으로 서로 통신해야 하는 여러 작업이 있는 경우나 데이터를 사용할 수 있게 될 때 해당 데이터를 처리하려는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-108">These dataflow components are useful when you have multiple operations that must communicate with one another asynchronously or when you want to process data as it becomes available.</span></span> <span data-ttu-id="d6e25-109">예를 들어 웹 카메라에서 이미지 데이터를 처리하는 애플리케이션의 경우,</span><span class="sxs-lookup"><span data-stu-id="d6e25-109">For example, consider an application that processes image data from a web camera.</span></span> <span data-ttu-id="d6e25-110">데이터 흐름 모델을 사용함으로써 애플리케이션은 이미지 프레임을 사용할 수 있게 될 때 해당 이미지 프레임을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-110">By using the dataflow model, the application can process image frames as they become available.</span></span> <span data-ttu-id="d6e25-111">애플리케이션이 명도를 보정하거나 적목 현상을 줄이는 등의 작업을 수행하여 이미지 프레임을 개선하는 경우 데이터 흐름 구성 요소의 *파이프라인* 을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-111">If the application enhances image frames, for example, by performing light correction or red-eye reduction, you can create a *pipeline* of dataflow components.</span></span> <span data-ttu-id="d6e25-112">파이프라인의 각 단계에서는 TPL이 제공하는 기능과 같은 좀더 정교하지 않은 병렬 처리 기능을 사용하여 이미지를 변환할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-112">Each stage of the pipeline might use more coarse-grained parallelism functionality, such as the functionality that is provided by the TPL, to transform the image.</span></span>  
  
 <span data-ttu-id="d6e25-113">이 문서에서는 TPL 데이터 흐름 라이브러리에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-113">This document provides an overview of the TPL Dataflow Library.</span></span> <span data-ttu-id="d6e25-114">여기에서는 프로그래밍 모델, 미리 정의된 데이터 흐름 블록 형식 및 애플리케이션의 특정 요구 사항을 충족하도록 데이터 흐름 블록을 구성하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-114">It describes the programming model, the predefined dataflow block types, and how to configure dataflow blocks to meet the specific requirements of your applications.</span></span>  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a><span data-ttu-id="d6e25-115">프로그래밍 모델</span><span class="sxs-lookup"><span data-stu-id="d6e25-115">Programming Model</span></span>

 <span data-ttu-id="d6e25-116">TPL 데이터 흐름 라이브러리는 처리량이 많고 대기 시간이 짧으며 CPU 및 I/O를 많이 사용하는 애플리케이션의 메시지 전달 및 병렬화를 위한 기반을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-116">The TPL Dataflow Library provides a foundation for message passing and parallelizing CPU-intensive and I/O-intensive applications that have high throughput and low latency.</span></span> <span data-ttu-id="d6e25-117">또한 데이터가 버퍼링되고 시스템에서 이동하는 방식을 명시적으로 제어할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-117">It also gives you explicit control over how data is buffered and moves around the system.</span></span> <span data-ttu-id="d6e25-118">데이터 흐름 프로그래밍 모델을 보다 정확히 이해하려면 디스크에서 이미지를 비동기적으로 로드하고 해당 이미지의 합성을 만드는 애플리케이션을 고려해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="d6e25-118">To better understand the dataflow programming model, consider an application that asynchronously loads images from disk and creates a composite of those images.</span></span> <span data-ttu-id="d6e25-119">기존의 프로그래밍 모델에서는 대개 콜백과 동기화 개체(예: 잠금)를 사용하여 작업을 조정하고 공유 데이터에 액세스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-119">Traditional programming models typically require that you use callbacks and synchronization objects, such as locks, to coordinate tasks and access to shared data.</span></span> <span data-ttu-id="d6e25-120">데이터 흐름 프로그래밍 모델을 사용하면 디스크에서 이미지를 읽을 때 해당 이미지를 처리하는 데이터 흐름 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-120">By using the dataflow programming model, you can create dataflow objects that process images as they are read from disk.</span></span> <span data-ttu-id="d6e25-121">데이터 흐름 모델에서는 데이터를 사용할 수 있게 될 때 데이터가 처리되는 방법과 데이터 간의 종속성도 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-121">Under the dataflow model, you declare how data is handled when it becomes available, and also any dependencies between data.</span></span> <span data-ttu-id="d6e25-122">런타임에서 데이터 간의 종속성을 관리하기 때문에 대개 공유 데이터에 대한 액세스를 동기화할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-122">Because the runtime manages dependencies between data, you can often avoid the requirement to synchronize access to shared data.</span></span> <span data-ttu-id="d6e25-123">또한 런타임에서 데이터의 비동기 도착을 기준으로 작업을 예약하기 때문에 데이터 흐름은 내부 스레드를 효율적으로 관리하여 응답성과 처리량을 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-123">In addition, because the runtime schedules work based on the asynchronous arrival of data, dataflow can improve responsiveness and throughput by efficiently managing the underlying threads.</span></span> <span data-ttu-id="d6e25-124">데이터 흐름 프로그래밍 모델을 사용하여 Windows Forms 애플리케이션에서 이미지 처리를 구현하는 예제는 [연습: Windows Forms 애플리케이션에서 데이터 흐름 사용](walkthrough-using-dataflow-in-a-windows-forms-application.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-124">For an example that uses the dataflow programming model to implement image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
### <a name="sources-and-targets"></a><span data-ttu-id="d6e25-125">소스 및 대상</span><span class="sxs-lookup"><span data-stu-id="d6e25-125">Sources and Targets</span></span>  

 <span data-ttu-id="d6e25-126">TPL 데이터 흐름 라이브러리는 데이터를 버퍼링하고 처리하는 데이터 구조인 *데이터 흐름 블록* 으로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-126">The TPL Dataflow Library consists of *dataflow blocks*, which are data structures that buffer and process data.</span></span> <span data-ttu-id="d6e25-127">TPL은 세 가지 데이터 흐름 블록인 *소스 블록*, *대상 블록* 및 *전파자 블록* 을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-127">The TPL defines three kinds of dataflow blocks: *source blocks*, *target blocks*, and *propagator blocks*.</span></span> <span data-ttu-id="d6e25-128">소스 블록은 데이터의 소스 역할을 하며 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-128">A source block acts as a source of data and can be read from.</span></span> <span data-ttu-id="d6e25-129">대상 블록은 데이터의 수신자 역할을 하며 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-129">A target block acts as a receiver of data and can be written to.</span></span> <span data-ttu-id="d6e25-130">전파자 블록은 소스 블록과 대상 블록 역할을 하며 읽고 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-130">A propagator block acts as both a source block and a target block, and can be read from and written to.</span></span> <span data-ttu-id="d6e25-131">TPL은 소스를 나타내는 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> 인터페이스, 대상을 나타내는 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> 및 전파자를 나타내는 <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType>을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-131">The TPL defines the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> interface to represent sources, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> to represent targets, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> to represent propagators.</span></span> <span data-ttu-id="d6e25-132"><xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>은 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 및 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 모두에서 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-132"><xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> inherits from both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span>  
  
 <span data-ttu-id="d6e25-133">TPL 데이터 흐름 라이브러리는 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 및 <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> 인터페이스를 구현하는 몇 가지 미리 정의된 데이터 흐름 블록 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-133">The TPL Dataflow Library provides several predefined dataflow block types that implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, and <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces.</span></span> <span data-ttu-id="d6e25-134">이러한 데이터 흐름 블록 형식은 이 문서의 [미리 정의된 데이터 흐름 블록 형식](#predefined-dataflow-block-types) 섹션에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-134">These dataflow block types are described in this document in the section [Predefined Dataflow Block Types](#predefined-dataflow-block-types).</span></span>  
  
### <a name="connecting-blocks"></a><span data-ttu-id="d6e25-135">블록 연결</span><span class="sxs-lookup"><span data-stu-id="d6e25-135">Connecting Blocks</span></span>  

 <span data-ttu-id="d6e25-136">데이터 흐름 블록의 선형 시퀀스인 *파이프라인* 이나 데이터 흐름 블록의 그래프인 *네트워크* 를 만들기 위해 데이터 흐름 블록을 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-136">You can connect dataflow blocks to form *pipelines*, which are linear sequences of dataflow blocks, or *networks*, which are graphs of dataflow blocks.</span></span> <span data-ttu-id="d6e25-137">파이프라인은 네트워크의 한 형태입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-137">A pipeline is one form of network.</span></span> <span data-ttu-id="d6e25-138">파이프라인 또는 네트워크에서 소스는 데이터를 사용할 수 있게 되면 대상에 데이터를 비동기적으로 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-138">In a pipeline or network, sources asynchronously propagate data to targets as that data becomes available.</span></span> <span data-ttu-id="d6e25-139"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> 메서드는 소스 데이터 흐름 블록을 대상 블록에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-139">The <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method links a source dataflow block to a target block.</span></span> <span data-ttu-id="d6e25-140">소스는 0개 이상의 대상에 연결될 수 있으며, 대상은 0개 이상의 소스에서 연결될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-140">A source can be linked to zero or more targets; targets can be linked from zero or more sources.</span></span> <span data-ttu-id="d6e25-141">파이프라인 또는 네트워크에서 데이터 흐름 블록을 동시에 추가하거나 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-141">You can add or remove dataflow blocks to or from a pipeline or network concurrently.</span></span> <span data-ttu-id="d6e25-142">미리 정의된 데이터 흐름 블록 형식은 연결 및 연결 해제의 모든 스레드로부터의 안전성 측면을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-142">The predefined dataflow block types handle all thread-safety aspects of linking and unlinking.</span></span>  
  
 <span data-ttu-id="d6e25-143">데이터 흐름 블록을 연결하여 기본 파이프라인을 만드는 예제는 [연습: 데이터 흐름 파이프라인 만들기](walkthrough-creating-a-dataflow-pipeline.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-143">For an example that connects dataflow blocks to form a basic pipeline, see [Walkthrough: Creating a Dataflow Pipeline](walkthrough-creating-a-dataflow-pipeline.md).</span></span> <span data-ttu-id="d6e25-144">데이터 흐름 블록을 연결하여 보다 복잡한 네트워크를 만드는 예제는 [연습: Windows Forms 애플리케이션에서 데이터 흐름 사용](walkthrough-using-dataflow-in-a-windows-forms-application.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-144">For an example that connects dataflow blocks to form a more complex network, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span> <span data-ttu-id="d6e25-145">소스가 대상에 메시지를 제공한 후 소스에서 대상의 연결을 해제하는 예제는 [방법: 데이터 흐름 블록 링크 끊기](how-to-unlink-dataflow-blocks.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-145">For an example that unlinks a target from a source after the source offers the target a message, see [How to: Unlink Dataflow Blocks](how-to-unlink-dataflow-blocks.md).</span></span>  
  
#### <a name="filtering"></a><span data-ttu-id="d6e25-146">필터링</span><span class="sxs-lookup"><span data-stu-id="d6e25-146">Filtering</span></span>  

 <span data-ttu-id="d6e25-147"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> 메서드를 호출하여 소스를 대상에 연결하는 경우 대상 블록이 메시지의 값에 따라 해당 메시지를 수락할지 아니면 거부할지를 결정하는 대리자를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-147">When you call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> method to link a source to a target, you can supply a delegate that determines whether the target block accepts or rejects a message based on the value of that message.</span></span> <span data-ttu-id="d6e25-148">이 필터링 메커니즘은 데이터 흐름 블록이 특정 값만 받도록 보장하는 유용한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-148">This filtering mechanism is a useful way to guarantee that a dataflow block receives only certain values.</span></span> <span data-ttu-id="d6e25-149">대부분의 미리 정의된 데이터 흐름 블록 형식의 경우 소스 블록이 여러 대상 블록에 연결되어 있으면 대상 블록이 메시지를 거부할 때 소스는 그 다음 대상에 해당 메시지를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-149">For most of the predefined dataflow block types, if a source block is connected to multiple target blocks, when a target block rejects a message, the source offers that message to the next target.</span></span> <span data-ttu-id="d6e25-150">소스가 대상에 메시지를 제공하는 순서는 소스에 의해 정의되며 소스의 형식에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-150">The order in which a source offers messages to targets is defined by the source and can vary according to the type of the source.</span></span> <span data-ttu-id="d6e25-151">대부분의 소스 블록 형식은 한 대상이 메시지를 수락할 후 해당 메시지의 제공을 중지합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-151">Most source block types stop offering a message after one target accepts that message.</span></span> <span data-ttu-id="d6e25-152">이 규칙의 한 가지 예외는 일부 대상이 메시지를 거부하는 경우에도 모든 대상에 각 메시지를 제공하는 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-152">One exception to this rule is the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, which offers each message to all targets, even if some targets reject the message.</span></span> <span data-ttu-id="d6e25-153">필터링을 사용하여 특정 메시지만 처리하는 예제는 [연습: Windows Forms 애플리케이션에서 데이터 흐름 사용](walkthrough-using-dataflow-in-a-windows-forms-application.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-153">For an example that uses filtering to process only certain messages, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="d6e25-154">미리 정의된 각 소스 데이터 흐름 블록 형식은 메시지가 수신된 순서대로 전파되도록 보장하기 때문에 각 메시지를 소스 블록에서 읽어온 후에야 소스 블록이 다음 메시지를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-154">Because each predefined source dataflow block type guarantees that messages are propagated out in the order in which they are received, every message must be read from the source block before the source block can process the next message.</span></span> <span data-ttu-id="d6e25-155">따라서 필터링을 사용하여 여러 대상을 소스에 연결하는 경우 적어도 하나의 대상 블록이 각 메시지를 받는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-155">Therefore, when you use filtering to connect multiple targets to a source, make sure that at least one target block receives each message.</span></span> <span data-ttu-id="d6e25-156">이렇게 하지 않으면 애플리케이션에서 교착 상태가 발생할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-156">Otherwise, your application might deadlock.</span></span>  
  
### <a name="message-passing"></a><span data-ttu-id="d6e25-157">메시지 전달</span><span class="sxs-lookup"><span data-stu-id="d6e25-157">Message Passing</span></span>  

 <span data-ttu-id="d6e25-158">데이터 흐름 프로그래밍 모델은 프로그램의 개별 구성 요소가 메시지를 전달하여 서로 통신하는 *메시지 전달* 개념과 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-158">The dataflow programming model is related to the concept of *message passing*, where independent components of a program communicate with one another by sending messages.</span></span> <span data-ttu-id="d6e25-159">애플리케이션 구성 요소 간에 메시지를 전파하는 한 가지 방법은 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> 및 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> 메서드를 호출하여 대상 데이터 흐름 블록 게시에 메시지를 보내고(<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A>는 동기적으로 동작함, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A>는 비동기적으로 동작함), <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> 및 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> 메서드를 호출하여 소스 블록에서 메시지를 받는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-159">One way to propagate messages among application components is to call the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> methods to send messages to target dataflow blocks post (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> acts synchronously; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> acts asynchronously) and the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, and <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> methods to receive messages from source blocks.</span></span> <span data-ttu-id="d6e25-160">입력 데이터를 헤드 노드(대상 블록)에 보내고 출력 데이터를 파이프라인의 터미널 노드나 네트워크의 터미널 노드(하나 이상의 소스 블록)에서 받는 방법으로 이러한 메서드를 데이터 흐름 파이프라인 또는 네트워크와 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-160">You can combine these methods with dataflow pipelines or networks by sending input data to the head node (a target block), and receiving output data from the terminal node of the pipeline or the terminal nodes of the network (one or more source blocks).</span></span> <span data-ttu-id="d6e25-161">또한 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> 메서드를 사용하여 제공된 소스 중에서 사용 가능한 데이터가 있는 첫 번째 소스에서 읽고 해당 데이터에 대한 작업을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-161">You can also use the <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> method to read from the first of the provided sources that has data available and perform action on that data.</span></span>  
  
 <span data-ttu-id="d6e25-162">소스 블록은 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> 메서드를 호출하여 대상 블록에 데이터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-162">Source blocks offer data to target blocks by calling the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d6e25-163">대상 블록은 세 가지 방법 중 하나로 제공된 메시지에 응답합니다. 즉, 메시지를 수락하거나, 메시지를 거부하거나, 메시지를 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-163">The target block responds to an offered message in one of three ways: it can accept the message, decline the message, or postpone the message.</span></span> <span data-ttu-id="d6e25-164">대상이 메시지를 수락하면 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 메서드가 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>를 반환하고,</span><span class="sxs-lookup"><span data-stu-id="d6e25-164">When the target accepts the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>.</span></span> <span data-ttu-id="d6e25-165">대상이 메시지를 거부하면 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 메서드가 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-165">When the target declines the message, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>.</span></span> <span data-ttu-id="d6e25-166">대상이 소스에서 더 이상 메시지를 받지 않도록 요구하는 경우에는 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A>가 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-166">When the target requires that it no longer receives any messages from the source, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>.</span></span> <span data-ttu-id="d6e25-167">미리 정의된 소스 블록 형식은 이러한 반환 값이 수신된 후 연결된 대상에 메시지를 보내지 않으며 해당 대상의 연결을 자동으로 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-167">The predefined source block types do not offer messages to linked targets after such a return value is received, and they automatically unlink from such targets.</span></span>  
  
 <span data-ttu-id="d6e25-168">대상 블록이 나중에 사용할 수 있도록 메시지를 연기하면 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> 메서드가 <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-168">When a target block postpones the message for later use, the <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> method returns <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>.</span></span> <span data-ttu-id="d6e25-169">메시지를 연기하는 대상 블록은 나중에 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> 메서드를 호출하여 제공된 메시지를 예약하려고 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-169">A target block that postpones a message can later call the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> method to try to reserve the offered message.</span></span> <span data-ttu-id="d6e25-170">이 시점에서 해당 메시지는 여전히 사용 가능하여 대상 블록이 사용할 수 있거나, 다른 대상이 사용하고 있는 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-170">At this point, the message is either still available and can be used by the target block, or the message has been taken by another target.</span></span> <span data-ttu-id="d6e25-171">대상 블록은 나중에 메시지가 필요하거나 더 이상 필요하지 않은 경우 각각 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-171">When the target block later requires the message or no longer needs the message, it calls the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> method, respectively.</span></span> <span data-ttu-id="d6e25-172">메시지 예약은 non-greedy 모드에서 작동하는 데이터 흐름 블록 형식에서 주로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-172">Message reservation is typically used by the dataflow block types that operate in non-greedy mode.</span></span> <span data-ttu-id="d6e25-173">non-greedy 모드는 이 문서의 뒷부분에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-173">Non-greedy mode is explained later in this document.</span></span> <span data-ttu-id="d6e25-174">연기된 메시지를 예약하는 대신 대상 블록은 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> 메서드를 사용하여 연기된 메시지를 직접 사용하려고 시도할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-174">Instead of reserving a postponed message, a target block can also use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType> method to attempt to directly consume the postponed message.</span></span>  
  
### <a name="dataflow-block-completion"></a><span data-ttu-id="d6e25-175">데이터 흐름 블록 완료</span><span class="sxs-lookup"><span data-stu-id="d6e25-175">Dataflow Block Completion</span></span>  

 <span data-ttu-id="d6e25-176">데이터 흐름 블록은 *완료* 개념도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-176">Dataflow blocks also support the concept of *completion*.</span></span> <span data-ttu-id="d6e25-177">완료된 상태에 있는 데이터 흐름 블록은 더 이상 작업을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-177">A dataflow block that is in the completed state does not perform any further work.</span></span> <span data-ttu-id="d6e25-178">각 데이터 흐름 블록에는 블록의 완료 상태를 나타내는 *완료 작업* 이라고 하는 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 개체가 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-178">Each dataflow block has an associated <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object, known as a *completion task*, that represents the completion status of the block.</span></span> <span data-ttu-id="d6e25-179">완료 작업을 사용하여 <xref:System.Threading.Tasks.Task> 개체가 완료될 때까지 기다릴 수 있기 때문에 데이터 흐름 네트워크의 터미널 노드 중 하나 이상이 완료될 때까지 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-179">Because you can wait for a <xref:System.Threading.Tasks.Task> object to finish, by using completion tasks, you can wait for one or more terminal nodes of a dataflow network to finish.</span></span> <span data-ttu-id="d6e25-180"><xref:System.Threading.Tasks.Dataflow.IDataflowBlock> 인터페이스는 데이터 흐름 블록에 완료 요청을 알리는 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 메서드와 데이터 흐름 블록에 대한 완료 작업을 반환하는 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-180">The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface defines the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method, which informs the dataflow block of a request for it to complete, and the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, which returns the completion task for the dataflow block.</span></span> <span data-ttu-id="d6e25-181"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 및 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 모두 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> 인터페이스를 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-181">Both <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> and <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> inherit the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface.</span></span>  
  
 <span data-ttu-id="d6e25-182">데이터 흐름 블록이 오류 없이 완료되었는지, 하나 이상의 오류가 발생했는지, 아니면 취소되었는지를 확인하는 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-182">There are two ways to determine whether a dataflow block completed without error, encountered one or more errors, or was canceled.</span></span> <span data-ttu-id="d6e25-183">첫 번째 방법은 `try`-`catch`(Visual Basic에서는 `Try`-`Catch`) 블록에서 완료 작업에 대해 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드를 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-183">The first way is to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method on the completion task in a `try`-`catch` block (`Try`-`Catch` in Visual Basic).</span></span> <span data-ttu-id="d6e25-184">다음 예제에서는 입력 값이 0보다 작은 경우 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>을 throw하는 <xref:System.ArgumentOutOfRangeException> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-184">The following example creates an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object that throws <xref:System.ArgumentOutOfRangeException> if its input value is less than zero.</span></span> <span data-ttu-id="d6e25-185">이 예제에서 완료 작업에 대해 <xref:System.AggregateException>를 호출할 때 <xref:System.Threading.Tasks.Task.Wait%2A>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-185"><xref:System.AggregateException> is thrown when this example calls <xref:System.Threading.Tasks.Task.Wait%2A> on the completion task.</span></span> <span data-ttu-id="d6e25-186"><xref:System.ArgumentOutOfRangeException>은 <xref:System.AggregateException.InnerExceptions%2A> 개체의 <xref:System.AggregateException> 속성을 통해 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-186">The <xref:System.ArgumentOutOfRangeException> is accessed through the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> object.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 <span data-ttu-id="d6e25-187">이 예제에서는 예외가 예외 데이터 흐름 블록의 대리자에서 처리되지 않는 경우를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-187">This example demonstrates the case in which an exception goes unhandled in the delegate of an execution dataflow block.</span></span> <span data-ttu-id="d6e25-188">이러한 블록의 본문에서 예외를 처리하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-188">We recommend that you handle exceptions in the bodies of such blocks.</span></span> <span data-ttu-id="d6e25-189">그러나 이렇게 할 수 없는 경우 블록은 메시지가 취소된 것처럼 동작하고 들어오는 메시지를 처리하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-189">However, if you are unable to do so, the block behaves as though it was canceled and does not process incoming messages.</span></span>  
  
 <span data-ttu-id="d6e25-190">데이터 흐름 블록이 명시적으로 취소되는 경우 <xref:System.AggregateException> 개체는 <xref:System.OperationCanceledException> 속성에 <xref:System.AggregateException.InnerExceptions%2A>을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-190">When a dataflow block is canceled explicitly, the <xref:System.AggregateException> object contains <xref:System.OperationCanceledException> in the <xref:System.AggregateException.InnerExceptions%2A> property.</span></span> <span data-ttu-id="d6e25-191">데이터 흐름 취소에 대한 자세한 내용은 [취소 사용](#enabling-cancellation) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-191">For more information about dataflow cancellation, see [Enabling Cancellation](#enabling-cancellation) section.</span></span>  
  
 <span data-ttu-id="d6e25-192">데이터 흐름 블록의 완료 상태를 확인하는 두 번째 방법은 완료 작업의 연속을 사용하거나, C# 및 Visual Basic의 비동기 언어 기능을 사용하여 완료 작업을 비동기적으로 기다리는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-192">The second way to determine the completion status of a dataflow block is to use a continuation of the completion task, or to use the asynchronous language features of C# and Visual Basic to asynchronously wait for the completion task.</span></span> <span data-ttu-id="d6e25-193"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드에 제공하는 대리자는 선행 작업을 나타내는 <xref:System.Threading.Tasks.Task> 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-193">The delegate that you provide to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method takes a <xref:System.Threading.Tasks.Task> object that represents the antecedent task.</span></span> <span data-ttu-id="d6e25-194"><xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 속성의 경우 연속의 대리자는 완료 작업 자체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-194">In the case of the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property, the delegate for the continuation takes the completion task itself.</span></span> <span data-ttu-id="d6e25-195">다음 예제는 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 메서드를 사용하여 전반적인 데이터 흐름 작업의 상태를 출력하는 연속 작업을 만드는 점을 제외하고 이전 예제와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-195">The following example resembles the previous one, except that it also uses the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method to create a continuation task that prints the status of the overall dataflow operation.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 <span data-ttu-id="d6e25-196">연속 작업의 본문에서 <xref:System.Threading.Tasks.Task.IsCanceled%2A>와 같은 속성을 사용하여 데이터 흐름 블록의 완료 상태에 대한 추가 정보를 확인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-196">You can also use properties such as <xref:System.Threading.Tasks.Task.IsCanceled%2A> in the body of the continuation task to determine additional information about the completion status of a dataflow block.</span></span> <span data-ttu-id="d6e25-197">연속 작업과 연속 작업의 취소 및 오류 처리와 관련된 방법에 대한 자세한 내용은 [연속 작업을 사용하여 작업 연결](chaining-tasks-by-using-continuation-tasks.md), [작업 취소](task-cancellation.md) 및 [예외 처리](exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-197">For more information about continuation tasks and how they relate to cancellation and error handling, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md), [Task Cancellation](task-cancellation.md), and [Exception Handling](exception-handling-task-parallel-library.md).</span></span>  

## <a name="predefined-dataflow-block-types"></a><span data-ttu-id="d6e25-198">미리 정의된 데이터 흐름 블록 형식</span><span class="sxs-lookup"><span data-stu-id="d6e25-198">Predefined Dataflow Block Types</span></span>  

 <span data-ttu-id="d6e25-199">TPL 데이터 흐름 라이브러리는 몇 가지 미리 정의된 데이터 흐름 블록 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-199">The TPL Dataflow Library provides several predefined dataflow block types.</span></span> <span data-ttu-id="d6e25-200">이러한 형식은 *버퍼링 블록*, *실행 블록* 및 *그룹 블록* 이라는 세 가지 범주로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-200">These types are divided into three categories: *buffering blocks*, *execution blocks*, and *grouping blocks*.</span></span> <span data-ttu-id="d6e25-201">다음 단원에서는 이러한 범주를 구성하는 블록 형식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-201">The following sections describe the block types that make up these categories.</span></span>  
  
### <a name="buffering-blocks"></a><span data-ttu-id="d6e25-202">버퍼링 블록</span><span class="sxs-lookup"><span data-stu-id="d6e25-202">Buffering Blocks</span></span>  

 <span data-ttu-id="d6e25-203">버퍼링 블록은 데이터 소비자가 사용할 데이터를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-203">Buffering blocks hold data for use by data consumers.</span></span> <span data-ttu-id="d6e25-204">TPL 데이터 흐름 라이브러리는 세 가지 버퍼링 블록 형식인 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-204">The TPL Dataflow Library provides three buffering block types: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.</span></span>  
  
#### <a name="bufferblockt"></a><span data-ttu-id="d6e25-205">BufferBlock(T)</span><span class="sxs-lookup"><span data-stu-id="d6e25-205">BufferBlock(T)</span></span>  

 <span data-ttu-id="d6e25-206"><xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 클래스는 일반적인 용도의 비동기 메시징 구조를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-206">The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class represents a general-purpose asynchronous messaging structure.</span></span> <span data-ttu-id="d6e25-207">이 클래스는 여러 소스가 기록하거나 여러 대상이 읽을 수 있는 메시지의 FIFO(선입 선출) 큐를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-207">This class stores a first in, first out (FIFO) queue of messages that can be written to by multiple sources or read from by multiple targets.</span></span> <span data-ttu-id="d6e25-208">대상이 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 개체에서 메시지를 받으면 해당 메시지가 메시지 큐에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-208">When a target receives a message from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, that message is removed from the message queue.</span></span> <span data-ttu-id="d6e25-209">따라서 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 개체에 대상이 여러 개 있을 수 있지만 한 대상만 각 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-209">Therefore, although a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object can have multiple targets, only one target will receive each message.</span></span> <span data-ttu-id="d6e25-210"><xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 클래스는 여러 메시지를 다른 구성 요소에 전달하려고 할 때 유용하고 해당 구성 요소는 각 메시지를 수신해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-210">The <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> class is useful when you want to pass multiple messages to another component, and that component must receive each message.</span></span>  
  
 <span data-ttu-id="d6e25-211">다음 기본 예제에서는 몇 가지 <xref:System.Int32> 값을 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 개체에 게시한 다음 이 개체에서 해당 값을 다시 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-211">The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object and then reads those values back from that object.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 <span data-ttu-id="d6e25-212"><xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 개체에서 메시지를 쓰고 읽는 방법을 보여 주는 전체 예제는 [방법: 데이터 흐름 블록에 메시지 쓰기 및 데이터 흐름 블록에서 메시지 읽기](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-212">For a complete example that demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object, see [How to: Write Messages to and Read Messages from a Dataflow Block](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).</span></span>  
  
#### <a name="broadcastblockt"></a><span data-ttu-id="d6e25-213">BroadcastBlock(T)</span><span class="sxs-lookup"><span data-stu-id="d6e25-213">BroadcastBlock(T)</span></span>  

 <span data-ttu-id="d6e25-214"><xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 클래스는 여러 메시지를 다른 구성 요소에 전달해야 하지만 해당 구성 요소에 최신 값만 필요한 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-214">The <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class is useful when you must pass multiple messages to another component, but that component needs only the most recent value.</span></span> <span data-ttu-id="d6e25-215">이 클래스는 여러 구성 요소에 메시지를 브로드캐스트하려고 할 때도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-215">This class is also useful when you want to broadcast a message to multiple components.</span></span>  
  
 <span data-ttu-id="d6e25-216">다음 기본 예제에서는 <xref:System.Double> 값을 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 개체에 게시한 다음 이 개체에서 해당 값을 여러 번 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-216">The following basic example posts a <xref:System.Double> value to a <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> object and then reads that value back from that object several times.</span></span> <span data-ttu-id="d6e25-217">값을 읽은 후 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 개체에서 제거하지 않기 때문에 동일한 값을 매번 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-217">Because values are not removed from <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objects after they are read, the same value is available every time.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 <span data-ttu-id="d6e25-218"><xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>을 사용하여 여러 대상 블록에 메시지를 브로드캐스트하는 방법을 보여 주는 예제는 [방법: 데이터 흐름 블록에서 작업 스케줄러 지정](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-218">For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> to broadcast a message to multiple target blocks, see [How to: Specify a Task Scheduler in a Dataflow Block](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).</span></span>  
  
#### <a name="writeonceblockt"></a><span data-ttu-id="d6e25-219">WriteOnceBlock(T)</span><span class="sxs-lookup"><span data-stu-id="d6e25-219">WriteOnceBlock(T)</span></span>  

 <span data-ttu-id="d6e25-220"><xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 클래스는 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 개체에 한 번만 쓸 수 있는 점을 제외하고 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 클래스와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-220">The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class resembles the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only.</span></span> <span data-ttu-id="d6e25-221"><xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 개체가 생성 시가 아니라 값을 받은 후에 변경할 수 없게 되는 점을 제외하면 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>을 C# [readonly](../../csharp/language-reference/keywords/readonly.md)(Visual Basic에서는 [ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md)) 키워드와 유사한 것으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-221">You can think of <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> as being similar to the C# [readonly](../../csharp/language-reference/keywords/readonly.md) ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) in Visual Basic) keyword, except that a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object becomes immutable after it receives a value instead of at construction.</span></span> <span data-ttu-id="d6e25-222"><xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> 클래스처럼 대상이 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 개체에서 메시지를 수신할 때 해당 메시지는 해당 개체에서 제거되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-222">Like the <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> class, when a target receives a message from a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object, that message is not removed from that object.</span></span> <span data-ttu-id="d6e25-223">따라서 여러 대상이 하나의 메시지 복사본을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-223">Therefore, multiple targets receive a copy of the message.</span></span> <span data-ttu-id="d6e25-224"><xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 클래스는 여러 메시지 중 첫 메시지만 전파하려는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-224">The <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> class is useful when you want to propagate only the first of multiple messages.</span></span>  
  
 <span data-ttu-id="d6e25-225">다음 기본 예제에서는 여러 <xref:System.String> 값을 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 개체에 게시한 다음 이 개체에서 해당 값을 다시 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-225">The following basic example posts multiple <xref:System.String> values to a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object and then reads the value back from that object.</span></span> <span data-ttu-id="d6e25-226"><xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 개체에 한 번만 쓸 수 있기 때문에 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> 개체는 메시지를 받은 후 이후 메시지를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-226">Because a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object can be written to one time only, after a <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> object receives a message, it discards subsequent messages.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 <span data-ttu-id="d6e25-227"><xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>을 사용하여 완료되는 첫 번째 작업의 값을 받는 방법을 보여 주는 전체 예제는 [방법: 데이터 흐름 블록 링크 끊기](how-to-unlink-dataflow-blocks.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-227">For a complete example that demonstrates how to use <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> to receive the value of the first operation that finishes, see [How to: Unlink Dataflow Blocks](how-to-unlink-dataflow-blocks.md).</span></span>  
  
### <a name="execution-blocks"></a><span data-ttu-id="d6e25-228">실행 블록</span><span class="sxs-lookup"><span data-stu-id="d6e25-228">Execution Blocks</span></span>  

 <span data-ttu-id="d6e25-229">실행 블록은 수신된 데이터의 각 조각에 대해 사용자가 제공한 대리자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-229">Execution blocks call a user-provided delegate for each piece of received data.</span></span> <span data-ttu-id="d6e25-230">TPL 데이터 흐름 라이브러리는 세 가지 실행 블록 형식인 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-230">The TPL Dataflow Library provides three execution block types: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.</span></span>  
  
#### <a name="actionblockt"></a><span data-ttu-id="d6e25-231">ActionBlock(T)</span><span class="sxs-lookup"><span data-stu-id="d6e25-231">ActionBlock(T)</span></span>  

 <span data-ttu-id="d6e25-232"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 클래스는 데이터를 받을 때 대리자를 호출하는 대상 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-232">The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class is a target block that calls a delegate when it receives data.</span></span> <span data-ttu-id="d6e25-233"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 개체를 데이터를 사용할 수 있게 될 때 비동기적으로 실행되는 대리자로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-233">Think of a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object as a delegate that runs asynchronously when data becomes available.</span></span> <span data-ttu-id="d6e25-234"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 개체에 제공하는 대리자는 <xref:System.Action%601> 형식이나 `System.Func<TInput, Task>` 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-234">The delegate that you provide to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object can be of type <xref:System.Action%601> or type `System.Func<TInput, Task>`.</span></span> <span data-ttu-id="d6e25-235"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601>과 함께 <xref:System.Action%601> 개체를 사용하는 경우 각 입력 요소의 처리는 대리자가 반환될 때 완료된 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-235">When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with <xref:System.Action%601>, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="d6e25-236"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601>와 함께 `System.Func<TInput, Task>` 개체를 사용하는 경우 각 입력 요소의 처리는 반환된 <xref:System.Threading.Tasks.Task> 개체가 완료되는 경우에만 완료된 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-236">When you use an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object with `System.Func<TInput, Task>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task> object is completed.</span></span> <span data-ttu-id="d6e25-237">이 두 가지 메커니즘을 사용하여 각 입력 요소의 동기적 처리와 비동기적 처리 모두에 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-237">By using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> for both synchronous and asynchronous processing of each input element.</span></span>  
  
 <span data-ttu-id="d6e25-238">다음 기본 예제에서는 여러 <xref:System.Int32> 값을 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 개체에 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-238">The following basic example posts multiple <xref:System.Int32> values to an <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object.</span></span> <span data-ttu-id="d6e25-239"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 개체는 해당 값을 콘솔에 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-239">The <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> object prints those values to the console.</span></span> <span data-ttu-id="d6e25-240">그런 다음 이 예제에서는 블록을 완료된 상태로 설정하고 모든 데이터 흐름 작업이 완료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-240">This example then sets the block to the completed state and waits for all dataflow tasks to finish.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 <span data-ttu-id="d6e25-241"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 클래스와 함께 대리자를 사용하는 방법을 보여 주는 전체 예제는 [방법: 데이터 흐름 블록에서 데이터를 받을 경우 작업 수행](how-to-perform-action-when-a-dataflow-block-receives-data.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-241">For complete examples that demonstrate how to use delegates with the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, see [How to: Perform Action When a Dataflow Block Receives Data](how-to-perform-action-when-a-dataflow-block-receives-data.md).</span></span>  
  
#### <a name="transformblocktinput-toutput"></a><span data-ttu-id="d6e25-242">TransformBlock(TInput, TOutput)</span><span class="sxs-lookup"><span data-stu-id="d6e25-242">TransformBlock(TInput, TOutput)</span></span>  

 <span data-ttu-id="d6e25-243"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 클래스는 소스와 대상 역할을 모두 수행하는 점을 제외하고 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> 클래스와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-243">The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> class, except that it acts as both a source and as a target.</span></span> <span data-ttu-id="d6e25-244"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 개체에 전달하는 대리자는 `TOutput` 형식의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-244">The delegate that you pass to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object returns a value of type `TOutput`.</span></span> <span data-ttu-id="d6e25-245"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 개체에 제공하는 대리자는 `System.Func<TInput, TOutput>` 형식이나 `System.Func<TInput, Task<TOutput>>` 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-245">The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object can be of type `System.Func<TInput, TOutput>` or type `System.Func<TInput, Task<TOutput>>`.</span></span> <span data-ttu-id="d6e25-246"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602>와 함께 `System.Func<TInput, TOutput>` 개체를 사용하는 경우 각 입력 요소의 처리는 대리자가 반환될 때 완료된 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-246">When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object with `System.Func<TInput, TOutput>`, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="d6e25-247"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602>와 함께 사용된 `System.Func<TInput, Task<TOutput>>` 개체를 사용하는 경우 각 입력 요소의 처리는 반환된 <xref:System.Threading.Tasks.Task%601> 개체가 완료되는 경우에만 완료된 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-247">When you use a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object used with `System.Func<TInput, Task<TOutput>>`, processing of each input element is considered completed only when the returned <xref:System.Threading.Tasks.Task%601> object is completed.</span></span> <span data-ttu-id="d6e25-248"><xref:System.Threading.Tasks.Dataflow.ActionBlock%601>과 마찬가지로, 이 두 가지 메커니즘을 사용함으로써 각 입력 요소의 동기적 처리와 비동기적 처리 모두에 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-248">As with <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, by using these two mechanisms, you can use <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> for both synchronous and asynchronous processing of each input element.</span></span>  
  
 <span data-ttu-id="d6e25-249">다음 기본 예제에서는 입력의 제곱근을 계산하는 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-249">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object that computes the square root of its input.</span></span> <span data-ttu-id="d6e25-250"><xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 개체는 <xref:System.Int32> 값을 입력으로 사용하고 <xref:System.Double> 값을 출력으로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-250">The <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> object takes <xref:System.Int32> values as input and produces <xref:System.Double> values as output.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 <span data-ttu-id="d6e25-251">Windows Forms 애플리케이션에서 이미지 처리를 수행하는 데이터 흐름 네트워크에서 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>을 사용하는 전체 예제는 [연습: Windows Forms 애플리케이션에서 데이터 흐름 사용](walkthrough-using-dataflow-in-a-windows-forms-application.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-251">For complete examples that uses <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in a network of dataflow blocks that performs image processing in a Windows Forms application, see [Walkthrough: Using Dataflow in a Windows Forms Application](walkthrough-using-dataflow-in-a-windows-forms-application.md).</span></span>  
  
#### <a name="transformmanyblocktinput-toutput"></a><span data-ttu-id="d6e25-252">TransformManyBlock(TInput, TOutput)</span><span class="sxs-lookup"><span data-stu-id="d6e25-252">TransformManyBlock(TInput, TOutput)</span></span>  

 <span data-ttu-id="d6e25-253"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 클래스는 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>이 각 입력 값에 대해 하나의 출력 값이 아니라 각 입력 값에 대해 0개 이상의 출력 값을 생성하는 점을 제외하고 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 클래스와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-253">The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> class resembles the <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> class, except that <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produces zero or more output values for each input value, instead of only one output value for each input value.</span></span> <span data-ttu-id="d6e25-254"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 개체에 제공하는 대리자는 `System.Func<TInput, IEnumerable<TOutput>>` 형식이나 `System.Func<TInput, Task<IEnumerable<TOutput>>>` 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-254">The delegate that you provide to a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object can be of type `System.Func<TInput, IEnumerable<TOutput>>` or type `System.Func<TInput, Task<IEnumerable<TOutput>>>`.</span></span> <span data-ttu-id="d6e25-255"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>와 함께 `System.Func<TInput, IEnumerable<TOutput>>` 개체를 사용하는 경우 각 입력 요소의 처리는 대리자가 반환될 때 완료된 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-255">When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, IEnumerable<TOutput>>`, processing of each input element is considered completed when the delegate returns.</span></span> <span data-ttu-id="d6e25-256"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>와 함께 `System.Func<TInput, Task<IEnumerable<TOutput>>>` 개체를 사용하는 경우 각 입력 요소의 처리는 반환된 `System.Threading.Tasks.Task<IEnumerable<TOutput>>` 개체가 완료되는 경우에만 완료된 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-256">When you use a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object with `System.Func<TInput, Task<IEnumerable<TOutput>>>`, processing of each input element is considered complete only when the returned `System.Threading.Tasks.Task<IEnumerable<TOutput>>` object is completed.</span></span>  
  
 <span data-ttu-id="d6e25-257">다음 기본 예제에서는 문자열을 개별 문자 시퀀스로 분할하는 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-257">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object that splits strings into their individual character sequences.</span></span> <span data-ttu-id="d6e25-258"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 개체는 <xref:System.String> 값을 입력으로 사용하고 <xref:System.Char> 값을 출력으로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-258">The <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object takes <xref:System.String> values as input and produces <xref:System.Char> values as output.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 <span data-ttu-id="d6e25-259"><xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>을 사용하여 데이터 흐름 파이프라인의 각 입력에 대한 여러 독립적 출력을 생성하는 전체 예제는 [연습: 데이터 흐름 파이프라인 만들기](walkthrough-creating-a-dataflow-pipeline.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-259">For complete examples that use <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> to produce multiple independent outputs for each input in a dataflow pipeline, see [Walkthrough: Creating a Dataflow Pipeline](walkthrough-creating-a-dataflow-pipeline.md).</span></span>  
  
#### <a name="degree-of-parallelism"></a><span data-ttu-id="d6e25-260">병렬 처리 수준</span><span class="sxs-lookup"><span data-stu-id="d6e25-260">Degree of Parallelism</span></span>  

 <span data-ttu-id="d6e25-261">모든 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 개체는 블록이 입력 메시지를 처리할 준비가 될 때까지 해당 메시지를 버퍼링합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-261">Every <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> object buffers input messages until the block is ready to process them.</span></span> <span data-ttu-id="d6e25-262">기본적으로 이러한 클래스 받은 순서대로 한 번에 하나씩 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-262">By default, these classes process messages in the order in which they are received, one message at a time.</span></span> <span data-ttu-id="d6e25-263">또한 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 개체가 동시에 여러 메시지를 처리할 수 있도록 하기 위해 병렬 처리 수준을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-263">You can also specify the degree of parallelism to enable <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects to process multiple messages concurrently.</span></span> <span data-ttu-id="d6e25-264">동시 실행에 대한 자세한 내용은 이 문서 뒷부분의 병렬 처리 수준 지정 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="d6e25-264">For more information about concurrent execution, see the section Specifying the Degree of Parallelism later in this document.</span></span> <span data-ttu-id="d6e25-265">실행 데이터 흐름 블록이 한 번에 두 개 이상의 메시지를 처리할 수 있도록 병렬 처리 수준을 설정하는 예제는 [방법: 데이터 흐름 블록의 병렬 처리 수준 지정](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-265">For an example that sets the degree of parallelism to enable an execution dataflow block to process more than one message at a time, see [How to: Specify the Degree of Parallelism in a Dataflow Block](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).</span></span>  
  
#### <a name="summary-of-delegate-types"></a><span data-ttu-id="d6e25-266">대리자 형식 요약</span><span class="sxs-lookup"><span data-stu-id="d6e25-266">Summary of Delegate Types</span></span>  

 <span data-ttu-id="d6e25-267">다음 표에서는 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> 개체에 제공할 수 있는 대리자 형식을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-267">The following table summarizes the delegate types that you can provide to <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objects.</span></span> <span data-ttu-id="d6e25-268">또한 대리자 형식이 동기적으로 작동하는지, 아니면 비동기적으로 작동하는지를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-268">This table also specifies whether the delegate type operates synchronously or asynchronously.</span></span>  
  
|<span data-ttu-id="d6e25-269">형식</span><span class="sxs-lookup"><span data-stu-id="d6e25-269">Type</span></span>|<span data-ttu-id="d6e25-270">동기 대리자 형식</span><span class="sxs-lookup"><span data-stu-id="d6e25-270">Synchronous Delegate Type</span></span>|<span data-ttu-id="d6e25-271">비동기 대리자 형식</span><span class="sxs-lookup"><span data-stu-id="d6e25-271">Asynchronous Delegate Type</span></span>|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 <span data-ttu-id="d6e25-272">실행 블록 형식으로 작업할 때 람다 식을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-272">You can also use lambda expressions when you work with execution block types.</span></span> <span data-ttu-id="d6e25-273">실행 블록과 함께 람다 식을 사용하는 방법을 보여 주는 예제는 [방법: 데이터 흐름 블록에서 데이터를 받을 경우 작업 수행](how-to-perform-action-when-a-dataflow-block-receives-data.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-273">For an example that shows how to use a lambda expression with an execution block, see [How to: Perform Action When a Dataflow Block Receives Data](how-to-perform-action-when-a-dataflow-block-receives-data.md).</span></span>  
  
### <a name="grouping-blocks"></a><span data-ttu-id="d6e25-274">그룹 블록</span><span class="sxs-lookup"><span data-stu-id="d6e25-274">Grouping Blocks</span></span>  

 <span data-ttu-id="d6e25-275">그룹 블록은 다양한 제약 조건에서 하나 이상의 소스로부터 데이터를 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-275">Grouping blocks combine data from one or more sources and under various constraints.</span></span> <span data-ttu-id="d6e25-276">TPL 데이터 흐름 라이브러리는 세가지 조인 블록 형식인 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-276">The TPL Dataflow Library provides three join block types: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.</span></span>  
  
#### <a name="batchblockt"></a><span data-ttu-id="d6e25-277">BatchBlock(T)</span><span class="sxs-lookup"><span data-stu-id="d6e25-277">BatchBlock(T)</span></span>  

 <span data-ttu-id="d6e25-278"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 클래스는 배치라고 하는 입력 데이터 집합을 출력 데이터의 배열로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-278">The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class combines sets of input data, which are known as batches, into arrays of output data.</span></span> <span data-ttu-id="d6e25-279"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체를 만들 때 각 배치의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-279">You specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object.</span></span> <span data-ttu-id="d6e25-280"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체는 지정된 수의 입력 요소를 받을 때 해당 요소가 포함된 배열을 비동기적으로 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-280">When the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object receives the specified count of input elements, it asynchronously propagates out an array that contains those elements.</span></span> <span data-ttu-id="d6e25-281"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체가 완료된 상태로 설정되었지만 배치를 형성하는 데 충분한 요소를 포함하지 않은 경우에는 나머지 입력 요소가 포함된 마지막 배열을 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-281">If a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object is set to the completed state but does not contain enough elements to form a batch, it propagates out a final array that contains the remaining input elements.</span></span>  
  
 <span data-ttu-id="d6e25-282"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 클래스는 *greedy* 또는 *non-greedy* 모드로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-282">The <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class operates in either *greedy* or *non-greedy* mode.</span></span> <span data-ttu-id="d6e25-283">기본값인 greedy 모드에서는 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체가 제공되는 모든 메시지를 수락하고 지정된 수의 요소를 받은 후 배열을 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-283">In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object accepts every message that it is offered and propagates out an array after it receives the specified count of elements.</span></span> <span data-ttu-id="d6e25-284">non-greedy 모드에서는 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체가 충분한 소스가 배치를 형성하기 위한 메시지를 블록에 제공할 때까지 모든 들어오는 메시지를 연기합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-284">In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough sources have offered messages to the block to form a batch.</span></span> <span data-ttu-id="d6e25-285">일반적으로 greedy 모드는 필요한 처리 오버헤드가 적기 때문에 non-greedy 모드보다 효율적으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-285">Greedy mode typically performs better than non-greedy mode because it requires less processing overhead.</span></span> <span data-ttu-id="d6e25-286">그러나 원자 방식으로 여러 소스에서 사용을 조정해야 하는 경우 non-greedy 모드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-286">However, you can use non-greedy mode when you must coordinate consumption from multiple sources in an atomic fashion.</span></span> <span data-ttu-id="d6e25-287"><xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A>를 `False` 생성자의 `dataflowBlockOptions` 매개 변수에서 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>로 설정하여 non-greedy 모드를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-287">Specify non-greedy mode by setting <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False` in the `dataflowBlockOptions` parameter in the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="d6e25-288">다음 기본 예제에서는 몇 가지 <xref:System.Int32> 값을 배치에 10개의 요소를 포함하는 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체에 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-288">The following basic example posts several <xref:System.Int32> values to a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object that holds ten elements in a batch.</span></span> <span data-ttu-id="d6e25-289"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601>에서 모든 값이 전파되도록 보장하기 위해서 이 예제에서는 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-289">To guarantee that all values propagate out of the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, this example calls the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method.</span></span> <span data-ttu-id="d6e25-290"><xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> 메서드는 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체를 완료된 상태로 설정하므로 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체가 남아 있는 요소를 모두 마지막 배치로 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-290">The <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> method sets the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object to the completed state, and therefore, the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object propagates out any remaining elements as a final batch.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 <span data-ttu-id="d6e25-291"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601>을 사용하여 데이터베이스 삽입 작업의 효율성을 높이는 전체 예제는 [연습: BatchBlock 및 BatchedJoinBlock을 사용하여 효율성 향상](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-291">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> to improve the efficiency of database insert operations, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).</span></span>  
  
#### <a name="joinblockt1-t2-"></a><span data-ttu-id="d6e25-292">JoinBlock(T1, T2, ...)</span><span class="sxs-lookup"><span data-stu-id="d6e25-292">JoinBlock(T1, T2, ...)</span></span>  

 <span data-ttu-id="d6e25-293"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 클래스는 입력 요소를 수집하고 해당 요소가 포함된 <xref:System.Tuple%602?displayProperty=nameWithType> 또는 <xref:System.Tuple%603?displayProperty=nameWithType> 개체를 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-293">The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes collect input elements and propagate out <xref:System.Tuple%602?displayProperty=nameWithType> or <xref:System.Tuple%603?displayProperty=nameWithType> objects that contain those elements.</span></span> <span data-ttu-id="d6e25-294"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 클래스는 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>에서 상속하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-294">The <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes do not inherit from <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span> <span data-ttu-id="d6e25-295">대신에 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>을 구현하는 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A> 및 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-295">Instead, they provide properties, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span>  
  
 <span data-ttu-id="d6e25-296">마찬가지로 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>은 greedy 또는 non-greedy 모드에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-296">Like <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operate in either greedy or non-greedy mode.</span></span> <span data-ttu-id="d6e25-297">기본값인 greedy 모드에서는 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 또는 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 개체가 제공되는 모든 메시지를 수락하고 각 대상이 적어도 하나의 메시지를 받은 후 튜플을 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-297">In greedy mode, which is the default, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object accepts every message that it is offered and propagates out a tuple after each of its targets receives at least one message.</span></span> <span data-ttu-id="d6e25-298">non-greedy 모드에서는 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 또는 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 개체가 모든 대상에 튜플을 만드는 데 필요한 데이터가 제공될 때까지 들어오는 모든 메시지를 연기합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-298">In non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> or <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object postpones all incoming messages until all targets have been offered the data that is required to create a tuple.</span></span> <span data-ttu-id="d6e25-299">이 시점에서 블록은 소스로부터 모든 필요한 항목을 원자적으로 검색하는 2단계 커밋 프로토콜에 참여합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-299">At this point, the block engages in a two-phase commit protocol to atomically retrieve all required items from the sources.</span></span> <span data-ttu-id="d6e25-300">이러한 연기를 통해 다른 엔터티가 그 동안 데이터를 사용할 수 있으므로 전반적인 시스템 작업이 진행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-300">This postponement makes it possible for another entity to consume the data in the meantime, to allow the overall system to make forward progress.</span></span>  
  
 <span data-ttu-id="d6e25-301">다음 기본 예제에서는 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 개체가 값을 계산하기 위해 여러 데이터를 필요로 하는 경우를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-301">The following basic example demonstrates a case in which a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object requires multiple data to compute a value.</span></span> <span data-ttu-id="d6e25-302">이 예제에서는 산술 연산을 수행하기 위해 두 <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> 값과 <xref:System.Int32> 값을 필요로 하는 <xref:System.Char> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-302">This example creates a <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> object that requires two <xref:System.Int32> values and a <xref:System.Char> value to perform an arithmetic operation.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 <span data-ttu-id="d6e25-303">non-greedy 모드에서 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 개체를 사용하여 리소스를 협조적으로 공유하는 전체 예제는 [방법: JoinBlock을 사용하여 여러 소스에서 데이터 읽기](how-to-use-joinblock-to-read-data-from-multiple-sources.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-303">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objects in non-greedy mode to cooperatively share a resource, see [How to: Use JoinBlock to Read Data From Multiple Sources](how-to-use-joinblock-to-read-data-from-multiple-sources.md).</span></span>  
  
#### <a name="batchedjoinblockt1-t2-"></a><span data-ttu-id="d6e25-304">BatchedJoinBlock(T1, T2, ...)</span><span class="sxs-lookup"><span data-stu-id="d6e25-304">BatchedJoinBlock(T1, T2, ...)</span></span>  

 <span data-ttu-id="d6e25-305"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> 클래스는 입력 요소의 배치를 수집하고 해당 요소가 포함된 `System.Tuple(IList(T1), IList(T2))` 또는 `System.Tuple(IList(T1), IList(T2), IList(T3))` 개체를 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-305">The <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classes collect batches of input elements and propagate out `System.Tuple(IList(T1), IList(T2))` or `System.Tuple(IList(T1), IList(T2), IList(T3))` objects that contain those elements.</span></span> <span data-ttu-id="d6e25-306"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>을 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>과 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>이 결합된 것으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-306">Think of <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> as a combination of <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> and <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</span></span> <span data-ttu-id="d6e25-307"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 개체를 만들 때 각 배치의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-307">Specify the size of each batch when you create a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object.</span></span> <span data-ttu-id="d6e25-308"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>은 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A>을 구현하는 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> 및 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 속성도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-308"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> also provides properties, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> and <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, that implement <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</span></span> <span data-ttu-id="d6e25-309">모든 대상에서 지정된 수의 입력 요소를 받으면 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 개체는 해당 요소가 포함된 `System.Tuple(IList(T1), IList(T2))` 개체를 비동기적으로 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-309">When the specified count of input elements are received from across all targets, the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object asynchronously propagates out a `System.Tuple(IList(T1), IList(T2))` object that contains those elements.</span></span>  
  
 <span data-ttu-id="d6e25-310">다음 기본 예제에서는 결과, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 값 및 <xref:System.Int32> 개체인 오류를 포함하는 <xref:System.Exception> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-310">The following basic example creates a <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object that holds results, <xref:System.Int32> values, and errors that are <xref:System.Exception> objects.</span></span> <span data-ttu-id="d6e25-311">이 예제에서는 여러 작업을 수행하고 결과를 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> 개체의 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> 속성에 쓰고 오류를 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 속성에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-311">This example performs multiple operations and writes results to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> property, and errors to the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> property, of the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> object.</span></span> <span data-ttu-id="d6e25-312">성공한 작업의 수와 실패한 작업의 수를 미리 알 수 없기 때문에 <xref:System.Collections.Generic.IList%601> 개체는 각 대상이 0개 이상의 값을 받을 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-312">Because the count of successful and failed operations is unknown in advance, the <xref:System.Collections.Generic.IList%601> objects enable each target to receive zero or more values.</span></span>  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 <span data-ttu-id="d6e25-313"><xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>을 사용하여 결과와 프로그램이 데이터베이스에서 읽는 동안 발생하는 모든 예외를 캡처하는 전체 예제는 [연습: BatchBlock 및 BatchedJoinBlock을 사용하여 효율성 향상](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-313">For a complete example that uses <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> to capture both the results and any exceptions that occur while the program reads from a database, see [Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).</span></span>  

## <a name="configuring-dataflow--block-behavior"></a><span data-ttu-id="d6e25-314">데이터 흐름 블록 동작 구성</span><span class="sxs-lookup"><span data-stu-id="d6e25-314">Configuring Dataflow  Block Behavior</span></span>  

 <span data-ttu-id="d6e25-315"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> 개체를 데이터 흐름 블록 형식의 생성자에 제공하여 추가 옵션을 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-315">You can enable additional options by providing a <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> object to the constructor of dataflow block types.</span></span> <span data-ttu-id="d6e25-316">이러한 옵션은 기본 작업과 병렬 처리 수준을 관리하는 스케줄러와 같은 동작을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-316">These options control behavior such the scheduler that manages the underlying task and the degree of parallelism.</span></span> <span data-ttu-id="d6e25-317"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>에는 데이터 흐름 블록 형식과 관련된 동작을 지정하는 파생 형식도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-317">The <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> also has derived types that specify behavior that is specific to certain dataflow block types.</span></span> <span data-ttu-id="d6e25-318">다음 표에서는 각 데이터 흐름 블록 형식과 관련된 옵션 형식을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-318">The following table summarizes which options type is associated with each dataflow block type.</span></span>  
  
|<span data-ttu-id="d6e25-319">데이터 흐름 블록 형식</span><span class="sxs-lookup"><span data-stu-id="d6e25-319">Dataflow Block Type</span></span>|<span data-ttu-id="d6e25-320"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> 형식</span><span class="sxs-lookup"><span data-stu-id="d6e25-320"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> type</span></span>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 <span data-ttu-id="d6e25-321">다음 단원에서는 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> 클래스를 통해 사용 가능한 중요한 데이터 흐름 블록 옵션에 대한 추가 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-321">The following sections provide additional information about the important kinds of dataflow block options that are available through the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> classes.</span></span>  
  
### <a name="specifying-the-task-scheduler"></a><span data-ttu-id="d6e25-322">작업 Scheduler 지정</span><span class="sxs-lookup"><span data-stu-id="d6e25-322">Specifying the Task Scheduler</span></span>  

 <span data-ttu-id="d6e25-323">모든 미리 정의된 데이터 흐름 블록은 TPL 작업 예약 메커니즘을 사용하여 대상에 데이터를 전파하고, 소스에서 데이터를 받고, 데이터를 사용할 수 있게 되면 사용자 정의 대리자를 실행하는 등의 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-323">Every predefined dataflow block uses the TPL task scheduling mechanism to perform activities such as propagating data to a target, receiving data from a source, and running user-defined delegates when data becomes available.</span></span> <span data-ttu-id="d6e25-324"><xref:System.Threading.Tasks.TaskScheduler>는 작업을 스레드의 큐에 대기시키는 작업 스케줄러를 나타내는 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-324"><xref:System.Threading.Tasks.TaskScheduler> is an abstract class that represents a task scheduler that queues tasks onto threads.</span></span> <span data-ttu-id="d6e25-325">기본 작업 스케줄러인 <xref:System.Threading.Tasks.TaskScheduler.Default%2A>는 <xref:System.Threading.ThreadPool> 클래스를 사용하여 작업을 큐에 대기시키고 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-325">The default task scheduler, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, uses the <xref:System.Threading.ThreadPool> class to queue and execute work.</span></span> <span data-ttu-id="d6e25-326">데이터 흐름 블록 개체를 생성할 때 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> 속성을 설정하여 기본 작업 스케줄러를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-326">You can override the default task scheduler by setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> property when you construct a dataflow block object.</span></span>  
  
 <span data-ttu-id="d6e25-327">동일한 작업 스케줄러가 여러 데이터 흐름 블록을 관리하는 경우 해당 블록 전체에 정책을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-327">When the same task scheduler manages multiple dataflow blocks, it can enforce policies across them.</span></span> <span data-ttu-id="d6e25-328">예들 들어 여러 데이터 흐름 블록이 동일한 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 개체의 단독 스케줄러를 대상으로 하도록 각각 구성된 경우 해당 블록에서 실행되는 모든 작업이 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-328">For example, if multiple dataflow blocks are each configured to target the exclusive scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, all work that runs across these blocks is serialized.</span></span> <span data-ttu-id="d6e25-329">이와 마찬가지로 이러한 블록이 동일한 <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 개체의 동시 스케줄러를 대상으로 하도록 구성되어 있고 이 스케줄러가 최대 동시성 수준을 갖도록 구성된 경우 이러한 블록의 모든 작업은 해당 동시 작업 수로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-329">Similarly, if these blocks are configured to target the concurrent scheduler of the same <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> object, and that scheduler is configured to have a maximum concurrency level, all work from these blocks is limited to that number of concurrent operations.</span></span> <span data-ttu-id="d6e25-330"><xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> 클래스를 사용하여 읽기 작업은 병렬로 발생하지만 쓰기 작업은 다른 모든 작업과 독립적으로 발생하도록 설정하는 예제는 [방법: 데이터 흐름 블록에서 작업 스케줄러 지정](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-330">For an example that uses the <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> class to enable read operations to occur in parallel, but write operations to occur exclusively of all other operations, see [How to: Specify a Task Scheduler in a Dataflow Block](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).</span></span> <span data-ttu-id="d6e25-331">TPL의 작업 스케줄러에 대한 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler> 클래스 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-331">For more information about task schedulers in the TPL, see the <xref:System.Threading.Tasks.TaskScheduler> class topic.</span></span>  
  
### <a name="specifying-the-degree-of-parallelism"></a><span data-ttu-id="d6e25-332">병렬 처리 수준 지정</span><span class="sxs-lookup"><span data-stu-id="d6e25-332">Specifying the Degree of Parallelism</span></span>  

 <span data-ttu-id="d6e25-333">기본적으로 TPL 데이터 흐름 라이브러리가 제공하는 세 가지 실행 블록 형식인 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>은 한 번에 하나의 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-333">By default, the three execution block types that the TPL Dataflow Library provides, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, process one message at a time.</span></span> <span data-ttu-id="d6e25-334">또한 이러한 데이터 흐름 블록 형식은 수신되는 순서대로 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-334">These dataflow block types also process messages in the order in which they are received.</span></span> <span data-ttu-id="d6e25-335">이러한 데이터 흐름 블록이 메시지를 동시에 처리하도록 설정하려면 데이터 흐름 블록 개체를 생성할 때 <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-335">To enable these dataflow blocks to process messages concurrently, set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> property when you construct the dataflow block object.</span></span>  
  
 <span data-ttu-id="d6e25-336"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A>의 기본값은 1이며, 이 경우 데이터 흐름 블록이 한 번에 하나의 메시지를 처리하도록 보장됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-336">The default value of <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> is 1, which guarantees that the dataflow block processes one message at a time.</span></span> <span data-ttu-id="d6e25-337">이 속성을 1보다 큰 값으로 설정하면 데이터 흐름 블록이 여러 메시지를 동시에 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-337">Setting this property to a value that is larger than 1 enables the dataflow block to process multiple messages concurrently.</span></span> <span data-ttu-id="d6e25-338">이 속성을 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>로 설정하면 내부 작업 스케줄러가 최대 동시성 수준을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-338">Setting this property to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> enables the underlying task scheduler to manage the maximum degree of concurrency.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="d6e25-339">최대 병렬 처리 수준을 1보다 크게 지정하는 경우 여러 메시지가 동시에 처리되므로 메시지가 수신된 순서대로 처리되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-339">When you specify a maximum degree of parallelism that is larger than 1, multiple messages are processed simultaneously, and therefore messages might not be processed in the order in which they are received.</span></span> <span data-ttu-id="d6e25-340">그러나 메시지가 블록에서 출력되는 순서는 메시지가 수신되는 순서와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-340">The order in which the messages are output from the block is, however, the same one in which they are received.</span></span>  
  
 <span data-ttu-id="d6e25-341"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 속성이 최대 병렬 처리 수준을 나타내기 때문에 데이터 흐름 블록은 지정한 것보다 낮은 병렬 처리 수준으로 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-341">Because the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property represents the maximum degree of parallelism, the dataflow block might execute with a lesser degree of parallelism than you specify.</span></span> <span data-ttu-id="d6e25-342">데이터 흐름 블록은 기능적 요구 사항을 충족하기 위해서나 사용 가능한 시스템 리소스가 부족하기 때문에 보다 낮은 병렬 처리 수준을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-342">The dataflow block might use a lesser degree of parallelism to meet its functional requirements or because there is a lack of available system resources.</span></span> <span data-ttu-id="d6e25-343">데이터 흐름 블록은 지정한 것보다 많은 병렬 처리를 선택하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-343">A dataflow block never chooses more parallelism than you specify.</span></span>  
  
 <span data-ttu-id="d6e25-344"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 속성의 값은 각 데이터 흐름 블록 개체에서 단독으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-344">The value of the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property is exclusive to each dataflow block object.</span></span> <span data-ttu-id="d6e25-345">예를 들어 4개의 데이터 흐름 블록이 각각 최대 병렬 처리 수준으로 1을 지정하는 경우 4개의 데이터 흐름 블록 개체는 모두 잠재적으로 병렬로 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-345">For example, if four dataflow block objects each specify 1 for the maximum degree of parallelism, all four dataflow block objects can potentially run in parallel.</span></span>  
  
 <span data-ttu-id="d6e25-346">긴 작업이 병렬로 발생할 수 있도록 최대 병렬 처리 수준을 설정하는 예제는 [방법: 데이터 흐름 블록의 병렬 처리 수준 지정](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-346">For an example that sets the maximum degree of parallelism to enable lengthy operations to occur in parallel, see [How to: Specify the Degree of Parallelism in a Dataflow Block](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).</span></span>  
  
### <a name="specifying-the-number-of-messages-per-task"></a><span data-ttu-id="d6e25-347">작업당 메시지 수 지정</span><span class="sxs-lookup"><span data-stu-id="d6e25-347">Specifying the Number of Messages per Task</span></span>  

 <span data-ttu-id="d6e25-348">미리 정의된 데이터 흐름 블록 형식은 작업을 사용하여 여러 입력 요소를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-348">The predefined dataflow block types use tasks to process multiple input elements.</span></span> <span data-ttu-id="d6e25-349">이는 데이터를 처리하는 데 필요한 작업 개체의 수를 최소화하는 데 도움이 되므로 애플리케이션이 보다 효율적으로 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-349">This helps minimize the number of task objects that are required to process data, which enables applications to run more efficiently.</span></span> <span data-ttu-id="d6e25-350">그러나 하나의 데이터 흐름 블록 집합에 있는 작업이 데이터를 처리하고 있는 경우 다른 데이터 흐름 블록의 작업은 메시지를 큐에 대기시켜서 처리 시간 동안 기다려야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-350">However, when the tasks from one set of dataflow blocks are processing data, the tasks from other dataflow blocks might need to wait for processing time by queuing messages.</span></span> <span data-ttu-id="d6e25-351">데이터 흐름 작업 간의 공정성을 높이려면 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-351">To enable better fairness among dataflow tasks, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property.</span></span> <span data-ttu-id="d6e25-352"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>가 기본값인 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>로 설정된 경우 데이터 흐름 블록에서 사용되는 작업은 사용할 수 있는 만큼의 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-352">When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, which is the default, the task used by a dataflow block processes as many messages as are available.</span></span> <span data-ttu-id="d6e25-353"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>가 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded> 이외의 값으로 설정된 경우 데이터 흐름 블록은 <xref:System.Threading.Tasks.Task> 개체당 해당 메시지 수 이하를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-353">When <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> is set to a value other than <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, the dataflow block processes at most this number of messages per <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="d6e25-354"><xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> 속성을 설정하여 작업 간의 공정성을 높일 수 있지만, 시스템에서 필요한 것보다 많은 작업을 만들어 성능이 저하될 수 있는 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-354">Although setting the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> property can increase fairness among tasks, it can cause the system to create more tasks than are necessary, which can decrease performance.</span></span>  
  
### <a name="enabling-cancellation"></a><span data-ttu-id="d6e25-355">취소 사용</span><span class="sxs-lookup"><span data-stu-id="d6e25-355">Enabling Cancellation</span></span>  

 <span data-ttu-id="d6e25-356">TPL은 작업이 협조적 방식으로 취소를 조정할 수 있도록 하는 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-356">The TPL provides a mechanism that enables tasks to coordinate cancellation in a cooperative manner.</span></span> <span data-ttu-id="d6e25-357">데이터 흐름 블록이 이 취소 메커니즘에 참여할 수 있도록 하려면 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-357">To enable dataflow blocks to participate in this cancellation mechanism, set the <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> property.</span></span> <span data-ttu-id="d6e25-358">이 <xref:System.Threading.CancellationToken> 개체가 취소된 상태로 설정된 경우 이 토큰을 모니터링하는 모든 데이터 흐름 블록은 동시 항목의 실행을 완료하지만 후속 항목의 처리를 시작하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-358">When this <xref:System.Threading.CancellationToken> object is set to the canceled state, all dataflow blocks that monitor this token finish execution of their current item but do not start processing subsequent items.</span></span> <span data-ttu-id="d6e25-359">또한 이러한 데이터 흐름 블록은 버퍼링된 메시지를 모두 지우고, 모든 소스 및 대상 블록에 대한 연결을 해제하고, 취소된 상태로 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-359">These dataflow blocks also clear any buffered messages, release connections to any source and target blocks, and transition to the canceled state.</span></span> <span data-ttu-id="d6e25-360">취소된 상태로 전환함으로써 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> 속성의 <xref:System.Threading.Tasks.Task.Status%2A> 속성은 처리 중에 예외가 발생하지 않는 한 <xref:System.Threading.Tasks.TaskStatus.Canceled>로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-360">By transitioning to the canceled state, the <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> property has the <xref:System.Threading.Tasks.Task.Status%2A> property set to <xref:System.Threading.Tasks.TaskStatus.Canceled>, unless an exception occurred during processing.</span></span> <span data-ttu-id="d6e25-361">이 경우 <xref:System.Threading.Tasks.Task.Status%2A>가 <xref:System.Threading.Tasks.TaskStatus.Faulted>로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-361">In that case, <xref:System.Threading.Tasks.Task.Status%2A> is set to <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span></span>  
  
 <span data-ttu-id="d6e25-362">Windows Forms 애플리케이션에서 취소를 사용하는 방법을 보여 주는 예제는 [방법: 데이터 흐름 블록 취소](how-to-cancel-a-dataflow-block.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-362">For an example that demonstrates how to use cancellation in a Windows Forms application, see [How to: Cancel a Dataflow Block](how-to-cancel-a-dataflow-block.md).</span></span> <span data-ttu-id="d6e25-363">TPL의 취소에 대한 자세한 내용은 [작업 취소](task-cancellation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-363">For more information about cancellation in the TPL, see [Task Cancellation](task-cancellation.md).</span></span>  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a><span data-ttu-id="d6e25-364">Greedy 및 Non-Greedy 동작 지정</span><span class="sxs-lookup"><span data-stu-id="d6e25-364">Specifying Greedy Versus Non-Greedy Behavior</span></span>  

 <span data-ttu-id="d6e25-365">몇 가지 그룹 데이터 흐름 블록 형식은 *greedy* 또는 *non-greedy* 모드로 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-365">Several grouping dataflow block types can operate in either *greedy* or *non-greedy* mode.</span></span> <span data-ttu-id="d6e25-366">기본적으로 미리 정의된 데이터 흐름 블록 형식은 greedy 모드로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-366">By default, the predefined dataflow block types operate in greedy mode.</span></span>  
  
 <span data-ttu-id="d6e25-367"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602>과 같은 조인 블록 형식의 경우 greedy 모드는 조인할 데이터를 아직 사용할 수 없는 경우에도 블록이 해당 데이터를 즉시 수락함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-367">For join block types such as <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, greedy mode means that the block immediately accepts data even if the corresponding data with which to join is not yet available.</span></span> <span data-ttu-id="d6e25-368">non-greedy 모드는 각 대상에서 조인을 완료하기 위해 메시지를 사용할 수 있을 때까지 블록이 들어오는 모든 메시지를 연기함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-368">Non-greedy mode means that the block postpones all incoming messages until one is available on each of its targets to complete the join.</span></span> <span data-ttu-id="d6e25-369">연기된 메시지 중에서 하나라도 더 이상 사용할 수 없는 경우 조인 블록은 연기된 메시지를 모두 해제하고 프로세스를 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-369">If any of the postponed messages are no longer available, the join block releases all postponed messages and restarts the process.</span></span> <span data-ttu-id="d6e25-370"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 클래스의 경우, non-greedy 모드에서 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 개체가 개별 소스들에서 배치를 완료하는 데 충분한 메시지를 사용할 수 있을 때까지 들어오는 메시지를 모두 연기하는 점을 제외하고 greedy 및 non-greedy 동작이 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-370">For the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class, greedy and non-greedy behavior is similar, except that under non-greedy mode, a <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> object postpones all incoming messages until enough are available from distinct sources to complete a batch.</span></span>  
  
 <span data-ttu-id="d6e25-371">데이터 흐름 블록에 대한 non-greedy 모드를 지정하려면 <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A>를 `False`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-371">To specify non-greedy mode for a dataflow block, set <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> to `False`.</span></span> <span data-ttu-id="d6e25-372">non-greedy 모드를 사용하여 여러 조인 블록이 데이터 소스를 보다 효율적으로 공유할 수 있도록 하는 방법을 보여 주는 예제는 [방법: JoinBlock을 사용하여 여러 소스에서 데이터 읽기](how-to-use-joinblock-to-read-data-from-multiple-sources.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-372">For an example that demonstrates how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently, see [How to: Use JoinBlock to Read Data From Multiple Sources](how-to-use-joinblock-to-read-data-from-multiple-sources.md).</span></span>

## <a name="custom-dataflow-blocks"></a><span data-ttu-id="d6e25-373">사용자 지정 데이터 흐름 블록</span><span class="sxs-lookup"><span data-stu-id="d6e25-373">Custom Dataflow Blocks</span></span>  

 <span data-ttu-id="d6e25-374">TPL 데이터 흐름 라이브러리가 미리 정의된 블록 형식을 다양하게 제공하지만 사용자 지정 동작을 수행하는 추가 블록 형식을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-374">Although the TPL Dataflow Library provides many predefined block types, you can create additional block types that perform custom behavior.</span></span> <span data-ttu-id="d6e25-375"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> 또는 <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> 인터페이스를 직접 구현하거나 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> 메서드를 사용하여 기존 블록 형식의 동작을 캡슐화하는 복합 블록을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-375">Implement the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> or <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfaces directly or use the  <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> method to build a complex block that encapsulates the behavior of existing block types.</span></span> <span data-ttu-id="d6e25-376">사용자 지정 데이터 흐름 블록 기능을 구현하는 방법을 보여 주는 예제는 [연습: 사용자 지정 데이터 흐름 블록 형식 만들기](walkthrough-creating-a-custom-dataflow-block-type.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d6e25-376">For examples that show how to implement custom dataflow block functionality, see [Walkthrough: Creating a Custom Dataflow Block Type](walkthrough-creating-a-custom-dataflow-block-type.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="d6e25-377">관련 항목</span><span class="sxs-lookup"><span data-stu-id="d6e25-377">Related Topics</span></span>  
  
|<span data-ttu-id="d6e25-378">제목</span><span class="sxs-lookup"><span data-stu-id="d6e25-378">Title</span></span>|<span data-ttu-id="d6e25-379">설명</span><span class="sxs-lookup"><span data-stu-id="d6e25-379">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="d6e25-380">방법: 데이터 흐름 블록에 메시지 쓰기 및 데이터 흐름 블록에서 메시지 읽기</span><span class="sxs-lookup"><span data-stu-id="d6e25-380">How to: Write Messages to and Read Messages from a Dataflow Block</span></span>](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|<span data-ttu-id="d6e25-381"><xref:System.Threading.Tasks.Dataflow.BufferBlock%601> 개체에서 메시지를 쓰고 읽는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-381">Demonstrates how to write messages to and read messages from a <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> object.</span></span>|  
|[<span data-ttu-id="d6e25-382">방법: 공급자-소비자 데이터 흐름 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="d6e25-382">How to: Implement a Producer-Consumer Dataflow Pattern</span></span>](how-to-implement-a-producer-consumer-dataflow-pattern.md)|<span data-ttu-id="d6e25-383">데이터 흐름 모델을 사용하여 생산자가 메시지를 데이터 흐름 블록에 보내고 소비자가 해당 블록에서 메시지를 읽는 생산자-소비자 패턴을 구현하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-383">Describes how to use the dataflow model to implement a producer-consumer pattern, where the producer sends messages to a dataflow block, and the consumer reads messages from that block.</span></span>|  
|[<span data-ttu-id="d6e25-384">방법: 데이터 흐름 블록에서 데이터를 받을 경우 작업 수행</span><span class="sxs-lookup"><span data-stu-id="d6e25-384">How to: Perform Action When a Dataflow Block Receives Data</span></span>](how-to-perform-action-when-a-dataflow-block-receives-data.md)|<span data-ttu-id="d6e25-385">실행 데이터 흐름 블록 형식인 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> 및 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>에 대리자를 제공하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-385">Describes how to provide delegates to the execution dataflow block types, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, and <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.</span></span>|  
|[<span data-ttu-id="d6e25-386">연습: 데이터 흐름 파이프라인 만들기</span><span class="sxs-lookup"><span data-stu-id="d6e25-386">Walkthrough: Creating a Dataflow Pipeline</span></span>](walkthrough-creating-a-dataflow-pipeline.md)|<span data-ttu-id="d6e25-387">웹에서 텍스트를 다운로드하고 해당 텍스트에 대한 작업을 수행하는 데이터 흐름 파이프라인을 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-387">Describes how to create a dataflow pipeline that downloads text from the web and performs operations on that text.</span></span>|  
|[<span data-ttu-id="d6e25-388">방법: 데이터 흐름 블록 링크 끊기</span><span class="sxs-lookup"><span data-stu-id="d6e25-388">How to: Unlink Dataflow Blocks</span></span>](how-to-unlink-dataflow-blocks.md)|<span data-ttu-id="d6e25-389"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> 메서드를 사용하여 소스가 대상에 메시지를 제공한 후 소스에서 대상 블록의 연결을 해제하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-389">Demonstrates how to use the <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> method to unlink a target block from its source after the source offers a message to the target.</span></span>|  
|[<span data-ttu-id="d6e25-390">연습: Windows Forms 애플리케이션에서 데이터 흐름 사용</span><span class="sxs-lookup"><span data-stu-id="d6e25-390">Walkthrough: Using Dataflow in a Windows Forms Application</span></span>](walkthrough-using-dataflow-in-a-windows-forms-application.md)|<span data-ttu-id="d6e25-391">Windows Forms 애플리케이션에서 이미지 처리를 수행하는 데이터 흐름 블록의 네트워크를 만드는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-391">Demonstrates how to create a network of dataflow blocks that perform image processing in a Windows Forms application.</span></span>|  
|[<span data-ttu-id="d6e25-392">방법: 데이터 흐름 블록 취소</span><span class="sxs-lookup"><span data-stu-id="d6e25-392">How to: Cancel a Dataflow Block</span></span>](how-to-cancel-a-dataflow-block.md)|<span data-ttu-id="d6e25-393">Windows Forms 애플리케이션에서 취소를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-393">Demonstrates how to use cancellation in a Windows Forms application.</span></span>|  
|[<span data-ttu-id="d6e25-394">방법: JoinBlock을 사용하여 여러 소스에서 데이터 읽기</span><span class="sxs-lookup"><span data-stu-id="d6e25-394">How to: Use JoinBlock to Read Data From Multiple Sources</span></span>](how-to-use-joinblock-to-read-data-from-multiple-sources.md)|<span data-ttu-id="d6e25-395"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602> 클래스를 사용하여 여러 소스에서 데이터를 사용할 수 있을 때 작업을 수행하는 방법과 non-greedy 모드를 사용하여 여러 조인 블록이 데이터 소스를 보다 효율적으로 공유할 수 있도록 하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-395">Explains how to use the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> class to perform an operation when data is available from multiple sources, and how to use non-greedy mode to enable multiple join blocks to share a data source more efficiently.</span></span>|  
|[<span data-ttu-id="d6e25-396">방법: 데이터 흐름 블록의 병렬 처리 수준 지정</span><span class="sxs-lookup"><span data-stu-id="d6e25-396">How to: Specify the Degree of Parallelism in a Dataflow Block</span></span>](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|<span data-ttu-id="d6e25-397"><xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 속성을 설정하여 실행 데이터 흐름 블록이 한 번에 둘 이상의 메시지를 처리할 수 있도록 하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-397">Describes how to set the <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> property to enable an execution dataflow block to process more than one message at a time.</span></span>|  
|[<span data-ttu-id="d6e25-398">방법: 데이터 흐름 블록에서 작업 스케줄러 지정</span><span class="sxs-lookup"><span data-stu-id="d6e25-398">How to: Specify a Task Scheduler in a Dataflow Block</span></span>](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|<span data-ttu-id="d6e25-399">애플리케이션에서 데이터 흐름을 사용하는 경우 특정 작업 스케줄러를 연결하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-399">Demonstrates how to associate a specific task scheduler when you use dataflow in your application.</span></span>|  
|[<span data-ttu-id="d6e25-400">연습: BatchBlock 및 BatchedJoinBlock을 사용하여 효율성 향상</span><span class="sxs-lookup"><span data-stu-id="d6e25-400">Walkthrough: Using BatchBlock and BatchedJoinBlock to Improve Efficiency</span></span>](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|<span data-ttu-id="d6e25-401"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601> 클래스를 사용하여 데이터베이스 삽입 작업의 효율성을 높이는 방법과 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> 클래스를 사용하여 결과와 프로그램이 데이터베이스에서 읽는 동안 발생하는 모든 예외를 캡처하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-401">Describes how to use the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> class to improve the efficiency of database insert operations, and how to use the <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> class to capture both the results and any exceptions that occur while the program reads from a database.</span></span>|  
|[<span data-ttu-id="d6e25-402">연습: 사용자 지정 데이터 흐름 블록 형식 만들기</span><span class="sxs-lookup"><span data-stu-id="d6e25-402">Walkthrough: Creating a Custom Dataflow Block Type</span></span>](walkthrough-creating-a-custom-dataflow-block-type.md)|<span data-ttu-id="d6e25-403">사용자 지정 동작을 구현하는 데이터 흐름 블록 형식을 만드는 두 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-403">Demonstrates two ways to create a dataflow block type that implements custom behavior.</span></span>|  
|[<span data-ttu-id="d6e25-404">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="d6e25-404">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)|<span data-ttu-id="d6e25-405">.NET Framework 애플리케이션에서 병렬 및 동시 프로그래밍을 단순화하는 라이브러리인 TPL을 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="d6e25-405">Introduces the TPL, a library that simplifies parallel and concurrent programming in .NET Framework applications.</span></span>|
