---
title: PLINQ에서 순서 유지
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, order preservation
ms.assetid: 10d202bc-19e1-4b5c-bbf1-9a977322a9ca
ms.openlocfilehash: 59d32f8801a1429718f39ab912f55cfcc5788a0e
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94820776"
---
# <a name="order-preservation-in-plinq"></a><span data-ttu-id="e8fe7-102">PLINQ에서 순서 유지</span><span class="sxs-lookup"><span data-stu-id="e8fe7-102">Order Preservation in PLINQ</span></span>
<span data-ttu-id="e8fe7-103">PLINQ에서 목표는 정확성을 유지하면서 성능을 최대화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-103">In PLINQ, the goal is to maximize performance while maintaining correctness.</span></span> <span data-ttu-id="e8fe7-104">쿼리는 가능한 한 빠르게 실행되지만 올바른 결과를 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-104">A query should run as fast as possible but still produce the correct results.</span></span> <span data-ttu-id="e8fe7-105">경우에 따라 정확성을 위해 소스 시퀀스의 순서를 유지해야 하지만 순서 지정의 계산 비용이 높을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-105">In some cases, correctness requires the order of the source sequence to be preserved; however, ordering can be computationally expensive.</span></span> <span data-ttu-id="e8fe7-106">따라서 기본적으로 PLINQ는 소스 시퀀스의 순서를 유지하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-106">Therefore, by default, PLINQ does not preserve the order of the source sequence.</span></span> <span data-ttu-id="e8fe7-107">이와 관련하여 PLINQ는 [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)]과 비슷하지만 순서를 유지하는 LINQ to Objects와는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-107">In this regard, PLINQ resembles [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], but is unlike LINQ to Objects, which does preserve ordering.</span></span>  
  
 <span data-ttu-id="e8fe7-108">기본 동작을 재정의하려면 소스 시퀀스에서 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 연산자를 사용하여 순서 유지 기능을 켤 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-108">To override the default behavior, you can turn on order-preservation by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="e8fe7-109">그런 다음, <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 메서드를 사용하여 쿼리에서 나중에 순서 유지 기능을 끌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-109">You can then turn off order preservation later in the query by using the <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> method.</span></span> <span data-ttu-id="e8fe7-110">두 메서드를 모두 사용하면 쿼리를 병렬로 실행할지 또는 순차적으로 실행할지 여부를 결정하는 추론을 기반으로 쿼리가 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-110">With both methods, the query is processed based on the heuristics that determine whether to execute the query as parallel or as sequential.</span></span> <span data-ttu-id="e8fe7-111">자세한 내용은 [PLINQ의 속도 향상 이해](understanding-speedup-in-plinq.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-111">For more information, see [Understanding Speedup in PLINQ](understanding-speedup-in-plinq.md).</span></span>  
  
 <span data-ttu-id="e8fe7-112">다음 예제는 어떤 방식으로든 결과의 순서를 지정하지 않고 조건과 일치하는 모든 요소에 대해 필터링되는 순서가 지정되지 않은 병렬 쿼리를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-112">The following example shows an unordered parallel query that filters for all the elements that match a condition, without trying to order the results in any way.</span></span>  
  
 [!code-csharp[PLINQ#8](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)]
 [!code-vb[PLINQ#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)]  
  
 <span data-ttu-id="e8fe7-113">이 쿼리는 조건을 충족하는 처음 1000개 도시를 소스 시퀀스에서 생성하기보다는 조건을 충족하는 1000개 도시 집합을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-113">This query does not necessarily produce the first 1000 cities in the source sequence that meet the condition, but rather some set of 1000 cities that meet the condition.</span></span> <span data-ttu-id="e8fe7-114">PLINQ 쿼리 연산자는 소스 시퀀스를 동시 작업으로 처리되는 여러 하위 시퀀스로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-114">PLINQ query operators partition the source sequence into multiple subsequences that are processed as concurrent tasks.</span></span> <span data-ttu-id="e8fe7-115">순서 유지를 지정하지 않으면 각 파티션의 결과가 쿼리의 다음 단계에 임의 순서로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-115">If order preservation is not specified, the results from each partition are handed off to the next stage of the query in an arbitrary order.</span></span> <span data-ttu-id="e8fe7-116">또한 파티션이 나머지 요소를 계속 처리하기 전에 결과 하위 집합을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-116">Also, a partition may yield a subset of its results before it continues to process the remaining elements.</span></span> <span data-ttu-id="e8fe7-117">결과 순서는 매번 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-117">The resulting order may be different every time.</span></span> <span data-ttu-id="e8fe7-118">순서는 운영 체제가 스레드를 예약하는 방법에 따라 다르므로 애플리케이션이 순서를 제어할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-118">Your application cannot control this because it depends on how the operating system schedules the threads.</span></span>  
  
 <span data-ttu-id="e8fe7-119">다음 예제에서는 소스 시퀀스에서 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 연산자를 사용하여 기본 동작을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-119">The following example overrides the default behavior by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="e8fe7-120">이렇게 하면 <xref:System.Linq.ParallelEnumerable.Take%2A> 메서드가 소스 시퀀스에서 조건을 충족하는 처음 1000개의 도시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-120">This ensures that the <xref:System.Linq.ParallelEnumerable.Take%2A> method returns the first 1000 cities in the source sequence that meet the condition.</span></span>  
  
 [!code-csharp[PLINQ#9](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)]
 [!code-vb[PLINQ#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)]  
  
 <span data-ttu-id="e8fe7-121">그러나 이 쿼리는 전체 파티션에서 원래 순서를 추적하고 병합 시 순서가 일치하는지 확인해야 하므로 순서가 지정되지 않은 버전만큼 빠르게 실행되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-121">However, this query probably does not run as fast as the unordered version because it must keep track of the original ordering throughout the partitions and at merge time ensure that the ordering is consistent.</span></span> <span data-ttu-id="e8fe7-122">따라서 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>는 필요한 경우에만, 그리고 필요한 쿼리의 파트에만 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-122">Therefore, we recommend that you use <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> only when it is required, and only for those parts of the query that require it.</span></span> <span data-ttu-id="e8fe7-123">순서 유지가 더 이상 필요하지 않으면 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A>를 사용하여 기능을 끕니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-123">When order preservation is no longer required, use <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> to turn it off.</span></span> <span data-ttu-id="e8fe7-124">다음 예제에서는 두 개의 쿼리를 작성하여 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-124">The following example achieves this by composing two queries.</span></span>  
  
 [!code-csharp[PLINQ#6](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)]
 [!code-vb[PLINQ#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)]  
  
 <span data-ttu-id="e8fe7-125">PLINQ는 나머지 쿼리에 대해 순서 포함 연산자에 의해 생성된 시퀀스의 순서를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-125">Note that PLINQ preserves the ordering of a sequence produced by order-imposing operators for the rest of the query.</span></span> <span data-ttu-id="e8fe7-126">즉, <xref:System.Linq.ParallelEnumerable.OrderBy%2A> 및 <xref:System.Linq.ParallelEnumerable.ThenBy%2A> 같은 연산자는 뒤에 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>에 대한 호출이 실행되는 것처럼 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-126">In other words, operators such as <xref:System.Linq.ParallelEnumerable.OrderBy%2A> and <xref:System.Linq.ParallelEnumerable.ThenBy%2A> are treated as if they were followed by a call to <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>.</span></span>  
  
## <a name="query-operators-and-ordering"></a><span data-ttu-id="e8fe7-127">쿼리 연산자 및 순서 지정</span><span class="sxs-lookup"><span data-stu-id="e8fe7-127">Query Operators and Ordering</span></span>  
 <span data-ttu-id="e8fe7-128">다음 쿼리 연산자는 순서 유지를 쿼리의 모든 후속 작업에 포함하거나 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A>가 호출될 때까지 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-128">The following query operators introduce order preservation into all subsequent operations in a query, or until <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> is called:</span></span>  
  
- <xref:System.Linq.ParallelEnumerable.OrderBy%2A>  
  
- <xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>  
  
- <xref:System.Linq.ParallelEnumerable.ThenBy%2A>  
  
- <xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>  
  
 <span data-ttu-id="e8fe7-129">다음 PLINQ 쿼리 연산자는 올바른 결과를 생성하기 위해 경우에 따라 순서가 지정된 소스 시퀀스가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-129">The following PLINQ query operators may in some cases require ordered source sequences to produce correct results:</span></span>  
  
- <xref:System.Linq.ParallelEnumerable.Reverse%2A>  
  
- <xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>  
  
- <xref:System.Linq.ParallelEnumerable.TakeWhile%2A>  
  
- <xref:System.Linq.ParallelEnumerable.SkipWhile%2A>  
  
- <xref:System.Linq.ParallelEnumerable.Zip%2A>  
  
 <span data-ttu-id="e8fe7-130">일부 PLINQ 쿼리 연산자는 소스 시퀀스의 순서가 지정되거나 순서가 지정되지 않았는지에 따라 다르게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-130">Some PLINQ query operators behave differently, depending on whether their source sequence is ordered or unordered.</span></span> <span data-ttu-id="e8fe7-131">다음 표에 이러한 연산자가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-131">The following table lists these operators.</span></span>  
  
|<span data-ttu-id="e8fe7-132">연산자</span><span class="sxs-lookup"><span data-stu-id="e8fe7-132">Operator</span></span>|<span data-ttu-id="e8fe7-133">소스 시퀀스의 순서가 지정된 경우의 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-133">Result when the source sequence is ordered</span></span>|<span data-ttu-id="e8fe7-134">소스 시퀀스의 순서가 지정되지 않은 경우의 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-134">Result when the source sequence is unordered</span></span>|  
|--------------|------------------------------------------------|--------------------------------------------------|  
|<xref:System.Linq.ParallelEnumerable.Aggregate%2A>|<span data-ttu-id="e8fe7-135">비연관 또는 비누적 작업에 대한 비결정적 출력</span><span class="sxs-lookup"><span data-stu-id="e8fe7-135">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="e8fe7-136">비연관 또는 비누적 작업에 대한 비결정적 출력</span><span class="sxs-lookup"><span data-stu-id="e8fe7-136">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.All%2A>|<span data-ttu-id="e8fe7-137">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-137">Not applicable</span></span>|<span data-ttu-id="e8fe7-138">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-138">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Any%2A>|<span data-ttu-id="e8fe7-139">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-139">Not applicable</span></span>|<span data-ttu-id="e8fe7-140">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-140">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="e8fe7-141">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-141">Not applicable</span></span>|<span data-ttu-id="e8fe7-142">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-142">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Average%2A>|<span data-ttu-id="e8fe7-143">비연관 또는 비누적 작업에 대한 비결정적 출력</span><span class="sxs-lookup"><span data-stu-id="e8fe7-143">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="e8fe7-144">비연관 또는 비누적 작업에 대한 비결정적 출력</span><span class="sxs-lookup"><span data-stu-id="e8fe7-144">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="e8fe7-145">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-145">Ordered results</span></span>|<span data-ttu-id="e8fe7-146">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-146">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="e8fe7-147">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-147">Ordered results</span></span>|<span data-ttu-id="e8fe7-148">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-148">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Count%2A>|<span data-ttu-id="e8fe7-149">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-149">Not applicable</span></span>|<span data-ttu-id="e8fe7-150">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-150">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="e8fe7-151">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-151">Not applicable</span></span>|<span data-ttu-id="e8fe7-152">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-152">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Distinct%2A>|<span data-ttu-id="e8fe7-153">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-153">Ordered results</span></span>|<span data-ttu-id="e8fe7-154">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-154">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAt%2A>|<span data-ttu-id="e8fe7-155">지정된 요소 반환</span><span class="sxs-lookup"><span data-stu-id="e8fe7-155">Return specified element</span></span>|<span data-ttu-id="e8fe7-156">임의 요소</span><span class="sxs-lookup"><span data-stu-id="e8fe7-156">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAtOrDefault%2A>|<span data-ttu-id="e8fe7-157">지정된 요소 반환</span><span class="sxs-lookup"><span data-stu-id="e8fe7-157">Return specified element</span></span>|<span data-ttu-id="e8fe7-158">임의 요소</span><span class="sxs-lookup"><span data-stu-id="e8fe7-158">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Except%2A>|<span data-ttu-id="e8fe7-159">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-159">Unordered results</span></span>|<span data-ttu-id="e8fe7-160">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-160">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.First%2A>|<span data-ttu-id="e8fe7-161">지정된 요소 반환</span><span class="sxs-lookup"><span data-stu-id="e8fe7-161">Return specified element</span></span>|<span data-ttu-id="e8fe7-162">임의 요소</span><span class="sxs-lookup"><span data-stu-id="e8fe7-162">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.FirstOrDefault%2A>|<span data-ttu-id="e8fe7-163">지정된 요소 반환</span><span class="sxs-lookup"><span data-stu-id="e8fe7-163">Return specified element</span></span>|<span data-ttu-id="e8fe7-164">임의 요소</span><span class="sxs-lookup"><span data-stu-id="e8fe7-164">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="e8fe7-165">병렬로 비결정적으로 실행</span><span class="sxs-lookup"><span data-stu-id="e8fe7-165">Executes nondeterministically in parallel</span></span>|<span data-ttu-id="e8fe7-166">병렬로 비결정적으로 실행</span><span class="sxs-lookup"><span data-stu-id="e8fe7-166">Executes nondeterministically in parallel</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupBy%2A>|<span data-ttu-id="e8fe7-167">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-167">Ordered results</span></span>|<span data-ttu-id="e8fe7-168">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-168">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupJoin%2A>|<span data-ttu-id="e8fe7-169">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-169">Ordered results</span></span>|<span data-ttu-id="e8fe7-170">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-170">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Intersect%2A>|<span data-ttu-id="e8fe7-171">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-171">Ordered results</span></span>|<span data-ttu-id="e8fe7-172">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-172">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Join%2A>|<span data-ttu-id="e8fe7-173">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-173">Ordered results</span></span>|<span data-ttu-id="e8fe7-174">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-174">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Last%2A>|<span data-ttu-id="e8fe7-175">지정된 요소 반환</span><span class="sxs-lookup"><span data-stu-id="e8fe7-175">Return specified element</span></span>|<span data-ttu-id="e8fe7-176">임의 요소</span><span class="sxs-lookup"><span data-stu-id="e8fe7-176">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LastOrDefault%2A>|<span data-ttu-id="e8fe7-177">지정된 요소 반환</span><span class="sxs-lookup"><span data-stu-id="e8fe7-177">Return specified element</span></span>|<span data-ttu-id="e8fe7-178">임의 요소</span><span class="sxs-lookup"><span data-stu-id="e8fe7-178">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LongCount%2A>|<span data-ttu-id="e8fe7-179">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-179">Not applicable</span></span>|<span data-ttu-id="e8fe7-180">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-180">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Min%2A>|<span data-ttu-id="e8fe7-181">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-181">Not applicable</span></span>|<span data-ttu-id="e8fe7-182">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-182">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderBy%2A>|<span data-ttu-id="e8fe7-183">시퀀스의 순서 변경</span><span class="sxs-lookup"><span data-stu-id="e8fe7-183">Reorders the sequence</span></span>|<span data-ttu-id="e8fe7-184">새 순서가 지정된 섹션 시작</span><span class="sxs-lookup"><span data-stu-id="e8fe7-184">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>|<span data-ttu-id="e8fe7-185">시퀀스의 순서 변경</span><span class="sxs-lookup"><span data-stu-id="e8fe7-185">Reorders the sequence</span></span>|<span data-ttu-id="e8fe7-186">새 순서가 지정된 섹션 시작</span><span class="sxs-lookup"><span data-stu-id="e8fe7-186">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Range%2A>|<span data-ttu-id="e8fe7-187">적용할 수 없음(<xref:System.Linq.ParallelEnumerable.AsParallel%2A>과 동일한 기본값)</span><span class="sxs-lookup"><span data-stu-id="e8fe7-187">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )</span></span>|<span data-ttu-id="e8fe7-188">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-188">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Repeat%2A>|<span data-ttu-id="e8fe7-189">적용할 수 없음(<xref:System.Linq.ParallelEnumerable.AsParallel%2A>과 동일한 기본값)</span><span class="sxs-lookup"><span data-stu-id="e8fe7-189">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)</span></span>|<span data-ttu-id="e8fe7-190">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-190">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="e8fe7-191">역방향 순서 지정</span><span class="sxs-lookup"><span data-stu-id="e8fe7-191">Reverses</span></span>|<span data-ttu-id="e8fe7-192">아무 작업도 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-192">Does nothing</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="e8fe7-193">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-193">Ordered results</span></span>|<span data-ttu-id="e8fe7-194">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-194">Unordered results</span></span>|  
|<span data-ttu-id="e8fe7-195"><xref:System.Linq.ParallelEnumerable.Select%2A>(인덱싱됨)</span><span class="sxs-lookup"><span data-stu-id="e8fe7-195"><xref:System.Linq.ParallelEnumerable.Select%2A> (indexed)</span></span>|<span data-ttu-id="e8fe7-196">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-196">Ordered results</span></span>|<span data-ttu-id="e8fe7-197">순서가 지정되지 않은 결과.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-197">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="e8fe7-198">순서가 지정된 결과.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-198">Ordered results.</span></span>|<span data-ttu-id="e8fe7-199">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-199">Unordered results</span></span>|  
|<span data-ttu-id="e8fe7-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A>(인덱싱됨)</span><span class="sxs-lookup"><span data-stu-id="e8fe7-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A> (indexed)</span></span>|<span data-ttu-id="e8fe7-201">순서가 지정된 결과.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-201">Ordered results.</span></span>|<span data-ttu-id="e8fe7-202">순서가 지정되지 않은 결과.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-202">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>|<span data-ttu-id="e8fe7-203">순서가 지정된 비교</span><span class="sxs-lookup"><span data-stu-id="e8fe7-203">Ordered comparison</span></span>|<span data-ttu-id="e8fe7-204">순서가 지정되지 않은 비교</span><span class="sxs-lookup"><span data-stu-id="e8fe7-204">Unordered comparison</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Single%2A>|<span data-ttu-id="e8fe7-205">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-205">Not applicable</span></span>|<span data-ttu-id="e8fe7-206">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-206">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SingleOrDefault%2A>|<span data-ttu-id="e8fe7-207">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-207">Not applicable</span></span>|<span data-ttu-id="e8fe7-208">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-208">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="e8fe7-209">처음 *n* 개 요소를 건너뜀</span><span class="sxs-lookup"><span data-stu-id="e8fe7-209">Skips first *n* elements</span></span>|<span data-ttu-id="e8fe7-210">임의 *n* 개 요소를 건너뜀</span><span class="sxs-lookup"><span data-stu-id="e8fe7-210">Skips any *n* elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SkipWhile%2A>|<span data-ttu-id="e8fe7-211">순서가 지정된 결과.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-211">Ordered results.</span></span>|<span data-ttu-id="e8fe7-212">비결정적.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-212">Nondeterministic.</span></span> <span data-ttu-id="e8fe7-213">현재 임의 순서로 SkipWhile 수행</span><span class="sxs-lookup"><span data-stu-id="e8fe7-213">Performs SkipWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Sum%2A>|<span data-ttu-id="e8fe7-214">비연관 또는 비누적 작업에 대한 비결정적 출력</span><span class="sxs-lookup"><span data-stu-id="e8fe7-214">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="e8fe7-215">비연관 또는 비누적 작업에 대한 비결정적 출력</span><span class="sxs-lookup"><span data-stu-id="e8fe7-215">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="e8fe7-216">처음 `n`개 요소 사용</span><span class="sxs-lookup"><span data-stu-id="e8fe7-216">Takes first `n` elements</span></span>|<span data-ttu-id="e8fe7-217">임의 `n`개 요소 사용</span><span class="sxs-lookup"><span data-stu-id="e8fe7-217">Takes any `n` elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.TakeWhile%2A>|<span data-ttu-id="e8fe7-218">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-218">Ordered results</span></span>|<span data-ttu-id="e8fe7-219">비결정적.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-219">Nondeterministic.</span></span> <span data-ttu-id="e8fe7-220">현재 임의 순서로 TakeWhile 수행</span><span class="sxs-lookup"><span data-stu-id="e8fe7-220">Performs TakeWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenBy%2A>|<span data-ttu-id="e8fe7-221">`OrderBy` 보완</span><span class="sxs-lookup"><span data-stu-id="e8fe7-221">Supplements `OrderBy`</span></span>|<span data-ttu-id="e8fe7-222">`OrderBy` 보완</span><span class="sxs-lookup"><span data-stu-id="e8fe7-222">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>|<span data-ttu-id="e8fe7-223">`OrderBy` 보완</span><span class="sxs-lookup"><span data-stu-id="e8fe7-223">Supplements `OrderBy`</span></span>|<span data-ttu-id="e8fe7-224">`OrderBy` 보완</span><span class="sxs-lookup"><span data-stu-id="e8fe7-224">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToArray%2A>|<span data-ttu-id="e8fe7-225">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-225">Ordered results</span></span>|<span data-ttu-id="e8fe7-226">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-226">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToDictionary%2A>|<span data-ttu-id="e8fe7-227">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-227">Not applicable</span></span>|<span data-ttu-id="e8fe7-228">해당 없음</span><span class="sxs-lookup"><span data-stu-id="e8fe7-228">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToList%2A>|<span data-ttu-id="e8fe7-229">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-229">Ordered results</span></span>|<span data-ttu-id="e8fe7-230">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-230">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToLookup%2A>|<span data-ttu-id="e8fe7-231">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-231">Ordered results</span></span>|<span data-ttu-id="e8fe7-232">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-232">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Union%2A>|<span data-ttu-id="e8fe7-233">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-233">Ordered results</span></span>|<span data-ttu-id="e8fe7-234">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-234">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="e8fe7-235">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-235">Ordered results</span></span>|<span data-ttu-id="e8fe7-236">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-236">Unordered results</span></span>|  
|<span data-ttu-id="e8fe7-237"><xref:System.Linq.ParallelEnumerable.Where%2A>(인덱싱됨)</span><span class="sxs-lookup"><span data-stu-id="e8fe7-237"><xref:System.Linq.ParallelEnumerable.Where%2A> (indexed)</span></span>|<span data-ttu-id="e8fe7-238">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-238">Ordered results</span></span>|<span data-ttu-id="e8fe7-239">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-239">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Zip%2A>|<span data-ttu-id="e8fe7-240">순서가 지정된 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-240">Ordered results</span></span>|<span data-ttu-id="e8fe7-241">순서가 지정되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="e8fe7-241">Unordered results</span></span>|  
  
 <span data-ttu-id="e8fe7-242">순서가 지정되지 않은 결과는 순서가 활발히 바뀌지 않습니다. 특별한 순서 지정 논리가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-242">Unordered results are not actively shuffled; they simply do not have any special ordering logic applied to them.</span></span> <span data-ttu-id="e8fe7-243">경우에 따라 순서가 지정되지 않은 쿼리가 소스 시퀀스의 순서를 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-243">In some cases, an unordered query may retain the ordering of the source sequence.</span></span> <span data-ttu-id="e8fe7-244">인덱싱된 Select 연산자를 사용하는 쿼리의 경우 PLINQ는 출력 요소가 인덱스 증가 순서로 표시되도록 보장하지만 어떤 인덱스가 어떤 요소에 할당되는지에 대한 보장은 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e8fe7-244">For queries that use the indexed Select operator, PLINQ guarantees that the output elements will come out in the order of increasing indices, but makes no guarantees about which indices will be assigned to which elements.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e8fe7-245">참고 항목</span><span class="sxs-lookup"><span data-stu-id="e8fe7-245">See also</span></span>

- [<span data-ttu-id="e8fe7-246">PLINQ(병렬 LINQ)</span><span class="sxs-lookup"><span data-stu-id="e8fe7-246">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
- [<span data-ttu-id="e8fe7-247">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="e8fe7-247">Parallel Programming</span></span>](index.md)
