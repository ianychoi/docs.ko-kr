---
title: 연속 작업을 사용하여 작업 연결
description: .NET에서 연속 작업을 사용하여 작업을 연결하는 방법을 알아봅니다. 연속 작업은 다른 작업에서 호출하는 비동기 작업입니다.
ms.date: 07/20/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
ms.openlocfilehash: c7afbc1bb22a1743aed8e4ebd0a06c4f3fb57e86
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94830612"
---
# <a name="chaining-tasks-using-continuation-tasks"></a><span data-ttu-id="a7142-104">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="a7142-104">Chaining tasks using continuation tasks</span></span>

<span data-ttu-id="a7142-105">비동기 프로그래밍에서는 한 비동기 작업이 완료 시 두 번째 작업을 호출하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-105">In asynchronous programming, it's common for one asynchronous operation, on completion, to invoke a second operation.</span></span> <span data-ttu-id="a7142-106">연속 작업을 사용하면 후행 작업이 첫 번째 작업의 결과를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-106">Continuations allow decedent operations to consume the results of the first operation.</span></span> <span data-ttu-id="a7142-107">일반적으로 연속 작업은 콜백 메서드를 통해 수행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-107">Traditionally, continuations have been done by using callback methods.</span></span> <span data-ttu-id="a7142-108">작업 병렬 라이브러리에서는 _연속 작업_ 이 동일한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-108">In the Task Parallel Library, the same functionality is provided by _continuation tasks_.</span></span> <span data-ttu-id="a7142-109">연속 작업(연속이라고도 함)은 선행 작업이라고도 하는 다른 작업이 완료 시 호출하는 비동기 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-109">A continuation task (also known just as a continuation) is an asynchronous task that's invoked by another task, known as the _antecedent_, when the antecedent finishes.</span></span>

<span data-ttu-id="a7142-110">연속은 비교적 사용이 용이하지만 강력하고 유연합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-110">Continuations are relatively easy to use, but are nevertheless powerful and flexible.</span></span> <span data-ttu-id="a7142-111">예를 들어 다음 작업을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-111">For example, you can:</span></span>

- <span data-ttu-id="a7142-112">선행 작업의 데이터를 연속 작업에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-112">Pass data from the antecedent to the continuation.</span></span>
- <span data-ttu-id="a7142-113">연속 작업이 호출되거나 호출되지 않는 정확한 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-113">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>
- <span data-ttu-id="a7142-114">시작되기 전이나 실행 중일 때 함께 연속 작업을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-114">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>
- <span data-ttu-id="a7142-115">연속 작업을 예약하는 방법에 대한 힌트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-115">Provide hints about how the continuation should be scheduled.</span></span>
- <span data-ttu-id="a7142-116">동일한 선행 작업에서 여러 개의 연속 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-116">Invoke multiple continuations from the same antecedent.</span></span>
- <span data-ttu-id="a7142-117">여러 선행 작업 중 하나 또는 모두가 완료되면 하나의 연속 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-117">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>
- <span data-ttu-id="a7142-118">연속 작업을 임의 길이까지 차례로 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-118">Chain continuations one after another to any arbitrary length.</span></span>
- <span data-ttu-id="a7142-119">연속 작업을 사용하여 선행 작업에서 발생한 예외를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-119">Use a continuation to handle exceptions thrown by the antecedent.</span></span>

## <a name="about-continuations"></a><span data-ttu-id="a7142-120">연속 작업 정보</span><span class="sxs-lookup"><span data-stu-id="a7142-120">About continuations</span></span>

<span data-ttu-id="a7142-121">연속 작업은 <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> 상태로 만들어지는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-121">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="a7142-122">선행 작업이 완료되면 자동으로 활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-122">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="a7142-123">사용자 코드에서 연속 작업에 대해 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> 를 호출하면 <xref:System.InvalidOperationException?displayProperty=nameWithType> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-123">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>

<span data-ttu-id="a7142-124">연속 작업 자체는 <xref:System.Threading.Tasks.Task> 이며 작업이 시작된 스레드를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-124">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="a7142-125">연속 작업이 완료될 때까지 차단하려면 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-125">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>

## <a name="create-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="a7142-126">단일 선행 작업에 대한 연속 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="a7142-126">Create a continuation for a single antecedent</span></span>

<span data-ttu-id="a7142-127"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드를 호출하여 선행 작업이 완료되었을 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-127">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a7142-128">다음 예제에서는 기본 패턴을 보여줍니다(이해하기 쉽도록 예외 처리는 생략됨).</span><span class="sxs-lookup"><span data-stu-id="a7142-128">The following example shows the basic pattern (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="a7142-129">현재 요일의 이름을 나타내는 `taskA`개체를 반환하는 선행 작업 <xref:System.DayOfWeek> 를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-129">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="a7142-130">선행 작업이 완료되면 연속 작업 `continuation`에 선행 작업이 전달되고 해당 결과를 포함하는 문자열을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-130">When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result.</span></span>

> [!NOTE]
> <span data-ttu-id="a7142-131">이 문서의 C# 샘플은 `Main` 메서드에서 `async` 한정자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-131">The C# samples in this article make use of the `async` modifier on the `Main` method.</span></span> <span data-ttu-id="a7142-132">해당 기능은 C# 7.1 이상에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-132">That feature is available in C# 7.1 and later.</span></span> <span data-ttu-id="a7142-133">이전 버전은 이 샘플 코드를 컴파일하는 경우 [`CS5001`](../../csharp/misc/cs5001.md)을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-133">Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code.</span></span> <span data-ttu-id="a7142-134">언어 버전을 C# 7.1 이상으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-134">You'll need to set the language version to C# 7.1 or newer.</span></span> <span data-ttu-id="a7142-135">[언어 버전 구성](../../csharp/language-reference/configure-language-version.md)에 관한 문서에서 언어 버전을 구성하는 방법을 알아볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-135">You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).</span></span>

:::code language="csharp" source="snippets/cs/simple1.cs":::

[!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]

## <a name="create-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="a7142-136">여러 선행 작업에 대한 연속 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="a7142-136">Create a continuation for multiple antecedents</span></span>

<span data-ttu-id="a7142-137">작업 그룹 중 하나 또는 모두가 완료되었을 때 실행되는 연속 작업을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-137">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="a7142-138">모든 선행 작업이 완료되었을 때 연속 작업을 실행하려면 static(Visual Basic에서는`Shared` ) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 메서드 또는 인스턴스 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-138">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a7142-139">선행 작업 중 하나가 완료되었을 때 연속 작업을 실행하려면 static(Visual Basic에서는`Shared` ) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 메서드 또는 인스턴스 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-139">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="a7142-140"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 오버로드 호출은 호출 스레드를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-140">Calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span> <span data-ttu-id="a7142-141">그러나 일반적으로는 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> 메서드를 제외하고 모두 호출하여 반환된 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성을 검색하므로, 호출 스레드가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-141">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>

<span data-ttu-id="a7142-142">다음 예제에서는 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 메서드를 호출하여 10개 선행 작업의 결과를 반영하는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-142">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks.</span></span> <span data-ttu-id="a7142-143">각 선행 작업은 1에서 10까지의 인덱스 값을 제곱합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-143">Each antecedent task squares an index value that ranges from one to 10.</span></span> <span data-ttu-id="a7142-144">선행 작업이 성공적으로 완료될 경우( <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성이 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>임) 연속 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 각 선행 작업에서 반환된 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 값의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-144">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="a7142-145">예제에서는 값을 더하여 1과 10 사이의 모든 숫자의 제곱 합계를 컴퓨팅합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-145">The example adds them to compute the sum of squares for all numbers between one and 10.</span></span>

:::code language="csharp" source="snippets/cs/whenall1.cs":::

[!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]

## <a name="continuation-options"></a><span data-ttu-id="a7142-146">연속 옵션</span><span class="sxs-lookup"><span data-stu-id="a7142-146">Continuation options</span></span>

<span data-ttu-id="a7142-147">단일 작업 연속을 만드는 경우 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 열거형 값을 받는 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 오버로드를 사용하여 연속 작업이 시작되는 조건을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-147">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="a7142-148">예를 들어 선행 작업이 성공적으로 완료되거나 오류 상태로 완료되는 경우에만 연속 작업이 실행되도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-148">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="a7142-149">선행 작업이 연속 작업을 호출할 준비가 되었을 때 조건이 true가 아니면 연속 작업이 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 상태로 바로 전환되며 그 후에 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-149">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started.</span></span>

<span data-ttu-id="a7142-150"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 메서드 오버로드와 같은 많은 다중 작업 연속 메서드에는 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 매개 변수도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-150">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="a7142-151">그러나 모든 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 열거형 멤버의 하위 집합만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-151">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="a7142-152"><xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 열거형에 해당 항목이 있는 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 값(예: <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>및 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>)을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-152">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a7142-153">다중 작업 연속에 `NotOn` 또는 `OnlyOn` 옵션을 지정하는 경우 런타임에 <xref:System.ArgumentOutOfRangeException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-153">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>

<span data-ttu-id="a7142-154">작업 연속 옵션에 대한 자세한 내용은 <xref:System.Threading.Tasks.TaskContinuationOptions> 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a7142-154">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>

## <a name="pass-data-to-a-continuation"></a><span data-ttu-id="a7142-155">연속 작업에 데이터 전달</span><span class="sxs-lookup"><span data-stu-id="a7142-155">Pass data to a continuation</span></span>

<span data-ttu-id="a7142-156"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드는 연속 작업의 사용자 대리자에게 선행 작업에 대한 참조를 인수로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-156">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="a7142-157">선행 작업이 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 개체이고 작업이 완료될 때까지 실행된 경우 연속 작업이 해당 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-157">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>

<span data-ttu-id="a7142-158"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-158">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="a7142-159">그러나 작업이 취소되거나 오류가 발생한 경우 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성에 액세스하려고 하면 <xref:System.AggregateException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-159">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="a7142-160">다음 예제와 같이 <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> 옵션을 사용하여 이 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-160">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/result1.cs":::

[!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]

<span data-ttu-id="a7142-161">선행 작업이 성공적으로 완료될 때까지 실행되지 않은 경우에도 연속 작업을 실행하려면 예외로부터 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-161">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="a7142-162">한 가지 방법은 선행 작업의 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성을 테스트하고 상태가 <xref:System.Threading.Tasks.Task%601.Result%2A> 또는 <xref:System.Threading.Tasks.TaskStatus.Faulted> 가 아닌 경우에만 <xref:System.Threading.Tasks.TaskStatus.Canceled>속성에 액세스하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-162">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="a7142-163">선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성을 검사할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-163">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="a7142-164">자세한 내용은 [예외 처리](exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a7142-164">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="a7142-165">다음 예제에서는 상태가 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 인 경우에만 선행 작업의 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>속성에 액세스하도록 이전 예제를 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-165">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/result2.cs":::

[!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]

## <a name="cancel-a-continuation"></a><span data-ttu-id="a7142-166">연속 작업 취소</span><span class="sxs-lookup"><span data-stu-id="a7142-166">Cancel a continuation</span></span>

<span data-ttu-id="a7142-167">다음과 같은 경우 연속 작업의 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성이 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-167">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>

- <span data-ttu-id="a7142-168">취소 요청에 대한 응답으로 <xref:System.OperationCanceledException> 예외를 발생시키는 경우.</span><span class="sxs-lookup"><span data-stu-id="a7142-168">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="a7142-169">모든 작업과 마찬가지로 연속 작업에 전달된 것과 동일한 토큰이 예외에 포함되어 있으면 협조적 취소의 인정으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-169">As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgment of cooperative cancellation.</span></span>
- <span data-ttu-id="a7142-170">연속 작업에 <xref:System.Threading.CancellationToken?displayProperty=nameWithType> 속성이 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 인 `true`이 전달된 경우.</span><span class="sxs-lookup"><span data-stu-id="a7142-170">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="a7142-171">이 경우에는 연속 작업이 시작되지 않고 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 상태로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-171">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>
- <span data-ttu-id="a7142-172"><xref:System.Threading.Tasks.TaskContinuationOptions> 인수로 설정된 조건이 충족되지 않았으므로 연속 작업이 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-172">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="a7142-173">예를 들어 선행 작업이 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 상태로 전환되는 경우 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> 옵션이 전달된 연속 작업이 실행되지 않고 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-173">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>

<span data-ttu-id="a7142-174">작업과 해당 연속 작업이 동일한 논리 작업의 두 부분을 나타내는 경우 다음 예제와 같이 두 작업에 모두 동일한 취소 토큰을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-174">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="a7142-175">취소 토큰은 33으로 나눌 수 있는 정수 목록을 생성하는 선행 작업으로 구성되며 연속 작업에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-175">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="a7142-176">그런 다음 연속 작업이 목록을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-176">The continuation in turn displays the list.</span></span> <span data-ttu-id="a7142-177">선행 작업과 연속 작업은 모두 임의 간격 동안 정기적으로 일시 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-177">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="a7142-178">또한 <xref:System.Threading.Timer?displayProperty=nameWithType> 개체는 5초 시간 제한 간격 후에 `Elapsed` 메서드를 실행하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-178">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="a7142-179">이 예제에서는 현재 실행 중인 작업이 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드를 호출하게 하는 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-179">This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a7142-180">선행 작업이나 해당 연속 작업이 실행 중일 때 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출할지 여부는 임의로 생성된 일시 중지 기간에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-180">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="a7142-181">선행 작업이 취소되면 연속 작업은 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-181">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="a7142-182">선행 작업이 취소되지 않은 경우에도 토큰을 사용하여 연속 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-182">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>

:::code language="csharp" source="snippets/cs/cancellation1.cs":::

[!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]

<span data-ttu-id="a7142-183">연속 작업을 만들 때 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> 옵션을 지정하면 연속 작업에 취소 토큰을 제공하지 않고 선행 작업이 취소된 경우에도 연속 작업이 실행되지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-183">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="a7142-184">다음은 간단한 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-184">The following is a simple example.</span></span>

:::code language="csharp" source="snippets/cs/cancellation2.cs":::

[!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]

<span data-ttu-id="a7142-185">연속 작업이 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태로 전환된 후 연속 작업에 대해 지정된 <xref:System.Threading.Tasks.TaskContinuationOptions> 에 따라 이후의 연속 작업에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-185">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>

<span data-ttu-id="a7142-186">삭제된 연속 작업은 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-186">Continuations that are disposed will not start.</span></span>

## <a name="continuations-and-child-tasks"></a><span data-ttu-id="a7142-187">연속 작업 및 자식 작업</span><span class="sxs-lookup"><span data-stu-id="a7142-187">Continuations and child tasks</span></span>

<span data-ttu-id="a7142-188">연속 작업은 선행 작업 및 연결된 모든 자식 작업이 완료될 때까지 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-188">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="a7142-189">연속 작업은 분리된 자식 작업이 완료되기를 기다리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-189">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="a7142-190">다음 두 예제에서는 연속 작업을 만드는 선행 작업에 연결된 자식 작업과 분리된 자식 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-190">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="a7142-191">다음 예제에서는 모든 자식 작업이 완료된 후에만 연속 작업이 실행되며 예제를 여러 번 실행해도 매번 동일한 출력이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-191">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="a7142-192">기본적으로 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드는 기본 작업 생성 옵션이 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>인 부모 작업을 만들기 때문에 예제에서는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드를 호출하여 선행 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-192">The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/attached1.cs":::

[!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]

<span data-ttu-id="a7142-193">그러나 자식 작업이 선행 작업에서 분리된 경우 자식 작업의 상태에 관계없이 선행 작업이 종료된 즉시 연속 작업이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-193">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="a7142-194">따라서 다음 예제를 여러 번 실행하면 작업 스케줄러가 각 자식 작업을 처리한 방식에 따라 다른 출력이 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-194">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>

:::code language="csharp" source="snippets/cs/detached1.cs":::

[!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]

<span data-ttu-id="a7142-195">선행 작업의 최종 상태는 연결된 자식 작업의 최종 상태에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-195">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="a7142-196">분리된 자식 작업의 상태는 부모에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-196">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="a7142-197">자세한 내용은 [연결된 자식 작업과 분리된 자식 작업](attached-and-detached-child-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a7142-197">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="associate-state-with-continuations"></a><span data-ttu-id="a7142-198">연속 작업에 상태 연결</span><span class="sxs-lookup"><span data-stu-id="a7142-198">Associate state with continuations</span></span>

<span data-ttu-id="a7142-199">연속 작업에 임의 상태를 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-199">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="a7142-200"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 메서드는 각각 연속 상태를 나타내는 <xref:System.Object> 값을 받는 오버로드된 버전을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-200">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="a7142-201">나중에 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 속성을 사용하여 이 상태 개체에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-201">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a7142-202">값을 제공하지 않을 경우 이 상태 개체는 `null` 입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-202">This state object is `null` if you do not provide a value.</span></span>

<span data-ttu-id="a7142-203">연속 상태는 [APM(비동기 프로그래밍 모델)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) 을 사용하는 기존 코드를 TPL을 사용하도록 변환하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-203">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="a7142-204">APM에서는 일반적으로 **Begin**_Method_ 메서드에 개체 상태를 제공하고 나중에 <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> 속성을 통해 해당 상태에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-204">In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a7142-205"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 메서드를 사용하면 APM을 사용하는 코드를 TPL을 사용하도록 변환할 때 이 상태를 보존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-205">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>

<span data-ttu-id="a7142-206">Visual Studio 디버거에서 <xref:System.Threading.Tasks.Task> 개체로 작업하는 경우에도 연속 상태가 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-206">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="a7142-207">예를 들어 **병렬 작업** 창의 **작업** 열에는 각 작업에 대한 상태 개체의 문자열 표현이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-207">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="a7142-208">**병렬 작업** 창에 대한 자세한 내용은 [작업 창 사용](/visualstudio/debugger/using-the-tasks-window)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a7142-208">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>

<span data-ttu-id="a7142-209">다음 예제에서는 연속 상태를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-209">The following example shows how to use continuation state.</span></span> <span data-ttu-id="a7142-210">연속 작업 체인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-210">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="a7142-211">각 작업은 <xref:System.DateTime> 메서드의 `state` 매개 변수에 대해 현재 시간인 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 개체를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-211">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="a7142-212">각 <xref:System.DateTime> 개체는 연속 작업이 만들어진 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-212">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="a7142-213">각 작업은 작업 완료 시간을 나타내는 두 번째 <xref:System.DateTime> 개체를 결과로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-213">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="a7142-214">이 예제에서는 모든 작업이 완료된 후 만든 시간과 각 연속 작업의 완료 시간이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-214">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>

:::code language="csharp" source="snippets/cs/continuationstate.cs":::

[!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]

## <a name="continuations-that-return-task-types"></a><span data-ttu-id="a7142-215">작업 유형을 반환하는 연속 작업</span><span class="sxs-lookup"><span data-stu-id="a7142-215">Continuations that return Task types</span></span>

<span data-ttu-id="a7142-216"><xref:System.Threading.Tasks.Task> 형식을 반환하는 연속 작업을 연결해야 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-216">Sometimes you may need to chain a continuation that returns a <xref:System.Threading.Tasks.Task> type.</span></span> <span data-ttu-id="a7142-217">이러한 작업은 중첩된 작업이라고 하며 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-217">These are referred to as nested tasks, and they are common.</span></span> <span data-ttu-id="a7142-218">부모 작업이 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>을 호출하고 작업을 반환하는 `continuationFunction`을 제공하는 경우 <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>을 호출하여 `<Task<Task<T>>>` 또는 `Task(Of Task(Of T))`(Visual Basic)의 비동기 작업을 나타내는 프록시 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-218">When a parent task calls <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>, and provides a `continuationFunction` that is task returning you call <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> to create a proxy task that represents the asynchronous operation of the `<Task<Task<T>>>` or `Task(Of Task(Of T))` (Visual Basic).</span></span>

<span data-ttu-id="a7142-219">다음 예제에서는 추가 작업 반환 함수를 래핑하는 연속 작업을 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-219">The following example shows how to use continuations that wrap additional task returning functions.</span></span> <span data-ttu-id="a7142-220">각 연속 작업을 래핑 해제하여 래핑된 내부 작업을 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-220">Each continuation can be unwrapped, exposing the inner task that was wrapped.</span></span>

:::code language="csharp" source="snippets/cs/unwrap.cs":::
:::code language="vb" source="snippets/vb/unwrap.vb":::

<span data-ttu-id="a7142-221"><xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>을 사용하는 방법에 대한 자세한 내용은 [방법: 중첩된 작업 래핑 취소](how-to-unwrap-a-nested-task.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a7142-221">For more information on using <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>, see [How to: Unwrap a nested Task](how-to-unwrap-a-nested-task.md).</span></span>

## <a name="handle-exceptions-thrown-from-continuations"></a><span data-ttu-id="a7142-222">연속 작업에서 throw된 예외 처리</span><span class="sxs-lookup"><span data-stu-id="a7142-222">Handle exceptions thrown from continuations</span></span>

<span data-ttu-id="a7142-223">선행-연속 관계는 부모-자식 관계가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-223">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="a7142-224">연속 작업에서 발생한 예외는 선행 작업으로 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-224">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="a7142-225">따라서 다른 작업에서 처리하는 것처럼 연속 작업에서 발생한 예외를 다음과 같이 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-225">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>

- <span data-ttu-id="a7142-226"><xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>또는 <xref:System.Threading.Tasks.Task.WaitAny%2A> 메서드나 해당하는 제네릭 항목을 사용하여 연속 작업을 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-226">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="a7142-227">다음 예제와 같이 동일한 `try` 문에서 선행 작업과 해당 연속 작업을 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-227">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/exception1.cs":::

[!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]

- <span data-ttu-id="a7142-228">두 번째 연속 작업을 사용하여 첫 번째 연속 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성을 관찰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-228">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="a7142-229">다음 예제에서는 작업이 존재하지 않는 파일을 읽으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-229">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="a7142-230">그런 다음 연속 작업이 선행 작업의 예외 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-230">The continuation then displays information about the exception in the antecedent task.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="example":::

[!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]

<span data-ttu-id="a7142-231"><xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> 옵션으로 실행되었기 때문에 연속 작업은 선행 작업에서 예외가 발생한 경우에만 실행되므로 선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성이 `null`이 아니라고 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-231">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="a7142-232">선행 작업에 예외가 발생했는지 여부에 관계없이 연속 작업이 실행되는 경우 다음 코드 조각과 같이 예외를 처리하기 전에 선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성이 `null` 이 아닌지 여부를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-232">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="exception":::

[!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]

<span data-ttu-id="a7142-233">자세한 내용은 [예외 처리](exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a7142-233">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

- <span data-ttu-id="a7142-234">연속 작업이 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> 옵션으로 만든 연결된 자식 작업인 경우 다른 연결된 자식과 마찬가지로 부모가 해당 예외를 호출 스레드로 다시 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="a7142-234">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="a7142-235">자세한 내용은 [연결된 자식 작업과 분리된 자식 작업](attached-and-detached-child-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a7142-235">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="a7142-236">참조</span><span class="sxs-lookup"><span data-stu-id="a7142-236">See also</span></span>

- [<span data-ttu-id="a7142-237">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="a7142-237">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
