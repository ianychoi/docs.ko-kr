---
title: 작업 기반 비동기 프로그래밍 - .NET
description: 이 문서에서는 .NET의 TPL(작업 병렬 라이브러리)을 통한 작업 기반 비동기 프로그래밍에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
ms.openlocfilehash: a1abe474628cd88e0c24f4152d83bd8ed7ad7950
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94830027"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="08603-103">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="08603-103">Task-based asynchronous programming</span></span>

<span data-ttu-id="08603-104">TPL(작업 병렬 라이브러리)은 *작업* 이란 개념을 기반으로 하며 비동기 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="08603-104">The Task Parallel Library (TPL) is based on the concept of a *task*, which represents an asynchronous operation.</span></span> <span data-ttu-id="08603-105">몇 가지 점에서 작업은 스레드 또는 <xref:System.Threading.ThreadPool> 작업 항목과 비슷하지만 추상화 수준은 더 높습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-105">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="08603-106">*작업 병렬 처리* 는 동시에 실행되는 하나 이상의 독립적인 작업을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-106">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="08603-107">작업을 사용할 때의 주된 이점 두 가지는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-107">Tasks provide two primary benefits:</span></span>

- <span data-ttu-id="08603-108">시스템 리소스를 더 효율적이고 확장 가능한 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-108">More efficient and more scalable use of system resources.</span></span>

     <span data-ttu-id="08603-109">내부적으로 작업은 <xref:System.Threading.ThreadPool>의 큐에 대기됩니다. 이 ThreadPool은 스레드 수를 파악하여 이에 맞게 조정하고, 처리량을 최대화하는 부하 분산을 제공하는 알고리즘을 사용하여 기능이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-109">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="08603-110">이로써 작업이 비교적 단순해지며, 여러 개의 작업을 만들어 세부적인 병렬 처리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-110">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>

- <span data-ttu-id="08603-111">프로그래밍 방식 제어 수준이 스레드 또는 작업 항목을 사용할 때보다 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="08603-111">More programmatic control than is possible with a thread or work item.</span></span>

     <span data-ttu-id="08603-112">작업과 작업을 기반으로 만들어진 프레임워크는 대기, 취소, 연속, 강력한 예외 처리, 세부 상태, 사용자 지정 예약 등을 지원하는 강력한 API 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-112">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>

<span data-ttu-id="08603-113">이 두 가지 이유 때문에 .NET에서는 다중 스레드, 비동기, 병렬 코드를 작성하는 API로 TPL이 선호됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-113">For both of these reasons, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code in .NET.</span></span>

## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="08603-114">암시적으로 작업 만들기 및 실행</span><span class="sxs-lookup"><span data-stu-id="08603-114">Creating and running tasks implicitly</span></span>

<span data-ttu-id="08603-115"><xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> 메서드를 사용하면 개수에 관계없이 여러 개의 임의 문을 간편하게 동시에 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-115">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="08603-116">작업의 각 항목에 대한 <xref:System.Action> 대리자를 전달하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-116">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="08603-117">이러한 대리자를 만드는 가장 쉬운 방법은 람다 식을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-117">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="08603-118">람다 식은 명명된 메서드를 호출하거나 코드를 인라인으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-118">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="08603-119">다음 예제에서는 동시에 실행되는 두 개의 작업을 만들고 시작하는 기본적인 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 호출을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-119">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="08603-120">이름이 `DoSomeWork`인 메서드를 호출하는 람다 식에서 첫 번째 작업을 표시하며 이름이 `DoSomeOtherWork`인 메서드를 호출하는 람다 식에서 두 번째 작업을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-120">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>

> [!NOTE]
> <span data-ttu-id="08603-121">이 문서에서는 람다 식을 사용하여 TPL에 대리자를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-121">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="08603-122">C# 또는 Visual Basic의 람다 식을 잘 모르는 경우 [PLINQ 및 TPL의 람다 식](lambda-expressions-in-plinq-and-tpl.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-122">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

[!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
[!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]

> [!NOTE]
> <span data-ttu-id="08603-123"><xref:System.Threading.Tasks.Task>에 의해 자동으로 만들어지는 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 인스턴스의 수는 제공되는 대리자의 수와 같지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-123">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="08603-124">TPL에서는 대리자 수가 많은 경우 등에 다양한 최적화 기능을 사용할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-124">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>

<span data-ttu-id="08603-125">자세한 내용은 [방법: Parallel.Invoke를 사용하여 병렬 작업 실행](how-to-use-parallel-invoke-to-execute-parallel-operations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-125">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>

<span data-ttu-id="08603-126">작업 실행을 더 구체적으로 제어하거나 작업을 통해 값을 반환하려면 <xref:System.Threading.Tasks.Task> 개체를 더 명시적으로 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-126">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>

## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="08603-127">명시적으로 작업 만들기 및 실행</span><span class="sxs-lookup"><span data-stu-id="08603-127">Creating and running tasks explicitly</span></span>

<span data-ttu-id="08603-128"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 클래스로 표현되는 값을 반환하지 않는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-128">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="08603-129">값을 반환하는 작업은 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>에서 상속하는 <xref:System.Threading.Tasks.Task> 클래스로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-129">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="08603-130">작업 개체는 인프라 세부 사항을 처리하고, 작업의 수명 내내 호출 스레드에서 액세스할 수 있는 메서드 및 속성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-130">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="08603-131">예를 들어 언제든지 작업의 <xref:System.Threading.Tasks.Task.Status%2A> 속성에 액세스하여 작업이 실행되기 시작했는지, 이미 실행되어 완료되었는지, 취소되었는지, 또는 예외를 throw했는지를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-131">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="08603-132">이러한 상태는 <xref:System.Threading.Tasks.TaskStatus> 열거형으로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-132">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>

<span data-ttu-id="08603-133">작업을 만들 때는 해당 작업에서 실행할 코드를 캡슐화하는 사용자 대리자를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-133">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="08603-134">대리자는 명명된 대리자, 익명 메서드 또는 람다 식으로 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-134">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="08603-135">람다 식에는 다음 예제에서처럼 명명된 메서드에 대한 호출을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-135">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="08603-136">예제에는 콘솔 모드 애플리케이션이 종료되기 전에 작업 실행이 완료되도록 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드에 대한 호출이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-136">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>

[!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
[!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]

<span data-ttu-id="08603-137"><xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드를 사용하여 한 번에 작업을 만들고 시작할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-137">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="08603-138">작업을 관리하기 위해 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 기본 작업 스케줄러를 사용합니다. 이 경우 작업 스케줄러가 현재 스레드와 연결되었는지 여부는 관계없습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-138">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="08603-139"><xref:System.Threading.Tasks.Task.Run%2A> 메서드는 작업을 만들고 작업 일정을 예약할 때 더 자세히 제어할 필요가 없는 경우 작업을 만들고 시작하는 데 가장 많이 사용되는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-139">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>

[!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
[!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]

<span data-ttu-id="08603-140"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드를 사용하여 한 번에 작업을 만들고 시작할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-140">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="08603-141">생성 및 일정 예약을 구분할 필요가 없고 추가 작업 생성 옵션이나 특정 스케줄러를 사용할 필요가 있는 경우 또는 다음 예제와 같이 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 속성을 통해 검색할 수 있는 작업에 추가 상태를 전달해야 하는 경우 이 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-141">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task that you can retrieve through its <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property, as shown in the following example.</span></span>

[!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

<span data-ttu-id="08603-142"><xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601>는 각각 <xref:System.Threading.Tasks.Task.Factory%2A>의 기본 인스턴스를 반환하는 정적 <xref:System.Threading.Tasks.TaskFactory> 속성을 노출하므로 메서드를 `Task.Factory.StartNew()`로 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-142"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="08603-143">또한 다음 예제에서 작업은 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 형식이므로 계산 결과가 들어 있는 공용 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성이 각 작업에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-143">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="08603-144">작업은 비동기적으로 실행되며 완료 순서에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-144">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="08603-145">계산이 완료되기 전에 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성에 액세스할 경우 이 속성이 값을 사용할 수 있을 때까지 호출 스레드를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-145">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>

[!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
[!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]

<span data-ttu-id="08603-146">자세한 내용은 [방법: 작업에서 값 반환](how-to-return-a-value-from-a-task.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-146">For more information, see [How to: Return a Value from a Task](how-to-return-a-value-from-a-task.md).</span></span>

<span data-ttu-id="08603-147">람다 식을 사용하여 대리자를 만드는 경우 소스 코드의 해당 지점에서 표시되는 모든 변수에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-147">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="08603-148">그러나 특히 루프 내에서 람다가 기대한 대로 변수를 캡처하지 않는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-148">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="08603-149">이 경우 람다는 각 반복 후에 변경할 때 값이 아닌 최종 값만 capture합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-149">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="08603-150">다음 예제에서 이 문제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-150">The following example illustrates the problem.</span></span> <span data-ttu-id="08603-151">`CustomData` 개체를 인스턴스화하고 루프 카운터를 개체 식별자로 사용하는 람다 식에 루프 카운터를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-151">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="08603-152">이 예제의 출력에서 표시되는 것처럼 각 `CustomData` 개체에는 동일한 식별자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-152">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>

[!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
[!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]

<span data-ttu-id="08603-153">생성자를 통해 작업에 상태 개체를 제공하여 각 반복의 값에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-153">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="08603-154">다음 예제에서는 `CustomData` 개체를 만들 때 루프 카운터를 사용하여 이전 예제를 수정하여 람다 식에 전달되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-154">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="08603-155">예제 출력에서 보듯이 각 `CustomData` 개체는 이제 개체를 인스턴스화한 시간에 루프 카운터의 값을 기반으로 한 고유 식별자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-155">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>

[!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
[!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]

<span data-ttu-id="08603-156">이 상태는 작업 대리자에 인수로 전달되며 작업 개체에서 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 속성을 사용하여 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-156">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="08603-157">다음 예제는 이전 예제를 약간 변형한 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-157">The following example is a variation on the previous example.</span></span> <span data-ttu-id="08603-158"><xref:System.Threading.Tasks.Task.AsyncState%2A> 속성을 사용하여 람다 식에 전달된 `CustomData` 개체에 대한 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-158">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>

[!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

## <a name="task-id"></a><span data-ttu-id="08603-159">작업 ID</span><span class="sxs-lookup"><span data-stu-id="08603-159">Task ID</span></span>

<span data-ttu-id="08603-160">모든 작업은 애플리케이션 도메인에서 작업을 고유하게 식별하는 정수 ID를 받으며, 이 ID는 <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> 속성을 사용하여 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-160">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="08603-161">ID는 Visual Studio 디버거의 **병렬 스택** 및 **작업** 창에서 작업 정보를 보는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-161">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="08603-162">ID는 나중에 만들어집니다. 즉, 요청될 때까지는 ID가 만들어지지 않으므로 프로그램이 실행될 때마다 작업 ID가 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-162">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="08603-163">디버거에서 작업 ID를 보는 방법에 대한 자세한 내용은 [작업 창 사용](/visualstudio/debugger/using-the-tasks-window) 및 [병렬 스택 창 사용](/visualstudio/debugger/using-the-parallel-stacks-window)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-163">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>

## <a name="task-creation-options"></a><span data-ttu-id="08603-164">작업 생성 옵션</span><span class="sxs-lookup"><span data-stu-id="08603-164">Task creation options</span></span>

<span data-ttu-id="08603-165">작업을 만드는 대부분의 API는 <xref:System.Threading.Tasks.TaskCreationOptions> 매개 변수를 사용하는 오버로드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-165">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="08603-166">관련 옵션 중 하나 이상을 지정하여 스레드 풀에서 작업을 예약하는 방법을 작업 스케줄러에 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-166">By specifying one or more of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="08603-167">옵션과 비트 **OR** 연산을 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-167">Options may be combined by using a bitwise **OR** operation.</span></span>

<span data-ttu-id="08603-168">다음 예제에서는 <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> 및 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> 옵션이 있는 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-168">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> options.</span></span>

[!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
[!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]

## <a name="tasks-threads-and-culture"></a><span data-ttu-id="08603-169">작업, 스레드 및 문화권</span><span class="sxs-lookup"><span data-stu-id="08603-169">Tasks, threads, and culture</span></span>

<span data-ttu-id="08603-170">각 스레드에는 각각 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> 속성으로 정의된 관련 문화권 및 UI 문화권이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-170">Each thread has an associated culture and UI culture, which are defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="08603-171">스레드의 문화권은 형식 지정, 구문 분석, 정렬 및 문자열 비교와 같은 작업에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-171">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="08603-172">스레드의 UI 문화권은 리소스 조회에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-172">A thread's UI culture is used in resource lookup.</span></span>

<span data-ttu-id="08603-173"><xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 속성을 사용하여 애플리케이션 도메인의 모든 스레드에 대한 기본 문화권을 지정하지 않는 한 스레드의 기본 문화권 및 UI 문화권은 시스템 문화권에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-173">Unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="08603-174">스레드의 문화권을 명시적으로 설정하고 새 스레드를 시작하는 경우 새 스레드는 호출 스레드의 문화권을 상속하지 않습니다. 대신, 해당 문화권은 기본 시스템 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-174">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="08603-175">그러나 작업 기반 프로그래밍에서 작업은 다른 스레드에서 비동기적으로 실행되는 경우에도 호출 스레드의 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-175">However, in task-based programming, tasks use the calling thread's culture, even if the task runs asynchronously on a different thread.</span></span>

<span data-ttu-id="08603-176">다음 예제에서는 간단한 설명을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-176">The following example provides a simple illustration.</span></span> <span data-ttu-id="08603-177">앱의 현재 문화권을 프랑스어(프랑스)로 변경하거나 프랑스어(프랑스)가 이미 현재 문화권인 경우 영어(미국)로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-177">It changes the app's current culture to French (France) (or, if French (France) is already the current culture, to English (United States)).</span></span> <span data-ttu-id="08603-178">그런 다음 새 문화권의 통화 값으로 형식이 지정된 일부 숫자를 반환하는 `formatDelegate`라는 대리자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-178">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="08603-179">대리자가 작업에서 동기적으로 또는 비동기적으로 호출되는지와 관계없이 작업은 호출 스레드의 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-179">Whether the delegate is invoked by a task either synchronously or asynchronously, the task uses the culture of the calling thread.</span></span>

:::code language="csharp" source="snippets/cs/asyncculture1.cs" id="1":::

:::code language="vbnet" source="snippets/vb/asyncculture1.vb" id="1":::

> [!NOTE]
> <span data-ttu-id="08603-180">.NET Framework 4.6 이전의 .NET Framework 버전에서 작업의 문화권은 ‘호출 스레드’의 문화권이 아니라 ‘실행’하는 스레드의 문화권에 의해 결정됩니다. </span><span class="sxs-lookup"><span data-stu-id="08603-180">In versions of .NET Framework prior to .NET Framework 4.6, a task's culture is determined by the culture of the thread on which it *runs*, not the culture of the *calling thread*.</span></span> <span data-ttu-id="08603-181">비동기 작업의 경우 작업에서 사용하는 문화권이 호출 스레드의 문화권과 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-181">For asynchronous tasks, this means the culture used by the task could be different to the calling thread's culture.</span></span>

<span data-ttu-id="08603-182">비동기 작업 및 문화권에 대한 자세한 내용은 <xref:System.Globalization.CultureInfo> 항목의 "문화권 및 비동기 작업 기반 작업" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-182">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>

## <a name="creating-task-continuations"></a><span data-ttu-id="08603-183">작업 연속 만들기</span><span class="sxs-lookup"><span data-stu-id="08603-183">Creating task continuations</span></span>

<span data-ttu-id="08603-184"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> 메서드를 사용하면 ‘선행 작업’이 완료될 때 시작할 작업을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-184">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="08603-185">연속 작업의 대리자가 선행 작업으로 참조를 전달하여 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성의 값을 검색하여 선행 작업의 상태를 검사할 수 있으며 선행 작업의 출력을 연속 작업의 입력으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-185">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>

<span data-ttu-id="08603-186">다음 예제에서는 `getData` 작업이 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 메서드에 대한 호출로 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-186">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08603-187">`processData`작업은 `getData`가 완료되면 자동으로 시작되고 `displayData`는 `processData`가 완료되면 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-187">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="08603-188">`getData`는 `processData` 작업의 `getData` 속성을 통해 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 작업에 액세스할 수 있는 정수 배열을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-188">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="08603-189">`processData` 작업은 해당 배열을 처리하고 <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> 메서드로 전달된 람다 식의 반환 형식에서 유추한 형식을 갖는 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-189">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08603-190">`displayData` 작업은 `processData`가 완료되면 자동으로 실행되며 <xref:System.Tuple%603> 람다 식에서 반환한 `processData` 개체는 `displayData` 작업의 `processData` 속성을 통해 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 작업에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-190">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="08603-191">`displayData` 작업은 `processData` 작업의 결과를 사용해서 해당 형식이 비슷한 방식으로 유추되고 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성의 프로그램에서 사용할 수 있는 결과를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-191">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>

[!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
[!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]

<span data-ttu-id="08603-192"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>는 인스턴스 메서드이므로 각 선행 작업에 대해 <xref:System.Threading.Tasks.Task%601> 개체를 인스턴스화하는 대신 메서드를 연속 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-192">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="08603-193">다음 예제는 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드에 대한 호출도 함께 연결된다는 점을 제외하고 이전 예제와 기능적으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-193">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08603-194">일련의 메서드 호출에서 반환되는 <xref:System.Threading.Tasks.Task%601> 개체는 최종 연속 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-194">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>

[!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
[!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]

<span data-ttu-id="08603-195"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 및 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> 메서드를 사용하면 여러 작업을 연속적으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-195">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>

<span data-ttu-id="08603-196">자세한 내용은 [연속 작업을 사용하여 작업 연결](chaining-tasks-by-using-continuation-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-196">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

## <a name="creating-detached-child-tasks"></a><span data-ttu-id="08603-197">분리된 자식 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="08603-197">Creating detached child tasks</span></span>

<span data-ttu-id="08603-198">작업에서 실행되는 사용자 코드를 통해 새 작업이 만들어지지만 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 옵션은 지정되지 않을 경우 새 작업은 어떤 특수한 방법으로도 부모 작업과 동기화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-198">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="08603-199">이 유형의 동기화되지 않은 작업을 *분리된 중첩 작업* 또는 *분리된 자식 작업* 이라고 부릅니다.</span><span class="sxs-lookup"><span data-stu-id="08603-199">This type of non-synchronized task is called a *detached nested task* or *detached child task*.</span></span> <span data-ttu-id="08603-200">다음 예제에서는 분리된 상태의 자식 작업을 하나 만드는 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-200">The following example shows a task that creates one detached child task.</span></span>

[!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
[!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]

<span data-ttu-id="08603-201">부모 작업은 분리된 자식 작업이 완료될 때까지 대기하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-201">Note that the parent task does not wait for the detached child task to finish.</span></span>

## <a name="creating-child-tasks"></a><span data-ttu-id="08603-202">자식 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="08603-202">Creating child tasks</span></span>

<span data-ttu-id="08603-203">작업에서 실행되는 사용자 코드에 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 옵션을 사용하여 작업을 만드는 경우 새 작업을 부모 작업의 ‘연결된 자식 작업’이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-203">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as an *attached child task* of the parent task.</span></span> <span data-ttu-id="08603-204"><xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 옵션을 사용하면 부모 작업은 암시적으로 모든 연결된 자식 작업이 완료될 때까지 대기하게 되므로 이 옵션을 사용하여 구조적 작업 병렬 처리를 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-204">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="08603-205">다음 예제에서는 10개의 연결된 자식 작업을 만드는 부모 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-205">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="08603-206">예제는 부모 작업이 완료되기를 기다리도록 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드를 호출하지만 첨부된 자식 작업이 완료되기를 명시적으로 기다릴 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-206">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>

[!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
[!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]

<span data-ttu-id="08603-207">부모 작업은 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 옵션을 사용하여 부모 작업에 다른 작업이 첨부되지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-207">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="08603-208">자세한 내용은 [연결된 자식 작업과 분리된 자식 작업](attached-and-detached-child-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-208">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="08603-209">작업 완료 시까지 대기</span><span class="sxs-lookup"><span data-stu-id="08603-209">Waiting for tasks to finish</span></span>

<span data-ttu-id="08603-210"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 형식은 작업이 완료될 때까지 대기할 수 있게 해주는 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드의 몇 가지 오버로드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-210">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="08603-211">또한 정적 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> 메서드의 오버로드를 사용하면 작업 배열의 일부 또는 모두가 완료될 때까지 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-211">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>

<span data-ttu-id="08603-212">일반적으로 다음과 같은 경우에 작업을 대기시킵니다.</span><span class="sxs-lookup"><span data-stu-id="08603-212">Typically, you would wait for a task for one of these reasons:</span></span>

- <span data-ttu-id="08603-213">주 스레드에서 작업에 의해 계산된 최종 결과를 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="08603-213">The main thread depends on the final result computed by a task.</span></span>

- <span data-ttu-id="08603-214">작업에서 throw될 수 있는 예외를 처리해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="08603-214">You have to handle exceptions that might be thrown from the task.</span></span>

- <span data-ttu-id="08603-215">애플리케이션은 모든 작업이 실행을 완료하기 전에 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-215">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="08603-216">예를 들어, 콘솔 애플리케이션은 `Main`(애플리케이션 진입점)의 모든 동기 코드가 실행되는 즉시 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-216">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>

<span data-ttu-id="08603-217">다음 예제에서는 예외 처리가 포함되지 않은 기본적인 패턴을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-217">The following example shows the basic pattern that does not involve exception handling.</span></span>

[!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
[!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]

<span data-ttu-id="08603-218">예외 처리를 보여 주는 예제는 [예외 처리](exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-218">For an example that shows exception handling, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

<span data-ttu-id="08603-219">일부 오버로드에서는 제한 시간을 지정할 수 있으며, 다른 오버로드에서는 프로그래밍 방식으로 또는 사용자 입력에 대한 응답으로 대기 자체를 취소할 수 있도록 추가 <xref:System.Threading.CancellationToken>을 입력 매개 변수로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-219">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>

<span data-ttu-id="08603-220">작업을 대기할 때는 암시적으로 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 옵션의 사용으로 생성된 해당 작업의 모든 자식 작업을 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-220">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="08603-221"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>는 작업이 이미 완료되었는지 여부를 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-221"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="08603-222">작업에서 발생한 예외는 모두 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드에 의해 throw됩니다. 이는 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드가 작업 완료 후 호출된 경우에도 해당됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-222">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>

## <a name="composing-tasks"></a><span data-ttu-id="08603-223">작업 작성</span><span class="sxs-lookup"><span data-stu-id="08603-223">Composing tasks</span></span>

<span data-ttu-id="08603-224"><xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601> 클래스는 공통 패턴을 구현하고 C#, Visual Basic 및 F#에서 제공하는 비동기 언어 기능을 더욱 효율적으로 사용하도록 여러 작업을 구성할 수 있는 여러 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-224">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="08603-225">이 단원에서는 <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A> 및 <xref:System.Threading.Tasks.Task.FromResult%2A> 메서드에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-225">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>

### <a name="taskwhenall"></a><span data-ttu-id="08603-226">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="08603-226">Task.WhenAll</span></span>

<span data-ttu-id="08603-227"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 메서드는 여러 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 개체가 완료될 때까지 비동기적으로 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-227">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="08603-228">균일하지 않은 작업 집합에 대해 대기할 수 있는 오버로드된 버전을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-228">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="08603-229">예를 들어, 여러 <xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601> 개체가 한 메서드 호출에서 완료되기를 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-229">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>

### <a name="taskwhenany"></a><span data-ttu-id="08603-230">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="08603-230">Task.WhenAny</span></span>

<span data-ttu-id="08603-231"><xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 메서드는 여러 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 개체 중 하나가 완료될 때까지 비동기적으로 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-231">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="08603-232"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 메서드에서와 마찬가지로 이 메서드는 균일하지 않은 작업 집합에 대해 대기할 수 있는 오버로드된 버전을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-232">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="08603-233"><xref:System.Threading.Tasks.Task.WhenAny%2A> 메서드는 다음과 같은 시나리오에서 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-233">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>

- <span data-ttu-id="08603-234">중복 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-234">Redundant operations.</span></span> <span data-ttu-id="08603-235">알고리즘 또는 여러 방법으로 수행할 수 있는 작업을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-235">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="08603-236"><xref:System.Threading.Tasks.Task.WhenAny%2A> 메서드를 사용하여 먼저 완료되는 작업을 선택한 다음 나머지 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-236">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>

- <span data-ttu-id="08603-237">인터리브 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-237">Interleaved operations.</span></span> <span data-ttu-id="08603-238">모두 완료되어야 하는 여러 작업을 시작하고 <xref:System.Threading.Tasks.Task.WhenAny%2A> 메서드를 사용하여 각 작업이 완료되면 결과를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-238">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="08603-239">하나의 작업이 완료되면 하나 이상의 추가 작업을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-239">After one operation finishes, you can start one or more additional tasks.</span></span>

- <span data-ttu-id="08603-240">제한된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-240">Throttled operations.</span></span> <span data-ttu-id="08603-241"><xref:System.Threading.Tasks.Task.WhenAny%2A> 메서드를 사용하여 동시 작업 수를 제한하여 이전 시나리오를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-241">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>

- <span data-ttu-id="08603-242">만료된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-242">Expired operations.</span></span> <span data-ttu-id="08603-243"><xref:System.Threading.Tasks.Task.WhenAny%2A> 메서드를 사용하여 <xref:System.Threading.Tasks.Task.Delay%2A> 메서드에서 반환되는 작업처럼 특정 시간 이후에 완료되는 하나 이상의 작업 중에서 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-243">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="08603-244"><xref:System.Threading.Tasks.Task.Delay%2A> 메서드는 다음 단원에서 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-244">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>

### <a name="taskdelay"></a><span data-ttu-id="08603-245">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="08603-245">Task.Delay</span></span>

<span data-ttu-id="08603-246"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> 메서드는 지정된 시간 이후에 완료되는 <xref:System.Threading.Tasks.Task> 개체를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-246">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="08603-247">이 메서드를 사용하여 때때로 데이터를 폴링하는 루프를 빌드하고, 제한 시간을 소개하고, 미리 지정된 시간 동안에 사용자의 입력 처리를 지연하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-247">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>

### <a name="tasktfromresult"></a><span data-ttu-id="08603-248">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="08603-248">Task(T).FromResult</span></span>

<span data-ttu-id="08603-249"><xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> 메서드를 사용하면 미리 계산된 결과를 갖는 <xref:System.Threading.Tasks.Task%601> 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-249">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="08603-250">이 메서드는 <xref:System.Threading.Tasks.Task%601> 개체가 반환되는 비동기 작업을 수행하고 해당 <xref:System.Threading.Tasks.Task%601> 개체의 결과가 계산되어 있을 때 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-250">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="08603-251"><xref:System.Threading.Tasks.Task.FromResult%2A>를 사용하여 캐시에 저장된 비동기 다운로드 작업 결과를 검색하는 예제는 [방법: 미리 계산된 작업 만들기](how-to-create-pre-computed-tasks.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-251">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](how-to-create-pre-computed-tasks.md).</span></span>

## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="08603-252">작업의 예외 처리</span><span class="sxs-lookup"><span data-stu-id="08603-252">Handling exceptions in tasks</span></span>

<span data-ttu-id="08603-253">작업이 하나 이상의 예외를 throw하면 해당 예외가 <xref:System.AggregateException> 예외에 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-253">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="08603-254">이 예외는 작업과 조인하는 스레드에 다시 전파됩니다. 이 스레드는 일반적으로 작업이 완료될 때까지 기다리는 스레드이거나 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성에 액세스하는 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-254">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="08603-255">이 동작을 통해 처리되지 않은 예외가 발생할 때마다 기본적으로 프로세스를 종료하도록 하는 .NET Framework 정책을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-255">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="08603-256">호출 코드는 다음 `try`/`catch` 블록을 사용하여 예외를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-256">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>

- <span data-ttu-id="08603-257"><xref:System.Threading.Tasks.Task.Wait%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="08603-257">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>

- <span data-ttu-id="08603-258"><xref:System.Threading.Tasks.Task.WaitAll%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="08603-258">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>

- <span data-ttu-id="08603-259"><xref:System.Threading.Tasks.Task.WaitAny%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="08603-259">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>

- <span data-ttu-id="08603-260"><xref:System.Threading.Tasks.Task%601.Result%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="08603-260">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>

<span data-ttu-id="08603-261">또한 조인하는 스레드에서는 작업이 가비지 수집되기 전에 <xref:System.Threading.Tasks.Task.Exception%2A> 속성에 액세스하여 예외를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-261">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="08603-262">이 속성에 액세스하면 처리되지 않은 예외로 인해 개체가 종료될 때 프로세스를 종료하는 예외 전파 동작이 트리거되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-262">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>

<span data-ttu-id="08603-263">예외 및 작업에 대한 자세한 내용은 [예외 처리](exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-263">For more information about exceptions and tasks, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

## <a name="canceling-tasks"></a><span data-ttu-id="08603-264">작업 취소</span><span class="sxs-lookup"><span data-stu-id="08603-264">Canceling tasks</span></span>

<span data-ttu-id="08603-265"><xref:System.Threading.Tasks.Task> 클래스는 협조적 취소를 지원하며 .NET Framework 4에 소개된 <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> 및 <xref:System.Threading.CancellationToken?displayProperty=nameWithType> 클래스와 완전히 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-265">The <xref:System.Threading.Tasks.Task> class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="08603-266"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 클래스의 많은 생성자는 <xref:System.Threading.CancellationToken> 개체를 입력 매개 변수로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-266">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="08603-267">대부분의 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 및 <xref:System.Threading.Tasks.Task.Run%2A> 오버로드는 <xref:System.Threading.CancellationToken> 매개 변수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-267">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>

<span data-ttu-id="08603-268">이 토큰을 만든 다음 나중에 <xref:System.Threading.CancellationTokenSource> 클래스를 사용하여 취소 요청을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-268">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="08603-269">이 토큰을 <xref:System.Threading.Tasks.Task>에 인수로 전달하고, 취소 요청에 대한 응답 작업을 수행하는 사용자 대리자에서도 동일한 토큰을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-269">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>

<span data-ttu-id="08603-270">자세한 내용은 [작업 취소](task-cancellation.md) 및 [방법: 작업 및 해당 자식 취소](how-to-cancel-a-task-and-its-children.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-270">For more information, see [Task Cancellation](task-cancellation.md) and [How to: Cancel a Task and Its Children](how-to-cancel-a-task-and-its-children.md).</span></span>

## <a name="the-taskfactory-class"></a><span data-ttu-id="08603-271">TaskFactory 클래스</span><span class="sxs-lookup"><span data-stu-id="08603-271">The TaskFactory class</span></span>

<span data-ttu-id="08603-272"><xref:System.Threading.Tasks.TaskFactory> 클래스에서는 작업 및 연속 작업을 만들고 시작하기 위한 몇 가지 일반적인 패턴을 캡슐화하는 정적 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-272">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>

- <span data-ttu-id="08603-273">가장 일반적인 패턴은 하나의 문으로 작업을 만들고 시작하는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-273">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>

- <span data-ttu-id="08603-274">여러 선행 작업에서 연속 작업을 만들 때는 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 메서드나 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> 메서드 또는 <xref:System.Threading.Tasks.Task%601> 클래스에서 이에 해당하는 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-274">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="08603-275">자세한 내용은 [연속 작업을 사용하여 작업 연결](chaining-tasks-by-using-continuation-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-275">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

- <span data-ttu-id="08603-276">비동기 프로그래밍 모델인 `BeginX` 및 `EndX` 메서드를 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 인스턴스에 캡슐화하려면 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-276">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="08603-277">자세한 내용은 [TPL 및 일반적인 .NET 비동기 프로그래밍](tpl-and-traditional-async-programming.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-277">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](tpl-and-traditional-async-programming.md).</span></span>

<span data-ttu-id="08603-278">기본 <xref:System.Threading.Tasks.TaskFactory>는 <xref:System.Threading.Tasks.Task> 클래스 또는 <xref:System.Threading.Tasks.Task%601> 클래스에서 정적 속성으로 액세스될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-278">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="08603-279"><xref:System.Threading.Tasks.TaskFactory>를 직접 인스턴스화하고 <xref:System.Threading.CancellationToken>, <xref:System.Threading.Tasks.TaskCreationOptions> 옵션, <xref:System.Threading.Tasks.TaskContinuationOptions> 옵션 또는 <xref:System.Threading.Tasks.TaskScheduler>를 포함한 다양한 옵션을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-279">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="08603-280">작업 팩터리를 만들 때 어떤 옵션을 지정하든 작업 팩터리에서 만드는 모든 작업에 해당 옵션이 적용됩니다. 단, <xref:System.Threading.Tasks.Task> 열거형을 사용하여 <xref:System.Threading.Tasks.TaskCreationOptions>을 만드는 경우는 제외되며, 이때는 해당 작업의 옵션이 작업 팩터리의 옵션을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-280">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>

## <a name="tasks-without-delegates"></a><span data-ttu-id="08603-281">대리자가 없는 작업</span><span class="sxs-lookup"><span data-stu-id="08603-281">Tasks without delegates</span></span>

<span data-ttu-id="08603-282">일부 경우에는 <xref:System.Threading.Tasks.Task>를 사용하여 사용자 대리자 대신 외부 구성 요소에서 수행되는 비동기 작업을 캡슐화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-282">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="08603-283">이 작업이 비동기 프로그래밍 모델인 Begin/End 패턴을 기반으로 하는 경우에는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-283">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="08603-284">그러지 않은 경우에는 <xref:System.Threading.Tasks.TaskCompletionSource%601> 개체를 사용하여 작업에서 수행할 비동기 작업을 래핑하고 이를 통해 예외 전파 및 연속에 대한 지원과 같은 <xref:System.Threading.Tasks.Task> 프로그래밍 기능의 몇 가지 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-284">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="08603-285">자세한 내용은 <xref:System.Threading.Tasks.TaskCompletionSource%601>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-285">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>

## <a name="custom-schedulers"></a><span data-ttu-id="08603-286">사용자 지정 스케줄러</span><span class="sxs-lookup"><span data-stu-id="08603-286">Custom schedulers</span></span>

<span data-ttu-id="08603-287">대부분의 애플리케이션 또는 라이브러리 개발자는 작업이 실행되는 프로세서, 작업과 다른 작업이 동기화되는 방식 또는 <xref:System.Threading.ThreadPool?displayProperty=nameWithType>에서 작업이 예약되는 방식에는 크게 신경 쓰지 않고,</span><span class="sxs-lookup"><span data-stu-id="08603-287">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="08603-288">단지 작업이 호스트 컴퓨터에서 가능한 한 효율적으로 실행되기만을 바랍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-288">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="08603-289">예약 세부 사항을 보다 세부적으로 제어해야 하는 경우 작업 병렬 라이브러리를 사용하면 기본 작업 스케줄러의 일부 설정을 구성할 수 있으며 사용자 지정 스케줄러를 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-289">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="08603-290">자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-290">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>

## <a name="related-data-structures"></a><span data-ttu-id="08603-291">관련 데이터 구조</span><span class="sxs-lookup"><span data-stu-id="08603-291">Related data structures</span></span>

<span data-ttu-id="08603-292">TPL에는 병렬 시나리오와 순차 시나리오 모두에 유용한 새로운 공용 형식이 몇 가지 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-292">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="08603-293">여기에는 스레드로부터 안전하며 속도 및 확장성이 우수한 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 네임스페이스의 몇 가지 컬렉션 클래스뿐 아니라 특정 종류의 작업 부하에 대해 이전보다 높은 효율성을 제공하는 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 및 <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 등의 새로운 몇 가지 동기화 형식도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="08603-293">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="08603-294">.NET Framework 4에 새로 추가된 <xref:System.Threading.Barrier?displayProperty=nameWithType> 및 <xref:System.Threading.SpinLock?displayProperty=nameWithType> 등의 다른 형식은 이전 릴리스에서는 사용할 수 없었던 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-294">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="08603-295">자세한 내용은 [병렬 프로그래밍의 데이터 구조](data-structures-for-parallel-programming.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-295">For more information, see [Data Structures for Parallel Programming](data-structures-for-parallel-programming.md).</span></span>

## <a name="custom-task-types"></a><span data-ttu-id="08603-296">사용자 지정 작업 형식</span><span class="sxs-lookup"><span data-stu-id="08603-296">Custom task types</span></span>

<span data-ttu-id="08603-297"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>에서 상속하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-297">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="08603-298">대신 <xref:System.Threading.Tasks.Task.AsyncState%2A> 속성을 사용하여 추가 데이터 또는 상태를 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 개체에 연결하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-298">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="08603-299">확장 메서드를 사용하여 <xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601> 클래스의 기능을 확장할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="08603-299">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="08603-300">확장 메서드에 대한 자세한 내용은 [확장 메서드](../../csharp/programming-guide/classes-and-structs/extension-methods.md) 및 [확장 메서드](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="08603-300">For more information about extension methods, see [Extension Methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>

<span data-ttu-id="08603-301"><xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601>에서 상속해야 하는 경우에는 <xref:System.Threading.Tasks.Task.Run%2A>을(를) 사용하거나 <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> 클래스를 사용하여 사용자 지정 작업 형식의 인스턴스를 만들 수 없습니다. 이러한 메커니즘은 <xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601> 개체만 만들기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-301">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="08603-302">또한 <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory> 및 <xref:System.Threading.Tasks.TaskFactory%601>에서 제공하는 작업 연속 메커니즘을 사용하여 사용자 지정 작업의 인스턴스를 만들 수 없습니다. 이 메커니즘에서도 mechanisms also create only <xref:System.Threading.Tasks.Task> 및 <xref:System.Threading.Tasks.Task%601> 개체만 만들기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-302">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>

## <a name="related-topics"></a><span data-ttu-id="08603-303">관련 항목</span><span class="sxs-lookup"><span data-stu-id="08603-303">Related topics</span></span>

|<span data-ttu-id="08603-304">제목</span><span class="sxs-lookup"><span data-stu-id="08603-304">Title</span></span>|<span data-ttu-id="08603-305">설명</span><span class="sxs-lookup"><span data-stu-id="08603-305">Description</span></span>|
|-|-|
|[<span data-ttu-id="08603-306">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="08603-306">Chaining Tasks by Using Continuation Tasks</span></span>](chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="08603-307">연속 작업이 실행되는 방식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-307">Describes how continuations work.</span></span>|
|[<span data-ttu-id="08603-308">연결된 자식 작업 및 분리된 자식 작업</span><span class="sxs-lookup"><span data-stu-id="08603-308">Attached and Detached Child Tasks</span></span>](attached-and-detached-child-tasks.md)|<span data-ttu-id="08603-309">연결된 자식 작업과 분리된 자식 작업의 차이점을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-309">Describes the difference between attached and detached child tasks.</span></span>|
|[<span data-ttu-id="08603-310">작업 취소</span><span class="sxs-lookup"><span data-stu-id="08603-310">Task Cancellation</span></span>](task-cancellation.md)|<span data-ttu-id="08603-311"><xref:System.Threading.Tasks.Task> 개체에 기본 제공되는 취소 지원에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-311">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|
|[<span data-ttu-id="08603-312">예외 처리</span><span class="sxs-lookup"><span data-stu-id="08603-312">Exception Handling</span></span>](exception-handling-task-parallel-library.md)|<span data-ttu-id="08603-313">동시 스레드에 대한 예외를 처리하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-313">Describes how exceptions on concurrent threads are handled.</span></span>|
|[<span data-ttu-id="08603-314">방법: Parallel.Invoke를 사용하여 병렬 작업 실행</span><span class="sxs-lookup"><span data-stu-id="08603-314">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="08603-315"><xref:System.Threading.Tasks.Parallel.Invoke%2A>를 사용하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-315">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|
|[<span data-ttu-id="08603-316">방법: 작업에서 값 반환</span><span class="sxs-lookup"><span data-stu-id="08603-316">How to: Return a Value from a Task</span></span>](how-to-return-a-value-from-a-task.md)|<span data-ttu-id="08603-317">작업을 통해 값을 반환하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-317">Describes how to return values from tasks.</span></span>|
|[<span data-ttu-id="08603-318">방법: 작업 및 해당 자식 취소</span><span class="sxs-lookup"><span data-stu-id="08603-318">How to: Cancel a Task and Its Children</span></span>](how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="08603-319">작업을 취소하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-319">Describes how to cancel tasks.</span></span>|
|[<span data-ttu-id="08603-320">방법: 미리 계산된 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="08603-320">How to: Create Pre-Computed Tasks</span></span>](how-to-create-pre-computed-tasks.md)|<span data-ttu-id="08603-321"><xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> 메서드를 사용하여 캐시에 저장된 비동기 다운로드 작업 결과를 검색하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-321">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|
|[<span data-ttu-id="08603-322">방법: 병렬 작업을 사용하여 이진 트리 트래버스</span><span class="sxs-lookup"><span data-stu-id="08603-322">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="08603-323">작업을 사용하여 이진 트리를 따라 이동하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-323">Describes how to use tasks to traverse a binary tree.</span></span>|
|[<span data-ttu-id="08603-324">방법: 중첩된 작업 래핑 취소</span><span class="sxs-lookup"><span data-stu-id="08603-324">How to: Unwrap a Nested Task</span></span>](how-to-unwrap-a-nested-task.md)|<span data-ttu-id="08603-325"><xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> 확장 메서드를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="08603-325">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|
|[<span data-ttu-id="08603-326">데이터 병렬 처리</span><span class="sxs-lookup"><span data-stu-id="08603-326">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)|<span data-ttu-id="08603-327"><xref:System.Threading.Tasks.Parallel.For%2A> 및 <xref:System.Threading.Tasks.Parallel.ForEach%2A>를 사용하여 데이터에 대한 병렬 루프를 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="08603-327">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|
|[<span data-ttu-id="08603-328">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="08603-328">Parallel Programming</span></span>](index.md)|<span data-ttu-id="08603-329">.NET Framework 병렬 프로그래밍의 최상위 노드입니다.</span><span class="sxs-lookup"><span data-stu-id="08603-329">Top level node for .NET Framework parallel programming.</span></span>|

## <a name="see-also"></a><span data-ttu-id="08603-330">참조</span><span class="sxs-lookup"><span data-stu-id="08603-330">See also</span></span>

- [<span data-ttu-id="08603-331">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="08603-331">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="08603-332">.NET Core 및 .NET Standard를 사용한 병렬 프로그래밍 샘플</span><span class="sxs-lookup"><span data-stu-id="08603-332">Samples for Parallel Programming with the .NET Core & .NET Standard</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
