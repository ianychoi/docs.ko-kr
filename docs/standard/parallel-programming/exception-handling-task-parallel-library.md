---
title: 예외 처리(작업 병렬 라이브러리)
description: .NET에서 TPL(작업 병렬 라이브러리)을 사용한 예외 처리를 살펴봅니다. 중첩 집계 예외, 내부 예외, 관찰되지 않은 작업 예외 등을 참조하세요.
ms.date: 04/20/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
ms.openlocfilehash: fd16fd4263c092f8678589e1a8dd9544955e798a
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827336"
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="02c54-104">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="02c54-104">Exception handling (Task Parallel Library)</span></span>

<span data-ttu-id="02c54-105">작업 내에서 실행되는 사용자 코드에 의해 throw된 처리되지 않은 예외는 이 항목의 뒷부분에서 설명하는 특정 시나리오를 제외하고는 호출 스레드로 다시 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-105">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="02c54-106">정적 또는 인스턴스 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드 중 하나를 사용할 때 예외가 전파되며 `try`/`catch` 문에 호출을 포함하여 예외를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-106">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="02c54-107">어떤 작업이 연결된 자식 작업의 부모인 경우 또는 여러 작업에서 대기 중인 경우, 여러 개의 예외가 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-107">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>

<span data-ttu-id="02c54-108">모든 예외를 호출 스레드로 다시 전파하기 위해 작업 인프라가 이러한 예외를 <xref:System.AggregateException> 인스턴스에서 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-108">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="02c54-109"><xref:System.AggregateException> 예외에는 <xref:System.AggregateException.InnerExceptions%2A> 속성이 있으며 이 속성을 열거하면 throw된 모든 원래 예외를 확인하고 각 예외를 개별적으로 처리하거나 처리하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-109">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="02c54-110">또한 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 메서드를 사용하여 원래 예외를 처리할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-110">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="02c54-111">하나의 예외만 throw된 경우 다음 예제와 같이 <xref:System.AggregateException> 예외에서 여전히 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-111">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
[!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]

<span data-ttu-id="02c54-112"><xref:System.AggregateException> 을 catch하고 내부 예외를 관찰하지 않으면 처리되지 않은 예외를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-112">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="02c54-113">하지만 이 방법은 기본 <xref:System.Exception> 유형을 비병렬 시나리오에서 catch하는 것과 유사하기 때문에 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-113">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="02c54-114">복구하기 위한 특정 작업을 수행하지 않고 예외를 catch하려면 프로그램을 결정할 수 없는 상태 그대로 두면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-114">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>

<span data-ttu-id="02c54-115"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드를 호출하여 작업의 완료를 기다리는 것을 원하지 않는 경우 다음 예제가 보여주는 것처럼 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성에서 <xref:System.AggregateException> 예외를 검색할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-115">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="02c54-116">자세한 내용은 이 문서의 [Task.Exception 속성을 사용하여 예외 관찰](#observing-exceptions-by-using-the-taskexception-property) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="02c54-116">For more information, see the [Observing exceptions by using the Task.Exception property](#observing-exceptions-by-using-the-taskexception-property) section in this topic.</span></span>

[!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
[!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]

<span data-ttu-id="02c54-117">예외를 전파하는 작업을 기다리지 않거나 해당 <xref:System.Threading.Tasks.Task.Exception%2A> 속성에 액세스하는 경우 작업이 가비지 수집될 때 .NET 예외 정책에 따라 예외가 에스컬레이션됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-117">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>

<span data-ttu-id="02c54-118">예외가 가입된 스레드로 다시 버블 업될 수 있는 경우 예외가 발생한 후에도 작업에서 일부 항목을 계속 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-118">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>

> [!NOTE]
> <span data-ttu-id="02c54-119">“내 코드만”이 사용하도록 설정된 경우 Visual Studio가 예외를 발생시키는 줄에서 중단하고 "예외가 사용자 코드에서 처리되지 않았다"는 오류 메시지를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-119">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="02c54-120">이 오류는 심각하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-120">This error is benign.</span></span> <span data-ttu-id="02c54-121">F5 키를 눌러 계속하고 이러한 예제에 설명된 예외 처리 동작을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-121">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="02c54-122">맨 처음 오류 지점에서 Visual Studio가 실행을 중단하지 않도록 하려면 **도구, 옵션, 디버깅, 일반** 을 차례로 선택하고 **내 코드만 사용** 확인란의 선택을 취소하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-122">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>

## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="02c54-123">연결된 자식 작업 및 중첩된 AggregateExceptions</span><span class="sxs-lookup"><span data-stu-id="02c54-123">Attached child tasks and nested AggregateExceptions</span></span>

<span data-ttu-id="02c54-124">작업에 예외를 throw하는 연결된 자식 작업이 있는 경우 해당 예외가 <xref:System.AggregateException> 에서 래핑된 다음 상위 작업으로 전파되고, 이 상위 작업은 해당 예외를 자체 <xref:System.AggregateException> 에서 래핑한 다음 호출 스레드로 다시 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-124">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="02c54-125">이러한 경우 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A> 또는 <xref:System.Threading.Tasks.Task.WaitAll%2A> 메서드에서 catch된 <xref:System.AggregateException> 예외의 <xref:System.AggregateException.InnerExceptions%2A> 속성에는 오류를 발생시킨 원래 예외가 아니라 하나 이상의 <xref:System.AggregateException> 인스턴스가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-125">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A>, or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="02c54-126">중첩된 <xref:System.AggregateException> 예외를 반복할 필요가 없도록 하려면 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 속성에 원래 예외가 포함되도록 <xref:System.AggregateException.Flatten%2A> 메서드를 사용하여 중첩된 모든 <xref:System.AggregateException> 예외를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-126">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="02c54-127">다음 예제에서는 중첩된 <xref:System.AggregateException> 인스턴스가 하나의 루프에서 결합되고 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-127">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>

[!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
[!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]

<span data-ttu-id="02c54-128">또한 다음 예제가 보여주는 것처럼 <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> 메서드를 사용하여 단일 <xref:System.AggregateException> 인스턴스에서 여러 작업에 의해 throw된 여러 <xref:System.AggregateException> 인스턴스의 내부 예외를 다시 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-128">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
[!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]

## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="02c54-129">분리된 자식 작업의 예외</span><span class="sxs-lookup"><span data-stu-id="02c54-129">Exceptions from detached child tasks</span></span>

<span data-ttu-id="02c54-130">기본적으로 자식 작업은 분리된 작업으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-130">By default, child tasks are created as detached.</span></span> <span data-ttu-id="02c54-131">분리된 작업에서 throw된 예외는 직계 부모 작업에서 처리되거나 다시 throw되어야 하지만, 연결된 자식 작업이 다시 전파되는 것과 동일한 방식으로 호출 스레드에 다시 전파되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-131">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="02c54-132">최상위 부모는 분리된 자식의 예외를 수동으로 다시 throw하여 <xref:System.AggregateException> 에서 래핑하고 호출 스레드로 다시 전파할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-132">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>

[!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
[!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]

<span data-ttu-id="02c54-133">연속을 사용하여 자식 작업에서 예외를 계속 관찰하는 경우에도 해당 예외는 여전히 부모 작업에서 관찰해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-133">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>

## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="02c54-134">협조적 취소를 나타내는 예외</span><span class="sxs-lookup"><span data-stu-id="02c54-134">Exceptions that indicate cooperative cancellation</span></span>

<span data-ttu-id="02c54-135">작업의 사용자 코드가 취소 요청에 응답하는 경우, 올바른 절차는 요청을 통신한 취소 토큰을 전달하는 <xref:System.OperationCanceledException> 을 throw하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-135">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="02c54-136">예외를 전파하려고 시도하기 전에 작업 인스턴스가 요청이 만들어졌을 때 요청에 전달된 토큰과 예외의 토큰을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-136">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="02c54-137">두 토큰이 동일한 경우 작업은 <xref:System.Threading.Tasks.TaskCanceledException> 에서 래핑된 <xref:System.AggregateException>을 전파하며 이는 내부 예외를 검사할 때 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-137">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="02c54-138">그러나 호출 스레드가 작업을 기다리지 않는 경우 이 특정 예외는 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-138">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="02c54-139">자세한 내용은 [작업 취소](task-cancellation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="02c54-139">For more information, see [Task Cancellation](task-cancellation.md).</span></span>

[!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
[!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]

## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="02c54-140">핸들 메서드를 사용하여 내부 예외 필터링</span><span class="sxs-lookup"><span data-stu-id="02c54-140">Using the handle method to filter inner exceptions</span></span>

<span data-ttu-id="02c54-141"><xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 메서드를 사용하여 추가 논리를 사용하지 않고 “처리됨”으로 처리할 수 있는 예외를 필터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-141">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="02c54-142"><xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 메서드에 제공되는 사용자 대리자에서 예외 형식, 해당 예외의 <xref:System.Exception.Message%2A> 속성 또는 예외가 무해한지 여부를 결정할 수 있는 정보를 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-142">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="02c54-143">이 대리자가 `false`를 반환하는 모든 예외는 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 메서드에서 반환한 직후 새 <xref:System.AggregateException> 인스턴스에서 다시 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-143">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>

<span data-ttu-id="02c54-144">다음 예제에서는 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 컬렉션에서 각 예외를 검사하는 이 항목의 첫 번째 예제와 기능적으로 같습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-144">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="02c54-145">대신 이 예외 처리기는 각 예외에 대해 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 메서드 개체를 호출하고 `CustomException` 인스턴스가 아닌 예외만 다시 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-145">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>

[!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
[!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]

<span data-ttu-id="02c54-146">다음은 보다 자세한 예제로, 파일을 열거할 때 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 예외에 특수 처리를 제공하기 위해 <xref:System.UnauthorizedAccessException> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-146">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>

[!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
[!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]

## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="02c54-147">Task.Exception 속성을 사용하여 예외 관찰</span><span class="sxs-lookup"><span data-stu-id="02c54-147">Observing exceptions by using the Task.Exception property</span></span>

<span data-ttu-id="02c54-148">작업이 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 상태에서 완료된 경우 <xref:System.Threading.Tasks.Task.Exception%2A> 속성을 검사하여 오류를 발생시킨 특정 예외를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-148">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="02c54-149"><xref:System.Threading.Tasks.Task.Exception%2A> 속성을 관찰하는 좋은 방법은 다음 예제에 나와 있는 것처럼 선행 작업에서 오류가 발생할 경우에만 실행되는 연속을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-149">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>

[!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
[!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]

<span data-ttu-id="02c54-150">의미 있는 애플리케이션에서 연속 대리자는 예외에 대한 자세한 정보를 기록하고 새 작업을 생성하여 예외에서 복구할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-150">In a meaningful application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span> <span data-ttu-id="02c54-151">작업이 실패하면 다음 식에서 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-151">If a task faults, the following expressions throw the exception:</span></span>

- `await task`
- `task.Wait()`
- `task.Result`
- `task.GetAwaiter().GetResult()`

<span data-ttu-id="02c54-152">[`try-catch`](../../csharp/language-reference/keywords/try-catch.md) 문을 사용하여 throw된 예외를 처리하고 관찰합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-152">Use a [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) statement to handle and observe thrown exceptions.</span></span> <span data-ttu-id="02c54-153">또는 <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> 속성에 액세스하여 예외를 관찰합니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-153">Alternatively, observe the exception by accessing the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property.</span></span>

## <a name="unobservedtaskexception-event"></a><span data-ttu-id="02c54-154">UnobservedTaskException 이벤트</span><span class="sxs-lookup"><span data-stu-id="02c54-154">UnobservedTaskException event</span></span>

<span data-ttu-id="02c54-155">일부 시나리오에서는 예를 들어 신뢰할 수 없는 플러그인을 호스트할 때 무해한 예외가 자주 발생할 수 있으며 그 모든 예외를 수동으로 관찰하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-155">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="02c54-156">이러한 경우 <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> 이벤트를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-156">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="02c54-157">처리기로 전달되는 <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> 인스턴스를 사용하면 관찰되지 않은 예외가 가입된 스레드로 다시 전파되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="02c54-157">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>

## <a name="see-also"></a><span data-ttu-id="02c54-158">참조</span><span class="sxs-lookup"><span data-stu-id="02c54-158">See also</span></span>

- [<span data-ttu-id="02c54-159">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="02c54-159">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
