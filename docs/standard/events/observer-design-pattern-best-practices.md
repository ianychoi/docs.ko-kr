---
title: 관찰자 디자인 패턴 모범 사례
ms.date: 03/30/2017
helpviewer_keywords:
- observer design pattern [.NET], best practices
- best practices [.NET], observer design pattern
ms.assetid: c834760f-ddd4-417f-abb7-a059679d5b8c
ms.openlocfilehash: 48a9bb49be20bbedbaa19d622aabfd18affe39bd
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94828259"
---
# <a name="observer-design-pattern-best-practices"></a><span data-ttu-id="6f410-102">관찰자 디자인 패턴 모범 사례</span><span class="sxs-lookup"><span data-stu-id="6f410-102">Observer Design Pattern Best Practices</span></span>

<span data-ttu-id="6f410-103">.NET에서는 관찰자 디자인 패턴이 인터페이스 세트로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-103">In .NET, the observer design pattern is implemented as a set of interfaces.</span></span> <span data-ttu-id="6f410-104"><xref:System.IObservable%601?displayProperty=nameWithType> 인터페이스는 데이터 공급자를 나타냅니다. 이 데이터 공급자는 관찰자가 알림 구독을 취소할 수 있도록 하는 <xref:System.IDisposable> 구현도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-104">The <xref:System.IObservable%601?displayProperty=nameWithType> interface represents the data provider, which is also responsible for providing an <xref:System.IDisposable> implementation that lets observers unsubscribe from notifications.</span></span> <span data-ttu-id="6f410-105"><xref:System.IObserver%601?displayProperty=nameWithType> 인터페이스는 관찰자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-105">The <xref:System.IObserver%601?displayProperty=nameWithType> interface represents the observer.</span></span> <span data-ttu-id="6f410-106">이 항목에는 이러한 인터페이스를 사용하여 관찰자 디자인 패턴을 구현할 때 개발자가 따라야 하는 모범 사례에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-106">This topic describes the best practices that developers should follow when implementing the observer design pattern using these interfaces.</span></span>  
  
## <a name="threading"></a><span data-ttu-id="6f410-107">스레딩</span><span class="sxs-lookup"><span data-stu-id="6f410-107">Threading</span></span>  
 <span data-ttu-id="6f410-108">일반적으로 공급자는 컬렉션 개체로 표시되는 구독자 목록에 특정 관찰자를 추가하여 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> 메서드를 구현하며, 구독자 목록에서 특정 관찰자를 제거하여 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 메서드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-108">Typically, a provider implements the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method by adding a particular observer to a subscriber list that is represented by some collection object, and it implements the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method by removing a particular observer from the subscriber list.</span></span> <span data-ttu-id="6f410-109">관찰자는 언제든지 이러한 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-109">An observer can call these methods at any time.</span></span> <span data-ttu-id="6f410-110">또한 공급자/관찰자 계약에서는 <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 콜백 메서드 후 구독 취소 담당자를 지정하지 않으므로 공급자와 관찰자가 모두 목록에서 같은 멤버를 제거하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-110">In addition, because the provider/observer contract does not specify who is responsible for unsubscribing after the <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> callback method, the provider and observer may both try to remove the same member from the list.</span></span> <span data-ttu-id="6f410-111">이러한 가능성 때문에 <xref:System.IObservable%601.Subscribe%2A> 및 <xref:System.IDisposable.Dispose%2A> 메서드는 모두 스레드로부터 안전해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-111">Because of this possibility, both the <xref:System.IObservable%601.Subscribe%2A> and <xref:System.IDisposable.Dispose%2A> methods should be thread-safe.</span></span> <span data-ttu-id="6f410-112">일반적으로는 이를 위해 [동시 컬렉션](../parallel-programming/data-structures-for-parallel-programming.md) 또는 잠금을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-112">Typically, this involves using a [concurrent collection](../parallel-programming/data-structures-for-parallel-programming.md) or a lock.</span></span> <span data-ttu-id="6f410-113">스레드로부터 안전하지 않은 구현은 스레드로부터 안전하지 않음을 명시적으로 문서화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-113">Implementations that are not thread-safe should explicitly document that they are not.</span></span>  
  
 <span data-ttu-id="6f410-114">추가로 보장할 내용은 공급자/관찰자 계약을 기반으로 하는 계층에 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-114">Any additional guarantees have to be specified in a layer on top of the provider/observer contract.</span></span> <span data-ttu-id="6f410-115">구현자는 관찰자 계약에 대한 사용자의 혼동을 방지하기 위해 추가 요구를 사항을 적용하는 경우 이를 명확하게 표시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-115">Implementers should clearly call out when they impose additional requirements to avoid user confusion about the observer contract.</span></span>  
  
## <a name="handling-exceptions"></a><span data-ttu-id="6f410-116">예외 처리</span><span class="sxs-lookup"><span data-stu-id="6f410-116">Handling Exceptions</span></span>  
 <span data-ttu-id="6f410-117">데이터 공급자와 관찰자는 느슨하게 결합되므로 관찰자 디자인 패턴의 예외는 정보 제공용으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-117">Because of the loose coupling between a data provider and an observer, exceptions in the observer design pattern are intended to be informational.</span></span> <span data-ttu-id="6f410-118">이는 공급자와 관찰자가 관찰자 디자인 패턴에서 예외를 처리하는 방식에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-118">This affects how providers and observers handle exceptions in the observer design pattern.</span></span>  
  
### <a name="the-provider----calling-the-onerror-method"></a><span data-ttu-id="6f410-119">공급자 - OnError 메서드 호출</span><span class="sxs-lookup"><span data-stu-id="6f410-119">The Provider -- Calling the OnError Method</span></span>  
 <span data-ttu-id="6f410-120"><xref:System.IObserver%601.OnError%2A> 메서드는 <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> 메서드와 같이 관찰자에 대한 정보 메시지로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-120">The <xref:System.IObserver%601.OnError%2A> method is intended as an informational message to observers, much like the <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6f410-121">그러나 <xref:System.IObserver%601.OnNext%2A> 메서드는 현재 또는 업데이트된 데이터를 관찰자에게 제공하는 반면 <xref:System.IObserver%601.OnError%2A> 메서드는 공급자가 유효한 데이터를 제공할 수 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-121">However, the <xref:System.IObserver%601.OnNext%2A> method is designed to provide an observer with current or updated data, whereas the <xref:System.IObserver%601.OnError%2A> method is designed to indicate that the provider is unable to provide valid data.</span></span>  
  
 <span data-ttu-id="6f410-122">공급자는 예외를 처리하고 <xref:System.IObserver%601.OnError%2A> 메서드를 호출할 때 다음의 모범 사례를 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-122">The provider should follow these best practices when handling exceptions and calling the <xref:System.IObserver%601.OnError%2A> method:</span></span>  
  
- <span data-ttu-id="6f410-123">공급자는 특정 요구 사항이 있는 경우 자체 예외를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-123">The provider must handle its own exceptions if it has any specific requirements.</span></span>  
  
- <span data-ttu-id="6f410-124">공급자는 관찰자가 특정 방식으로 예외를 처리한다고 예상하거나 처리하도록 요구해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-124">The provider should not expect or require that observers handle exceptions in any particular way.</span></span>  
  
- <span data-ttu-id="6f410-125">공급자는 업데이트 제공 기능을 손상시키는 예외를 처리할 때 <xref:System.IObserver%601.OnError%2A> 메서드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-125">The provider should call the <xref:System.IObserver%601.OnError%2A> method when it handles an exception that compromises its ability to provide updates.</span></span> <span data-ttu-id="6f410-126">이러한 예외에 대한 정보를 관찰자에게 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-126">Information on such exceptions can be passed to the observer.</span></span> <span data-ttu-id="6f410-127">다른 경우에는 관찰자에게 예외에 대해 알릴 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-127">In other cases, there is no need to notify observers of an exception.</span></span>  
  
 <span data-ttu-id="6f410-128">공급자가 <xref:System.IObserver%601.OnError%2A> 또는 <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 메서드를 호출한 후에는 추가 알림이 표시되지 않아야 하며 공급자는 해당 관찰자의 구독을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-128">Once the provider calls the <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> method, there should be no further notifications, and the provider can unsubscribe its observers.</span></span> <span data-ttu-id="6f410-129">그러나 관찰자는 <xref:System.IObserver%601.OnError%2A> 또는 <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 알림을 받기 전이나 받은 후를 포함하여 언제든지 직접 구독을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-129">However, the observers can also unsubscribe themselves at any time, including both before and after they receive an <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> notification.</span></span> <span data-ttu-id="6f410-130">관찰자 디자인 패턴에서는 구독 취소 담당자(공급자 또는 관찰자)가 지정되지 않으므로 공급자와 관찰자가 모두 구독 취소를 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-130">The observer design pattern does not dictate whether the provider or the observer is responsible for unsubscribing; therefore, there is a possibility that both may attempt to unsubscribe.</span></span> <span data-ttu-id="6f410-131">일반적으로 관찰자는 구독 취소 시 구독자 컬렉션에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-131">Typically, when observers unsubscribe, they are removed from a subscribers collection.</span></span> <span data-ttu-id="6f410-132">단일 스레드 애플리케이션에서는 제거를 시도하기 전에 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 구현에서 개체 참조가 유효하며 개체가 구독자 컬렉션의 멤버임을 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-132">In a single-threaded application, the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation should ensure that an object reference is valid and that the object is a member of the subscribers collection before attempting to remove it.</span></span> <span data-ttu-id="6f410-133">다중 스레드 애플리케이션에서는 <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> 개체와 같은 스레드로부터 안전한 컬렉션 개체를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-133">In a multithreaded application, a thread-safe collection object, such as a <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> object, should be used.</span></span>  
  
### <a name="the-observer----implementing-the-onerror-method"></a><span data-ttu-id="6f410-134">관찰자 - OnError 메서드를 구현</span><span class="sxs-lookup"><span data-stu-id="6f410-134">The Observer -- Implementing the OnError Method</span></span>  
 <span data-ttu-id="6f410-135">관찰자는 공급자로부터 오류 알림을 받으면 예외를 정보로 처리해야 하며 특정 작업을 수행하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-135">When an observer receives an error notification from a provider, the observer should treat the exception as informational and should not be required to take any particular action.</span></span>  
  
 <span data-ttu-id="6f410-136">관찰자는 공급자로의 <xref:System.IObserver%601.OnError%2A> 메서드 호출에 응답할 때 다음 모범 사례를 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-136">The observer should follow these best practices when responding to an <xref:System.IObserver%601.OnError%2A> method call from a provider:</span></span>  
  
- <span data-ttu-id="6f410-137">관찰자는 <xref:System.IObserver%601.OnNext%2A> 또는 <xref:System.IObserver%601.OnError%2A> 등의 인터페이스 구현에서 예외를 throw해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-137">The observer should not throw exceptions from its interface implementations, such as <xref:System.IObserver%601.OnNext%2A> or <xref:System.IObserver%601.OnError%2A>.</span></span> <span data-ttu-id="6f410-138">관찰자가 예외를 throw하는 경우 해당 예외는 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-138">However, if the observer does throw exceptions, it should expect these exceptions to go unhandled.</span></span>  
  
- <span data-ttu-id="6f410-139">호출 스택을 유지하려면 <xref:System.Exception> 메서드로 전달된 <xref:System.IObserver%601.OnError%2A> 개체를 throw하려는 관찰자는 예외를 throw하기 전에 래핑해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-139">To preserve the call stack, an observer that wishes to throw an <xref:System.Exception> object that was passed to its <xref:System.IObserver%601.OnError%2A> method should wrap the exception before throwing it.</span></span> <span data-ttu-id="6f410-140">이렇게 하려면 표준 예외 개체를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-140">A standard exception object should be used for this purpose.</span></span>  
  
## <a name="additional-best-practices"></a><span data-ttu-id="6f410-141">추가 모범 사례</span><span class="sxs-lookup"><span data-stu-id="6f410-141">Additional Best Practices</span></span>  
 <span data-ttu-id="6f410-142"><xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> 메서드에서 등록 취소를 시도하면 null 참조가 생성될 수 있으므로</span><span class="sxs-lookup"><span data-stu-id="6f410-142">Attempting to unregister in the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method may result in a null reference.</span></span> <span data-ttu-id="6f410-143">이러한 방식은 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-143">Therefore, we recommend that you avoid this practice.</span></span>  
  
 <span data-ttu-id="6f410-144">관찰자 하나를 여러 공급자에 연결할 수는 있지만, <xref:System.IObserver%601> 인스턴스를 <xref:System.IObservable%601> 인스턴스 하나에만 연결하는 패턴을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6f410-144">Although it is possible to attach an observer to multiple providers, the recommended pattern is to attach an <xref:System.IObserver%601> instance to only one <xref:System.IObservable%601> instance.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6f410-145">참고 항목</span><span class="sxs-lookup"><span data-stu-id="6f410-145">See also</span></span>

- [<span data-ttu-id="6f410-146">관찰자 디자인 패턴</span><span class="sxs-lookup"><span data-stu-id="6f410-146">Observer Design Pattern</span></span>](observer-design-pattern.md)
- [<span data-ttu-id="6f410-147">방법: 관찰자 구현</span><span class="sxs-lookup"><span data-stu-id="6f410-147">How to: Implement an Observer</span></span>](how-to-implement-an-observer.md)
- [<span data-ttu-id="6f410-148">방법: 공급자 구현</span><span class="sxs-lookup"><span data-stu-id="6f410-148">How to: Implement a Provider</span></span>](how-to-implement-a-provider.md)
