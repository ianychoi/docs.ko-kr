---
title: 최선의 이벤트 기반 비동기 패턴 구현 방법
ms.date: 03/30/2017
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET], asynchronous
- AsyncOperationManager class
- threading [.NET], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 6c2df4c2877f9191bd2b8190869c359a74de8e8f
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94830495"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="3ce7d-102">최선의 이벤트 기반 비동기 패턴 구현 방법</span><span class="sxs-lookup"><span data-stu-id="3ce7d-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>

<span data-ttu-id="3ce7d-103">이벤트 기반 비동기 패턴은 익숙한 이벤트 및 대리자 의미 체계를 사용하여 클래스에 비동기 동작을 노출하는 효과적인 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="3ce7d-104">이벤트 기반 비동기 패턴을 구현하려면 몇 가지 구체적인 동작 요구 사항을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="3ce7d-105">다음 섹션에서는 이벤트 기반 비동기 패턴을 따르는 클래스를 구현할 때 고려해야 할 요구 사항 및 지침을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="3ce7d-106">개요를 보려면 [이벤트 기반 비동기 패턴 구현](implementing-the-event-based-asynchronous-pattern.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="3ce7d-107">필요한 동작 보장</span><span class="sxs-lookup"><span data-stu-id="3ce7d-107">Required Behavioral Guarantees</span></span>

 <span data-ttu-id="3ce7d-108">이벤트 기반 비동기 패턴을 구현하는 경우 클래스가 올바르게 동작하고 클래스의 클라이언트가 해당 동작을 사용할 수 있도록 보장하는 다양한 보장을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="3ce7d-109">완료</span><span class="sxs-lookup"><span data-stu-id="3ce7d-109">Completion</span></span>

 <span data-ttu-id="3ce7d-110">성공적인 완료, 오류 또는 취소가 있는 경우 항상 <em>MethodName</em>**Completed** 이벤트 처리기를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-110">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="3ce7d-111">애플리케이션이 유휴 상태로 유지되고 절대 완료되지 않는 상황이 애플리케이션에 발생해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="3ce7d-112">이 규칙에 대한 한 가지 예외는 비동기 작업 자체가 절대 완료되지 않도록 디자인된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-112">One exception to this rule is if the asynchronous operation itself is designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="3ce7d-113">완료된 이벤트 및 EventArgs</span><span class="sxs-lookup"><span data-stu-id="3ce7d-113">Completed Event and EventArgs</span></span>

<span data-ttu-id="3ce7d-114">별개의 각 <em>MethodName</em>**Async** 메서드의 경우 다음 디자인 요구 사항을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-114">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
- <span data-ttu-id="3ce7d-115">동일한 클래스에서 <em>MethodName</em>**Completed** 이벤트를 메서드로 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-115">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
- <span data-ttu-id="3ce7d-116"><xref:System.EventArgs> 클래스에서 파생되는 <em>MethodName</em>**Completed** 이벤트에 대한 <xref:System.ComponentModel.AsyncCompletedEventArgs> 클래스 및 수반하는 대리자를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-116">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="3ce7d-117">기본 클래스 이름은 <em>MethodName</em>**CompletedEventArgs** 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-117">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.</span></span>  
  
- <span data-ttu-id="3ce7d-118"><xref:System.EventArgs> 클래스가 <em>MethodName</em> 메서드의 반환 값에 관련되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="3ce7d-119"><xref:System.EventArgs> 클래스를 사용할 경우 개발자가 결과를 캐스팅할 필요가 없도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="3ce7d-120">다음 코드 예제에서는 각각 이 디자인 요구 사항의 좋은 구현과 나쁜 구현을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)
{
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)
{
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
- <span data-ttu-id="3ce7d-121"><xref:System.EventArgs>를 반환하는 반환 메서드에 대해 `void` 클래스를 정의하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="3ce7d-122">대신 <xref:System.ComponentModel.AsyncCompletedEventArgs> 클래스의 인스턴스를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
- <span data-ttu-id="3ce7d-123">항상 <em>MethodName</em>**Completed** 이벤트가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-123">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="3ce7d-124">이 이벤트는 성공적인 완료, 오류 또는 취소 시 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="3ce7d-125">애플리케이션이 유휴 상태로 유지되고 절대 완료되지 않는 상황이 애플리케이션에 발생해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
- <span data-ttu-id="3ce7d-126">비동기 작업에서 발생하는 모든 예외를 catch하고 catch된 예외를 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 속성에 할당하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="3ce7d-127">작업을 완료하는 중에 오류가 발생한 경우 결과에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="3ce7d-128"><xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 속성이 `null`이 아닌 경우 <xref:System.EventArgs> 구조의 모든 속성에 액세스할 때 예외가 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="3ce7d-129"><xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 메서드를 사용하여 이 확인을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
- <span data-ttu-id="3ce7d-130">제한 시간 초과를 오류로 모델링합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-130">Model a time out as an error.</span></span> <span data-ttu-id="3ce7d-131">제한 시간 초과가 발생하면 <em>MethodName</em>**Completed** 이벤트를 발생시키고 <xref:System.TimeoutException>을<xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 속성에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-131">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="3ce7d-132">클래스가 여러 동시 호출을 지원하는 경우 <em>MethodName</em>**Completed** 이벤트에 `userSuppliedState` 개체가 포함되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-132">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
- <span data-ttu-id="3ce7d-133">적절한 스레드 및 애플리케이션 수명 주기의 적절한 시간에 <em>MethodName</em>**Completed** 이벤트가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-133">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="3ce7d-134">자세한 내용은 스레딩 및 컨텍스트 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="3ce7d-135">작업 동시 실행</span><span class="sxs-lookup"><span data-stu-id="3ce7d-135">Simultaneously Executing Operations</span></span>  
  
- <span data-ttu-id="3ce7d-136">클래스가 여러 동시 호출을 지원하는 경우 개발자가 개체 반환 상태 매개 변수 또는 `userSuppliedState`라는 작업 ID를 사용하는 <em>MethodName</em>**Async** 오버로드를 별도로 정의하여 각 호출을 추적할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="3ce7d-137">이 매개 변수는 항상 <em>MethodName</em>**Async** 메서드 시그니처의 마지막 매개 변수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-137">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
- <span data-ttu-id="3ce7d-138">클래스가 개체 반환 상태 매개 변수 또는 작업 ID를 사용하는 <em>MethodName</em>**Async** 오버로드를 정의하는 경우 해당 작업 ID로 작업의 수명을 추적해야 하며, 해당 작업 ID를 완료 처리기에 다시 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-138">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="3ce7d-139">도움이 되는 도우미 클래스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-139">There are helper classes available to assist.</span></span> <span data-ttu-id="3ce7d-140">동시성 관리에 대한 자세한 내용은 [방법: 이벤트 기반 비동기 패턴을 지 원하는 구성 요소 구현](component-that-supports-the-event-based-asynchronous-pattern.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-140">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
- <span data-ttu-id="3ce7d-141">클래스가 상태 매개 변수 없이 <em>MethodName</em>**Async** 메서드를 정의하고 클래스가 여러 동시 호출을 지원하지 않는 경우 이전 <em>MethodName</em>**Async** 호출이 완료되기 전에 <em>MethodName</em>**Async** 를 호출하려는 시도에서 <xref:System.InvalidOperationException>이 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-141">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="3ce7d-142">일반적으로 처리 중인 작업이 여러 개 있도록 `userSuppliedState` 매개 변수 없이 <em>MethodName</em>**Async** 메서드를 여러 번 호출한 경우 예외를 발생시키지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-142">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="3ce7d-143">클래스가 명시적으로 해당 상황을 처리할 수 없는 경우 예외를 발생시킬 수 있지만 개발자가 구분할 수 없는 이러한 여러 콜백을 처리할 수 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="3ce7d-144">결과 액세스</span><span class="sxs-lookup"><span data-stu-id="3ce7d-144">Accessing Results</span></span>  
  
- <span data-ttu-id="3ce7d-145">비동기 작업을 실행하는 중에 오류가 발생한 경우 결과에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="3ce7d-146"><xref:System.ComponentModel.AsyncCompletedEventArgs>가 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>이 아닌 경우 `null`의 속성에 액세스하면 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>에서 참조하는 예외가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="3ce7d-147"><xref:System.ComponentModel.AsyncCompletedEventArgs> 클래스는 이 용도로 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
- <span data-ttu-id="3ce7d-148">결과에 액세스하려는 모든 시도에서 작업이 취소되었음을 나타내는 <xref:System.InvalidOperationException>이 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="3ce7d-149"><xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 메서드를 사용하여 이 확인을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="3ce7d-150">진행률 보고</span><span class="sxs-lookup"><span data-stu-id="3ce7d-150">Progress Reporting</span></span>  
  
- <span data-ttu-id="3ce7d-151">가능한 경우 진행률 보고를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="3ce7d-152">그러면 개발자가 클래스를 사용할 때 더 나은 애플리케이션 사용자 경험을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="3ce7d-153">**ProgressChanged** 또는 <em>MethodName</em>**ProgressChanged** 이벤트를 구현하는 경우 특정 비동기 작업의 <em>MethodName</em>**Completed** 이벤트가 발생한 후 해당 작업에 대해 그러한 이벤트가 발생하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-153">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
- <span data-ttu-id="3ce7d-154">표준 <xref:System.ComponentModel.ProgressChangedEventArgs>를 채우는 경우 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A>가 항상 백분율로 해석될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="3ce7d-155">백분율이 정확할 필요는 없지만 백분율을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="3ce7d-156">진행률 보고 메트릭이 백분율이 아닌 다른 메트릭이어야 하는 경우 <xref:System.ComponentModel.ProgressChangedEventArgs> 클래스에서 클래스를 파생시키고 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A>를 0으로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="3ce7d-157">백분율이 아닌 보고 메트릭을 사용하는 것을 피하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
- <span data-ttu-id="3ce7d-158">적절한 스레드 및 애플리케이션 수명 주기의 적절한 시간에 `ProgressChanged` 이벤트가 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="3ce7d-159">자세한 내용은 스레딩 및 컨텍스트 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="3ce7d-160">IsBusy 구현</span><span class="sxs-lookup"><span data-stu-id="3ce7d-160">IsBusy Implementation</span></span>  
  
- <span data-ttu-id="3ce7d-161">클래스가 여러 동시 호출을 지원하는 경우 `IsBusy` 속성을 노출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="3ce7d-162">예를 들어, XML 웹 서비스 프록시는 비동기 메서드의 여러 동시 호출을 지원하므로 `IsBusy` 속성을 노출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
- <span data-ttu-id="3ce7d-163">`IsBusy` 속성은 <em>MethodName</em>**Async** 메서드가 호출된 후 <em>MethodName</em>**Completed** 이벤트가 발생하기 전에 `true`를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-163">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="3ce7d-164">그렇지 않으면 `false`를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="3ce7d-165"><xref:System.ComponentModel.BackgroundWorker> 및 <xref:System.Net.WebClient> 구성 요소는 `IsBusy` 속성을 노출하는 클래스의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="3ce7d-166">취소</span><span class="sxs-lookup"><span data-stu-id="3ce7d-166">Cancellation</span></span>  
  
- <span data-ttu-id="3ce7d-167">가능한 경우 취소를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-167">Support cancellation, if possible.</span></span> <span data-ttu-id="3ce7d-168">그러면 개발자가 클래스를 사용할 때 더 나은 애플리케이션 사용자 경험을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="3ce7d-169">취소의 경우 <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> 개체에 <xref:System.ComponentModel.AsyncCompletedEventArgs> 플래그를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
- <span data-ttu-id="3ce7d-170">결과에 액세스하려는 모든 시도에서 작업이 취소되었음을 나타내는 <xref:System.InvalidOperationException>이 발생하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="3ce7d-171"><xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 메서드를 사용하여 이 확인을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
- <span data-ttu-id="3ce7d-172">취소 메서드에 대한 호출은 항상 성공적으로 반환되고 예외를 발생시키지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="3ce7d-173">일반적으로 클라이언트는 어느 시점에서든 작업이 진정으로 취소 가능한지에 대한 알림을 받지 않으며, 이전에 발생한 취소가 성공적인지에 대한 알림도 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="3ce7d-174">그러나 애플리케이션은 완료 상태에 참여하므로 취소가 성공적일 때 애플리케이션에는 항상 알림이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
- <span data-ttu-id="3ce7d-175">작업이 취소되면 <em>MethodName</em>**Completed** 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-175">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="3ce7d-176">오류 및 예외</span><span class="sxs-lookup"><span data-stu-id="3ce7d-176">Errors and Exceptions</span></span>  
  
- <span data-ttu-id="3ce7d-177">비동기 작업에서 발생하는 모든 예외를 catch하고 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> 속성 값을 해당 예외로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="3ce7d-178">스레딩 및 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="3ce7d-178">Threading and Contexts</span></span>

 <span data-ttu-id="3ce7d-179">클래스가 올바로 작동하도록 하려면 ASP.NET 및 Windows Forms 애플리케이션을 비롯한 지정된 애플리케이션 모델에 대해 올바른 스레드 또는 컨텍스트에서 클라이언트의 이벤트 처리기가 호출되도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications.</span></span> <span data-ttu-id="3ce7d-180">모든 애플리케이션 모델에서 비동기 클래스가 올바르게 동작하도록 하기 위해 두 개의 중요한 도우미 클래스인 <xref:System.ComponentModel.AsyncOperation> 및 <xref:System.ComponentModel.AsyncOperationManager>가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="3ce7d-181"><xref:System.ComponentModel.AsyncOperationManager>는 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>을 반환하는 하나의 메서드 <xref:System.ComponentModel.AsyncOperation>을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="3ce7d-182"><em>MethodName</em>**Async** 메서드는 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>을 호출하고 클래스는 반환된 <xref:System.ComponentModel.AsyncOperation>을 사용하여 비동기 작업의 수명을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-182">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="3ce7d-183">클라이언트에 진행률, 증분 결과 및 완료를 보고하려면 <xref:System.ComponentModel.AsyncOperation.Post%2A>에 대해 <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> 및 <xref:System.ComponentModel.AsyncOperation> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="3ce7d-184"><xref:System.ComponentModel.AsyncOperation>은 클라이언트의 이벤트 처리기에 대한 호출을 올바른 스레드 또는 컨텍스트로 마샬링하는 작업을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3ce7d-185">명시적으로 애플리케이션 모델의 정책에 반대하되 이벤트 기반 비동기 패턴 사용의 다른 이점을 이용하려는 경우 이러한 규칙을 피해 갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="3ce7d-186">예를 들어, Windows Forms에서 작동하는 클래스가 자유 스레드가 되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="3ce7d-187">개발자가 암시된 제한 사항을 이해하는 한 자유 스레드 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="3ce7d-188">콘솔 애플리케이션은 <xref:System.ComponentModel.AsyncOperation.Post%2A> 호출 실행을 동기화하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="3ce7d-189">이로 인해 `ProgressChanged` 이벤트가 잘못 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="3ce7d-190"><xref:System.ComponentModel.AsyncOperation.Post%2A> 호출이 serialize되어 실행되도록 하려면 <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> 클래스를 구현하여 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="3ce7d-191">비동기 작업이 가능하도록 <xref:System.ComponentModel.AsyncOperation> 및 <xref:System.ComponentModel.AsyncOperationManager>를 사용하는 방법에 대한 자세한 내용은 [방법: 이벤트 기반 비동기 패턴을 지 원하는 구성 요소 구현](component-that-supports-the-event-based-asynchronous-pattern.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="3ce7d-192">지침</span><span class="sxs-lookup"><span data-stu-id="3ce7d-192">Guidelines</span></span>  
  
- <span data-ttu-id="3ce7d-193">이상적으로는 각 메서드 호출이 다른 메서드 호출과 별개여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="3ce7d-194">호출을 공유 리소스와 결합하는 것을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="3ce7d-195">리소스가 호출 간에 공유되는 경우 구현에 적절한 동기화 메커니즘을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
- <span data-ttu-id="3ce7d-196">클라이언트가 동기화를 구현해야 하는 디자인은 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="3ce7d-197">예를 들어, 전역 정적 개체를 매개 변수로 받는 비동기 메서드가 있을 수 있습니다. 이러한 메서드의 여러 동시 호출로 인해 데이터 손상이나 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
- <span data-ttu-id="3ce7d-198">여러 호출 오버로드로 메서드를 구현하는 경우(시그니처에 `userState`가 있음) 클래스가 사용자 상태 또는 작업 ID 및 해당 보류 중인 작업의 컬렉션을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="3ce7d-199">다양한 호출에서 컬렉션에 `lock` 개체를 추가 및 제거하므로 이 컬렉션은 `userState` 영역으로 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
- <span data-ttu-id="3ce7d-200">실현 가능하고 적절한 경우 `CompletedEventArgs` 클래스 재사용을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="3ce7d-201">이 경우 지정된 대리자 및 <xref:System.EventArgs> 형식이 단일 메서드에 연결된 것이 아니므로 명명이 메서드 이름과 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="3ce7d-202">그러나 개발자가 <xref:System.EventArgs>에 대한 속성에서 검색된 값을 강제로 캐스팅하도록 하는 것은 절대 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
- <span data-ttu-id="3ce7d-203"><xref:System.ComponentModel.Component>에서 파생되는 클래스를 작성하는 경우 고유한 <xref:System.Threading.SynchronizationContext> 클래스를 구현하여 설치하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="3ce7d-204">구성 요소가 아니라 애플리케이션 모델이 사용되는 <xref:System.Threading.SynchronizationContext>를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
- <span data-ttu-id="3ce7d-205">모든 종류의 다중 스레딩을 사용할 때는 매우 심각하고 복잡한 버그에 잠재적으로 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="3ce7d-206">다중 스레딩을 사용하는 솔루션을 구현하기 전에 [관리되는 스레딩을 구현하는 최선의 방법](../threading/managed-threading-best-practices.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3ce7d-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3ce7d-207">참조</span><span class="sxs-lookup"><span data-stu-id="3ce7d-207">See also</span></span>

- <xref:System.ComponentModel.AsyncOperation>
- <xref:System.ComponentModel.AsyncOperationManager>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- [<span data-ttu-id="3ce7d-208">이벤트 기반 비동기 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="3ce7d-208">Implementing the Event-based Asynchronous Pattern</span></span>](implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="3ce7d-209">EAP(이벤트 기반 비동기 패턴)</span><span class="sxs-lookup"><span data-stu-id="3ce7d-209">Event-based Asynchronous Pattern (EAP)</span></span>](event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="3ce7d-210">이벤트 기반 비동기 패턴 구현 시기 결정</span><span class="sxs-lookup"><span data-stu-id="3ce7d-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="3ce7d-211">최선의 이벤트 기반 비동기 패턴 구현 방법</span><span class="sxs-lookup"><span data-stu-id="3ce7d-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="3ce7d-212">방법: 이벤트 기반 비동기 패턴을 지원하는 구성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="3ce7d-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="3ce7d-213">방법: 이벤트 기반 비동기 패턴을 지원하는 구성 요소 구현</span><span class="sxs-lookup"><span data-stu-id="3ce7d-213">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](component-that-supports-the-event-based-asynchronous-pattern.md)
