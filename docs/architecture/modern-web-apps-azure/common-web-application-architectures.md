---
title: 일반 웹 애플리케이션 아키텍처
description: ASP.NET Core 및 Azure를 사용하여 현대식 웹 애플리케이션 설계 | 일반 웹 애플리케이션 아키텍처 둘러보기
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: 86d2e931e6462fb9f6ff5e3cd31b8d3fd188dd5a
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95682044"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="db317-103">일반 웹 애플리케이션 아키텍처</span><span class="sxs-lookup"><span data-stu-id="db317-103">Common web application architectures</span></span>

> <span data-ttu-id="db317-104">"좋은 아키텍처가 비싸다고 생각된다면 나쁜 아키텍처를 사용해 보세요."</span><span class="sxs-lookup"><span data-stu-id="db317-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="db317-105">_- Brian Foote 및 Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="db317-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="db317-106">대부분의 기존 .NET 애플리케이션은 단일 IIS appdomain에서 실행되는 실행 파일 또는 단일 웹 애플리케이션에 해당하는 단일 단위로 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="db317-107">이 방법은 가장 간단한 배포 모델이며 다양한 내부 애플리케이션과 작은 공용 애플리케이션에 매우 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="db317-108">하지만 이 단일 배포 단위를 사용하더라도 대부분의 중요한 업무용 애플리케이션은 여러 레이어로 논리적 분리 시 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="db317-109">모놀리식 애플리케이션이란?</span><span class="sxs-lookup"><span data-stu-id="db317-109">What is a monolithic application?</span></span>

<span data-ttu-id="db317-110">모놀리식 애플리케이션은 그 동작에 있어서 완전히 독립적인 애플리케이션입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="db317-111">작업을 수행하는 과정에서 다른 서비스 또는 데이터 저장소와 상호 작용할 수도 있지만, 동작의 핵심은 자체 프로세스 내에서 실행되고 전체 애플리케이션은 일반적으로 하나의 단위로 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="db317-112">이러한 애플리케이션을 수평으로 확장해야 하는 경우 일반적으로 전체 애플리케이션이 여러 서버 또는 가상 머신에서 중복됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="db317-113">올인원 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="db317-113">All-in-one applications</span></span>

<span data-ttu-id="db317-114">애플리케이션 아키텍처에 허용되는 최소 프로젝트 수는 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="db317-115">이 아키텍처에서 애플리케이션의 전체 로직은 단일 프로젝트에 포함되고, 단일 어셈블리로 컴파일되고, 단일 단위로 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="db317-116">새 ASP.NET Core 프로젝트는 Visual Studio에서 만들었든 아니면 명령줄에서 만들었든, 간단한 "올인원" 모놀리스로 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="db317-117">프레젠테이션, 비즈니스 및 데이터 액세스 논리를 포함하여 애플리케이션의 모든 동작을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="db317-118">그림 5-1은 단일 프로젝트 앱의 파일 구조를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![단일 프로젝트 ASP.NET Core 앱](./media/image5-1.png)

<span data-ttu-id="db317-120">**그림 5-1.**</span><span class="sxs-lookup"><span data-stu-id="db317-120">**Figure 5-1.**</span></span> <span data-ttu-id="db317-121">단일 프로젝트 ASP.NET Core 앱.</span><span class="sxs-lookup"><span data-stu-id="db317-121">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="db317-122">단일 프로젝트 시나리오에서는 폴더를 사용하여 문제를 격리합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="db317-123">기본 템플릿에는 데이터 및 서비스에 대한 추가 폴더 외에도 Models, Views 및 Controllers의 MVC 패턴 책임에 대한 별도의 폴더가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="db317-124">이 정렬에서 프레젠테이션 세부 정보는 되도록이면 Views 폴더로 제한되어야 하고, 데이터 액세스 구현 세부 정보는 Data 폴더에 보관되는 클래스로 제한되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="db317-125">비즈니스 논리는 Models 폴더 내부의 서비스 및 클래스에 상주해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="db317-126">단일 프로젝트 모놀리식 솔루션은 간단하지만 몇 가지 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="db317-127">프로젝트의 크기와 복잡성이 증가하면 파일 및 폴더의 수도 계속해서 함께 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="db317-128">사전순으로 그룹화되지 않은 여러 폴더에 UI(사용자 인터페이스) 문제(모델, 보기, 컨트롤러)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-128">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="db317-129">이 문제는 Filters 또는 ModelBinders 같은 UI 수준의 구성이 자체 폴더에 추가될 때에만 악화됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="db317-130">비즈니스 논리는 Models 폴더와 Services 폴더 사이에 흩어져 있으며, 어떤 폴더의 어떤 클래스가 무엇에 의존해야 하는지 명확한 표시가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-130">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="db317-131">이와 같이 프로젝트 수준에서 깔끔하게 정리되지 않기 때문에 [스파게티 코드](https://deviq.com/spaghetti-code/)로 이어지는 경우가 자주 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-131">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="db317-132">이 문제를 해결하기 위해 종종 애플리케이션은 각 프로젝트가 애플리케이션의 특정 _레이어_ 에 상주하는 것으로 간주되는 다중 프로젝트 솔루션으로 발전합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-132">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="db317-133">레이어란 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="db317-133">What are layers?</span></span>

<span data-ttu-id="db317-134">증가하는 애플리케이션 복잡성을 관리하는 한 가지 방법은 애플리케이션의 책임이나 문제에 따라 애플리케이션을 나누는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-134">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="db317-135">이것은 문제 분리 원칙을 따르며, 개발자가 특정 기능이 어디에 구현되는지 쉽게 찾을 수 있도록 증가하는 코드 베이스를 정리하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-135">This follows the separation of concerns principle and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="db317-136">하지만 계층화 아키텍처는 코드 구성 이상의 여러 가지 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="db317-137">코드를 여러 레이어로 구성하면 공통 하위 수준 기능을 애플리케이션 전체에서 재사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="db317-138">이러한 재사용은 작성할 코드의 양이 줄어들고 애플리케이션에서 [DRY(반복 금지)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 원칙에 따라 단일 구현을 표준화할 수 있다는 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="db317-139">계층화 아키텍처를 사용하면 애플리케이션에서 다른 레이어와 통신할 수 있는 레이어를 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="db317-140">이렇게 하면 캡슐화를 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="db317-141">한 레이어가 변경되거나 대체되면 해당 레이어와 함께 작동하는 레이어만 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="db317-142">어떤 레이어가 어떤 레이어에 종속되는지를 제한하면 단일 변경 내용이 전체 애플리케이션에 영향을 미치지 않도록 변경의 영향을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="db317-143">레이어(및 캡슐화)를 사용하면 애플리케이션 내에서 훨씬 간단하게 기능을 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="db317-144">예를 들어 애플리케이션에서 처음에는 지속성을 위해 자체 SQL Server 데이터베이스를 사용하지만, 나중에는 클라우드 기반 지속성 전략 또는 웹 API 뒤에 있는 것을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="db317-145">애플리케이션이 논리적 레이어 내에서 지속성 구현을 적절하게 캡슐화한 경우 동일한 공용 인터페이스를 구현하여 해당 SQL Server 관련 레이어를 새 레이어로 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="db317-146">향후 요구 사항의 변화에 따라 구현을 교환할 가능성 외에도, 애플리케이션 레이어를 사용하면 테스트 목적으로 구현을 쉽게 교환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="db317-147">애플리케이션의 실제 데이터 레이어 또는 UI 레이어에 대해 작동하는 테스트를 작성하는 대신, 테스트 시 이러한 레이어를 요청에 대한 알려진 응답을 제공하는 가짜 구현으로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="db317-148">이렇게 하면 일반적으로 애플리케이션의 실제 인프라에 대해 테스트를 실행하는 것에 비해 테스트를 훨씬 쉽게 작성하고 훨씬 빠르게 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-148">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="db317-149">논리적 레이어링은 엔터프라이즈 소프트웨어 애플리케이션에서 코드 구성을 향상하는 일반적인 방법이며, 코드를 레이어로 구성할 수 있는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="db317-150">_레이어_ 는 애플리케이션 내부의 논리적 분리를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="db317-150">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="db317-151">애플리케이션 논리가 별도의 서버 또는 프로세스에 물리적으로 분산된 경우 이러한 별도의 실제 배포 대상을 _계층_ 이라고 부릅니다.</span><span class="sxs-lookup"><span data-stu-id="db317-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="db317-152">N 레이어 애플리케이션을 단일 계층에 배포할 수 있으며, 이는 매우 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="db317-153">기존의 "N 레이어" 아키텍처 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="db317-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="db317-154">그림 5-2는 애플리케이션 논리를 레이어로 구성하는 가장 일반적인 예입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-154">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![일반적인 애플리케이션 레이어](./media/image5-2.png)

<span data-ttu-id="db317-156">**그림 5-2.**</span><span class="sxs-lookup"><span data-stu-id="db317-156">**Figure 5-2.**</span></span> <span data-ttu-id="db317-157">일반적인 애플리케이션 레이어.</span><span class="sxs-lookup"><span data-stu-id="db317-157">Typical application layers.</span></span>

<span data-ttu-id="db317-158">이러한 레이어를 종종 줄여서 UI, BLL(비즈니스 논리 레이어) 및 DAL(데이터 액세스 레이어)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-158">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="db317-159">이 아키텍처를 사용하면 사용자는 BLL하고만 상호 작용하는 UI 레이어를 통해 요청을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="db317-159">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="db317-160">그러면 BLL은 데이터 액세스 요청을 위해 DAL을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-160">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="db317-161">UI 레이어는 DAL에 대한 요청을 직접 만들면 안 되고, 다른 방법을 통해 지속성과 직접 상호 작용해서도 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-161">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="db317-162">마찬가지로, BLL은 DAL을 통해서만 지속성과 상호 작용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-162">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="db317-163">이러한 방식으로 레이어마다 잘 알려진 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-163">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="db317-164">이 기존 레이어링 방식의 단점 중 하나는 컴파일 시간 종속성이 위에서 아래로 흐른다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-164">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="db317-165">즉, UI 레이어가 BLL에 종속되고, BLL은 DAL에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-165">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="db317-166">다시 말해서, 일반적으로 애플리케이션에서 가장 중요한 논리를 보관하는 BLL이 데이터 액세스 구현 세부 정보(및 존재하는 데이터베이스)에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-166">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="db317-167">이러한 아키텍처에서 비즈니스 논리를 테스트하기가 어려운 경우가 종종 있으며, 테스트 데이터베이스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-167">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="db317-168">다음 섹션에서 설명드리겠지만, 종속성 반전 원칙을 사용하여 이 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-168">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="db317-169">그림 5-3은 애플리케이션을 책임(또는 레이어)에 따라 세 개 프로젝트로 분할하는 예제 솔루션을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-169">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![3개의 프로젝트가 있는 간단한 모놀리식 애플리케이션](./media/image5-3.png)

<span data-ttu-id="db317-171">**그림 5-3.**</span><span class="sxs-lookup"><span data-stu-id="db317-171">**Figure 5-3.**</span></span> <span data-ttu-id="db317-172">세 개 프로젝트가 있는 간단한 모놀리식 애플리케이션입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-172">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="db317-173">이 애플리케이션은 구성을 목적으로 여러 프로젝트를 사용하지만 여전히 단일 단위로 배포되고 그 클라이언트는 단일 웹앱과 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-173">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="db317-174">따라서 배포 프로세스가 매우 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-174">This allows for very simple deployment process.</span></span> <span data-ttu-id="db317-175">그림 5-4는 Azure를 사용하여 이러한 앱을 호스팅하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-175">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![Azure 웹앱의 간단한 배포](./media/image5-4.png)

<span data-ttu-id="db317-177">**그림 5-4.**</span><span class="sxs-lookup"><span data-stu-id="db317-177">**Figure 5-4.**</span></span> <span data-ttu-id="db317-178">Azure 웹앱의 간단한 배포</span><span class="sxs-lookup"><span data-stu-id="db317-178">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="db317-179">애플리케이션 요구 사항이 증가하면 좀 더 복잡하고 강력한 배포 솔루션이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-179">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="db317-180">그림 5-5는 추가 기능을 지원하는 좀 더 복잡한 배포 계획의 예를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-180">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![Azure App Service에 웹앱 배포](./media/image5-5.png)

<span data-ttu-id="db317-182">**그림 5-5.**</span><span class="sxs-lookup"><span data-stu-id="db317-182">**Figure 5-5.**</span></span> <span data-ttu-id="db317-183">Azure App Service에 웹앱 배포</span><span class="sxs-lookup"><span data-stu-id="db317-183">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="db317-184">내부적으로 책임을 기반으로 이 프로젝트를 여러 프로젝트로 정리하면 애플리케이션의 유지 관리 용이성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-184">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="db317-185">이 단위를 수직 확장 또는 수평 확장하여 클라우드 기반 주문형 확장성의 장점을 누릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-185">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="db317-186">수직 확장이란 앱을 호스팅하는 서버에 추가 CPU, 메모리, 디스크 공간 또는 기타 리소스를 추가하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-186">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="db317-187">수평 확장이란 물리적 서버,가상 머신 또는 컨테이너인지와 상관 없이 서버의 추가 인스턴스를 추가하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-187">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="db317-188">앱이 여러 인스턴스에서 호스트되는 경우 부하 분산 장치를 사용하여 개별 앱 인스턴스에 요청을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-188">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="db317-189">Azure에서 웹 애플리케이션을 확장하는 가장 간단한 방법은 애플리케이션의 App Service 계획에서 수동으로 확장하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-189">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="db317-190">그림 5-6은 앱에 서비스를 제공하는 인스턴스 수를 구성하는 적절한 Azure 대시보드 화면을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-190">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![Azure에서 App Service 계획 크기 조정](./media/image5-6.png)

<span data-ttu-id="db317-192">**그림 5-6.**</span><span class="sxs-lookup"><span data-stu-id="db317-192">**Figure 5-6.**</span></span> <span data-ttu-id="db317-193">Azure에서 App Service 계획의 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-193">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="db317-194">클린 아키텍처</span><span class="sxs-lookup"><span data-stu-id="db317-194">Clean architecture</span></span>

<span data-ttu-id="db317-195">종속성 반전 원칙과 DDD(도메인 중심 디자인) 원칙을 따르는 애플리케이션은 비슷한 아키텍처에 도달하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-195">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="db317-196">이 아키텍처는 수년 동안 여러 가지 이름으로 불렸습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-196">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="db317-197">첫 번째 이름 중 하나는 육각형 아키텍처이고, 그 다음은 포트 및 어댑터(Ports-and-Adapters)였습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-197">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="db317-198">최근에는 [양파형 아키텍처](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) 또는 [클린 아키텍처](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)로 불렸습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-198">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="db317-199">두 번째 이름인 클린 아키텍처는 이 eBook에서 이 아키텍처에 대한 이름으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-199">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

<span data-ttu-id="db317-200">eShopOnWeb 참조 애플리케이션은 프로젝트에 코드를 구성하는 데 클린 아키텍처 접근 방법을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-200">The eShopOnWeb reference application uses the Clean Architecture approach in organizing its code into projects.</span></span> <span data-ttu-id="db317-201">[ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) GitHub 리포지토리에서 자체 ASP.NET Core의 시작 지점으로 사용할 수 있는 솔루션 템플릿을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-201">You can find a solution template you can use as a starting point for your own ASP.NET Core on the [ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) GitHub repository.</span></span>

<span data-ttu-id="db317-202">클린 아키텍처는 비즈니스 논리와 애플리케이션 모델을 애플리케이션의 중심에 놓습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-202">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="db317-203">비즈니스 논리가 데이터 액세스 또는 다른 인프라 고려 사항에 따라 달라지는 것이 아니라 이 종속성을 반전하여 인프라 및 구현 세부 사항이 애플리케이션 코어에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="db317-203">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="db317-204">이것은 Application Core에서 추상화 또는 인터페이스를 정의하여 달성된 후 인프라 계층에서 정의된 형식에 따라 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-204">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="db317-205">이 아키텍처를 시각화하는 일반적인 방법은 양파와 비슷한 일련의 동심원을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-205">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="db317-206">그림 5-7은 이 아키텍처 표현 스타일의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-206">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![클린 아키텍처; 양파형 보기](./media/image5-7.png)

<span data-ttu-id="db317-208">**그림 5-7.**</span><span class="sxs-lookup"><span data-stu-id="db317-208">**Figure 5-7.**</span></span> <span data-ttu-id="db317-209">클린 아키텍처; 양파형 보기</span><span class="sxs-lookup"><span data-stu-id="db317-209">Clean Architecture; onion view</span></span>

<span data-ttu-id="db317-210">이 다이어그램에서 종속성은 가장 안쪽에 있는 원을 향해 흐릅니다.</span><span class="sxs-lookup"><span data-stu-id="db317-210">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="db317-211">Application Core는 이 다이어그램의 중심에 있는 해당 위치에서 해당 이름을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-211">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="db317-212">또한 Application Core가 다른 애플리케이션 계층에 종속되지 않음을 다이어그램에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-212">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="db317-213">정중앙에는 애플리케이션의 엔터티 및 인터페이스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-213">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="db317-214">그 바로 바깥에는(여전히 Application Core 안에 있지만) 일반적으로 내부 원에 정의된 인터페이스를 구현하는 도메인 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-214">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="db317-215">Application Core 밖에서는 UI 및 인프라 계층이 Application Core에 종속되지만 서로 종속되지는 않습니다(반드시).</span><span class="sxs-lookup"><span data-stu-id="db317-215">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="db317-216">그림 5-8은 UI와 다른 레이어 간에 종속성을 좀 더 잘 반영하는 더 일반적인 수평 방향 레이어 다이어그램입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-216">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![클린 아키텍처; 수평 방향 레이어 보기](./media/image5-8.png)

<span data-ttu-id="db317-218">**그림 5-8.**</span><span class="sxs-lookup"><span data-stu-id="db317-218">**Figure 5-8.**</span></span> <span data-ttu-id="db317-219">클린 아키텍처; 수평 방향 레이어 보기</span><span class="sxs-lookup"><span data-stu-id="db317-219">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="db317-220">실선 화살표는 컴파일 시간 종속성을 나타내고, 파선 화살표는 런타임 전용 종속성을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="db317-220">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="db317-221">클린 아키텍처를 사용하면 UI 레이어는 컴파일 시 Application Core에서 정의된 인터페이스와 함께 작동하며, 인프라 계층에 정의된 구현 형식에 대해서는 모르는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-221">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="db317-222">하지만 런타임 시 앱이 실행되려면 이러한 구현 형식이 필요하며, 따라서 구현 형식이 있어야 하고 종속성 주입을 통해 Application Core 인터페이스에 연결되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-222">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="db317-223">그림 5-9는 이러한 권장 사항에 따라 빌드할 때의 ASP.NET Core 애플리케이션 아키텍처를 자세히 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-223">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![클린 아키텍처를 따르는 ASP.NET Core 아키텍처 다이어그램](./media/image5-9.png)

<span data-ttu-id="db317-225">**그림 5-9.**</span><span class="sxs-lookup"><span data-stu-id="db317-225">**Figure 5-9.**</span></span> <span data-ttu-id="db317-226">클린 아키텍처를 따르는 ASP.NET Core 아키텍처 다이어그램.</span><span class="sxs-lookup"><span data-stu-id="db317-226">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="db317-227">Application Core는 인프라에 종속되지 않기 때문에 이 레이어에 대한 자동화된 단위 테스트를 작성하기가 매우 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-227">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="db317-228">그림 5-10 및 5-11은 테스트가 이 아키텍처와 얼마나 잘 맞는지를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="db317-228">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="db317-230">**그림 5-10.**</span><span class="sxs-lookup"><span data-stu-id="db317-230">**Figure 5-10.**</span></span> <span data-ttu-id="db317-231">격리 상태로 Application Core 단위 테스트.</span><span class="sxs-lookup"><span data-stu-id="db317-231">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="db317-233">**그림 5-11.**</span><span class="sxs-lookup"><span data-stu-id="db317-233">**Figure 5-11.**</span></span> <span data-ttu-id="db317-234">외부 종속성으로 인프라 구현 통합 테스트.</span><span class="sxs-lookup"><span data-stu-id="db317-234">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="db317-235">UI 레이어는 인프라 프로젝트에 정의된 형식에 조금도 종속되지 않으므로 테스트를 쉽게 하기 위해서든 아니면 애플리케이션 요구 사항의 변화에 대응하기 위해서든 구현을 교체하기가 매우 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-235">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="db317-236">ASP.NET Core는 종속성 주입을 기본적으로 사용하고 지원하기 때문에 특수 모놀리식 애플리케이션을 만드는 가장 적합한 방식은 이 아키텍처입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-236">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="db317-237">모놀리식 애플리케이션의 경우 Application Core, 인프라 및 UI 프로젝트는 모두 단일 애플리케이션으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-237">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="db317-238">런타임 애플리케이션 아키텍처는 그림 5-12처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-238">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core 아키텍처 2](./media/image5-12.png)

<span data-ttu-id="db317-240">**그림 5-12.**</span><span class="sxs-lookup"><span data-stu-id="db317-240">**Figure 5-12.**</span></span> <span data-ttu-id="db317-241">샘플 ASP.NET Core 앱의 런타임 아키텍처.</span><span class="sxs-lookup"><span data-stu-id="db317-241">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="db317-242">클린 아키텍처에서 코드 구성</span><span class="sxs-lookup"><span data-stu-id="db317-242">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="db317-243">클린 아키텍처 솔루션에서는 프로젝트마다 명확한 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-243">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="db317-244">따라서 각 프로젝트에 속하는 특정 형식이 있으며 해당 프로젝트에서 이러한 형식에 해당하는 폴더를 자주 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-244">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

#### <a name="application-core"></a><span data-ttu-id="db317-245">애플리케이션 코어</span><span class="sxs-lookup"><span data-stu-id="db317-245">Application Core</span></span>

<span data-ttu-id="db317-246">Application Core는 비즈니스 모델을 보관하며, 비즈니스 모델에는 엔터티, 서비스 및 인터페이스가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-246">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="db317-247">이러한 인터페이스는 데이터 액세스, 파일 시스템 액세스, 네트워크 호출 등의 인프라를 사용하여 수행되는 작업의 추상화를 포함합니다. 경우에 따라 이 레이어에 정의된 서비스 또는 인터페이스가 UI 또는 인프라에 종속되지 않은 비 엔터티 형식과 함께 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-247">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="db317-248">이러한 동작은 간단한 DTO(데이터 전송 개체)로 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-248">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

##### <a name="application-core-types"></a><span data-ttu-id="db317-249">Application Core 형식</span><span class="sxs-lookup"><span data-stu-id="db317-249">Application Core types</span></span>

- <span data-ttu-id="db317-250">엔터티(유지되는 비즈니스 모델 클래스)</span><span class="sxs-lookup"><span data-stu-id="db317-250">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="db317-251">인터페이스</span><span class="sxs-lookup"><span data-stu-id="db317-251">Interfaces</span></span>
- <span data-ttu-id="db317-252">Services</span><span class="sxs-lookup"><span data-stu-id="db317-252">Services</span></span>
- <span data-ttu-id="db317-253">DTO</span><span class="sxs-lookup"><span data-stu-id="db317-253">DTOs</span></span>

#### <a name="infrastructure"></a><span data-ttu-id="db317-254">인프라</span><span class="sxs-lookup"><span data-stu-id="db317-254">Infrastructure</span></span>

<span data-ttu-id="db317-255">인프라 프로젝트는 일반적으로 데이터 액세스 구현을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-255">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="db317-256">일반적인 ASP.NET Core 웹 애플리케이션에서는 EF(Entity Framework) DbContext, 정의된 EF Core `Migration` 개체 및 데이터 액세스 구현 클래스가 해당 구현에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-256">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="db317-257">데이터 액세스 구현 코드를 추상화하는 가장 일반적인 방법은 [리포지토리 디자인 패턴](https://deviq.com/repository-pattern/)을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-257">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="db317-258">인프라 프로젝트는 데이터 액세스 구현 외에도 인프라 문제와 상호 작용해야 하는 서비스 구현을 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-258">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="db317-259">이러한 서비스는 Application Core에 정의된 인터페이스를 구현해야 하며, 따라서 인프라에 Application Core 프로젝트에 대한 참조가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-259">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

##### <a name="infrastructure-types"></a><span data-ttu-id="db317-260">인프라 형식</span><span class="sxs-lookup"><span data-stu-id="db317-260">Infrastructure types</span></span>

- <span data-ttu-id="db317-261">EF Core 형식(`DbContext`, `Migration`)</span><span class="sxs-lookup"><span data-stu-id="db317-261">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="db317-262">데이터 액세스 구현 형식(리포지토리)</span><span class="sxs-lookup"><span data-stu-id="db317-262">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="db317-263">인프라 관련 서비스(예: `FileLogger` 또는 `SmtpNotifier`)</span><span class="sxs-lookup"><span data-stu-id="db317-263">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

#### <a name="ui-layer"></a><span data-ttu-id="db317-264">UI 계층</span><span class="sxs-lookup"><span data-stu-id="db317-264">UI Layer</span></span>

<span data-ttu-id="db317-265">ASP.NET Core MVC 애플리케이션의 사용자 인터페이스 레이어는 애플리케이션의 진입점입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-265">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="db317-266">이 프로젝트는 Application Core 프로젝트를 참조해야 하고, 그 형식은 Application Core에 정의된 인터페이스를 통해 인프라와 엄격하게 상호 작용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-266">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="db317-267">어느 인프라 계층 형식의 직접 인스턴스화 또는 정적 호출도 UI 레이어에서 허용되어서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-267">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

##### <a name="ui-layer-types"></a><span data-ttu-id="db317-268">UI 계층 형식</span><span class="sxs-lookup"><span data-stu-id="db317-268">UI Layer types</span></span>

- <span data-ttu-id="db317-269">컨트롤러</span><span class="sxs-lookup"><span data-stu-id="db317-269">Controllers</span></span>
- <span data-ttu-id="db317-270">필터</span><span class="sxs-lookup"><span data-stu-id="db317-270">Filters</span></span>
- <span data-ttu-id="db317-271">보기</span><span class="sxs-lookup"><span data-stu-id="db317-271">Views</span></span>
- <span data-ttu-id="db317-272">ViewModels</span><span class="sxs-lookup"><span data-stu-id="db317-272">ViewModels</span></span>
- <span data-ttu-id="db317-273">Startup 클래스</span><span class="sxs-lookup"><span data-stu-id="db317-273">Startup</span></span>

<span data-ttu-id="db317-274">시작 클래스는 런타임에 종속성 주입이 올바르게 작동하도록 애플리케이션을 구성하고 구현 형식을 인터페이스에 연결할 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-274">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="db317-275">UI 프로젝트의 Startup.cs 파일에 있는 ConfigureServices에서 종속성 주입을 연결하려면 프로젝트가 인프라 프로젝트를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-275">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="db317-276">이 종속성을 가장 쉽게 제어하는 방법은 사용자 지정 DI 컨테이너를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-276">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="db317-277">이 샘플에서는 UI 프로젝트가 인프라 프로젝트를 참조하도록 허용하는 것이 가장 간단한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-277">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="db317-278">모놀리식 애플리케이션 및 컨테이너</span><span class="sxs-lookup"><span data-stu-id="db317-278">Monolithic applications and containers</span></span>

<span data-ttu-id="db317-279">단일 모놀리식 배포 기반 웹 애플리케이션 또는 서비스를 빌드하고 컨테이너로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-279">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="db317-280">애플리케이션 내에서는 모놀리식이 아닐 수 있지만 여러 라이브러리, 구성 요소 또는 레이어로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-280">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="db317-281">외부적으로는 단일 프로세스, 단일 웹 애플리케이션 또는 단일 서비스 같은 단일 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-281">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="db317-282">이 모델을 관리하려면 애플리케이션을 나타내는 단일 컨테이너를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-282">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="db317-283">크기를 조정하려면 부하 분산 장치 앞에 여러 복사본을 추가하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-283">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="db317-284">단일 컨테이너 또는 VM에서 단일 배포를 관리하면 단순성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-284">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![그림 5-13](./media/image5-13.png)

<span data-ttu-id="db317-286">그림 5-13에서 보여준 대로 각 컨테이너 내에 여러 구성 요소/라이브러리 또는 내부 레이어를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-286">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="db317-287">하지만 이 모놀리식 패턴은 _“컨테이너는 한 가지 작업을 하나의 프로세스에서 수행합니다”_ 라는 컨테이너 원칙과 충돌할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-287">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="db317-288">이 방법의 단점은 애플리케이션이 커지면 크기를 조정해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-288">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="db317-289">전체 애플리케이션의 크기를 조정하는 경우에는 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-289">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="db317-290">그러나 대부분의 경우 애플리케이션의 일부는 크기 조정이 필요하고, 나머지 구성 요소는 활용도가 떨어집니다.</span><span class="sxs-lookup"><span data-stu-id="db317-290">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="db317-291">일반적인 전자상거래를 예로 들자면, 크기 조정이 필요할 가능성이 높은 부분은 제품 정보 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-291">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="db317-292">제품을 구매하는 고객보다 제품을 살펴보는 고객이 훨씬 많습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-292">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="db317-293">많은 고객이 결제 파이프라인을 사용하지 않고 자신의 바구니를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-293">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="db317-294">적은 수의 고객이 주석을 추가하거나 자신의 구매 기록을 봅니다.</span><span class="sxs-lookup"><span data-stu-id="db317-294">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="db317-295">또한 얼마 되지 않는 직원들이 한 지역에서 근무하며 콘텐츠와 마케팅 캠페인을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-295">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="db317-296">모놀리식 디자인을 확장하면 모든 코드가 여러 번 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-296">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="db317-297">하지만 “모든 것을 확장”하는 문제 외에도 단일 구성 요소를 변경하려면 전체 애플리케이션을 모두 다시 테스트하고 전체 인스턴스를 모두 다시 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-297">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="db317-298">모놀리식 접근 방식이 주로 사용되며, 많은 조직에서 이 아키텍처 접근 방법을 개발 중입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-298">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="db317-299">좋은 결과를 얻은 곳도 많지만, 한계에 부딪힌 곳도 많습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-299">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="db317-300">SOA(서비스 지향 아키텍처)를 빌드하기에는 도구 및 인프라 사용 방법이 너무 어려웠고 앱이 커지기 전에는 필요성을 느끼지도 않았기 때문에 많은 조직에서 이 모델을 사용하여 애플리케이션을 디자인했습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-300">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="db317-301">모놀리식 방식의 한계에 도달한 것 같으면 앱을 분할하여 컨테이너를 보다 효율적으로 활용할 수 있으며, 그 다음 논리적 단계는 마이크로 서비스가 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-301">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![그림 5-14](./media/image5-14.png)

<span data-ttu-id="db317-303">각 인스턴스의 전용 VM을 사용하여 Microsoft Azure에 모놀리식 애플리케이션을 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-303">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="db317-304">[Azure Virtual Machine Scale Sets](/azure/virtual-machine-scale-sets/)를 사용하여 VM 크기를 쉽게 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-304">Using [Azure Virtual Machine Scale Sets](/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="db317-305">[Azure App Services](https://azure.microsoft.com/services/app-service/)는 VM을 관리하지 않고 모놀리식 애플리케이션을 실행하고 인스턴스 크기를 쉽게 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-305">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="db317-306">Azure App Services는 배포를 단순화할 뿐만 아니라 Docker 컨테이너의 단일 인스턴스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-306">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="db317-307">Docker를 사용하면 단일 VM을 Docker 호스트로 배포하고 여러 인스턴스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-307">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="db317-308">그림 5-14처럼 Azure 분산 장치를 사용하여 크기 조정을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-308">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="db317-309">기존의 배포 기술로 다양한 호스트에 대한 배포를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-309">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="db317-310">Docker 호스트는 **docker run** 같은 명령을 사용하여 수동으로 관리하거나 CD(지속적인 업데이트) 파이프라인 같은 자동화를 통해 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-310">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="db317-311">컨테이너로 배포된 모놀리식 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="db317-311">Monolithic application deployed as a container</span></span>

<span data-ttu-id="db317-312">모놀리식 애플리케이션 배포 관리에 컨테이너를 사용하면 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-312">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="db317-313">컨테이너 인스턴스의 크기를 확장하는 것은 추가 VM을 배포하는 것보다 훨씬 쉽고 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="db317-313">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="db317-314">Virtual Machine Scale Sets를 사용하여 VM 크기를 조정하는 경우에도 인스턴스화에는 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="db317-314">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="db317-315">앱 인스턴스로 배포되는 경우 앱 구성은 VM의 일부로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-315">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="db317-316">Docker 이미지로 업데이트를 배포하는 것이 훨씬 더 빠르고 네트워크 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-316">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="db317-317">Docker 이미지는 일반적으로 몇 초 내에 시작되어 롤아웃 속도가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-317">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="db317-318">Docker 인스턴스를 중지하는 방법은 아주 간단합니다. `docker stop` 명령을 실행하면 일반적으로 몇 초 내에 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-318">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="db317-319">컨테이너는 기본적으로 변경할 수 없도록 설계되므로 손상된 VM에 대해 걱정할 필요가 없는 반면, 업데이트 스크립트는 디스크에 남아 있는 일부 특정 구성 또는 파일을 고려하는 것을 잊을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-319">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="db317-320">간단한 웹 애플리케이션의 모놀리식 배포에 Docker 컨테이너를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-320">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="db317-321">이를 통해 지속적인 통합 및 지속적인 배포 파이프라인이 개선되며 프로덕션에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-321">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="db317-322">더 이상 “내 머신에서는 되는데 프로덕션에서는 되지 않는” 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-322">No more “It works on my machine, why does it not work in production?”</span></span>

<span data-ttu-id="db317-323">마이크로 서비스 기반 아키텍처에는 다양한 이점이 있지만 그에 따른 복잡성도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-323">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="db317-324">혜택에 비해 비용이 더 많이 들어서, 단일 컨테이너 또는 소수의 컨테이너에서 실행되는 모놀리식 배포 애플리케이션을 사용하는 것이 더 나은 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-324">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="db317-325">모놀리식 애플리케이션은 잘 분리된 마이크로 서비스로 쉽게 분할되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-325">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="db317-326">마이크로 서비스는 복원력이 우수한 애플리케이션을 제공하기 위해 서로 독립적으로 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-326">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="db317-327">애플리케이션의 독립된 기능 조각을 제공할 수 없는 경우 애플리케이션을 분리하면 복잡성만 더할 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-327">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="db317-328">애플리케이션의 기능을 독립적으로 확장할 필요가 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-328">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="db317-329">많은 애플리케이션에서는 단일 인스턴스를 초과하여 확장해야 하는 경우 전체 인스턴스를 복제하는 비교적 단순한 과정을 통해 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-329">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="db317-330">애플리케이션을 불연속 서비스로 분리하기 위한 추가 작업은 애플리케이션의 전체 인스턴스 확장이 간단하고 비용 효율적인 경우 최소한의 혜택을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-330">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="db317-331">또한 애플리케이션의 개발 초기에는 자연적인 기능 경계를 명확하게 알지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-331">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="db317-332">최소 기능 제품을 개발할 때는 자연적인 분리가 아직 발생하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-332">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="db317-333">이러한 조건 중 일부는 일시적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-333">Some of these conditions might be temporary.</span></span> <span data-ttu-id="db317-334">모놀리식 애플리케이션을 만들어 시작하고 나중에 일부 기능을 분리하여 마이크로 서비스로 개발하고 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-334">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="db317-335">애플리케이션의 문제 영역에는 다른 조건이 필요할 수 있습니다. 즉, 애플리케이션은 여러 마이크로 서비스로 분리되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-335">Other conditions might be essential to the application's problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="db317-336">애플리케이션을 다수의 불연속 프로세스로 분리하면 오버헤드도 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-336">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="db317-337">기능을 다른 프로세스로 분리하는 작업이 더 어려워지며</span><span class="sxs-lookup"><span data-stu-id="db317-337">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="db317-338">통신 프로토콜이 더 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="db317-338">The communication protocols become more complex.</span></span> <span data-ttu-id="db317-339">서비스 간에 메서드 호출 대신 비동기적인 통신을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-339">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="db317-340">마이크로 서비스 아키텍처로 이동하면 이벤트 버스 처리, 메시지 복원력 및 다시 시도, 최종 일관성 등 eShopOnContainers 애플리케이션의 마이크로 서비스 버전에서 구현된 빌드 블록을 많이 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-340">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="db317-341">훨씬 더 간단한 [eShopOnWeb 참조 애플리케이션](https://github.com/dotnet-architecture/eShopOnWeb)은 단일 컨테이너 모놀리식 컨테이너 사용을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-341">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="db317-342">애플리케이션에는 기존 MVC 보기, 웹 API 및 Razor Pages를 포함하는 하나의 웹 애플리케이션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-342">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="db317-343">이 애플리케이션은 `docker-compose build` 및 `docker-compose up` 명령을 사용하여 솔루션 루트에서 시작될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-343">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="db317-344">이 명령은 웹 프로젝트의 루트에서 찾은 `Dockerfile`을 사용하여 웹 인스턴스에 대한 컨테이너를 구성하며, 특정 포트에서 해당 컨테이너를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-344">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="db317-345">GitHub에서 이 애플리케이션에 대한 소스를 다운로드하고 로컬에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-345">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="db317-346">이 모놀리식 애플리케이션도 컨테이너 환경에서의 배포를 통해 이점을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-346">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="db317-347">첫째, 컨테이너화된 배포는 애플리케이션의 모든 인스턴스가 동일한 환경에서 실행되는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-347">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="db317-348">여기에는 초기 테스트 및 개발이 이루어지는 개발자 환경이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-348">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="db317-349">개발 팀은 프로덕션 환경과 일치하는 컨테이너화된 환경에서 애플리케이션을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-349">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="db317-350">둘째, 저렴한 비용으로 컨테이너화된 애플리케이션을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-350">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="db317-351">컨테이너 환경에서는 기존의 VM 환경보다 더 많은 리소스를 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-351">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="db317-352">마지막으로, 애플리케이션을 컨테이너화하면 비즈니스 논리와 스토리지 서버 사이에서 강제 분할이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-352">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="db317-353">애플리케이션이 확장되면 여러 컨테이너는 모두 단일 실제 스토리지 매체를 사용하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-353">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="db317-354">이 스토리지 미디엄은 일반적으로 SQL Server 데이터베이스를 실행하는 고가용성의 서버입니다.</span><span class="sxs-lookup"><span data-stu-id="db317-354">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="db317-355">Docker 지원</span><span class="sxs-lookup"><span data-stu-id="db317-355">Docker support</span></span>

<span data-ttu-id="db317-356">`eShopOnWeb` 프로젝트는 .NET Core에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-356">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="db317-357">따라서 Linux 기반 또는 Windows 기반 컨테이너에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-357">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="db317-358">Docker 배포에서는 SQL Server에 대해서 동일한 호스트 유형을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-358">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="db317-359">사람들은 Linux 기반 컨테이너를 선호하며 여기에서는 더 작은 공간을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-359">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="db317-360">**솔루션 탐색기** 에서 프로젝트를 마우스 오른쪽 단추로 클릭하고 **추가** > **Docker 지원** 을 선택하면 Visual Studio 2017 이상을 사용하여 기존 애플리케이션에 Docker 지원을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-360">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="db317-361">이를 통해 필요한 파일을 추가하고 해당 파일을 사용하도록 프로젝트를 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-361">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="db317-362">현재 `eShopOnWeb` 샘플에는 이러한 파일이 이미 준비되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-362">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="db317-363">솔루션 수준의 `docker-compose.yml` 파일에는 빌드할 이미지 및 시작할 컨테이너에 대한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-363">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="db317-364">이 파일을 통해 `docker-compose` 명령을 사용하여 동시에 여러 애플리케이션을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-364">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="db317-365">이 경우에는 웹 프로젝트를 시작하기만 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-365">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="db317-366">별도 데이터베이스 컨테이너와 같은 종속성을 구성하는 데 이를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-366">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="db317-367">`docker-compose.yml` 파일은 `Web` 프로젝트에서 `Dockerfile`을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-367">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="db317-368">`Dockerfile`은 사용할 기본 컨테이너 및 애플리케이션의 구성 방식을 지정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-368">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="db317-369">`Web`' `Dockerfile`:</span><span class="sxs-lookup"><span data-stu-id="db317-369">The `Web`' `Dockerfile`:</span></span>

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:3.1 AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/aspnet:3.1 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="db317-370">Docker 문제 해결</span><span class="sxs-lookup"><span data-stu-id="db317-370">Troubleshooting Docker problems</span></span>

<span data-ttu-id="db317-371">컨테이너화된 애플리케이션을 한 번 실행하고 나면 사용자가 실행을 중지할 때까지 계속 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-371">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="db317-372">`docker ps` 명령으로 실행 중인 컨테이너를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-372">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="db317-373">`docker stop` 명령을 사용하여 실행 중인 컨테이너를 중지하고 컨테이너 ID를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-373">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="db317-374">실행 중인 Docker 컨테이너는 포트로 바인딩될 수 있지만, 그렇지 않다면 개발 환경에서 사용해 볼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-374">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="db317-375">실행 중인 Docker 컨테이너와 동일한 포트를 사용하여 애플리케이션을 실행 또는 디버깅하려고 하면, 서버가 해당 포트에 바인딩할 수 없다는 내용의 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="db317-375">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="db317-376">다시 한번 컨테이너를 중지하여 문제를 해결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-376">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="db317-377">Visual Studio를 사용하여 애플리케이션에 Docker 지원을 추가하려는 경우 Docker Desktop이 실행되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-377">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="db317-378">마법사를 시작할 때 Docker Desktop이 실행되지 않은 경우 마법사가 올바르게 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="db317-378">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="db317-379">또한 마법사는 올바른 Docker 지원을 추가하기 위해 현재 선택한 컨테이너를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-379">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="db317-380">Windows 컨테이너에 대한 지원을 추가하려는 경우 구성된 Windows 컨테이너에서 Docker Desktop이 실행되는 동안 마법사를 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-380">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="db317-381">Linux 컨테이너에 대한 지원을 추가하려는 경우 구성된 Linux 컨테이너를 통해 Docker가 실행되는 동안 마법사를 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="db317-381">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="db317-382">참조 – 공통 웹 아키텍처</span><span class="sxs-lookup"><span data-stu-id="db317-382">References – Common web architectures</span></span>

- <span data-ttu-id="db317-383">**클린 아키텍처**</span><span class="sxs-lookup"><span data-stu-id="db317-383">**The Clean Architecture**</span></span>  
  <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
- <span data-ttu-id="db317-384">**양파형 아키텍처**</span><span class="sxs-lookup"><span data-stu-id="db317-384">**The Onion Architecture**</span></span>  
  <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
- <span data-ttu-id="db317-385">**리포지토리 패턴**</span><span class="sxs-lookup"><span data-stu-id="db317-385">**The Repository Pattern**</span></span>  
  <https://deviq.com/repository-pattern/>
- <span data-ttu-id="db317-386">**클린 아키텍처 솔루션 템플릿**</span><span class="sxs-lookup"><span data-stu-id="db317-386">**Clean Architecture Solution Template**</span></span>  
  <https://github.com/ardalis/cleanarchitecture>
- <span data-ttu-id="db317-387">**마이크로 서비스 설계 eBook**</span><span class="sxs-lookup"><span data-stu-id="db317-387">**Architecting Microservices e-book**</span></span>  
  <https://aka.ms/MicroservicesEbook>
- <span data-ttu-id="db317-388">**DDD(도메인 기반 디자인)**</span><span class="sxs-lookup"><span data-stu-id="db317-388">**DDD (Domain-Driven Design)**</span></span>  
  <https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/>

>[!div class="step-by-step"]
><span data-ttu-id="db317-389">[이전](architectural-principles.md)
>[다음](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="db317-389">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
