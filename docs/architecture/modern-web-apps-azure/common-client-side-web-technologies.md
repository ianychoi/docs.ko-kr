---
title: 일반 클라이언트측 웹 기술
description: ASP.NET Core 및 Azure를 사용하여 현대식 웹 애플리케이션 설계 | 일반 클라이언트측 웹 기술
author: ardalis
ms.author: wiwagn
no-loc:
- Blazor
ms.date: 12/01/2020
ms.openlocfilehash: 75c696d881ad0586b11cdbd264f3ff90ec3bce8d
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/14/2021
ms.locfileid: "98187966"
---
# <a name="common-client-side-web-technologies"></a><span data-ttu-id="e2a6d-103">일반 클라이언트측 웹 기술</span><span class="sxs-lookup"><span data-stu-id="e2a6d-103">Common client-side web technologies</span></span>

> <span data-ttu-id="e2a6d-104">“웹 사이트는 안팎으로 보기에 좋아야 합니다.”</span><span class="sxs-lookup"><span data-stu-id="e2a6d-104">"Websites should look good from the inside and out."</span></span>
> <span data-ttu-id="e2a6d-105">_- Paul Cookson_</span><span class="sxs-lookup"><span data-stu-id="e2a6d-105">_- Paul Cookson_</span></span>

<span data-ttu-id="e2a6d-106">ASP.NET Core 애플리케이션은 웹 애플리케이션이며 일반적으로 HTML, CSS 및 JavaScript와 같은 클라이언트측 웹 기술에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-106">ASP.NET Core applications are web applications and they typically rely on client-side web technologies like HTML, CSS, and JavaScript.</span></span> <span data-ttu-id="e2a6d-107">레이아웃과 스타일(CSS), 동작(JavaScript를 통해)에서 페이지(HTML)의 콘텐츠를 분리하면 복잡한 웹앱에서 관심사 분리 원칙을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-107">By separating the content of the page (the HTML) from its layout and styling (the CSS), and its behavior (via JavaScript), complex web apps can leverage the Separation of Concerns principle.</span></span> <span data-ttu-id="e2a6d-108">이러한 관심사가 긴밀히 연결되어 있지 않으면 향후에 애플리케이션의 구조, 디자인 또는 동작을 더 쉽게 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-108">Future changes to the structure, design, or behavior of the application can be made more easily when these concerns are not intertwined.</span></span>

<span data-ttu-id="e2a6d-109">HTML 및 CSS는 상대적으로 안정적인 반면, JavaScript는 웹 기반 애플리케이션 빌드를 위해 애플리케이션 프레임워크와 유틸리티 개발자가 함께 일하는 덕분에 빠른 속도로 발전하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-109">While HTML and CSS are relatively stable, JavaScript, by means of the application frameworks and utilities developers work with to build web-based applications, is evolving at breakneck speed.</span></span> <span data-ttu-id="e2a6d-110">이 장에서는 웹 개발자가 JavaScript를 사용하는 몇 가지 방법을 살펴보고 Angular 및 React 클라이언트 쪽 라이브러리의 간단한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-110">This chapter looks at a few ways that JavaScript is used by web developers and provides a high-level overview of the Angular and React client-side libraries.</span></span>

> [!NOTE]
> <span data-ttu-id="e2a6d-111">Blazor는 풍부한 대화형 클라이언트 사용자 인터페이스를 빌드하기 위해 JavaScript 프레임워크에 대한 대안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-111">Blazor provides an alternative to JavaScript frameworks for building rich, interactive client user interfaces.</span></span>

## <a name="html"></a><span data-ttu-id="e2a6d-112">HTML</span><span class="sxs-lookup"><span data-stu-id="e2a6d-112">HTML</span></span>

<span data-ttu-id="e2a6d-113">HTML은 웹 페이지 및 웹 애플리케이션을 만드는 데 사용되는 표준 표시 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-113">HTML is the standard markup language used to create web pages and web applications.</span></span> <span data-ttu-id="e2a6d-114">해당 요소는 서식 있는 텍스트, 이미지, 입력 구성 및 다른 구조를 나타내는 페이지의 구성 요소를 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-114">Its elements form the building blocks of pages, representing formatted text, images, form inputs, and other structures.</span></span> <span data-ttu-id="e2a6d-115">브라우저가 URL에 대한 요청을 만들 때 페이지나 애플리케이션을 페치하는지 상관 없이 가장 먼저 반환되는 것은 HTML 문서입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-115">When a browser makes a request to a URL, whether fetching a page or an application, the first thing that is returned is an HTML document.</span></span> <span data-ttu-id="e2a6d-116">이 HTML 문서는 CSS 양식의 모양과 레이아웃에 대한 추가 정보 또는 JavaScript 양식의 동작을 참조하거나 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-116">This HTML document may reference or include additional information about its look and layout in the form of CSS, or behavior in the form of JavaScript.</span></span>

## <a name="css"></a><span data-ttu-id="e2a6d-117">CSS</span><span class="sxs-lookup"><span data-stu-id="e2a6d-117">CSS</span></span>

<span data-ttu-id="e2a6d-118">CSS(CSS 스타일시트)는 HTML 요소의 모양과 레이아웃을 제어하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-118">CSS (Cascading Style Sheets) is used to control the look and layout of HTML elements.</span></span> <span data-ttu-id="e2a6d-119">CSS 스타일은 HTML 요소에 직접 적용되고, 동일한 페이지에서 별도로 정의되거나 개별 파일로 정의되며, 페이지별로 참조될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-119">CSS styles can be applied directly to an HTML element, defined separately on the same page, or defined in a separate file and referenced by the page.</span></span> <span data-ttu-id="e2a6d-120">스타일은 주어진 HTML 요소를 선택하는 데 사용되는 방식에 따라 계단식으로 배열됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-120">Styles cascade based on how they are used to select a given HTML element.</span></span> <span data-ttu-id="e2a6d-121">예를 들어 스타일은 전체 문서에 적용될 수도 있지만 특정 요소에 적용되는 스타일에 의해 재정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-121">For instance, a style might apply to an entire document, but would be overridden by a style that applied to a particular element.</span></span> <span data-ttu-id="e2a6d-122">마찬가지로, 요소 관련 스타일은 요소에 적용된 CSS 클래스에 적용되는 스타일에 의해 재정의됩니다. 그 다음으로 해당 요소의 특정 인스턴스를 대상으로 하는 스타일에 의해 재정의됩니다(해당 ID를 통해).</span><span class="sxs-lookup"><span data-stu-id="e2a6d-122">Likewise, an element-specific style would be overridden by a style that applied to a CSS class that was applied to the element, which in turn would be overridden by a style targeting a specific instance of that element (via its ID).</span></span> <span data-ttu-id="e2a6d-123">그림 6-1</span><span class="sxs-lookup"><span data-stu-id="e2a6d-123">Figure 6-1</span></span>

![CSS 특이성 규칙](./media/image6-1.png)

<span data-ttu-id="e2a6d-125">**그림 6-1.**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-125">**Figure 6-1.**</span></span> <span data-ttu-id="e2a6d-126">순서 대로 CSS 특이성 규칙</span><span class="sxs-lookup"><span data-stu-id="e2a6d-126">CSS Specificity rules, in order.</span></span>

<span data-ttu-id="e2a6d-127">자체 개별 스타일시트의 스타일을 유지하고 선택 영역 기반 계단식 배열을 사용하여 애플리케이션 내에서 스타일의 일관성 및 재사용을 구현하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-127">It's best to keep styles in their own separate stylesheet files, and to use selection-based cascading to implement consistent and reusable styles within the application.</span></span> <span data-ttu-id="e2a6d-128">HTML 내에 스타일 규칙을 배치하지 말아야 하며, 스타일을 특정 개별 요소(요소의 전체 클래스 또는 특정 CSS 클래스가 적용되어 있는 요소 아님)에 적용하는 것은 규칙이 아닌 예외여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-128">Placing style rules within HTML should be avoided, and applying styles to specific individual elements (rather than whole classes of elements, or elements that have had a particular CSS class applied to them) should be the exception, not the rule.</span></span>

### <a name="css-preprocessors"></a><span data-ttu-id="e2a6d-129">CSS 프로세서</span><span class="sxs-lookup"><span data-stu-id="e2a6d-129">CSS preprocessors</span></span>

<span data-ttu-id="e2a6d-130">CSS 스타일시트에는 조건부 논리, 변수 및 다른 프로그래밍 언어의 기능에 대한 지원이 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-130">CSS stylesheets lack support for conditional logic, variables, and other programming language features.</span></span> <span data-ttu-id="e2a6d-131">따라서 같은 색, 글꼴 또는 기타 설정이 HTML 요소 및 CSS 클래스의 여러 다른 변형에 적용되는 것처럼 큰 스타일 시트에는 종종 상당한 반복이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-131">Thus, large stylesheets often include quite a bit of repetition, as the same color, font, or other setting is applied to many different variations of HTML elements and CSS classes.</span></span> <span data-ttu-id="e2a6d-132">CSS 프로세서는 변수 및 논리에 대한 지원을 추가하여 [DRY 원칙](https://deviq.com/don-t-repeat-yourself/)을 따르는 사용자의 스타일시트에 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-132">CSS preprocessors can help your stylesheets follow the [DRY principle](https://deviq.com/don-t-repeat-yourself/) by adding support for variables and logic.</span></span>

<span data-ttu-id="e2a6d-133">가장 인기 있는 CSS 프로세서는 Sass와 LESS입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-133">The most popular CSS preprocessors are Sass and LESS.</span></span> <span data-ttu-id="e2a6d-134">둘 다 CSS를 확장하며 이전 버전과 호환됩니다. 즉, 일반 CSS 파일은 유효한 Sass 또는 LESS 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-134">Both extend CSS and are backward compatible with it, meaning that a plain CSS file is a valid Sass or LESS file.</span></span> <span data-ttu-id="e2a6d-135">Sass는 Ruby를 기반으로 하며, LESS는 JavaScript를 기반으로 합니다. 일반적으로 둘 다 로컬 개발 프로세스의 일환으로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-135">Sass is Ruby-based and LESS is JavaScript based, and both typically run as part of your local development process.</span></span> <span data-ttu-id="e2a6d-136">둘 다 Gulp 또는 Grunt 작업을 사용하여 실행할 수 있도록 Visual Studio의 기본 제공 지원뿐만 아니라 사용 가능한 명령줄 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-136">Both have command-line tools available, as well as built-in support in Visual Studio for running them using Gulp or Grunt tasks.</span></span>

## <a name="javascript"></a><span data-ttu-id="e2a6d-137">JavaScript</span><span class="sxs-lookup"><span data-stu-id="e2a6d-137">JavaScript</span></span>

<span data-ttu-id="e2a6d-138">JavaScript는 ECMAScript 언어 사양에 표준화된 동적이고 해석된 프로그래밍 언어이며,</span><span class="sxs-lookup"><span data-stu-id="e2a6d-138">JavaScript is a dynamic, interpreted programming language that has been standardized in the ECMAScript language specification.</span></span> <span data-ttu-id="e2a6d-139">웹의 프로그래밍 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-139">It is the programming language of the web.</span></span> <span data-ttu-id="e2a6d-140">CSS와 마찬가지로 JavaScript는 페이지 내 또는 개별 파일의 스크립트 차단과 같이 HTML 요소 내 특성으로 정의될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-140">Like CSS, JavaScript can be defined as attributes within HTML elements, as blocks of script within a page, or in separate files.</span></span> <span data-ttu-id="e2a6d-141">CSS와 마찬가지로, JavaScript를 개별 웹 페이지나 애플리케이션 뷰에 있는 HTML로부터 최대한 분리하여 별도 파일에 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-141">Just like CSS, it's recommended to organize JavaScript into separate files, keeping it separated as much as possible from the HTML found on individual web pages or application views.</span></span>

<span data-ttu-id="e2a6d-142">웹 애플리케이션에서 JavaScript를 작업할 때 일반적으로 수행해야 하는 다음과 같은 몇 가지 작업이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-142">When working with JavaScript in your web application, there are a few tasks that you'll commonly need to perform:</span></span>

- <span data-ttu-id="e2a6d-143">HTML 요소를 선택하고 해당 값을 검색 및/또는 업데이트.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-143">Selecting an HTML element and retrieving and/or updating its value.</span></span>

- <span data-ttu-id="e2a6d-144">데이터에 대한 Web API 쿼리.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-144">Querying a Web API for data.</span></span>

- <span data-ttu-id="e2a6d-145">Web API에 대한 명령 전송(및 해당 결과가 포함된 콜백에 응답).</span><span class="sxs-lookup"><span data-stu-id="e2a6d-145">Sending a command to a Web API (and responding to a callback with its result).</span></span>

- <span data-ttu-id="e2a6d-146">유효성 검사 수행.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-146">Performing validation.</span></span>

<span data-ttu-id="e2a6d-147">이러한 작업은 모두 JavaScript만 사용하여 수행할 수도 있지만, 이러한 작업을 쉽게 수행할 수 있도록 해주는 다양한 라이브러리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-147">You can perform all of these tasks with JavaScript alone, but many libraries exist to make these tasks easier.</span></span> <span data-ttu-id="e2a6d-148">이러한 라이브러리 중 첫 번째이자 가장 성공적인 것은 jQuery로, 웹 페이지에서 이러한 작업을 간소화하는 데 꾸준히 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-148">One of the first and most successful of these libraries are jQuery, which continues to be a popular choice for simplifying these tasks on web pages.</span></span> <span data-ttu-id="e2a6d-149">SPA(단일 페이지 애플리케이션)의 경우 jQuery는 Angular 및 React가 제공하는 원하는 기능을 많이 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-149">For Single Page Applications (SPAs), jQuery doesn't provide many of the desired features that Angular and React offer.</span></span>

### <a name="legacy-web-apps-with-jquery"></a><span data-ttu-id="e2a6d-150">jQuery를 사용한 레거시 웹앱</span><span class="sxs-lookup"><span data-stu-id="e2a6d-150">Legacy web apps with jQuery</span></span>

<span data-ttu-id="e2a6d-151">JavaScript 프레임워크 표준에서 유래되었음에도 jQuery는 여전히 HTML/CSS로 작업하고 웹 API에 대한 AJAX 호출을 수행하는 애플리케이션을 빌드하기 위해 일반적으로 사용되는 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-151">Although ancient by JavaScript framework standards, jQuery continues to be a commonly used library for working with HTML/CSS and building applications that make AJAX calls to web APIs.</span></span> <span data-ttu-id="e2a6d-152">그러나 jQuery는 브라우저 DOM(문서 개체 모델)의 수준에서 작동하며, 기본적으로 선언적이 아닌 명령적 모델을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-152">However, jQuery operates at the level of the browser document object model (DOM), and by default offers only an imperative, rather than declarative, model.</span></span>

<span data-ttu-id="e2a6d-153">예를 들어 텍스트 상자의 값이 10을 초과하는 경우 페이지에 요소가 표시되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-153">For example, imagine that if a textbox's value exceeds 10, an element on the page should be made visible.</span></span> <span data-ttu-id="e2a6d-154">jQuery에서는 일반적으로 텍스트 상자의 값을 검사하고 해당 값에 따라 대상 요소의 표시 여부를 설정하는 코드를 사용하여 이벤트 처리기를 작성하면 이 기능을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-154">In jQuery, this functionality would typically be implemented by writing an event handler with code that would inspect the textbox's value and set the visibility of the target element based on that value.</span></span> <span data-ttu-id="e2a6d-155">이 프로세스는 명령형 코드 기반 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-155">This process is an imperative, code-based approach.</span></span> <span data-ttu-id="e2a6d-156">대신 다른 프레임워크가 데이터 바인딩을 사용하여 텍스트 상자의 값에 따라 요소의 표시 여부를 선언적으로 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-156">Another framework might instead use databinding to bind the visibility of the element to the value of the textbox declaratively.</span></span> <span data-ttu-id="e2a6d-157">이 방법에서는 코드를 작성할 필요는 없으나, 대신 데이터 바인딩 특성이 포함된 요소를 데코레이팅해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-157">This approach would not require writing any code, but instead only requires decorating the elements involved with data binding attributes.</span></span> <span data-ttu-id="e2a6d-158">클라이언트측 동작이 더 복잡해짐에 따라 데이터 바인딩 방식은 코드 및 조건부 복잡성이 덜한 더 간단한 솔루션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-158">As client-side behaviors grow more complex, data binding approaches frequently result in simpler solutions with less code and conditional complexity.</span></span>

### <a name="jquery-vs-a-spa-framework"></a><span data-ttu-id="e2a6d-159">jQuery 대 SPA 프레임워크</span><span class="sxs-lookup"><span data-stu-id="e2a6d-159">jQuery vs a SPA Framework</span></span>

| <span data-ttu-id="e2a6d-160">**요소**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-160">**Factor**</span></span> | <span data-ttu-id="e2a6d-161">**jQuery**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-161">**jQuery**</span></span> | <span data-ttu-id="e2a6d-162">**Angular**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-162">**Angular**</span></span>|
|--------------------------|------------|-------------|
| <span data-ttu-id="e2a6d-163">DOM 추상화</span><span class="sxs-lookup"><span data-stu-id="e2a6d-163">Abstracts the DOM</span></span> | <span data-ttu-id="e2a6d-164">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-164">**Yes**</span></span> | <span data-ttu-id="e2a6d-165">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-165">**Yes**</span></span> |
| <span data-ttu-id="e2a6d-166">AJAX 지원</span><span class="sxs-lookup"><span data-stu-id="e2a6d-166">AJAX Support</span></span> | <span data-ttu-id="e2a6d-167">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-167">**Yes**</span></span> | <span data-ttu-id="e2a6d-168">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-168">**Yes**</span></span> |
| <span data-ttu-id="e2a6d-169">선언적 데이터 바인딩</span><span class="sxs-lookup"><span data-stu-id="e2a6d-169">Declarative Data Binding</span></span> | <span data-ttu-id="e2a6d-170">**No**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-170">**No**</span></span> | <span data-ttu-id="e2a6d-171">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-171">**Yes**</span></span> |
| <span data-ttu-id="e2a6d-172">MVC 스타일 라우팅</span><span class="sxs-lookup"><span data-stu-id="e2a6d-172">MVC-style Routing</span></span> | <span data-ttu-id="e2a6d-173">**No**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-173">**No**</span></span> | <span data-ttu-id="e2a6d-174">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-174">**Yes**</span></span> |
| <span data-ttu-id="e2a6d-175">템플릿</span><span class="sxs-lookup"><span data-stu-id="e2a6d-175">Templating</span></span> | <span data-ttu-id="e2a6d-176">**No**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-176">**No**</span></span> | <span data-ttu-id="e2a6d-177">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-177">**Yes**</span></span> |
| <span data-ttu-id="e2a6d-178">딥 링크 라우팅</span><span class="sxs-lookup"><span data-stu-id="e2a6d-178">Deep-Link Routing</span></span> | <span data-ttu-id="e2a6d-179">**No**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-179">**No**</span></span> | <span data-ttu-id="e2a6d-180">**예**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-180">**Yes**</span></span> |

<span data-ttu-id="e2a6d-181">대부분의 jQuery 기능 부족은 본질적으로 다른 라이브러리를 추가하여 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-181">Most of the features jQuery lacks intrinsically can be added with the addition of other libraries.</span></span> <span data-ttu-id="e2a6d-182">그러나 Angular와 같은 SPA 프레임워크는 이러한 기능을 더 통합된 방식으로 제공합니다. 처음부터 이러한 사항 모두를 고려하여 설계되었기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-182">However, a SPA framework like Angular provides these features in a more integrated fashion, since it's been designed with all of them in mind from the start.</span></span> <span data-ttu-id="e2a6d-183">또한 jQuery는 명령적 라이브러리입니다. 즉, jQuery를 사용한 작업을 수행하려면 jQuery 함수를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-183">Also, jQuery is an imperative library, meaning that you need to call jQuery functions in order to do anything with jQuery.</span></span> <span data-ttu-id="e2a6d-184">SPA 프레임워크가 제공하는 많은 작업과 기능은 실제 코드를 작성할 필요 없이 선언적으로 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-184">Much of the work and functionality that SPA frameworks provide can be done declaratively, requiring no actual code to be written.</span></span>

<span data-ttu-id="e2a6d-185">데이터 바인딩은 이 기능의 좋은 예입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-185">Data binding is a great example of this functionality.</span></span> <span data-ttu-id="e2a6d-186">jQuery에서는 일반적으로 단 한 줄의 코드로 DOM 요소의 값을 가져오거나 요소의 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-186">In jQuery, it usually only takes one line of code to get the value of a DOM element or to set an element's value.</span></span> <span data-ttu-id="e2a6d-187">단, 이 코드는 요소의 값을 변경해야 때마다 작성해야 하며, 경우에 따라 이는 페이지의 여러 기능에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-187">However, you have to write this code anytime you need to change the value of the element, and sometimes this will occur in multiple functions on a page.</span></span> <span data-ttu-id="e2a6d-188">또 다른 일반적인 예제는 요소 표시 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-188">Another common example is element visibility.</span></span> <span data-ttu-id="e2a6d-189">jQuery에서는 여러 다른 위치에서 특정 요소를 표시할지 여부를 제어하는 코드를 작성해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-189">In jQuery, there might be many different places where you'd write code to control whether certain elements were visible.</span></span> <span data-ttu-id="e2a6d-190">이러한 각각의 경우에서 데이터 바인딩을 사용할 때 코드를 작성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-190">In each of these cases, when using data binding, no code would need to be written.</span></span> <span data-ttu-id="e2a6d-191">문제의 값 또는 요소의 표시 여부를 페이지의 ‘viewmodel’에 바인딩하기만 하면 해당 viewmodel에 대한 변경 사항이 자동으로 바인딩된 요소에 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-191">You'd simply bind the value or visibility of the elements in question to a *viewmodel* on the page, and changes to that viewmodel would automatically be reflected in the bound elements.</span></span>

### <a name="angular-spas"></a><span data-ttu-id="e2a6d-192">Angular SPA</span><span class="sxs-lookup"><span data-stu-id="e2a6d-192">Angular SPAs</span></span>

<span data-ttu-id="e2a6d-193">Angular는 세계에서 가장 인기 있는 JavaScript 프레임워크 중 하나로 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-193">Angular remains one of the world's most popular JavaScript frameworks.</span></span> <span data-ttu-id="e2a6d-194">Angular 2부터 팀이 처음부터 프레임워크를 다시 빌드하고([TypeScript](https://www.typescriptlang.org/) 사용) 원래 AngularJS 이름에서 Angular로 브랜드를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-194">Since Angular 2, the team rebuilt the framework from the ground up (using [TypeScript](https://www.typescriptlang.org/)) and rebranded from the original AngularJS name to angular.</span></span> <span data-ttu-id="e2a6d-195">이제 몇 년이 지나 다시 디자인된 Angular는 여전히 단일 페이지 애플리케이션을 빌드하기 위한 강력한 프레임워크입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-195">Now several years old, the redesigned Angular continues to be a robust framework for building Single Page Applications.</span></span>

<span data-ttu-id="e2a6d-196">Angular 애플리케이션은 구성 요소에서 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-196">Angular applications are built from components.</span></span> <span data-ttu-id="e2a6d-197">구성 요소는 특정 개체와 HTML 템플릿을 결합하고 페이지의 일부를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-197">Components combine HTML templates with special objects and control a portion of the page.</span></span> <span data-ttu-id="e2a6d-198">Angular 문서의 간단한 구성 요소는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-198">A simple component from Angular's docs is shown here:</span></span>

```js
import { Component } from '@angular/core';

@Component({
    selector: 'my-app',
    template: `<h1>Hello {{name}}</h1>`
})

export class AppComponent { name = 'Angular'; }
```

<span data-ttu-id="e2a6d-199">구성 요소는 @Component 데코레이터 함수를 사용하여 정의되며 구성 요소에 대한 메타데이터에 위치합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-199">Components are defined using the @Component decorator function, which takes in metadata about the component.</span></span> <span data-ttu-id="e2a6d-200">선택기 속성은 이 구성 요소가 표시되는 페이지에서 요소의 ID를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-200">The selector property identifies the ID of the element on the page where this component will be displayed.</span></span> <span data-ttu-id="e2a6d-201">템플릿 속성은 마지막 줄에 정의되는 구성 요소의 이름 속성에 해당하는 자리 표시자를 포함하는 간단한 HTML 템플릿입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-201">The template property is a simple HTML template that includes a placeholder that corresponds to the component's name property, defined on the last line.</span></span>

<span data-ttu-id="e2a6d-202">DOM 요소 대신 구성 요소 및 템플릿을 사용하면 Angular 앱은 추상화의 상위 수준에서 작업할 수 있으며 JavaScript만(“바닐라 JS”라고 함) 또는 jQuery를 사용하여 작성된 앱보다 전체 코드가 더 적습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-202">By working with components and templates, instead of DOM elements, Angular apps can operate at a higher level of abstraction and with less overall code than apps written using just JavaScript (also called "vanilla JS") or with jQuery.</span></span> <span data-ttu-id="e2a6d-203">또한 Angular는 클라이언트 쪽 스크립트 파일을 구성하는 방식에 몇 가지 순서를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-203">Angular also imposes some order on how you organize your client-side script files.</span></span> <span data-ttu-id="e2a6d-204">규칙에 따라 Angular 앱은 앱 폴더에 모듈 및 구성 요소 스크립트 파일이 포함된 일반적인 폴더 구조를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-204">By convention, Angular apps use a common folder structure, with module and component script files located in an app folder.</span></span> <span data-ttu-id="e2a6d-205">앱의 빌드, 배포 및 테스트와 관련된 Angular 스크립트는 일반적으로 상위 폴더에 위치합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-205">Angular scripts concerned with building, deploying, and testing the app are typically located in a higher-level folder.</span></span>

<span data-ttu-id="e2a6d-206">CLI를 사용하여 Angular 앱을 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-206">You can develop Angular apps by using a CLI.</span></span> <span data-ttu-id="e2a6d-207">로컬에서 Angular 개발을 시작하면(이미 git 및 npm이 설치되어 있다고 가정) 바로 GitHub에서 리포지토리 복제가 구성되고 `npm install` 및 `npm start`가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-207">Getting started with Angular development locally (assuming you already have git and npm installed) consists of simply cloning a repo from GitHub and running `npm install` and `npm start`.</span></span> <span data-ttu-id="e2a6d-208">이 외에 Angular는 프로젝트를 만들고, 파일을 추가하고, 테스트, 묶음 및 배포 작업을 지원할 수 있는 자체 CLI를 함께 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-208">Beyond this, Angular ships its own CLI, which can create projects, add files, and assist with testing, bundling, and deployment tasks.</span></span> <span data-ttu-id="e2a6d-209">이러한 CLI 친화성 덕분에 Angular는 CLI 지원 역시 뛰어난 ASP.NET Core와 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-209">This CLI friendliness makes Angular especially compatible with ASP.NET Core, which also features great CLI support.</span></span>

<span data-ttu-id="e2a6d-210">Microsoft는 Angular SPA 구현을 포함하는 eShopOnContainers라는 참조 애플리케이션을 개발했습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-210">Microsoft has developed a reference application, eShopOnContainers, which includes an Angular SPA implementation.</span></span> <span data-ttu-id="e2a6d-211">이 앱에는 온라인 상점의 장바구니를 관리하고, 해당 카탈로그의 항목을 로드 및 표시하며, 주문 생성을 처리하는 Angular 모듈이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-211">This app includes Angular modules to manage the online store's shopping basket, load and display items from its catalog, and handling order creation.</span></span> <span data-ttu-id="e2a6d-212">[GitHub](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebSPA)에서 샘플 애플리케이션을 보고 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-212">You can view and download the sample application from [GitHub](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebSPA).</span></span>

### <a name="react"></a><span data-ttu-id="e2a6d-213">React</span><span class="sxs-lookup"><span data-stu-id="e2a6d-213">React</span></span>

<span data-ttu-id="e2a6d-214">전체 모델-뷰-컨트롤러 패턴 구현을 제공하는 Angular와 달리, React는 오직 뷰와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-214">Unlike Angular, which offers a full Model-View-Controller pattern implementation, React is only concerned with views.</span></span> <span data-ttu-id="e2a6d-215">프레임워크가 아닌 라이브러리일 뿐이므로 SPA를 빌드하려면 추가 라이브러리를 활용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-215">It's not a framework, just a library, so to build a SPA you'll need to leverage additional libraries.</span></span> <span data-ttu-id="e2a6d-216">React와 함께 사용하여 풍부한 단일 페이지 애플리케이션을 생성하도록 설계된 많은 라이브러리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-216">There are a number of libraries that are designed to be used with React to produce rich single page applications.</span></span>

<span data-ttu-id="e2a6d-217">React의 가장 중요한 기능 중 하나는 가상 DOM을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-217">One of React's most important features is its use of a virtual DOM.</span></span> <span data-ttu-id="e2a6d-218">가상 DOM은 React에 성능(가상 DOM은 업데이트가 필요한 실제 DOM의 부분을 최적화할 수 있음) 및 테스트 용이성(React와 해당 가상 DOM과의 상호 작용을 테스트하기 위해 브라우저가 필요하지 않음)을 포함한 여러 장점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-218">The virtual DOM provides React with several advantages, including performance (the virtual DOM can optimize which parts of the actual DOM need to be updated) and testability (no need to have a browser to test React and its interactions with its virtual DOM).</span></span>

<span data-ttu-id="e2a6d-219">또한 React는 HTML과 작동하는 방식 작동 방식이 특이합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-219">React is also unusual in how it works with HTML.</span></span> <span data-ttu-id="e2a6d-220">코드 및 표시 사이를 엄격히 구분하지 않으면서(아마 HTML 특성에 표시되는 JavaScript에 대한 참조 사용) React는 HTML을 직접 해당 JavaScript 코드 내에 JSX로 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-220">Rather than having a strict separation between code and markup (with references to JavaScript appearing in HTML attributes perhaps), React adds HTML directly within its JavaScript code as JSX.</span></span> <span data-ttu-id="e2a6d-221">JSX는 순수 JavaScript로 컴파일 다운할 수 있는 HTML 스타일의 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-221">JSX is HTML-like syntax that can compile down to pure JavaScript.</span></span> <span data-ttu-id="e2a6d-222">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="e2a6d-222">For example:</span></span>

```js
<ul>
{ authors.map(author =>
    <li key={author.id}>{author.name}</li>
)}
</ul>
```

<span data-ttu-id="e2a6d-223">JavaScript에 대해 이미 알고 있다면 React는 이해하기 쉬울 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-223">If you already know JavaScript, learning React should be easy.</span></span> <span data-ttu-id="e2a6d-224">Angular 또는 다른 인기 있는 라이브러리를 사용하는 것만큼 곡선이나 특수 구문이 거의 포함되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-224">There isn't nearly as much learning curve or special syntax involved as with Angular or other popular libraries.</span></span>

<span data-ttu-id="e2a6d-225">React는 전체 프레임워크가 아니므로 라우팅, 웹 API 호출 및 종속성 관리와 같은 작업을 처리하기 위해 일반적으로 다른 라이브러리가 필요할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-225">Because React isn't a full framework, you'll typically want other libraries to handle things like routing, web API calls, and dependency management.</span></span> <span data-ttu-id="e2a6d-226">장점은 이러한 각 작업에 최선의 라이브러리를 사용자가 고를 수 있다는 점이며, 단점은 이러한 모든 결정을 사용자가 내려야 하며, 작업을 완료했을 때 함께 제대로 작동하는지 선택한 모든 라이브러리의 유효성을 검사해야 한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-226">The nice thing is, you can pick the best library for each of these, but the disadvantage is that you need to make all of these decisions and verify all of your chosen libraries work well together when you're done.</span></span> <span data-ttu-id="e2a6d-227">시작점을 찾고 있다면, 일련의 호환 가능한 라이브러리를 React와 함께 패키지로 묶은 React Slingshot 같은 시작키트를 사용해 보세요.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-227">If you want a good starting point, you can use a starter kit like React Slingshot, which prepackages a set of compatible libraries together with React.</span></span>

### <a name="vue"></a><span data-ttu-id="e2a6d-228">Vue</span><span class="sxs-lookup"><span data-stu-id="e2a6d-228">Vue</span></span>

<span data-ttu-id="e2a6d-229">시작 가이드를 인용하자면 "Vue는 사용자 인터페이스를 빌드하기 위한 프로그레시브 프레임워크입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-229">From its getting started guide, "Vue is a progressive framework for building user interfaces.</span></span> <span data-ttu-id="e2a6d-230">다른 모놀리식 프레임워크와 달리 Vue는 처음부터 증분식으로 채택할 수 있도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-230">Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable.</span></span> <span data-ttu-id="e2a6d-231">핵심 라이브러리는 뷰 계층에만 초점을 맞추고, 용이하게 선택하여 다른 라이브러리 또는 기존 프로젝트와 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-231">The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects.</span></span> <span data-ttu-id="e2a6d-232">반면 Vue는 최신 도구 및 지원 라이브러리와 함께 사용될 때 정교한 단일 페이지 애플리케이션을 완벽하게 제공할 수 있습니다."</span><span class="sxs-lookup"><span data-stu-id="e2a6d-232">On the other hand, Vue is perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries."</span></span>

<span data-ttu-id="e2a6d-233">Vue를 시작하려면 HTML 파일 내에 스크립트를 포함하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-233">Getting started with Vue simply requires including its script within an HTML file:</span></span>

```html
<!-- development version, includes helpful console warnings -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
```

<span data-ttu-id="e2a6d-234">프레임워크가 추가되면 Vue의 간단한 템플릿 구문을 사용하여 데이터를 DOM에 선언적으로 렌더링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-234">With the framework added, you're then able to declaratively render data to the DOM using Vue's straightforward templating syntax:</span></span>

```html
<div id="app">
  {{ message }}
</div>
```

<span data-ttu-id="e2a6d-235">그리고 다음 스크립트를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-235">and then adding the following script:</span></span>

```js
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```

<span data-ttu-id="e2a6d-236">이렇게 하면 페이지에서 "Hello Vue!"를 렌더링하는 데</span><span class="sxs-lookup"><span data-stu-id="e2a6d-236">This is enough to render "Hello Vue!"</span></span> <span data-ttu-id="e2a6d-237">충분합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-237">on the page.</span></span> <span data-ttu-id="e2a6d-238">그러나 Vue는 단순히 메시지를 div로 한 번 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-238">Note, however, that Vue isn't simply rendering the message to the div once.</span></span> <span data-ttu-id="e2a6d-239">`message` 값이 변경되면 `<div>`의 값이 즉시 업데이트되어 이를 반영하도록 데이터 바인딩 및 동적 업데이트를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-239">It supports databinding and dynamic updates such that if the value of `message` changes, the value in the `<div>` is immediately updated to reflect it.</span></span>

<span data-ttu-id="e2a6d-240">물론, 이는 Vue에서 사용할 수 있는 기능의 일부에 불과합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-240">Of course, this only scratches the surface of what Vue is capable of.</span></span> <span data-ttu-id="e2a6d-241">지난 몇 년간 많은 인기를 얻으며 대규모 커뮤니티가 형성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-241">It's gained a great deal of popularity in the last several years and has a large community.</span></span> <span data-ttu-id="e2a6d-242">Vue와 함께 사용하여 그 기능을 확장할 수 있는 [지원 구성 요소 및 라이브러리](https://github.com/vuejs/awesome-vue#redux)는 방대하며 계속 확장되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-242">There's a [huge and growing list of supporting components and libraries](https://github.com/vuejs/awesome-vue#redux) that work with Vue to extend it as well.</span></span> <span data-ttu-id="e2a6d-243">웹 애플리케이션에 클라이언트 쪽 동작을 추가하거나 전체 SPA를 빌드하려는 경우 Vue는 고려할 가치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-243">If you're looking to add client-side behavior to your web application or considering building a full SPA, Vue is worth investigating.</span></span>

### <a name="no-locblazor-webassembly"></a><span data-ttu-id="e2a6d-244">Blazor WebAssembly</span><span class="sxs-lookup"><span data-stu-id="e2a6d-244">Blazor WebAssembly</span></span>

<span data-ttu-id="e2a6d-245">다른 JavaScript 프레임워크와 달리 `Blazor WebAssembly`는 .NET을 사용하여 대화형 클라이언트 쪽 웹앱을 빌드하기 위한 SPA(단일 페이지 앱) 프레임워크입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-245">Unlike other JavaScript frameworks, `Blazor WebAssembly` is a single-page app (SPA) framework for building interactive client-side web apps with .NET.</span></span> <span data-ttu-id="e2a6d-246">Blazor WebAssembly는 플러그 인을 사용하거나 다른 언어로 코드를 다시 컴파일하지 않고 개방형 웹 표준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-246">Blazor WebAssembly uses open web standards without plugins or recompiling code into other languages.</span></span> <span data-ttu-id="e2a6d-247">Blazor WebAssembly는 모바일 브라우저를 비롯한 모든 최신 웹 브라우저에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-247">Blazor WebAssembly works in all modern web browsers, including mobile browsers.</span></span>

<span data-ttu-id="e2a6d-248">웹 브라우저 내에서 .NET 코드를 실행하는 것은 WebAssembly(약식 `wasm`)를 통해 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-248">Running .NET code inside web browsers is made possible by WebAssembly (abbreviated `wasm`).</span></span> <span data-ttu-id="e2a6d-249">WebAssembly는 빠른 다운로드와 최대 실행 속도를 위해 최적화된 압축 바이트 코드 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-249">WebAssembly is a compact bytecode format optimized for fast download and maximum execution speed.</span></span> <span data-ttu-id="e2a6d-250">WebAssembly는 공개 웹 표준이며 플러그 인 없이 웹 브라우저에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-250">WebAssembly is an open web standard and is supported in web browsers without plugins.</span></span>

<span data-ttu-id="e2a6d-251">WebAssembly 코드는 JavaScript 상호 운용성(종종 JavaScript interop 또는 JS interop로 단축됨)이라고 하는 JavaScript를 통해 브라우저의 전체 기능에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-251">WebAssembly code can access the full functionality of the browser via JavaScript, called JavaScript interoperability, often shortened to JavaScript interop or JS interop.</span></span> <span data-ttu-id="e2a6d-252">브라우저에서 WebAssembly를 통해 실행된 .NET 코드는 브라우저의 JavaScript 샌드박스에서 클라이언트 컴퓨터의 악의적 활동에 대해 제공하는 보호를 사용하여 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-252">.NET code executed via WebAssembly in the browser runs in the browser's JavaScript sandbox with the protections that the sandbox provides against malicious actions on the client machine.</span></span>

<span data-ttu-id="e2a6d-253">자세한 내용은 [ASP.NET Core 소개Blazor](/aspnet/core/blazor/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-253">For more information, see [Introduction to ASP.NET Core Blazor](/aspnet/core/blazor/).</span></span>

### <a name="choosing-a-spa-framework"></a><span data-ttu-id="e2a6d-254">SPA 프레임워크 선택</span><span class="sxs-lookup"><span data-stu-id="e2a6d-254">Choosing a SPA Framework</span></span>

<span data-ttu-id="e2a6d-255">SPA를 지원하기에 어떤 옵션이 최선인지를 고려할 때는 다음 고려 사항을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-255">When considering which option will work best to support your SPA, keep in mind the following considerations:</span></span>

- <span data-ttu-id="e2a6d-256">팀이 프레임워크 및 해당 종속성에 대해 잘 알고 있는가(일부 경우에 TypeScript 포함)?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-256">Is your team familiar with the framework and its dependencies (including TypeScript in some cases)?</span></span>

- <span data-ttu-id="e2a6d-257">프레임워크는 얼마나 독단적인가? 그리고 그러한 작업을 수행하는 기본 방식에 동의하는가?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-257">How opinionated is the framework, and do you agree with its default way of doing things?</span></span>

- <span data-ttu-id="e2a6d-258">프레임워크(또는 도우미 라이브러리)에 앱에 필요한 모든 기능이 포함되어 있는가?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-258">Does it (or a companion library) include all of the features your app requires?</span></span>

- <span data-ttu-id="e2a6d-259">문서화가 제대로 되어 있는가?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-259">Is it well documented?</span></span>

- <span data-ttu-id="e2a6d-260">해당 커뮤니티는 얼마나 활발한가?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-260">How active is its community?</span></span> <span data-ttu-id="e2a6d-261">해당 프레임워크를 사용하여 새 프로젝트가 빌드되고 있는가?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-261">Are new projects being built with it?</span></span>

- <span data-ttu-id="e2a6d-262">해당 코어 팀은 얼마나 활발한가?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-262">How active is its core team?</span></span> <span data-ttu-id="e2a6d-263">문제가 해결되고 있는가? 또 새 버전이 정기적으로 제공되는가?</span><span class="sxs-lookup"><span data-stu-id="e2a6d-263">Are issues being resolved and new versions shipped regularly?</span></span>

<span data-ttu-id="e2a6d-264">프레임워크는 지속해서 매우 빠르게 발전하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-264">Frameworks continue to evolve with breakneck speed.</span></span> <span data-ttu-id="e2a6d-265">나중에 종속된 것을 후회하게 될 프레임워크의 선택 위험을 완화하는 데 도움을 받으려면 위에 나열된 고려 사항을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-265">Use the considerations listed above to help mitigate the risk of choosing a framework you'll later regret being dependent upon.</span></span> <span data-ttu-id="e2a6d-266">특히 안전 주의자인 경우 상용 지원을 제공하고 또는 대기업에서 개발되는 프레임워크를 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="e2a6d-266">If you're particularly risk-averse, consider a framework that offers commercial support and/or is being developed by a large enterprise.</span></span>

> ### <a name="references--client-web-technologies"></a><span data-ttu-id="e2a6d-267">참조 - 클라이언트 웹 기술</span><span class="sxs-lookup"><span data-stu-id="e2a6d-267">References – Client Web Technologies</span></span>
>
> - <span data-ttu-id="e2a6d-268">**HTML 및 CSS**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-268">**HTML and CSS**</span></span>  
> <https://www.w3.org/standards/webdesign/htmlcss>
> - <span data-ttu-id="e2a6d-269">**Sass 대 LESS**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-269">**Sass vs. LESS**</span></span>  
> <https://www.keycdn.com/blog/sass-vs-less/>
> - <span data-ttu-id="e2a6d-270">**LESS, Sass 및 Font Awesome을 사용하여 ASP.NET Core 앱 스타일 지정**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-270">**Styling ASP.NET Core Apps with LESS, Sass, and Font Awesome**</span></span>  
> <https://docs.microsoft.com/aspnet/core/client-side/less-sass-fa>
> - <span data-ttu-id="e2a6d-271">**ASP.NET Core의 클라이언트측 개발**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-271">**Client-Side Development in ASP.NET Core**</span></span>  
> <https://docs.microsoft.com/aspnet/core/client-side/>
> - <span data-ttu-id="e2a6d-272">**jQuery**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-272">**jQuery**</span></span>  
> <https://jquery.com/>
> - <span data-ttu-id="e2a6d-273">**jQuery 대 AngularJS**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-273">**jQuery vs AngularJS**</span></span>  
> <https://www.airpair.com/angularjs/posts/jquery-angularjs-comparison-migration-walkthrough>
> - <span data-ttu-id="e2a6d-274">**Angular**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-274">**Angular**</span></span>  
> <https://angular.io/>
> - <span data-ttu-id="e2a6d-275">**React**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-275">**React**</span></span>  
> <https://reactjs.org/>
> - <span data-ttu-id="e2a6d-276">**Vue**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-276">**Vue**</span></span>  
> <https://vuejs.org/>
> - <span data-ttu-id="e2a6d-277">**Angular vs React vs Vue: 2020년에 선택할 프레임워크**
> <https://www.codeinwp.com/blog/angular-vs-vue-vs-react/></span><span class="sxs-lookup"><span data-stu-id="e2a6d-277">**Angular vs React vs Vue: Which Framework to Choose in 2020**
<https://www.codeinwp.com/blog/angular-vs-vue-vs-react/></span></span>
> - <span data-ttu-id="e2a6d-278">**2020년 프런트 엔드 개발용 상위 JavaScript 프레임워크**</span><span class="sxs-lookup"><span data-stu-id="e2a6d-278">**The Top JavaScript Frameworks for Front-End Development in 2020**</span></span>  
> <https://www.freecodecamp.org/news/complete-guide-for-front-end-developers-javascript-frameworks-2019/>

>[!div class="step-by-step"]
><span data-ttu-id="e2a6d-279">[이전](common-web-application-architectures.md)
>[다음](develop-asp-net-core-mvc-apps.md)</span><span class="sxs-lookup"><span data-stu-id="e2a6d-279">[Previous](common-web-application-architectures.md)
[Next](develop-asp-net-core-mvc-apps.md)</span></span>
