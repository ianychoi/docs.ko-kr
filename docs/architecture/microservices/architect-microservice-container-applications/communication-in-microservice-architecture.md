---
title: 마이크로 서비스 아키텍처의 통신
description: 동기 및 비동기 방식의 의미를 이해하고 마이크로 서비스 간의 다양한 통신 방법을 탐색합니다.
ms.date: 01/30/2020
ms.openlocfilehash: a918ea7573d7402a82d2df2c63301e4838fa66dc
ms.sourcegitcommit: 88fbb019b84c2d044d11fb4f6004aec07f2b25b1
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/05/2021
ms.locfileid: "97899602"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="a9a8e-103">마이크로 서비스 아키텍처의 통신</span><span class="sxs-lookup"><span data-stu-id="a9a8e-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="a9a8e-104">단일 프로세스에서 실행 중인 모놀리식 애플리케이션에서 구성 요소는 언어 수준 메서드 또는 함수 호출을 사용하여 서로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="a9a8e-105">코드(예:`new ClassName()`)를 사용하여 개체를 만드는 경우, 또는 구체적인 개체 인스턴스보다는 추상화를 참조하여 종속성 주입을 사용하는 경우 분리된 방식으로 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="a9a8e-106">어느 방법이든 개체는 동일한 프로세스 내에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="a9a8e-107">모놀리식 애플리케이션에서 마이크로 서비스 기반 애플리케이션으로 변경할 때의 가장 큰 문제는 통신 메커니즘을 변경하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="a9a8e-108">RPC 호출에 대한 in-process 메서드 호출에서 서비스로의 직접 변환은 분산 환경에서 원활히 수행되지 않는, 번거롭고 비효율적인 통신을 야기합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="a9a8e-109">분산 시스템을 제대로 디자인하는 데 따르는 과제는 개발자가 모놀리식 디자인에서 분산 디자인으로 이동할 때 흔히 수행하는 가정을 나열하는 [분산 컴퓨팅에 관한 오류](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)라고 알려진 캐논도 있다는 것은 충분히 잘 알려져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="a9a8e-110">하나의 솔루션이 아니라 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-110">There isn't one solution, but several.</span></span> <span data-ttu-id="a9a8e-111">한 가지 해결책에는 최대한 많은 비즈니스 마이크로 서비스를 격리하는 것이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="a9a8e-112">그런 다음, 내부 마이크로 서비스 간의 비동기 통신을 사용하고, 개체 간의 프로세스 내에서 일반적인 세분화된 통신을 성긴 통신으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="a9a8e-113">이 작업은 호출을 그룹화하고, 클라이언트에 여러 내부 호출의 결과 집계하는 데이터를 반환하여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="a9a8e-114">마이크로 서비스 기반 애플리케이션은 보통 여러 서버 또는 호스트에 걸쳐있더라도 여러 프로세스 또는 서비스에서 실행되는 분산 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="a9a8e-115">각 서비스 인스턴스는 일반적으로 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-115">Each service instance is typically a process.</span></span> <span data-ttu-id="a9a8e-116">따라서 서비스는 각 서비스의 성격에 따라 HTTP, AMQP 또는 TCP와 같은 이진 프로토콜과 같은 프로세스 내 통신 프로토콜을 사용하여 상호 작용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="a9a8e-117">마이크로 서비스 커뮤니티는 "[스마트 엔드포인트 및 단순 파이프](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)"의 원리를 장려합니다. 이 표어는 마이크로 서비스 간 가능한 분리되고, 단일 마이크로 서비스 내에서는 가능한 화합하는 디자인을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="a9a8e-118">앞에서 설명한 대로 각 마이크로 서비스는 자체 데이터 및 자체 도메인 논리를 소유합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="a9a8e-119">엔드투엔드 애플리케이션을 작성하는 마이크로 서비스는 보통 WS-\*와 같은 복잡한 프로토콜 대신 REST 통신, 그리고 중앙 집중화된 비즈니스 프로세스 오케스트레이터 대신 유연한 이벤트 구동 통신을 사용하여 간단히 조율됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="a9a8e-120">일반적으로 사용되는 두 가지 프로토콜은 리소스 API를 통한 HTTP 요청/응답(대부분 쿼리할 때)과 여러 마이크로 서비스 간 업데이트를 통신할 때의 간단한 비동기 메시징입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="a9a8e-121">이 내용은 다음 섹션에서 더 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="a9a8e-122">통신 유형</span><span class="sxs-lookup"><span data-stu-id="a9a8e-122">Communication types</span></span>

<span data-ttu-id="a9a8e-123">클라이언트와 서비스는 각각 다른 시나리오 및 목표를 대상으로 지정하여 다양한 유형의 통신을 통해 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="a9a8e-124">처음에, 그러한 통신 유형은 두 가지 축으로 분류할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="a9a8e-125">첫 번째 축은 프로토콜이 동기 또는 비동기인지를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="a9a8e-126">동기 프로토콜.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-126">Synchronous protocol.</span></span> <span data-ttu-id="a9a8e-127">HTTP는 동기 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="a9a8e-128">클라이언트가 요청을 보내고 서비스로부터 응답을 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="a9a8e-129">이는 동기(스레드 차단됨) 또는 비동기(스레드 차단 안 됨, 응답은 결국 콜백에 도달함)가 될 수 있는 클라이언트 코드 실행과는 관계가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="a9a8e-130">여기서 중요한 점은 프로토콜(HTTP/HTTPS)이 동기화되었으며 클라이언트 코드는 HTTP 서버 응답을 받을 때 해당 작업을 계속할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="a9a8e-131">비동기 프로토콜.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-131">Asynchronous protocol.</span></span> <span data-ttu-id="a9a8e-132">AMQP와 같은 다른 프로토콜(많은 운영 체제 및 클라우드 환경에서 지원되는 프로토콜)은 비동기 메시지를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="a9a8e-133">일반적으로 클라이언트 코드 또는 메시지를 보낸 사람은 응답을 기다리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="a9a8e-134">단순히 RabbitMQ 큐나 다른 메시지 브로커에 메시지를 보낼 때처럼 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="a9a8e-135">두 번째 축은 통신에 단일 수신기 또는 여러 수신기가 있는지 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="a9a8e-136">단일 수신기.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-136">Single receiver.</span></span> <span data-ttu-id="a9a8e-137">각 요청은 정확히 하나의 수신기 또는 서비스에서 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="a9a8e-138">이 통신의 예는 [명령 패턴](https://en.wikipedia.org/wiki/Command_pattern)입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="a9a8e-139">여러 수신기.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-139">Multiple receivers.</span></span> <span data-ttu-id="a9a8e-140">각 요청을 처리하는 수신기는 없거나 여러 개일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="a9a8e-141">이 유형의 통신은 비동기여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="a9a8e-142">[이벤트 기반 아키텍처](https://microservices.io/patterns/data/event-driven-architecture.html)와 같은 패턴에서 사용되는 [게시/구독](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) 메커니즘이 그 예입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="a9a8e-143">이는 데이터 업데이트를 이벤트를 통해 여러 마이크로 서비스 사이에 전파하는 경우 이벤트 버스 인터페이스 또는 메시지 브로커를 기반으로 합니다. 보통 Service Bus 또는 [항목과 구독](/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)을 사용하여 [Azure Service Bus](https://azure.microsoft.com/services/service-bus/)와 같은 비슷한 아티팩트를 통해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="a9a8e-144">마이크로 서비스 기반 애플리케이션은 이러한 통신 스타일의 조합을 종종 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="a9a8e-145">가장 일반적인 유형은 일반 Web API HTTP 서비스를 호출할 때 HTTP/HTTPS와 같은 동기 프로토콜을 사용하는 단일 수신기 통신입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="a9a8e-146">또한 마이크로 서비스는 마이크로 서비스 간 비동기 통신을 위해 일반적으로 메시징 프로토콜을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="a9a8e-147">이러한 축은 가능한 통신 메커니즘을 확실히 아는 데 유용하지만, 마이크로 서비스를 빌드할 때 중요한 고려 사항은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="a9a8e-148">클라이언트 스레드 실행의 비동기 특성은 물론, 선택한 프로토콜의 비동기 특성조차도 마이크로 서비스를 통합할 때 중요한 사안이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="a9a8e-149">중요한 *것은* 다음 섹션에 설명되어 있듯이 마이크로 서비스의 독립성을 유지 관리하면서 마이크로 서비스를 비동기적으로 통합할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="a9a8e-150">비동기 마이크로 서비스 통합은 마이크로 서비스의 자율성을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="a9a8e-151">언급했듯이 마이크로 서비스 기반 애플리케이션을 빌드할 때 중요한 점은 마이크로 서비스를 통합하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="a9a8e-152">이상적으로 내부 마이크로 서비스 간의 통신을 최소화하려고 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="a9a8e-153">마이크로 서비스 간의 통신이 적을수록 더 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="a9a8e-154">하지만 대부분의 경우 어떻게든 마이크로 서비스를 통합해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="a9a8e-155">이를 수행해야 할 때 여기서 중요한 규칙은 마이크로 서비스 간 통신은 비동기여야 한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="a9a8e-156">특정 프로토콜(예를 들어 비동기 메시징 대 동기 HTTP)을 사용해야 한다는 의미는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="a9a8e-157">마이크로 서비스 간의 통신은 데이터를 비동기적으로 전파해서 수행되어야 하지만, 초기 서비스의 HTTP 요청/응답 작업의 일환으로 다른 내부 마이크로 서비스에 종속되게 하지는 말라는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="a9a8e-158">가능하면 심지어 쿼리의 경우에도 여러 마이크로 서비스 간 동기 통신(요청/응답)에 종속되지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="a9a8e-159">각 마이크로 서비스의 목표는 엔드투엔드 애플리케이션의 일부로 다른 서비스가 다운되거나 비정상인 경우에도 자율적이며 클라이언트 고객에게 제공되는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="a9a8e-160">클라이언트 애플리케이션에 응답을 제공하기 위해 하나의 마이크로 서비스에서 다른 마이크로 서비스로 호출해야 한다고 생각한다면(예: 데이터 쿼리에 대한 HTTP 요청 수행), 일부 마이크로 서비스가 실패하는 경우 회복되지 않는 아키텍처가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="a9a8e-161">또한 그림 4-15의 첫 부분에 나와 있듯이 HTTP 요청 체인을 통해 긴 요청/응답 주기를 만들 때처럼 마이크로 서비스 간 HTTP 종속성이 있으면 마이크로 서비스가 자치적이지 않게 되며, 해당 체인의 서비스 중 하나가 제대로 수행되지 않는 즉시 성능에 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="a9a8e-162">쿼리 요청과 같은 마이크로 서비스 간 동기 종속성을 추가하면 할수록 클라이언트 앱에 대한 전체 응답 시간은 악화됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![마이크로 서비스 전반의 세 가지 통신 유형을 보여주는 다이어그램입니다.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="a9a8e-164">**그림 4-15**.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-164">**Figure 4-15**.</span></span> <span data-ttu-id="a9a8e-165">마이크로 서비스 간 통신의 안티 패턴 및 패턴</span><span class="sxs-lookup"><span data-stu-id="a9a8e-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="a9a8e-166">위의 다이어그램에 표시된 것처럼, 동기 통신에서 클라이언트 요청을 처리하는 동안 마이크로 서비스 간에 요청의 "체인"이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="a9a8e-167">이는 안티 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-167">This is an anti-pattern.</span></span> <span data-ttu-id="a9a8e-168">비동기 통신 마이크로 서비스에서는 비동기 메시지 또는 http 폴링을 사용하여 다른 마이크로 서비스와 통신하지만, 클라이언트 요청은 즉시 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="a9a8e-169">마이크로 서비스를 다른 마이크로 서비스의 추가 기능으로 만드는 경우, 가능하면 작업을 동기적으로, 그리고 원래 마이크로 서비스 요청 및 응답 작업의 일환으로 수행하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="a9a8e-170">대신, 비동기적으로 수행합니다(비동기 메시징 또는 통합 이벤트, 큐 등을 사용).</span><span class="sxs-lookup"><span data-stu-id="a9a8e-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="a9a8e-171">단, 되도록 원래 동기 요청 및 응답 작업의 일환으로 작업을 동기적으로 호출하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="a9a8e-172">마지막으로(그리고 마이크로 서비스를 빌드할 때 여기서 대부분의 문제가 발생함), 원래 다른 마이크로 서비스가 소유하는 데이터가 초기 마이크로 서비스에 필요한 경우 해당 데이터에 대한 동기 요청 만들기에 의존하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="a9a8e-173">대신, 최종 일관성(일반적으로 통합 이벤트를 사용, 다음 섹션에 설명됨)을 사용하여 해당 데이터(필요한 특성만)를 초기 서비스의 데이터베이스에 복제하거나 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="a9a8e-174">앞서 [각 마이크로 서비스의 도메인 모델 경계 식별](identify-microservice-domain-model-boundaries.md) 섹션에서 설명한 것처럼, 여러 마이크로 서비스에서 일부 데이터의 중복은 잘못된 디자인이 아닙니다. 반면, 이 경우 데이터를 특정 언어 또는 해당 추가 도메인 또는 바인딩된 컨텍스트의 용어로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="a9a8e-175">예를 들어 [eShopOnContainers 애플리케이션](https://github.com/dotnet-architecture/eShopOnContainers)에 `User`라는 엔터티가 있는 사용자의 데이터 대부분을 담당하는 `identity-api`라는 마이크로 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="a9a8e-176">단, `Ordering` 마이크로 서비스 내에서 사용자에 대한 데이터를 저장해야 하는 경우 `Buyer`라는 다른 엔터티로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="a9a8e-177">`Buyer` 엔터티는 원래 `User` 엔터티와 동일한 ID를 공유하지만, 전체 사용자 프로필이 아닌 `Ordering` 도메인에 필요한 몇몇 특성만 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="a9a8e-178">최종 일관성을 가지기 위해 프로토콜을 사용하여 마이크로 서비스 사이에 데이터를 비동기적으로 통신하고 전파할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="a9a8e-179">언급했듯이 이벤트 버스 또는 메시지 브로커를 사용하여 통합 이벤트를 사용하거나, 다른 서비스를 대신 폴링하여 HTTP를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="a9a8e-180">이는 중요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-180">It doesn't matter.</span></span> <span data-ttu-id="a9a8e-181">중요한 규칙은 마이크로 서비스 간 동기 종속성을 만들지 않는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="a9a8e-182">다음 섹션에서는 마이크로 서비스 기반 애플리케이션에서 사용을 고려할 수 있는 여러 통신 스타일에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="a9a8e-183">통신 스타일</span><span class="sxs-lookup"><span data-stu-id="a9a8e-183">Communication styles</span></span>

<span data-ttu-id="a9a8e-184">사용하려는 통신 유형에 따라 통신에 사용할 수 있는 여러 프로토콜 및 선택 항목이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="a9a8e-185">동기 요청/응답 기반 통신 메커니즘을 사용하는 경우, HTTP 및 REST 방식과 같은 프로토콜이 특히 Docker 호스트나 마이크로 서비스 클러스터 외부에 서비스를 게시하는 경우 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="a9a8e-186">내부적으로 서비스 간에 통신하는 경우(Docker 호스트나 마이크로서비스 클러스터 내) 이진 형식 통신 메커니즘을 사용할 수도 있습니다(예: TCP 및 이진 형식을 사용하는 WCF).</span><span class="sxs-lookup"><span data-stu-id="a9a8e-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="a9a8e-187">또는 AMQP 같은 비동기 메시지 기반 통신 메커니즘을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="a9a8e-188">또한 JSON 또는 XML과 같은 여러 메시지 형식, 더 효율적일 수 있는 이진 형식까지 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="a9a8e-189">선택한 이진 형식이 표준이 아닌 경우 해당 형식을 사용하여 서비스를 공개적으로 게시하는 것은 좋지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="a9a8e-190">마이크로 서비스 간의 내부 통신에 비표준 형식을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="a9a8e-191">이를 Docker 호스트나 마이크로서비스 클러스터 내 마이크로서비스 간 통신할 때(예: Docker 오케스트레이터) 또는 마이크로서비스에 통신하는 고유의 클라이언트 애플리케이션에서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="a9a8e-192">HTTP와 REST를 사용한 요청/응답 통신</span><span class="sxs-lookup"><span data-stu-id="a9a8e-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="a9a8e-193">클라이언트가 요청/응답 통신을 사용하는 경우 요청을 서비스에 보낸 다음, 서비스가 요청을 처리하고 다시 응답을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="a9a8e-194">요청/응답 통신은 특히 클라이언트 앱에서 실시간 UI(라이브 사용자 인터페이스)에 대한 데이터를 쿼리하는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="a9a8e-195">따라서 그림 4-16에 표시된 것처럼 마이크로 서비스 아키텍처에서는 대부분의 쿼리에 이 통신 메커니즘을 사용하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![라이브 쿼리와 업데이트에 대한 요청/응답 통신을 보여주는 다이어그램입니다.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="a9a8e-197">**그림 4-16**.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-197">**Figure 4-16**.</span></span> <span data-ttu-id="a9a8e-198">HTTP 요청/응답 통신 사용(동기 또는 비동기)</span><span class="sxs-lookup"><span data-stu-id="a9a8e-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="a9a8e-199">클라이언트가 요청/응답 통신을 사용하는 경우 응답이 짧은 시간에(일반적으로 1초 미만이거나 최대 수 초) 도착한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="a9a8e-200">지연된 응답의 경우 다음 섹션에서 설명하는 다른 접근 방식인 [메시징 패턴](/azure/architecture/patterns/category/messaging) 및 [메시징 기술](https://en.wikipedia.org/wiki/Message-oriented_middleware)을 기반으로 한 비동기 통신을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="a9a8e-201">요청/응답 통신을 위한 인기 있는 아키텍처 스타일은 [REST](https://en.wikipedia.org/wiki/Representational_state_transfer)입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="a9a8e-202">이 방법은 [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) 프로토콜을 기반으로 하며 밀접하게 결합되어 있으며 GET, POST 및 PUT과 같은 HTTP 동사를 수용합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="a9a8e-203">REST는 서비스를 만들 때 가장 흔히 사용되는 아키텍처 통신 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="a9a8e-204">ASP.NET Core Web API 서비스를 개발하는 경우 REST 서비스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="a9a8e-205">인터페이스 정의 언어로 HTTP REST 서비스를 사용하는 경우 추가 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="a9a8e-206">예를 들어, [Swagger 메타데이터](https://swagger.io/)를 사용하여 서비스 API를 설명하는 경우 서비스를 직접 검색하고 사용할 수 있는 클라이언트 스텁을 생성하는 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="a9a8e-207">추가 자료</span><span class="sxs-lookup"><span data-stu-id="a9a8e-207">Additional resources</span></span>

- <span data-ttu-id="a9a8e-208">**Martin Fowler. Richardson Maturity 모델** REST 모델의 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="a9a8e-209">**Swagger** 공식 사이트입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="a9a8e-210">HTTP 기반 푸시 및 실시간 통신</span><span class="sxs-lookup"><span data-stu-id="a9a8e-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="a9a8e-211">다른 가능성(일반적으로 REST와는 다른 용도용)은 [ASP.NET SignalR](https://www.asp.net/signalr)과 같은 더 높은 수준의 프레임워크와 [Websocket](https://en.wikipedia.org/wiki/WebSocket)과 같은 프로토콜을 사용한 실시간 및 일대다 통신입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="a9a8e-212">그림 4-17에서 볼 수 있듯이 실시간 HTTP 통신은 서버가 클라이언트에서 새 데이터를 요청하길 기다리도록 하는 대신, 서버 코드가 콘텐츠를 연결된 클라이언트로 푸시하도록 할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![SignalR 기반의 푸시 및 실시간 통신을 보여주는 다이어그램입니다.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="a9a8e-214">**그림 4-17**.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-214">**Figure 4-17**.</span></span> <span data-ttu-id="a9a8e-215">일대다 실시간 비동기 메시지 통신</span><span class="sxs-lookup"><span data-stu-id="a9a8e-215">One-to-many real-time asynchronous message communication</span></span>

<span data-ttu-id="a9a8e-216">SignalR은 백 엔드 서버에서 클라이언트로 콘텐츠를 푸시하기 위한 실시간 통신을 달성하는 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="a9a8e-217">통신이 실시간이므로 클라이언트 앱은 변경 내용을 거의 즉시 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="a9a8e-218">이는 일반적으로 많은 Websocket 연결을 사용하여(클라이언트당 하나) Websocket과 같은 프로토콜에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="a9a8e-219">일반적인 예는 서비스가 스포츠 경기 점수의 변경 내용을 여러 클라이언트 웹앱에 동시에 전달하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="a9a8e-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a9a8e-220">[이전](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[다음](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="a9a8e-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
