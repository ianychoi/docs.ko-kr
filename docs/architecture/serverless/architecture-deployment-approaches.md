---
title: 아키텍처 배포 방법 - 서버리스 앱
description: IaaS, PaaS, 컨테이너 및 서버리스 간 비교를 통해 엔터프라이즈 아키텍처를 클라우드에 배포하는 다양한 방법을 설명하는 가이드입니다.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: 89a8e6a52331b563be334a867f563e9ded8d8cc4
ms.sourcegitcommit: 7e42488c2f8f63f6d499b5f8fb1dec5bac9ad254
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/28/2021
ms.locfileid: "98957964"
---
# <a name="architecture-deployment-approaches"></a><span data-ttu-id="64402-103">아키텍처 배포 접근 방식</span><span class="sxs-lookup"><span data-stu-id="64402-103">Architecture deployment approaches</span></span>

<span data-ttu-id="64402-104">비즈니스 애플리케이션을 디자인하는 데 사용되는 아키텍처 접근 방식에 관계없이 이러한 애플리케이션의 구현 또는 배포는 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-104">Regardless of the architecture approach used to design a business application, the implementation, or deployment of those applications may vary.</span></span> <span data-ttu-id="64402-105">기업은 물리적 하드웨어에서 서버리스 함수에 이르기까지 다양한 애플리케이션을 호스트합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-105">Businesses host applications on everything from physical hardware to serverless functions.</span></span>

## <a name="n-tier-applications"></a><span data-ttu-id="64402-106">N 계층 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="64402-106">N-Tier applications</span></span>

<span data-ttu-id="64402-107">[N 계층 아키텍처 패턴](/azure/architecture/guide/architecture-styles/n-tier)은 완성도 높은 아키텍처로, 다양한 논리 계층을 별도의 물리적 계층으로 분리하는 애플리케이션을 지칭합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-107">The [N-Tier architecture pattern](/azure/architecture/guide/architecture-styles/n-tier) is a mature architecture and simply refers to applications that separate various logical layers into separate physical tiers.</span></span> <span data-ttu-id="64402-108">N 계층 아키텍처는 N 레이어 아키텍처의 물리적 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-108">N-Tier architecture is a physical implementation of N-Layer architecture.</span></span> <span data-ttu-id="64402-109">이 아키텍처의 가장 일반적인 구현에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="64402-109">The most common implementation of this architecture includes:</span></span>

- <span data-ttu-id="64402-110">프레젠테이션 계층(예: 웹앱)</span><span class="sxs-lookup"><span data-stu-id="64402-110">A presentation tier, for example a web app.</span></span>
- <span data-ttu-id="64402-111">API 또는 데이터 액세스 계층(예: REST API)</span><span class="sxs-lookup"><span data-stu-id="64402-111">An API or data access tier, such as a REST API.</span></span>
- <span data-ttu-id="64402-112">데이터 계층(예: SQL 데이터베이스)</span><span class="sxs-lookup"><span data-stu-id="64402-112">A data tier, such as a SQL database.</span></span>

![N 계층 아키텍처](./media/n-tier-architecture.png)

<span data-ttu-id="64402-114">N 계층 솔루션은 다음과 같은 특징이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-114">N-tier solutions have the following characteristics:</span></span>

- <span data-ttu-id="64402-115">프로젝트가 일반적으로 계층과 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="64402-115">Projects are typically aligned with tiers.</span></span>
- <span data-ttu-id="64402-116">테스트는 계층에 따라 다르게 접근할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-116">Testing may be approached differently by tier.</span></span>
- <span data-ttu-id="64402-117">계층은 추상화 레이어를 제공합니다. 예를 들어 프레젠테이션 계층은 일반적으로 데이터 계층의 구현 세부 정보를 알지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-117">Tiers provide layers of abstraction, for example the presentation tier is typically ignorant of the implementation details of the data tier.</span></span>
- <span data-ttu-id="64402-118">일반적으로 레이어는 인접 레이어와만 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-118">Typically, layers only interact with adjacent layers.</span></span>
- <span data-ttu-id="64402-119">릴리스는 프로젝트에서, 즉 계층 수준에서 관리되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-119">Releases are often managed at the project, and therefore tier, level.</span></span> <span data-ttu-id="64402-120">간단한 API 변경 때문에 전체 중간 계층의 새로운 릴리스가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-120">A simple API change may require a new release of an entire middle tier.</span></span>

<span data-ttu-id="64402-121">이 접근 방식은 다음과 같은 몇 가지 이점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-121">This approach provides several benefits, including:</span></span>

- <span data-ttu-id="64402-122">데이터베이스 격리(프런트 엔드가 데이터베이스 백 엔드에 직접 액세스할 수 없는 경우가 많음)</span><span class="sxs-lookup"><span data-stu-id="64402-122">Isolation of the database (often the front end doesn't have direct access to the database back end).</span></span>
- <span data-ttu-id="64402-123">API 재사용(예: 모바일, 데스크톱 및 웹앱 클라이언트는 모두 동일한 API를 재사용할 수 있음)</span><span class="sxs-lookup"><span data-stu-id="64402-123">Reuse of the API (for example, mobile, desktop, and web app clients can all reuse the same APIs).</span></span>
- <span data-ttu-id="64402-124">계층을 독립적으로 확장 가능</span><span class="sxs-lookup"><span data-stu-id="64402-124">Ability to scale out tiers independent of each other.</span></span>
- <span data-ttu-id="64402-125">리팩터링 격리: 다른 계층에 영향을 주지 않고 한 계층을 리팩터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-125">Refactoring isolation: one tier may be refactored without impacting other tiers.</span></span>

## <a name="on-premises-and-infrastructure-as-a-service-iaas"></a><span data-ttu-id="64402-126">온-프레미스 및 IaaS(Infrastructure as a Service)</span><span class="sxs-lookup"><span data-stu-id="64402-126">On-premises and Infrastructure as a Service (IaaS)</span></span>

<span data-ttu-id="64402-127">애플리케이션을 호스트하기 위한 일반적 접근 방식에서는 하드웨어를 구입하고 운영 체제를 비롯한 모든 소프트웨어 설치를 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-127">The traditional approach to hosting applications requires buying hardware and managing all of the software installations, including the operating system.</span></span> <span data-ttu-id="64402-128">원래는 이를 위해 비용이 많이 드는 데이터 센터 및 물리적 하드웨어가 필요했습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-128">Originally this involved expensive data centers and physical hardware.</span></span> <span data-ttu-id="64402-129">물리적 하드웨어를 운용하는 데 따른 어려운 문제는 다음과 같이 다양합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-129">The challenges that come with operating physical hardware are many, including:</span></span>

- <span data-ttu-id="64402-130">"만일" 또는 최대 수요 시나리오에 대비해 과다 구입해야 할 필요성</span><span class="sxs-lookup"><span data-stu-id="64402-130">The need to buy excess for "just in case" or peak demand scenarios.</span></span>
- <span data-ttu-id="64402-131">하드웨어에 대한 물리적 액세스 보호</span><span class="sxs-lookup"><span data-stu-id="64402-131">Securing physical access to the hardware.</span></span>
- <span data-ttu-id="64402-132">하드웨어 오류(예: 디스크 오류)에 대한 책임</span><span class="sxs-lookup"><span data-stu-id="64402-132">Responsibility for hardware failure (such as disk failure).</span></span>
- <span data-ttu-id="64402-133">냉각</span><span class="sxs-lookup"><span data-stu-id="64402-133">Cooling.</span></span>
- <span data-ttu-id="64402-134">라우터 및 부하 분산 장치 구성</span><span class="sxs-lookup"><span data-stu-id="64402-134">Configuring routers and load balancers.</span></span>
- <span data-ttu-id="64402-135">전원 중복성</span><span class="sxs-lookup"><span data-stu-id="64402-135">Power redundancy.</span></span>
- <span data-ttu-id="64402-136">소프트웨어 액세스 보안</span><span class="sxs-lookup"><span data-stu-id="64402-136">Securing software access.</span></span>

![IaaS 접근 방식](./media/iaas-approach.png)

<span data-ttu-id="64402-138">"가상 머신"을 통해 하드웨어를 가상화하면 IaaS(Infrastructure as a Service)를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-138">Virtualization of hardware, via "virtual machines" enables Infrastructure as a Service (IaaS).</span></span> <span data-ttu-id="64402-139">호스트 컴퓨터는 자체 메모리, CPU 및 저장소에 대한 할당을 사용하여 인스턴스에 리소스를 제공하도록 효과적으로 분할됩니다.</span><span class="sxs-lookup"><span data-stu-id="64402-139">Host machines are effectively partitioned to provide resources to instances with allocations for their own memory, CPU, and storage.</span></span> <span data-ttu-id="64402-140">팀은 필요한 VM을 프로비전하고 연결된 네트워크와 저장소 액세스를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-140">The team provisions the necessary VMs and configures the associated networks and access to storage.</span></span>

<span data-ttu-id="64402-141">자세한 내용은 [가상 머신 N 계층 참조 아키텍처](/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="64402-141">For more information, see [virtual machine N-tier reference architecture](/azure/architecture/reference-architectures/virtual-machines-windows/n-tier).</span></span>

<span data-ttu-id="64402-142">가상화 및 IaaS(Infrastructure as a Service)는 많은 문제를 해결하지만 인프라 팀에게 많은 책임도 안깁니다.</span><span class="sxs-lookup"><span data-stu-id="64402-142">Although virtualization and Infrastructure as a Service (IaaS) address many concerns, it still leaves much responsibility in the hands of the infrastructure team.</span></span> <span data-ttu-id="64402-143">팀은 운영 체제 버전을 유지 관리하고, 보안 패치를 적용하고, 대상 컴퓨터에 타사 종속성을 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-143">The team maintains operating system versions, applies security patches, and installs third-party dependencies on the target machines.</span></span> <span data-ttu-id="64402-144">앱은 프로덕션 컴퓨터에서 테스트 환경과 다르게 동작하는 경우가 자주 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-144">Apps often behave differently on production machines compared to the test environment.</span></span> <span data-ttu-id="64402-145">다른 종속성 버전 및/또는 OS SKU 수준 때문에 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-145">Issues arise due to different dependency versions and/or OS SKU levels.</span></span> <span data-ttu-id="64402-146">많은 조직에서 이러한 대상에 N 계층 애플리케이션을 배포하지만 많은 기업이 [서비스로서의 플랫폼](#platform-as-a-service-paas)과 같은 향상된 수준의 클라우드 네이티브 모델에 배포함으로써 혜택을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-146">Although many organizations deploy N-Tier applications to these targets, many companies benefit from deploying to a more cloud native model such as [Platform as a Service](#platform-as-a-service-paas).</span></span> <span data-ttu-id="64402-147">마이크로 서비스를 사용하는 아키텍처는 탄력성 및 복원력에 대한 확장 요구 사항 때문에 더 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-147">Architectures with microservices are more challenging because of the requirements to scale out for elasticity and resiliency.</span></span>

<span data-ttu-id="64402-148">자세한 내용은 [가상 머신](/azure/virtual-machines/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="64402-148">For more information, see [virtual machines](/azure/virtual-machines/).</span></span>

## <a name="platform-as-a-service-paas"></a><span data-ttu-id="64402-149">PaaS(Platform as a Service)</span><span class="sxs-lookup"><span data-stu-id="64402-149">Platform as a Service (PaaS)</span></span>

<span data-ttu-id="64402-150">PaaS(Platform as a Service)는 개발자가 직접 연결할 수 있는 구성된 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-150">Platform as a Service (PaaS) offers configured solutions that developers can plug into directly.</span></span> <span data-ttu-id="64402-151">PaaS는 관리되는 호스팅을 의미하는 또 다른 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-151">PaaS is another term for managed hosting.</span></span> <span data-ttu-id="64402-152">기본 운영 체제, 보안 패치 및 (대부분의 경우) 타사 종속성을 관리할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-152">It eliminates the need to manage the base operating system, security patches and in many cases any third-party dependencies.</span></span> <span data-ttu-id="64402-153">플랫폼의 예로는 웹 애플리케이션, 데이터베이스 및 모바일 백 엔드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-153">Examples of platforms include web applications, databases, and mobile back ends.</span></span>

<span data-ttu-id="64402-154">PaaS는 IaaS에 일반적으로 발생하는 어려운 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-154">PaaS addresses the challenges common to IaaS.</span></span> <span data-ttu-id="64402-155">PaaS는 개발자가 배포 방법이 아니라 코드 또는 데이터베이스 스키마에 집중할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-155">PaaS allows the developer to focus on the code or database schema rather than how it gets deployed.</span></span> <span data-ttu-id="64402-156">PaaS의 이점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-156">Benefits of PaaS include:</span></span>

- <span data-ttu-id="64402-157">유휴 컴퓨터에 투자하는 오버헤드를 제거하는 종량제 모델</span><span class="sxs-lookup"><span data-stu-id="64402-157">Pay for use models that eliminate the overhead of investing in idle machines.</span></span>
- <span data-ttu-id="64402-158">직접 배포 및 향상된 DevOps, CI(지속적인 통합) 및 CD(지속적인 업데이트) 파이프라인을 제공</span><span class="sxs-lookup"><span data-stu-id="64402-158">Direct deployment and improved DevOps, continuous integration (CI), and continuous delivery (CD) pipelines.</span></span>
- <span data-ttu-id="64402-159">자동 업그레이드, 업데이트 및 보안 패치</span><span class="sxs-lookup"><span data-stu-id="64402-159">Automatic upgrades, updates, and security patches.</span></span>
- <span data-ttu-id="64402-160">원스톱 수평 확장 및 수직 확장(탄력적 크기 조정)</span><span class="sxs-lookup"><span data-stu-id="64402-160">Push-button scale out and scale up (elastic scale).</span></span>

<span data-ttu-id="64402-161">일반적으로 PaaS의 주요 단점은 공급자 잠금이었습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-161">The main disadvantage of PaaS traditionally has been vendor lock-in.</span></span> <span data-ttu-id="64402-162">예를 들어 일부 PaaS 공급자는 ASP.NET, node.js 또는 다른 특정 언어 및 플랫폼만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-162">For example, some PaaS providers only support ASP.NET, Node.js, or other specific languages and platforms.</span></span> <span data-ttu-id="64402-163">Azure App Service 같은 제품은 여러 플랫폼에서 사용할 수 있고 웹앱을 호스팅하기 위한 다양한 언어 및 프레임워크를 지원하도록 발전했습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-163">Products like Azure App Service have evolved to address multiple platforms and support a variety of languages and frameworks for hosting web apps.</span></span>

![PaaS(Platform as a Service) 아키텍처](./media/paas-architecture.png)

## <a name="software-as-a-service-saas"></a><span data-ttu-id="64402-165">SaaS(Software as a Service)</span><span class="sxs-lookup"><span data-stu-id="64402-165">Software as a Service (SaaS)</span></span>

<span data-ttu-id="64402-166">SaaS(Software as a Service)는 중앙에서 호스트되고 로컬 설치 또는 프로비전 없이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-166">Software as a Service or SaaS is centrally hosted and available without local installation or provisioning.</span></span> <span data-ttu-id="64402-167">SaaS는 소프트웨어를 배포하기 위한 플랫폼으로 PaaS 위에 호스트되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-167">SaaS often is hosted on top of PaaS as a platform for deploying software.</span></span> <span data-ttu-id="64402-168">SaaS는 기존 소프트웨어를 실행하고 연결하는 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-168">SaaS provides services to run and connect with existing software.</span></span> <span data-ttu-id="64402-169">SaaS는 특정 산업 및 버티컬과 관련되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-169">SaaS is often industry and vertical specific.</span></span> <span data-ttu-id="64402-170">SaaS는 흔히 라이선스 방식이고 일반적으로 클라이언트/서버 모델을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-170">SaaS is often licensed and typically provides a client/server model.</span></span> <span data-ttu-id="64402-171">최신 SaaS 제품은 대부분 클라이언트에 웹 기반 앱을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-171">Most modern SaaS offerings use web-based apps for the client.</span></span> <span data-ttu-id="64402-172">기업은 일반적으로 SaaS를 라이선스 제품에 대한 비즈니스 솔루션으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-172">Companies typically consider SaaS as a business solution to license offerings.</span></span> <span data-ttu-id="64402-173">애플리케이션의 확장성 및 유지 관리에 대한 아키텍처 고려 사항으로 구현되는 경우는 많지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-173">It isn't often implemented as architecture consideration for scalability and maintainability of an application.</span></span> <span data-ttu-id="64402-174">실제로 대부분의 SaaS 솔루션은 IaaS, PaaS 및/또는 서버리스 백 엔드를 기반으로 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="64402-174">Indeed, most SaaS solutions are built on IaaS, PaaS, and/or serverless back ends.</span></span>

<span data-ttu-id="64402-175">[샘플 애플리케이션](/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)을 통해 SaaS에 대해 자세히 알아보세요.</span><span class="sxs-lookup"><span data-stu-id="64402-175">Learn more about SaaS through a [sample application](/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app).</span></span>

## <a name="containers-and-functions-as-a-service-faas"></a><span data-ttu-id="64402-176">컨테이너 및 FaaS(Functions as a Service)</span><span class="sxs-lookup"><span data-stu-id="64402-176">Containers and Functions as a Service (FaaS)</span></span>

<span data-ttu-id="64402-177">컨테이너는 IaaS 오버헤드 없이 PaaS와 비슷한 이점을 실현할 수 있는 흥미로운 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-177">Containers are an interesting solution that enables PaaS-like benefits without the IaaS overhead.</span></span> <span data-ttu-id="64402-178">컨테이너는 기본적으로 고유한 애플리케이션을 실행하는 데 필요한 필수 항목을 포함하는 런타임입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-178">A container is essentially a runtime that contains the bare essentials needed to run a unique application.</span></span> <span data-ttu-id="64402-179">호스트 운영 체제의 커널 또는 코어 부분과 저장소와 같은 서비스는 호스트에서 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="64402-179">The kernel or core part of the host operating system and services such as storage are shared across a host.</span></span> <span data-ttu-id="64402-180">공유 커널을 사용하면 컨테이너를 경량화할 수 있습니다(일반 가상 머신이 기가바이트 크기인데 비해 일부 컨테이너는 크기가 몇 메가바이트에 불과함).</span><span class="sxs-lookup"><span data-stu-id="64402-180">The shared kernel enables containers to be lightweight (some are mere megabytes in size, compared to the gigabyte size of typical virtual machines).</span></span> <span data-ttu-id="64402-181">호스트를 이미 실행 중인 경우 컨테이너를 신속하 게 시작하여 용이하게 고가용성을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-181">With hosts already running, containers can be started quickly, facilitating high availability.</span></span> <span data-ttu-id="64402-182">또한 컨테이너를 신속하게 실행하는 기능은 복원력을 추가로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-182">The ability to spin up containers quickly also provides extra layers of resiliency.</span></span> <span data-ttu-id="64402-183">Docker는 인기 있는 컨테이너 구현 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-183">Docker is one of the more popular implementations of containers.</span></span>

<span data-ttu-id="64402-184">컨테이너의 이점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-184">Benefits of containers include:</span></span>

- <span data-ttu-id="64402-185">경량 및 이식성</span><span class="sxs-lookup"><span data-stu-id="64402-185">Lightweight and portable</span></span>
- <span data-ttu-id="64402-186">자체적으로 포함되어 있으므로 종속성을 설치할 필요가 없음</span><span class="sxs-lookup"><span data-stu-id="64402-186">Self-contained so no need to install dependencies</span></span>
- <span data-ttu-id="64402-187">호스트에 관계없이 일관된 환경을 제공(클라우드 서버에서든 노트북에서든 동일하게 실행)</span><span class="sxs-lookup"><span data-stu-id="64402-187">Provide a consistent environment regardless of the host (runs exactly same on a laptop as on a cloud server)</span></span>
- <span data-ttu-id="64402-188">확장을 위해 신속하게 프로비전할 수 있음</span><span class="sxs-lookup"><span data-stu-id="64402-188">Can be provisioned quickly for scale-out</span></span>
- <span data-ttu-id="64402-189">오류 복구를 위해 신속하게 다시 시작할 수 있음</span><span class="sxs-lookup"><span data-stu-id="64402-189">Can be restarted quickly to recover from failure</span></span>

<span data-ttu-id="64402-190">컨테이너는 컨테이너 호스트에서 실행되며, 컨테이너 호스트는 운영 체제 미설치 컴퓨터 또는 가상 머신에서 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-190">A container runs on a container host (that in turn may run on a bare metal machine or a virtual machine).</span></span> <span data-ttu-id="64402-191">여러 컨테이너 또는 동일한 컨테이너의 여러 인스턴스를 단일 호스트에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-191">Multiple containers or instances of the same containers may run on a single host.</span></span> <span data-ttu-id="64402-192">진정한 장애 조치(failover) 및 복원력을 위해서는 컨테이너를 호스트 간에 확장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-192">For true failover and resiliency, containers must be scaled across hosts.</span></span>

<span data-ttu-id="64402-193">Docker 컨테이너에 대한 자세한 내용은 [Docker 정의](../microservices/container-docker-introduction/docker-defined.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="64402-193">For more information about Docker containers, see [What is Docker](../microservices/container-docker-introduction/docker-defined.md).</span></span>

<span data-ttu-id="64402-194">일반적으로 호스트 간에 컨테이너를 관리하려면 Kubernetes와 같은 오케스트레이션 도구가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-194">Managing containers across hosts typically requires an orchestration tool such as Kubernetes.</span></span> <span data-ttu-id="64402-195">오케스트레이션 솔루션을 구성하고 관리하면 프로젝트에 오버헤드와 복잡성이 추가될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-195">Configuring and managing orchestration solutions may add additional overhead and complexity to projects.</span></span> <span data-ttu-id="64402-196">다행히 많은 클라우드 공급자는 PaaS 솔루션을 통해 오케스트레이션 서비스를 제공하므로 컨테이너 관리가 간소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="64402-196">Fortunately, many cloud providers provide orchestration services through PaaS solutions to simplify the management of containers.</span></span>

<span data-ttu-id="64402-197">다음 그림에서는 Kubernetes 설치 예제를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="64402-197">The following image illustrates an example Kubernetes installation.</span></span> <span data-ttu-id="64402-198">설치 주소의 노드가 확장하고 장애 조치(failover)합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-198">Nodes in the installation address scale out and failover.</span></span> <span data-ttu-id="64402-199">주 서버에서 관리하는 Docker 컨테이너 인스턴스를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-199">They run Docker container instances that are managed by the primary server.</span></span> <span data-ttu-id="64402-200">*kubelet* 은 Kubernetes에서 Docker로 명령을 전달하는 클라이언트입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-200">The *kubelet* is the client that relays commands from Kubernetes to Docker.</span></span>

![Kubernetes](./media/kubernetes-example.png)

<span data-ttu-id="64402-202">오케스트레이션에 대한 자세한 내용은 [Azure의 Kubernetes](/azure/aks/intro-kubernetes)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="64402-202">For more information about orchestration, see [Kubernetes on Azure](/azure/aks/intro-kubernetes).</span></span>

<span data-ttu-id="64402-203">FaaS(Functions as a Service)는 서버리스와 비슷한 특수 컨테이너 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-203">Functions as a Service (FaaS) is a specialized container service that is similar to serverless.</span></span> <span data-ttu-id="64402-204">[OpenFaaS](https://github.com/openfaas/faas)라고 하는 FaaS 구현은 서버리스 기능을 제공하기 위해 컨테이너 위에 위치합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-204">A specific implementation of FaaS, called [OpenFaaS](https://github.com/openfaas/faas), sits on top of containers to provide serverless capabilities.</span></span> <span data-ttu-id="64402-205">OpenFaaS는 코드 조각을 실행하는 데 필요한 모든 컨테이너 종속성을 패키지하는 템플릿을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-205">OpenFaaS provides templates that package all of the container dependencies necessary to run a piece of code.</span></span> <span data-ttu-id="64402-206">템플릿을 사용하면 코드를 기능 단위로 배포하는 프로세스가 간단해집니다.</span><span class="sxs-lookup"><span data-stu-id="64402-206">Using templates simplifies the process of deploying code as a functional unit.</span></span> <span data-ttu-id="64402-207">OpenFaaS는 기존 인프라를 사용할 수 있기 때문에 이미 컨테이너 및 오케스트레이터를 포함하는 아키텍처를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-207">OpenFaaS targets architectures that already include containers and orchestrators because it can use the existing infrastructure.</span></span> <span data-ttu-id="64402-208">서버리스 기능을 제공하지만, 구체적으로 Docker 및 오케스트레이터를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-208">Although it provides serverless functionality, it specifically requires you to use Docker and an orchestrator.</span></span>

## <a name="serverless"></a><span data-ttu-id="64402-209">서버를 사용하지 않음</span><span class="sxs-lookup"><span data-stu-id="64402-209">Serverless</span></span>

<span data-ttu-id="64402-210">서버리스 아키텍처에서는 코드와 해당 호스팅 환경을 명확하게 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-210">A serverless architecture provides a clear separation between the code and its hosting environment.</span></span> <span data-ttu-id="64402-211">*트리거* 에서 호출하는 *함수* 에 코드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-211">You implement code in a *function* that is invoked by a *trigger*.</span></span> <span data-ttu-id="64402-212">해당 함수가 종료되면 필요한 모든 리소스가 해제될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-212">After that function exits, all its needed resources may be freed.</span></span> <span data-ttu-id="64402-213">트리거는 수동이거나 시간 지정된 프로세스, HTTP 요청 또는 파일 업로드일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-213">The trigger might be manual, a timed process, an HTTP request, or a file upload.</span></span> <span data-ttu-id="64402-214">트리거 결과는 코드를 실행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-214">The result of the trigger is the execution of code.</span></span> <span data-ttu-id="64402-215">서버리스 플랫폼이 다를 수 있지만 대부분은 데이터베이스에 쓰기 또는 큐 결과 등의 작업을 간소화하기 위해 미리 정의된 API 및 바인딩에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-215">Although serverless platforms vary, most provide access to pre-defined APIs and bindings to streamline tasks such as writing to a database or queueing results.</span></span>

<span data-ttu-id="64402-216">서버리스는 코드에 집중할 수 있게 호스트 환경 추상화에 크게 의존하는 아키텍처입니다.</span><span class="sxs-lookup"><span data-stu-id="64402-216">Serverless is an architecture that relies heavily on abstracting away the host environment to focus on code.</span></span> <span data-ttu-id="64402-217">이를 *매우 작은 서버* 로 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-217">It can be thought of as *less server*.</span></span>

<span data-ttu-id="64402-218">컨테이너 솔루션은 개발자에게 코드를 서버리스 지원 이미지에 게시하는 기존 빌드 스크립트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-218">Container solutions provide developers existing build scripts to publish code to serverless-ready images.</span></span> <span data-ttu-id="64402-219">다른 구현에서는 기존 PaaS 솔루션을 사용하여 확장 가능한 아키텍처를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-219">Other implementations use existing PaaS solutions to provide a scalable architecture.</span></span>

<span data-ttu-id="64402-220">추상화는 DevOps 팀이 서버 또는 특정 컨테이너를 프로비전하거나 관리할 필요가 없음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-220">The abstraction means the DevOps team doesn't have to provision or manage servers, nor specific containers.</span></span> <span data-ttu-id="64402-221">서버리스 플랫폼은 관련 SDK를 사용하여 작성된 스크립트 또는 패키지된 실행 파일로 코드를 호스팅하고 코드 크기를 조정하는 데 필요한 리소스를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-221">The serverless platform hosts code, either as script or packaged executables built with a related SDK, and allocates the necessary resources for the code to scale.</span></span>

<span data-ttu-id="64402-222">다음 그림에서는 4개의 서버리스 구성 요소를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="64402-222">The following illustration diagrams four serverless components.</span></span> <span data-ttu-id="64402-223">HTTP 요청은 체크 아웃 API 코드를 실행시킵니다.</span><span class="sxs-lookup"><span data-stu-id="64402-223">An HTTP request causes the Checkout API code to run.</span></span> <span data-ttu-id="64402-224">체크 아웃 API는 데이터베이스에 코드를 삽입하고, 이는 다른 여러 함수를 트리거하여 계산 작업, 주문 이행과 같은 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-224">The Checkout API inserts code into a database, and the insert triggers several other functions to run to perform tasks like computing tasks and fulfilling the order.</span></span>

![서버리스 구현](./media/serverless-implementation.png)

<span data-ttu-id="64402-226">서버리스의 장점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-226">The advantages of serverless include:</span></span>

- <span data-ttu-id="64402-227">**고밀도.**</span><span class="sxs-lookup"><span data-stu-id="64402-227">**High density.**</span></span> <span data-ttu-id="64402-228">컨테이너 또는 가상 머신과 비교할 때, 동일한 서버리스 코드의 여러 인스턴스가 동일한 호스트에서 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-228">Many instances of the same serverless code can run on the same host compared to containers or virtual machines.</span></span> <span data-ttu-id="64402-229">인스턴스는 여러 호스트에 걸쳐 확장되고 복원력이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="64402-229">The instances scale across multiple hosts scale out and resiliency.</span></span>
- <span data-ttu-id="64402-230">**마이크로 대금 청구.**</span><span class="sxs-lookup"><span data-stu-id="64402-230">**Micro-billing.**</span></span> <span data-ttu-id="64402-231">대부분의 서버리스 공급자는 서버리스 실행을 기준으로 비용을 부과하므로 특정 시나리오에서 막대한 비용 절감 효과가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-231">Most serverless providers bill based on serverless executions, enabling massive cost savings in certain scenarios.</span></span>
- <span data-ttu-id="64402-232">**즉각적인 크기 조정.**</span><span class="sxs-lookup"><span data-stu-id="64402-232">**Instant scale.**</span></span> <span data-ttu-id="64402-233">서버리스는 워크로드에 맞춰 자동으로 신속하게 크기가 조정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-233">Serverless can scale to match workloads automatically and quickly.</span></span>
- <span data-ttu-id="64402-234">**보다 신속한 출시.**</span><span class="sxs-lookup"><span data-stu-id="64402-234">**Faster time to market.**</span></span> <span data-ttu-id="64402-235">개발자는 코드에 집중하고 서버리스 플랫폼에 직접 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-235">Developers focus on code and deploy directly to the serverless platform.</span></span> <span data-ttu-id="64402-236">구성 요소는 서로 독립적으로 릴리스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-236">Components can be released independently of each other.</span></span>

<span data-ttu-id="64402-237">서버리스는 컴퓨팅 맥락에서 고려되는 것이 가장 일반적이지만, 데이터에도 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-237">Serverless is most often discussed in the context of compute, but can also apply to data.</span></span> <span data-ttu-id="64402-238">예를 들어 [Azure SQL](/azure/sql-database) 및 [Cosmos DB](/azure/cosmos-db)는 모두 호스트 컴퓨터 또는 클러스터를 구성할 필요가 없는 클라우드 데이터베이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-238">For example, [Azure SQL](/azure/sql-database) and [Cosmos DB](/azure/cosmos-db) both provide cloud databases that don't require you to configure host machines or clusters.</span></span> <span data-ttu-id="64402-239">이 책에서는 서버리스 컴퓨팅에 초점을 맞춥니다.</span><span class="sxs-lookup"><span data-stu-id="64402-239">This book focuses on serverless compute.</span></span>

## <a name="summary"></a><span data-ttu-id="64402-240">요약</span><span class="sxs-lookup"><span data-stu-id="64402-240">Summary</span></span>

<span data-ttu-id="64402-241">아키텍처에는 하이브리드 접근 방식을 포함하여 광범위한 선택지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-241">There's a broad spectrum of available choices for architecture, including a hybrid approach.</span></span> <span data-ttu-id="64402-242">서버리스는 제어 및 이식성을 대가로 애플리케이션 기능의 접근 방식, 관리 및 비용을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-242">Serverless simplifies the approach, management, and cost of application features at the expense of control and portability.</span></span> <span data-ttu-id="64402-243">그러나 많은 서버리스 플랫폼은 솔루션을 미세 조정하는 데 도움이 되는 구성을 공개합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-243">However, many serverless platforms do expose configuration to help fine-tune the solution.</span></span> <span data-ttu-id="64402-244">또한 바람직한 프로그래밍 관행 덕분에 이식 가능한 코드는 증가하고 서버리스 플랫폼 잠금은 감소할 발수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64402-244">Good programming practices can also lead to more portable code and less serverless platform lock-in.</span></span> <span data-ttu-id="64402-245">다음 표에서는 아키텍처 접근 방식을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-245">The following table illustrates the architecture approaches side by side.</span></span> <span data-ttu-id="64402-246">확장 요구 사항에 따라 서버리스를 선택하고, 런타임을 관리할지 여부를 선택하고, 워크로드를 작은 구성 요소로 세분화할 수준을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-246">Choose serverless based on your scale needs, whether or not you want to manage the runtime, and how well you can break your workloads into small components.</span></span> <span data-ttu-id="64402-247">다음 장에서 서버리스 및 기타 결정 사항에 대한 잠재적 문제에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="64402-247">You'll learn about potential challenges with serverless and other decision points in the next chapter.</span></span>

|         |<span data-ttu-id="64402-248">IaaS</span><span class="sxs-lookup"><span data-stu-id="64402-248">IaaS</span></span>     |<span data-ttu-id="64402-249">PaaS</span><span class="sxs-lookup"><span data-stu-id="64402-249">PaaS</span></span>     |<span data-ttu-id="64402-250">컨테이너</span><span class="sxs-lookup"><span data-stu-id="64402-250">Container</span></span>|<span data-ttu-id="64402-251">서버를 사용하지 않음</span><span class="sxs-lookup"><span data-stu-id="64402-251">Serverless</span></span>|
|---------|---------|---------|---------|----------|
|<span data-ttu-id="64402-252">**배율**</span><span class="sxs-lookup"><span data-stu-id="64402-252">**Scale**</span></span>|<span data-ttu-id="64402-253">VM</span><span class="sxs-lookup"><span data-stu-id="64402-253">VM</span></span>       |<span data-ttu-id="64402-254">인스턴스</span><span class="sxs-lookup"><span data-stu-id="64402-254">Instance</span></span> |<span data-ttu-id="64402-255">App</span><span class="sxs-lookup"><span data-stu-id="64402-255">App</span></span>      |<span data-ttu-id="64402-256">함수</span><span class="sxs-lookup"><span data-stu-id="64402-256">Function</span></span>  |
|<span data-ttu-id="64402-257">**추상화**</span><span class="sxs-lookup"><span data-stu-id="64402-257">**Abstracts**</span></span>|<span data-ttu-id="64402-258">하드웨어</span><span class="sxs-lookup"><span data-stu-id="64402-258">Hardware</span></span>|<span data-ttu-id="64402-259">플랫폼</span><span class="sxs-lookup"><span data-stu-id="64402-259">Platform</span></span>|<span data-ttu-id="64402-260">OS 호스트</span><span class="sxs-lookup"><span data-stu-id="64402-260">OS Host</span></span>|<span data-ttu-id="64402-261">런타임</span><span class="sxs-lookup"><span data-stu-id="64402-261">Runtime</span></span>   |
|<span data-ttu-id="64402-262">**단위**</span><span class="sxs-lookup"><span data-stu-id="64402-262">**Unit**</span></span> |<span data-ttu-id="64402-263">VM</span><span class="sxs-lookup"><span data-stu-id="64402-263">VM</span></span>       |<span data-ttu-id="64402-264">프로젝트</span><span class="sxs-lookup"><span data-stu-id="64402-264">Project</span></span>  |<span data-ttu-id="64402-265">이미지</span><span class="sxs-lookup"><span data-stu-id="64402-265">Image</span></span>    |<span data-ttu-id="64402-266">코드</span><span class="sxs-lookup"><span data-stu-id="64402-266">Code</span></span>      |
|<span data-ttu-id="64402-267">**수명(lifetime)**</span><span class="sxs-lookup"><span data-stu-id="64402-267">**Lifetime**</span></span>|<span data-ttu-id="64402-268">개월</span><span class="sxs-lookup"><span data-stu-id="64402-268">Months</span></span>|<span data-ttu-id="64402-269">일 단위에서 개월 단위</span><span class="sxs-lookup"><span data-stu-id="64402-269">Days to Months</span></span>|<span data-ttu-id="64402-270">분 단위에서 일 단위</span><span class="sxs-lookup"><span data-stu-id="64402-270">Minutes to Days</span></span>|<span data-ttu-id="64402-271">밀리초 단위에서 분 단위</span><span class="sxs-lookup"><span data-stu-id="64402-271">Milliseconds to Minutes</span></span>|
|<span data-ttu-id="64402-272">**책임**</span><span class="sxs-lookup"><span data-stu-id="64402-272">**Responsibility**</span></span>|<span data-ttu-id="64402-273">애플리케이션, 종속성, 런타임 및 운영 체제</span><span class="sxs-lookup"><span data-stu-id="64402-273">Applications, dependencies, runtime, and operating system</span></span>|<span data-ttu-id="64402-274">애플리케이션 및 종속성</span><span class="sxs-lookup"><span data-stu-id="64402-274">Applications and dependencies</span></span>|<span data-ttu-id="64402-275">애플리케이션, 종속성 및 런타임</span><span class="sxs-lookup"><span data-stu-id="64402-275">Applications, dependencies, and runtime</span></span>|<span data-ttu-id="64402-276">함수</span><span class="sxs-lookup"><span data-stu-id="64402-276">Function</span></span>

- <span data-ttu-id="64402-277">**배율** 은 애플리케이션의 크기를 조정하는 데 사용되는 단위를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="64402-277">**Scale** refers to the unit that is used to scale the application</span></span>
- <span data-ttu-id="64402-278">**추상화** 는 구현에 의해 추상화된 레이어를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="64402-278">**Abstracts** refers to the layer that is abstracted by the implementation</span></span>
- <span data-ttu-id="64402-279">**단위** 는 배포되는 항목의 범위를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="64402-279">**Unit** refers to the scope of what is deployed</span></span>
- <span data-ttu-id="64402-280">**수명** 은 특정 인스턴스의 일반적인 런타임을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="64402-280">**Lifetime** refers to the typical runtime of a specific instance</span></span>
- <span data-ttu-id="64402-281">**책임** 은 애플리케이션을 빌드, 배포 및 유지 관리하는 오버헤드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="64402-281">**Responsibility** refers to the overhead to build, deploy, and maintain the application</span></span>

<span data-ttu-id="64402-282">다음 장에서 서버리스 아키텍처, 사용 사례 및 디자인 패턴을 중점적으로 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="64402-282">The next chapter will focus on serverless architecture, use cases, and design patterns.</span></span>

## <a name="recommended-resources"></a><span data-ttu-id="64402-283">권장되는 리소스</span><span class="sxs-lookup"><span data-stu-id="64402-283">Recommended resources</span></span>

- [<span data-ttu-id="64402-284">Azure 애플리케이션 아키텍처 가이드</span><span class="sxs-lookup"><span data-stu-id="64402-284">Azure application architecture guide</span></span>](/azure/architecture/guide/)
- [<span data-ttu-id="64402-285">Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="64402-285">Azure Cosmos DB</span></span>](/azure/cosmos-db)
- [<span data-ttu-id="64402-286">Azure SQL</span><span class="sxs-lookup"><span data-stu-id="64402-286">Azure SQL</span></span>](/azure/sql-database)
- [<span data-ttu-id="64402-287">N 계층 아키텍처 패턴</span><span class="sxs-lookup"><span data-stu-id="64402-287">N-Tier architecture pattern</span></span>](/azure/architecture/guide/architecture-styles/n-tier)
- [<span data-ttu-id="64402-288">Azure의 Kubernetes</span><span class="sxs-lookup"><span data-stu-id="64402-288">Kubernetes on Azure</span></span>](/azure/aks/intro-kubernetes)
- [<span data-ttu-id="64402-289">마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="64402-289">Microservices</span></span>](/azure/architecture/guide/architecture-styles/microservices)
- [<span data-ttu-id="64402-290">가상 머신 N 계층 참조 아키텍처</span><span class="sxs-lookup"><span data-stu-id="64402-290">Virtual machine N-tier reference architecture</span></span>](/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)
- [<span data-ttu-id="64402-291">가상 머신</span><span class="sxs-lookup"><span data-stu-id="64402-291">Virtual machines</span></span>](/azure/virtual-machines/)
- [<span data-ttu-id="64402-292">Docker란?</span><span class="sxs-lookup"><span data-stu-id="64402-292">What is Docker?</span></span>](../microservices/container-docker-introduction/docker-defined.md)
- [<span data-ttu-id="64402-293">Wingtip Tickets SaaS 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="64402-293">Wingtip Tickets SaaS application</span></span>](/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)

>[!div class="step-by-step"]
><span data-ttu-id="64402-294">[이전](architecture-approaches.md)
>[다음](serverless-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="64402-294">[Previous](architecture-approaches.md)
[Next](serverless-architecture.md)</span></span>
