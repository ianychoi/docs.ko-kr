---
title: 애플리케이션 복원력 패턴
description: Azure 용 클라우드 네이티브 .NET 앱 설계 | 응용 프로그램 복원 력 패턴
author: robvet
ms.date: 01/19/2021
ms.openlocfilehash: 9a59a7d93b61b0dea11680f6caf0bd3b68a0f853
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505923"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="726eb-103">애플리케이션 복원력 패턴</span><span class="sxs-lookup"><span data-stu-id="726eb-103">Application resiliency patterns</span></span>

<span data-ttu-id="726eb-104">첫 번째 방어 줄은 응용 프로그램 복원 력입니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="726eb-105">사용자 고유의 복원 력 프레임 워크를 작성 하는 데 상당한 시간을 투자할 수 있지만 이러한 제품은 이미 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="726eb-106">[이는 개발자가 흐름](http://www.thepollyproject.org/) 및 스레드로부터 안전한 방식으로 복원 력을 표현할 수 있도록 하는 포괄적인 .net 복원 력 및 일시적인 오류 처리 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="726eb-107">응용 프로그램은 .NET Framework 또는 .NET 5로 빌드된 응용 프로그램을 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-107">Polly targets applications built with either the .NET Framework or .NET 5.</span></span> <span data-ttu-id="726eb-108">다음 표에서는 기능을 제공 하는 `policies` 라이브러리에서 사용할 수 있는 복원 력 기능에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="726eb-109">개별적으로 적용 하거나 그룹화 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="726eb-110">정책</span><span class="sxs-lookup"><span data-stu-id="726eb-110">Policy</span></span> | <span data-ttu-id="726eb-111">환경</span><span class="sxs-lookup"><span data-stu-id="726eb-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="726eb-112">다시 시도</span><span class="sxs-lookup"><span data-stu-id="726eb-112">Retry</span></span> | <span data-ttu-id="726eb-113">지정 된 작업에 대 한 재시도 작업을 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="726eb-114">회로 차단기</span><span class="sxs-lookup"><span data-stu-id="726eb-114">Circuit Breaker</span></span> | <span data-ttu-id="726eb-115">오류가 구성 된 임계값을 초과 하는 경우 미리 정의 된 기간 동안 요청 된 작업을 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="726eb-116">제한 시간</span><span class="sxs-lookup"><span data-stu-id="726eb-116">Timeout</span></span> | <span data-ttu-id="726eb-117">호출자가 응답을 기다릴 수 있는 기간에 제한을 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="726eb-118">격벽</span><span class="sxs-lookup"><span data-stu-id="726eb-118">Bulkhead</span></span> | <span data-ttu-id="726eb-119">리소스를 swamping 하는 실패 한 호출을 방지 하기 위해 작업을 고정 크기 리소스 풀로 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="726eb-120">캐시</span><span class="sxs-lookup"><span data-stu-id="726eb-120">Cache</span></span> | <span data-ttu-id="726eb-121">응답을 자동으로 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="726eb-122">대체</span><span class="sxs-lookup"><span data-stu-id="726eb-122">Fallback</span></span> | <span data-ttu-id="726eb-123">실패 시 구조화 된 동작을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="726eb-124">이전 그림에서 복원 력 정책은 외부 클라이언트나 백 엔드 서비스에서 들어오는 요청 메시지에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="726eb-125">목표는 일시적으로 사용할 수 없는 서비스에 대 한 요청을 보정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="726eb-126">이러한 단기 중단은 일반적으로 다음 표에 나와 있는 HTTP 상태 코드를 사용 하 여 매니페스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="726eb-127">HTTP 상태 코드</span><span class="sxs-lookup"><span data-stu-id="726eb-127">HTTP Status Code</span></span>| <span data-ttu-id="726eb-128">원인</span><span class="sxs-lookup"><span data-stu-id="726eb-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="726eb-129">404</span><span class="sxs-lookup"><span data-stu-id="726eb-129">404</span></span> | <span data-ttu-id="726eb-130">찾을 수 없음</span><span class="sxs-lookup"><span data-stu-id="726eb-130">Not Found</span></span> |
| <span data-ttu-id="726eb-131">408</span><span class="sxs-lookup"><span data-stu-id="726eb-131">408</span></span> | <span data-ttu-id="726eb-132">요청 시간 초과</span><span class="sxs-lookup"><span data-stu-id="726eb-132">Request timeout</span></span> |
| <span data-ttu-id="726eb-133">429</span><span class="sxs-lookup"><span data-stu-id="726eb-133">429</span></span> | <span data-ttu-id="726eb-134">요청이 너무 많음 (최대 제한 됨)</span><span class="sxs-lookup"><span data-stu-id="726eb-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="726eb-135">502</span><span class="sxs-lookup"><span data-stu-id="726eb-135">502</span></span> | <span data-ttu-id="726eb-136">나쁜 게이트웨이</span><span class="sxs-lookup"><span data-stu-id="726eb-136">Bad gateway</span></span> |
| <span data-ttu-id="726eb-137">503</span><span class="sxs-lookup"><span data-stu-id="726eb-137">503</span></span> | <span data-ttu-id="726eb-138">서비스를 사용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="726eb-138">Service unavailable</span></span> |
| <span data-ttu-id="726eb-139">504</span><span class="sxs-lookup"><span data-stu-id="726eb-139">504</span></span> | <span data-ttu-id="726eb-140">게이트웨이 시간 제한</span><span class="sxs-lookup"><span data-stu-id="726eb-140">Gateway timeout</span></span> |

<span data-ttu-id="726eb-141">질문: 403-금지 된 HTTP 상태 코드를 다시 시도 하나요?</span><span class="sxs-lookup"><span data-stu-id="726eb-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="726eb-142">아니요.</span><span class="sxs-lookup"><span data-stu-id="726eb-142">No.</span></span> <span data-ttu-id="726eb-143">여기에서 시스템이 제대로 작동 하지만 요청 된 작업을 수행할 수 있는 권한이 호출자에 게 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="726eb-144">오류로 인해 발생 하는 작업만 다시 시도해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="726eb-145">1 장에서 권장 한 대로 클라우드 네이티브 응용 프로그램을 구성 하는 Microsoft 개발자는 .NET 플랫폼을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET platform.</span></span> <span data-ttu-id="726eb-146">버전 2.1에는 URL 기반 리소스와 상호 작용 하기 위한 HTTP 클라이언트 인스턴스를 만들기 위한 [Httpclientfactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) 라이브러리가 도입 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="726eb-147">원래 HTTPClient 클래스를 대체 하는 팩터리 클래스는 향상 된 많은 기능을 지원 하며, 그 중 하나는이 기능을 사용 하는 것 [이 좋습니다.](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md)</span><span class="sxs-lookup"><span data-stu-id="726eb-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="726eb-148">이를 통해 응용 프로그램 시작 클래스에서 복원 력 정책을 쉽게 정의 하 여 부분 오류 및 연결 문제를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="726eb-149">다음으로 다시 시도 및 회로 차단기 패턴을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="726eb-150">다시 시도 패턴</span><span class="sxs-lookup"><span data-stu-id="726eb-150">Retry pattern</span></span>

<span data-ttu-id="726eb-151">분산 클라우드 기본 환경에서 서비스 및 클라우드 리소스에 대 한 호출은 일시적 (단기) 오류로 인해 실패할 수 있습니다. 일반적으로 잠시 후에 자체적으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="726eb-152">재시도 전략을 구현 하면 클라우드 네이티브 서비스에서 이러한 시나리오를 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="726eb-153">[다시 시도 패턴](/azure/architecture/patterns/retry) 을 사용 하면 서비스에서 실패 한 요청 작업 (구성 가능)을 지 수 많은 대기 시간으로 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-153">The [Retry pattern](/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="726eb-154">그림 6-2에서는 다시 시도 하는 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-154">Figure 6-2 shows a retry in action.</span></span>

![재시도 패턴 실행](./media/retry-pattern.png)

<span data-ttu-id="726eb-156">**그림 6-2**.</span><span class="sxs-lookup"><span data-stu-id="726eb-156">**Figure 6-2**.</span></span> <span data-ttu-id="726eb-157">재시도 패턴 실행</span><span class="sxs-lookup"><span data-stu-id="726eb-157">Retry pattern in action</span></span>

<span data-ttu-id="726eb-158">위의 그림에서 재시도 패턴은 요청 작업에 대해 구현 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="726eb-159">백오프 간격 (대기 시간)이 2 초에서 시작 하 여 실패 하기 전까지 최대 4 번의 재시도를 허용 하도록 구성 되며,이는 각 후속 시도에 대해 두 배가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="726eb-160">첫 번째 호출이 실패 하 고 HTTP 상태 코드 500을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="726eb-161">응용 프로그램은 2 초 동안 대기한 후 호출을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="726eb-162">두 번째 호출도 실패 하 고 HTTP 상태 코드 500을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="726eb-163">이제 응용 프로그램은 백오프 간격을 4 초로 두 배로 증가 하 고 호출을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="726eb-164">마지막으로 세 번째 호출은 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="726eb-165">이 시나리오에서 재시도 작업은 호출을 실패 하기 전에 백오프 기간을 두 배로 하는 동시에 최대 4 번의 재시도를 시도 했습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="726eb-166">네 번째 다시 시도 시도가 실패 한 경우 문제를 정상적으로 처리 하기 위해 대체 정책이 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="726eb-167">서비스 시간을 자체 수정할 수 있도록 호출을 다시 시도 하기 전에 백오프 기간을 늘려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="726eb-168">백오프을 구현 하 여 적절 한 수정 시간을 허용 하는 것이 좋습니다. 즉, 재시도 마다 마침표를 두 배로 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="726eb-169">회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="726eb-169">Circuit breaker pattern</span></span>

<span data-ttu-id="726eb-170">재시도 패턴은 부분 실패에 대 한 요청을 복구 하는 데 도움이 되지만, 해결 하는 데 시간이 더 오래 걸릴 수 있는 예기치 않은 이벤트로 인해 오류가 발생할 수 있는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="726eb-171">이러한 오류의 심각도는 부분적 연결 손실에서부터 전체 서비스 오류에까지 이를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="726eb-172">이러한 상황에서는 응용 프로그램이 성공할 가능성이 없는 작업을 계속 해 서 다시 시도 하는 것은 무의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="726eb-173">과도 한 작업을 수행 하기 위해 응답성이 없는 서비스에 대 한 지속적인 재시도 작업을 실행 하면 메모리, 스레드 및 데이터베이스 연결과 같은 리소스를 지속적으로 사용 하 여 서비스를 제한 하 여 동일한 리소스를 사용 하는 시스템의 관련 되지 않은 부분에서 오류가 발생 하는 자체 서비스 거부 시나리오로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="726eb-174">이러한 경우에는 작업이 즉시 실패 하 고 성공할 가능성이 있는 경우에만 서비스를 호출 하려고 시도 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="726eb-175">[회로 차단기 패턴](/azure/architecture/patterns/circuit-breaker) 은 응용 프로그램이 실패할 가능성이 있는 작업을 반복적으로 실행 하는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-175">The [Circuit Breaker pattern](/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="726eb-176">미리 정의 된 수의 실패 한 호출 후에는 서비스에 대 한 모든 트래픽을 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="726eb-177">정기적으로 평가판 호출을 통해 오류가 해결 되었는지 여부를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="726eb-178">그림 6-3은 작동 중인 회로 차단기 패턴을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![작동 중인 회로 차단기 패턴](./media/circuit-breaker-pattern.png)

<span data-ttu-id="726eb-180">**그림 6-3**.</span><span class="sxs-lookup"><span data-stu-id="726eb-180">**Figure 6-3**.</span></span> <span data-ttu-id="726eb-181">작동 중인 회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="726eb-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="726eb-182">위의 그림에서 회로 차단기 패턴은 원래 재시도 패턴에 추가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="726eb-183">100 실패 한 후에는 회로 차단기가 열리고 더 이상 서비스에 대 한 호출을 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="726eb-184">CheckCircuit 값 (30 초)은 라이브러리에서 한 요청이 서비스를 진행 하도록 허용 하는 빈도를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="726eb-185">해당 호출이 성공 하면 회로가 닫히고 서비스는 다시 트래픽에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="726eb-186">회로 차단기 패턴의 의도는 재시도 패턴과 *다르다는* 점에 유의 하세요.</span><span class="sxs-lookup"><span data-stu-id="726eb-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="726eb-187">재시도 패턴을 사용 하면 응용 프로그램이 성공 하다 고 가정 하에 작업을 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="726eb-188">회로 차단기 패턴은 응용 프로그램이 실패할 가능성이 있는 작업을 수행할 수 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="726eb-189">일반적으로 응용 프로그램은 회로 차단기를 통해 작업을 호출 하기 위해 재시도 패턴을 사용 하 여 이러한 두 가지 패턴을 *결합* 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="726eb-190">복원력 테스트</span><span class="sxs-lookup"><span data-stu-id="726eb-190">Testing for resiliency</span></span>

<span data-ttu-id="726eb-191">단위 테스트, 통합 테스트 등을 실행 하 여 응용 프로그램 기능을 테스트 하는 것과 동일한 방식으로 복원 력 테스트를 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests, and so on).</span></span> <span data-ttu-id="726eb-192">대신, 간헐적으로 발생 하는 오류 조건에서 종단 간 작업을 수행 하는 방식을 테스트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-192">Instead, you must test how the end-to-end workload performs under failure conditions, which only occur intermittently.</span></span> <span data-ttu-id="726eb-193">예: 충돌 하는 프로세스, 만료 된 인증서로 오류 삽입, 종속 서비스를 사용할 수 없도록 설정 등 혼란 스러운 [원숭이](https://github.com/Netflix/chaosmonkey) 와 같은 프레임 워크는 이러한 비정상 테스트에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="726eb-194">응용 프로그램 복원 력을 통해 문제가 있는 요청 된 작업을 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="726eb-195">그러나이는 스토리의 절반에 불과합니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-195">But, it's only half of the story.</span></span> <span data-ttu-id="726eb-196">다음으로, Azure 클라우드에서 사용할 수 있는 복원 력 기능을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="726eb-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="726eb-197">[이전](resiliency.md)
>[다음](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="726eb-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
