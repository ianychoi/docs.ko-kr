---
title: 분선 데이터
description: 모놀리식 및 클라우드 네이티브 응용 프로그램의 데이터 저장소를 대조 합니다.
author: robvet
ms.date: 01/19/2021
ms.openlocfilehash: c83ac5dc973ff4c7a4626746472a74cfc6bf54bb
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505871"
---
# <a name="distributed-data"></a><span data-ttu-id="9505a-103">분선 데이터</span><span class="sxs-lookup"><span data-stu-id="9505a-103">Distributed data</span></span>

<span data-ttu-id="9505a-104">이 책 전반에서 살펴본 것 처럼 클라우드 기본 접근 방식은 응용 프로그램을 디자인, 배포 및 관리 하는 방식을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="9505a-105">또한 데이터를 관리 하 고 저장 하는 방식을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="9505a-106">그림 5-1에서는 차이점을 대조 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-106">Figure 5-1 contrasts the differences.</span></span>

![클라우드 네이티브 응용 프로그램의 데이터 저장소](./media/distributed-data.png)

<span data-ttu-id="9505a-108">**그림 5-1**.</span><span class="sxs-lookup"><span data-stu-id="9505a-108">**Figure 5-1**.</span></span> <span data-ttu-id="9505a-109">클라우드 네이티브 응용 프로그램의 데이터 관리</span><span class="sxs-lookup"><span data-stu-id="9505a-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="9505a-110">숙련 된 개발자는 그림 5-1의 왼쪽에 있는 아키텍처를 쉽게 인식할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="9505a-111">이 *모놀리식 응용 프로그램* 에서 비즈니스 서비스 구성 요소는 단일 관계형 데이터베이스의 데이터를 공유 하는 공유 서비스 계층에서 함께 배치.</span><span class="sxs-lookup"><span data-stu-id="9505a-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="9505a-112">여러 가지 측면에서 단일 데이터베이스는 데이터 관리를 간단 하 게 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="9505a-113">여러 테이블에서 데이터를 쿼리 하는 것은 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="9505a-114">데이터 업데이트를 함께 변경 하거나 모두 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="9505a-115">[ACID 트랜잭션은](/windows/desktop/cossdk/acid-properties) 강력 하 고 즉각적인 일관성을 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-115">[ACID transactions](/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="9505a-116">클라우드 네이티브를 설계할 때 다른 접근 방법을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="9505a-117">그림 5-1의 오른쪽에서 비즈니스 기능이 소규모의 독립적인 마이크로 서비스에 분리 하는 방식을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="9505a-118">각 마이크로 서비스는 특정 비즈니스 기능과 자체 데이터를 캡슐화 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="9505a-119">모놀리식 데이터베이스는 각각 마이크로 서비스를 사용 하 여 여러 개의 작은 데이터베이스를 포함 하는 분산 데이터 모델로 분해.</span><span class="sxs-lookup"><span data-stu-id="9505a-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="9505a-120">연기를 지우면 *마이크로 서비스 당 데이터베이스* 를 표시 하는 디자인이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="database-per-microservice-why"></a><span data-ttu-id="9505a-121">마이크로 서비스 데이터베이스의 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="9505a-121">Database-per-microservice, why?</span></span>

<span data-ttu-id="9505a-122">마이크로 서비스 당이 데이터베이스는 특히 신속 하 게 진화 하 고 대규모 확장을 지 원하는 시스템에 많은 이점을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="9505a-123">이 모델을 사용 하 여 ...</span><span class="sxs-lookup"><span data-stu-id="9505a-123">With this model...</span></span>

- <span data-ttu-id="9505a-124">도메인 데이터는 서비스 내에 캡슐화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="9505a-125">다른 서비스에 직접 영향을 주지 않고 데이터 스키마를 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="9505a-126">각 데이터 저장소는 독립적으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-126">Each data store can independently scale</span></span>
- <span data-ttu-id="9505a-127">한 서비스의 데이터 저장소 오류는 다른 서비스에 직접적인 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="9505a-128">또한 데이터를 분리 하면 각 마이크로 서비스가 작업, 저장소 요구 사항 및 읽기/쓰기 패턴에 가장 적합 한 데이터 저장소 형식을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="9505a-129">관계형, 문서, 키 값 및 그래프 기반 데이터 저장소를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="9505a-130">그림 5-2은 클라우드 네이티브 시스템에서 polyglot 지 속성의 원칙을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Polyglot 데이터 지 속성](./media/polyglot-data-persistence.png)

<span data-ttu-id="9505a-132">**그림 5-2**.</span><span class="sxs-lookup"><span data-stu-id="9505a-132">**Figure 5-2**.</span></span> <span data-ttu-id="9505a-133">Polyglot 데이터 지 속성</span><span class="sxs-lookup"><span data-stu-id="9505a-133">Polyglot data persistence</span></span>

<span data-ttu-id="9505a-134">위의 그림에서 각 마이크로 서비스는 서로 다른 유형의 데이터 저장소를 지 원하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="9505a-135">제품 카탈로그 마이크로 서비스는 관계형 데이터베이스를 사용 하 여 기본 데이터의 풍부한 관계형 구조를 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="9505a-136">쇼핑 카트 마이크로 서비스는 간단한 키-값 데이터 저장소를 지 원하는 분산 캐시를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="9505a-137">정렬 마이크로 서비스는 읽기 작업의 대량 사용을 수용 하기 위해 매우 비 정규화 된 키/값 저장소와 함께 쓰기 작업용 NoSql 문서 데이터베이스를 모두 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="9505a-138">관계형 데이터베이스는 복잡 한 데이터를 포함 하는 마이크로 서비스에 대 한 관련성을 유지 하지만 NoSQL 데이터베이스는 상당한 인기를 얻었습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="9505a-139">광범위 하 고 고가용성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="9505a-140">이러한 특성을 사용 하면 개발자는 형식화 된 데이터 클래스의 아키텍처에서 벗어나 서 비용이 많이 들고 시간이 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="9505a-141">이 챕터의 뒷부분에 NoSQL 데이터베이스가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="9505a-142">데이터를 별도의 마이크로 서비스에 캡슐화 하는 동안 민첩성, 성능 및 확장성을 높일 수 있습니다. 또한 많은 과제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="9505a-143">다음 섹션에서는 이러한 과제를 해결 하는 데 도움이 되는 패턴 및 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="9505a-144">서비스 간 쿼리</span><span class="sxs-lookup"><span data-stu-id="9505a-144">Cross-service queries</span></span>

<span data-ttu-id="9505a-145">마이크로 서비스는 독립적 이며 재고, 배송 또는 주문과 같은 특정 기능에 중점을 두는 반면, 다른 마이크로 서비스와 통합 해야 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="9505a-146">통합에는 데이터에 대 한 다른 마이크로 서비스 *쿼리* 를 포함 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="9505a-147">그림 5-3은 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-147">Figure 5-3 shows the scenario.</span></span>

![마이크로 서비스 간 쿼리](./media/cross-service-query.png)

<span data-ttu-id="9505a-149">**그림 5-3**.</span><span class="sxs-lookup"><span data-stu-id="9505a-149">**Figure 5-3**.</span></span> <span data-ttu-id="9505a-150">마이크로 서비스 간 쿼리</span><span class="sxs-lookup"><span data-stu-id="9505a-150">Querying across microservices</span></span>

<span data-ttu-id="9505a-151">앞의 그림에는 사용자의 시장 바구니에 항목을 추가 하는 시장 바구니 마이크로 서비스이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="9505a-152">이 마이크로 서비스에 대 한 데이터 저장소는 바구니와 품목 데이터를 포함 하지만 제품 또는 가격 데이터는 유지 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="9505a-153">대신 이러한 데이터 항목은 카탈로그 및 가격 마이크로 서비스에서 소유 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="9505a-154">이 측면에서는 문제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-154">This aspect presents a problem.</span></span> <span data-ttu-id="9505a-155">시장 바구니 마이크로 서비스 데이터베이스에 제품 및 가격 책정 데이터가 없는 경우 사용자의 시장 바구니에 제품을 추가 하는 방법</span><span class="sxs-lookup"><span data-stu-id="9505a-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="9505a-156">4 장에서 설명 하는 한 가지 옵션은 쇼핑 바구니에서 카탈로그 및 가격 책정 마이크로 서비스에 대 한 [직접 HTTP 호출](service-to-service-communication.md#queries) 입니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="9505a-157">그러나 4 장에서는 동기 HTTP 호출을 통해 *두* 마이크로 서비스를 함께 제공 하 여 자율성을 줄이고 아키텍처 혜택을 축소 한다고 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="9505a-158">각 서비스에 대해 별도의 인바운드 및 아웃 바운드 큐를 사용 하 여 요청-회신 패턴을 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="9505a-159">그러나이 패턴은 복잡 하 고 요청 및 응답 메시지의 상관 관계를 파악 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="9505a-160">백엔드 마이크로 서비스 호출을 분리 하는 동안 호출 하는 서비스는 호출이 완료 될 때까지 동기적으로 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="9505a-161">네트워크 정체, 일시적인 오류 또는 오버 로드 된 마이크로 서비스로 인해 장기 실행 및 실패 한 작업이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="9505a-162">대신, 교차 서비스 종속성을 제거 하는 데 널리 승인 된 패턴은 그림 5-4에 표시 된 [구체화 된 뷰 패턴](/azure/architecture/patterns/materialized-view)입니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![구체화 된 뷰 패턴](./media/materialized-view-pattern.png)

<span data-ttu-id="9505a-164">**그림 5-4**.</span><span class="sxs-lookup"><span data-stu-id="9505a-164">**Figure 5-4**.</span></span> <span data-ttu-id="9505a-165">구체화 된 뷰 패턴</span><span class="sxs-lookup"><span data-stu-id="9505a-165">Materialized View Pattern</span></span>

<span data-ttu-id="9505a-166">이 패턴을 사용 하 여 쇼핑 바구니 서비스에서 로컬 데이터 테이블 ( *읽기 모델* 이라고 함)을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="9505a-167">이 테이블에는 제품 및 가격 마이크로 서비스에서 필요한 정규화 되지 않은 데이터 사본이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="9505a-168">시장 바구니 마이크로 서비스 데이터를 직접 복사 하면 비용이 많이 드는 서비스 간 호출이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="9505a-169">서비스의 로컬 데이터를 사용 하 여 서비스의 응답 시간과 안정성을 향상 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="9505a-170">또한 고유한 데이터 복사본을 사용 하면 시장 바구니 서비스의 복원 력이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="9505a-171">카탈로그 서비스를 사용할 수 없게 되 면 장바구니 서비스에 직접 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="9505a-172">쇼핑 바구니는 자신의 저장소에서 데이터를 계속 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="9505a-173">이 방법을 사용 하는 경우 시스템에 중복 된 데이터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="9505a-174">그러나 클라우드 네이티브 시스템에서 데이터를 *전략적* 으로 복제 하는 것은 설정 된 습관 이며, 안전 하지 않은 방법이 나 잘못 된 방법으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="9505a-175">한 *서비스 에서만* 데이터 집합을 소유 하 고 해당 서비스에 대 한 권한을 가질 수 있다는 점에 유의 하세요.</span><span class="sxs-lookup"><span data-stu-id="9505a-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="9505a-176">레코드의 시스템이 업데이트 될 때 읽기 모델을 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="9505a-177">일반적으로 동기화는 그림 5.4에 표시 된 것 처럼 [게시/구독 패턴](service-to-service-communication.md#events)을 사용 하 여 비동기 메시지를 통해 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="9505a-178">분산 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="9505a-178">Distributed transactions</span></span>

<span data-ttu-id="9505a-179">마이크로 서비스를 통해 데이터를 쿼리 하는 것이 어렵기 때문에 여러 마이크로 서비스에서 트랜잭션을 구현 하는 것은 훨씬 더 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="9505a-180">서로 다른 마이크로 서비스의 독립적인 데이터 원본에서 데이터 일관성을 유지 관리 하는 내재 된 과제는 understated 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="9505a-181">클라우드 네이티브 응용 프로그램에 분산 트랜잭션이 없으면 분산 트랜잭션을 프로그래밍 방식으로 관리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="9505a-182">*즉시 일관성* 의 세계에서 *최종 일관성* 으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="9505a-183">그림 5-5에서는 문제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-183">Figure 5-5 shows the problem.</span></span>

![Saga 패턴의 트랜잭션](./media/saga-transaction-operation.png)

<span data-ttu-id="9505a-185">**그림 5-5**.</span><span class="sxs-lookup"><span data-stu-id="9505a-185">**Figure 5-5**.</span></span> <span data-ttu-id="9505a-186">마이크로 서비스에서 트랜잭션 구현</span><span class="sxs-lookup"><span data-stu-id="9505a-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="9505a-187">위의 그림에서 5 개의 독립 마이크로 서비스는 주문을 만드는 분산 트랜잭션에 참여 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="9505a-188">각 마이크로 서비스는 자체 데이터 저장소를 유지 관리 하 고 해당 저장소에 대 한 로컬 트랜잭션을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="9505a-189">주문을 만들려면 *각* 개별 마이크로 서비스의 로컬 트랜잭션이 성공 해야 합니다. 그렇지 않으면 *모두* 작업을 중단 하 고 롤백해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="9505a-190">기본 제공 트랜잭션 지원은 각 마이크로 서비스 내에서 사용할 수 있지만 데이터 일관성을 유지 하기 위해 5 개 서비스 전체에 걸쳐 분산 된 트랜잭션을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="9505a-191">대신이 분산 트랜잭션을 *프로그래밍 방식으로* 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="9505a-192">분산 트랜잭션 지원을 추가 하는 일반적인 패턴은 Saga 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="9505a-193">로컬 트랜잭션을 프로그래밍 방식으로 그룹화 하 고 각 트랜잭션을 순차적으로 호출 하 여 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="9505a-194">로컬 트랜잭션이 실패 하면 Saga는 작업을 중단 하 고 [보정 트랜잭션](/azure/architecture/patterns/compensating-transaction)집합을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="9505a-195">보정 트랜잭션은 위의 로컬 트랜잭션에의 한 변경 내용을 취소 하 고 데이터 일관성을 복원 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="9505a-196">그림 5-6에서는 Saga 패턴을 사용 하는 실패 한 트랜잭션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Saga 패턴으로 롤백](./media/saga-rollback-operation.png)

<span data-ttu-id="9505a-198">**그림 5-6**.</span><span class="sxs-lookup"><span data-stu-id="9505a-198">**Figure 5-6**.</span></span> <span data-ttu-id="9505a-199">트랜잭션 롤백</span><span class="sxs-lookup"><span data-stu-id="9505a-199">Rolling back a transaction</span></span>

<span data-ttu-id="9505a-200">위의 그림에서 inventory 마이크로 서비스에서 *Inventory 업데이트* 작업이 실패 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="9505a-201">Saga는 보상 트랜잭션 집합 (빨간색)을 호출 하 여 재고 수를 조정 하 고, 지불 및 주문을 취소 하 고, 각 마이크로 서비스에 대 한 데이터를 다시 일관 된 상태로 되돌립니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="9505a-202">Saga 패턴은 일반적으로 일련의 관련 이벤트 또는 오케스트레이션 관련 된 명령 집합으로 조율 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="9505a-203">4 장에서는 오케스트레이션 saga 구현의 기초가 되는 서비스 집계 패턴에 대해 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="9505a-204">또한 조율 saga 구현의 기초가 되는 Azure Service Bus 및 Azure Event Grid 항목과 함께 이벤트에 대해 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="9505a-205">대량 데이터</span><span class="sxs-lookup"><span data-stu-id="9505a-205">High volume data</span></span>

<span data-ttu-id="9505a-206">대규모 클라우드 네이티브 응용 프로그램은 종종 대용량 데이터 요구 사항을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="9505a-207">이러한 시나리오에서는 기존 데이터 저장 기술을 통해 병목 현상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="9505a-208">대규모 시스템에 배포 하는 복잡 한 시스템의 경우 명령과 쿼리의 역할 분리 (CQRS) 및 이벤트 소싱을 모두 통해 응용 프로그램 성능을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="9505a-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="9505a-209">CQRS</span></span>

<span data-ttu-id="9505a-210">[CQRS](/azure/architecture/patterns/cqrs)는 성능, 확장성 및 보안을 최대화 하는 데 도움이 될 수 있는 아키텍처 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-210">[CQRS](/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="9505a-211">패턴은 데이터를 쓰는 작업에서 데이터를 읽는 작업을 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="9505a-212">일반적인 *시나리오의 경우 읽기 및* 쓰기 작업에 동일한 엔터티 모델 및 데이터 리포지토리 개체가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="9505a-213">그러나 대량 데이터 시나리오는 읽기 및 쓰기에 대 한 별도의 모델 및 데이터 테이블을 활용 하는 이점을 누릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="9505a-214">성능 향상을 위해 읽기 작업은 비용이 많이 드는 반복적인 테이블 조인과 테이블 잠금을 방지 하기 위해 매우 비 정규화 된 데이터 표현을 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="9505a-215">*명령* 이라고 하는 *쓰기* 작업은 일관성을 보장 하는 완전히 정규화 된 데이터 표현과 비교 하 여 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="9505a-216">그런 다음 두 표현을 동기화 하기 위한 메커니즘을 구현 해야 합니다. 일반적으로 쓰기 테이블을 수정할 때마다 수정 내용을 읽기 테이블로 복제 하는 이벤트를 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="9505a-217">그림 5-7에서는 CQRS 패턴의 구현을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![명령과 쿼리의 역할 분리](./media/cqrs-implementation.png)

<span data-ttu-id="9505a-219">**그림 5-7**.</span><span class="sxs-lookup"><span data-stu-id="9505a-219">**Figure 5-7**.</span></span> <span data-ttu-id="9505a-220">CQRS 구현</span><span class="sxs-lookup"><span data-stu-id="9505a-220">CQRS implementation</span></span>

<span data-ttu-id="9505a-221">위의 그림에서는 별도의 명령 및 쿼리 모델을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="9505a-222">각 데이터 쓰기 작업은 쓰기 저장소에 저장 된 다음 읽기 저장소로 전파 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="9505a-223">[최종 일관성](https://www.cloudcomputingpatterns.org/eventual_consistency/)원칙에 따라 데이터 전파 프로세스가 작동 하는 방식에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="9505a-224">읽기 모델은 결국 쓰기 모델과 동기화 되지만 프로세스가 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="9505a-225">다음 섹션에서 최종 일관성에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="9505a-226">이러한 분리를 통해 읽기 및 쓰기가 독립적으로 확장 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="9505a-227">읽기 작업은 쿼리에 최적화 된 스키마를 사용 하지만 쓰기는 업데이트에 최적화 된 스키마를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="9505a-228">읽기 쿼리는 비 정규화 된 데이터를 기반으로 하며, 복잡 한 비즈니스 논리를 쓰기 모델에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="9505a-229">또한 읽기를 노출 하는 것 보다 쓰기 작업에 대 한 보안을 강화 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="9505a-230">CQRS를 구현 하면 클라우드 네이티브 서비스에 대 한 응용 프로그램 성능을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="9505a-231">그러나이로 인해 디자인이 더 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="9505a-232">이 원칙을 활용 하는 클라우드 네이티브 응용 프로그램의 해당 섹션에 신중 하 게 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="9505a-233">CQRS에 대 한 자세한 내용은 Microsoft book [.Net 마이크로 서비스: 컨테이너 화 된 .Net 응용 프로그램 아키텍처](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9505a-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="9505a-234">이벤트 소싱</span><span class="sxs-lookup"><span data-stu-id="9505a-234">Event sourcing</span></span>

<span data-ttu-id="9505a-235">대량 데이터 시나리오를 최적화 하는 또 다른 방법으로는 [이벤트 소싱](/azure/architecture/patterns/event-sourcing)이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="9505a-236">일반적으로 시스템은 데이터 엔터티의 현재 상태를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="9505a-237">예를 들어 사용자가 전화 번호를 변경 하는 경우 고객 레코드는 새 숫자로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="9505a-238">항상 데이터 엔터티의 현재 상태를 알 수 있지만 각 업데이트는 이전 상태를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="9505a-239">대부분의 경우이 모델은 제대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-239">In most cases, this model works fine.</span></span> <span data-ttu-id="9505a-240">그러나 대용량 시스템에서 트랜잭션 잠금 및 빈번한 업데이트 작업으로 인 한 오버 헤드는 데이터베이스 성능, 응답성 및 한계 확장성에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="9505a-241">이벤트 소싱은 데이터를 캡처하는 다른 방법을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="9505a-242">데이터에 영향을 주는 각 작업은 이벤트 저장소에 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="9505a-243">데이터 레코드의 상태를 업데이트 하는 대신, 회계사의 원장과 유사 하 게 이전 이벤트의 순차적 목록에 각 변경 내용을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="9505a-244">이벤트 저장소는 데이터에 대 한 레코드의 시스템이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="9505a-245">마이크로 서비스의 제한 된 컨텍스트 내에서 다양 한 구체화 된 뷰를 전파 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="9505a-246">그림 5.8에서는 패턴을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-246">Figure 5.8 shows the pattern.</span></span>

![이벤트 소싱](./media/event-sourcing.png)

<span data-ttu-id="9505a-248">**그림 5-8**.</span><span class="sxs-lookup"><span data-stu-id="9505a-248">**Figure 5-8**.</span></span> <span data-ttu-id="9505a-249">이벤트 소싱</span><span class="sxs-lookup"><span data-stu-id="9505a-249">Event Sourcing</span></span>

<span data-ttu-id="9505a-250">위의 그림에서 사용자의 쇼핑 카트에 대 한 각 항목 (파란색)은 기본 이벤트 저장소에 추가 되는 방식을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="9505a-251">인접 한 구체화 된 뷰에서 시스템은 각 쇼핑 카트에 연결 된 모든 이벤트를 재생 하 여 현재 상태를 프로젝션 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="9505a-252">그런 다음이 뷰 또는 읽기 모델은 UI에 다시 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="9505a-253">이벤트를 외부 시스템 및 응용 프로그램과 통합 하거나 쿼리할 수 있으며 엔터티의 현재 상태를 확인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="9505a-254">이 방법을 사용 하면 기록을 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-254">With this approach, you maintain history.</span></span> <span data-ttu-id="9505a-255">엔터티의 현재 상태 뿐만 아니라이 상태에 도달 하는 방법에 대해서도 잘 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="9505a-256">기계적 말하는 이벤트 소싱은 쓰기 모델을 단순화 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="9505a-257">업데이트 또는 삭제가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-257">There are no updates or deletes.</span></span> <span data-ttu-id="9505a-258">각 데이터 항목을 변경할 수 없는 이벤트로 추가 하면 관계형 데이터베이스와 관련 된 경합, 잠금 및 동시성 충돌을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="9505a-259">구체화 된 뷰 패턴을 사용 하 여 읽기 모델을 빌드하면 쓰기 모델에서 뷰를 분리 하 고 가장 적합 한 데이터 저장소를 선택 하 여 응용 프로그램 UI의 요구 사항을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="9505a-260">이 패턴에서는 이벤트 소싱을 직접 지 원하는 데이터 저장소를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="9505a-261">Azure Cosmos DB, MongoDB, Cassandra,, RavenDB,는 좋은 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="9505a-262">모든 패턴 및 기술과 마찬가지로 전략적이 고 필요한 경우 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="9505a-263">이벤트 소싱은 향상 된 성능 및 확장성을 제공할 수 있지만 복잡성과 학습 곡선이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9505a-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9505a-264">[이전](service-mesh-communication-infrastructure.md)
>[다음](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="9505a-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
