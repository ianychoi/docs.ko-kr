---
title: gRPC
description: GRPC, 클라우드 네이티브 응용 프로그램에서의 역할 및 HTTP RESTful 통신과 어떻게 다른 지에 대해 알아봅니다.
author: robvet
no-loc:
- Blazor
- Blazor WebAssembly
ms.date: 01/19/2021
ms.openlocfilehash: 8667f2d3a7a19aa6dffdd8ce8bef103eab5cc54f
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505702"
---
# <a name="grpc"></a><span data-ttu-id="b82f2-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="b82f2-103">gRPC</span></span>

<span data-ttu-id="b82f2-104">지금까지이 책에서는 [REST 기반](/azure/architecture/best-practices/api-design) 통신에 초점을 두었습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-104">So far in this book, we've focused on [REST-based](/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="b82f2-105">REST는 엔터티 리소스에 대해 CRUD 기반 작업을 정의 하는 유연한 아키텍처 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="b82f2-106">클라이언트는 요청/응답 통신 모델을 사용 하 여 HTTP에서 리소스와 상호 작용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="b82f2-107">REST는 널리 구현 되는 반면, 최신 통신 기술인 gRPC는 클라우드 네이티브 커뮤니티에서 엄청난 모멘텀를 얻었습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="b82f2-108">GRPC 란?</span><span class="sxs-lookup"><span data-stu-id="b82f2-108">What is gRPC?</span></span>

<span data-ttu-id="b82f2-109">gRPC는 오래 된 [원격 프로시저 호출 (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) 프로토콜을 진화 하는 현대적인 고성능 프레임 워크입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="b82f2-110">응용 프로그램 수준에서 gRPC는 클라이언트와 백 엔드 서비스 간의 메시징을 간소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="b82f2-111">Google에서 시작 하 여 gRPC는 오픈 소스 이며 클라우드 기본 제공의  [CNCF (Cloud Native 컴퓨팅 Foundation)](https://www.cncf.io/) 에코 시스템의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="b82f2-112">CNCF는 gRPC에 [incubating 프로젝트](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="b82f2-113">Incubating은 최종 사용자가 프로덕션 응용 프로그램의 기술을 사용 하 고 있고 프로젝트에 참가자 수가 정상 임을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="b82f2-114">일반적인 gRPC 클라이언트 앱은 비즈니스 작업을 구현 하는 로컬 in-process 함수를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="b82f2-115">내부적으로 해당 로컬 함수는 원격 컴퓨터에서 다른 함수를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="b82f2-116">로컬 호출로 표시 되는 것은 기본적으로 원격 서비스에 대 한 out-of-process 호출로 인해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="b82f2-117">RPC는 지점 간 네트워킹 통신, serialization 및 컴퓨터 간의 실행을 추상화 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="b82f2-118">클라우드 네이티브 응용 프로그램에서 개발자는 종종 프로그래밍 언어, 프레임 워크 및 기술에 대해 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="b82f2-119">이러한 *상호 운용성* 은 메시지 계약과 플랫폼 간 통신에 필요한 통로를 복잡 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="b82f2-120">gRPC는 이러한 문제를 추상화 하는 "균일 한 수평 계층"을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="b82f2-121">개발자는 기본 플랫폼의 비즈니스 기능에 초점을 맞춘 반면, gRPC는 통신 연결을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="b82f2-122">gRPC는 Java, JavaScript, c #, Go, Swift 및 NodeJS를 비롯 하 여 가장 인기 있는 개발 스택에 대 한 포괄적인 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="b82f2-123">gRPC 혜택</span><span class="sxs-lookup"><span data-stu-id="b82f2-123">gRPC Benefits</span></span>

<span data-ttu-id="b82f2-124">gRPC는 해당 전송 프로토콜에 대해 HTTP/2를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="b82f2-125">Http/2는 HTTP 1.1와 호환 되지만 다음과 같은 다양 한 고급 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="b82f2-126">데이터 전송을 위한 이진 프레이밍 프로토콜-텍스트 기반 HTTP 1.1와는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-126">A binary framing protocol for data transport - unlike HTTP 1.1, which is text based.</span></span>
- <span data-ttu-id="b82f2-127">동일한 연결을 통해 여러 병렬 요청을 보내기 위한 멀티플렉싱 지원-HTTP 1.1는 한 번에 하나의 요청/응답 메시지로 처리를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="b82f2-128">클라이언트 요청과 서버 응답을 동시에 전송 하기 위한 양방향 전이중 통신입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="b82f2-129">대량 데이터 집합을 비동기적으로 스트림 하는 요청 및 응답을 설정 하는 기본 제공 스트리밍입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>
- <span data-ttu-id="b82f2-130">네트워크 사용량을 줄이는 헤더 압축입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-130">Header compression that reduces network usage.</span></span>

<span data-ttu-id="b82f2-131">gRPC는 간단 하 고 성능이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-131">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="b82f2-132">메시지 60-80% 더 작게 JSON serialization 보다 최대 8 배 더 빠를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-132">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="b82f2-133">Microsoft [Windows Communication Foundation (WCF)](../../framework/wcf/whats-wcf.md) 용어에서 grpc 성능은 매우 최적화 된 [nettcp 바인딩의](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)속도와 효율성을 초과 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-133">In Microsoft [Windows Communication Foundation (WCF)](../../framework/wcf/whats-wcf.md) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="b82f2-134">Microsoft stack을 중심으로 하는 NetTCP와는 달리 gRPC는 플랫폼 간입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-134">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="b82f2-135">프로토콜 버퍼</span><span class="sxs-lookup"><span data-stu-id="b82f2-135">Protocol Buffers</span></span>

<span data-ttu-id="b82f2-136">gRPC는 [프로토콜 버퍼](https://developers.google.com/protocol-buffers/docs/overview)라는 오픈 소스 기술을 채택 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-136">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="b82f2-137">서비스에서 서로 전송 하는 구조화 된 메시지를 serialize 하기 위한 매우 효율적이 고 플랫폼 중립적인 serialization 형식을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-137">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="b82f2-138">개발자는 크로스 플랫폼 IDL (인터페이스 정의 언어)을 사용 하 여 각 마이크로 서비스에 대 한 서비스 계약을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-138">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="b82f2-139">텍스트 기반 파일로 구현 되는 계약은 `.proto` 각 서비스의 메서드, 입력 및 출력을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-139">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="b82f2-140">동일한 계약 파일은 다양 한 개발 플랫폼에서 빌드된 gRPC 클라이언트 및 서비스에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-140">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="b82f2-141">Protobuf 컴파일러 인 프로토콜 파일을 사용 하 여 `protoc` 대상 플랫폼에 대 한 클라이언트와 서비스 코드를 모두 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-141">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="b82f2-142">코드에는 다음 구성 요소가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-142">The code includes the following components:</span></span>

- <span data-ttu-id="b82f2-143">클라이언트 및 서비스에서 공유 하는 강력한 형식의 개체로, 메시지의 서비스 작업 및 데이터 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-143">Strongly typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="b82f2-144">원격 gRPC 서비스가 상속 하 고 확장할 수 있는 필수 네트워크를 사용 하는 강력한 형식의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-144">A strongly typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="b82f2-145">원격 gRPC 서비스를 호출 하는 데 필요한 통로를 포함 하는 클라이언트 스텁입니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-145">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="b82f2-146">런타임에 각 메시지는 표준 Protobuf 표현으로 직렬화 되 고 클라이언트와 원격 서비스 간에 교환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-146">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="b82f2-147">JSON 또는 XML과 달리 Protobuf 메시지는 컴파일된 이진 바이트로 serialize 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-147">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="b82f2-148">Microsoft 아키텍처 사이트에서 사용할 수 있는 [WCF 개발자를 위한 Grpc](../grpc-for-wcf-developers/index.md)는 grpc와 프로토콜 버퍼에 대 한 심층적인 검사를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-148">The book, [gRPC for WCF Developers](../grpc-for-wcf-developers/index.md), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="b82f2-149">.NET의 gRPC 지원</span><span class="sxs-lookup"><span data-stu-id="b82f2-149">gRPC support in .NET</span></span>

<span data-ttu-id="b82f2-150">gRPC는 .NET Core 3.0 SDK 이상에 통합 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-150">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="b82f2-151">지원 되는 도구는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-151">The following tools support it:</span></span>

- <span data-ttu-id="b82f2-152">웹 개발 워크 로드가 설치 된 Visual Studio 2019, 버전 16.3 이상</span><span class="sxs-lookup"><span data-stu-id="b82f2-152">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="b82f2-153">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="b82f2-153">Visual Studio Code</span></span>
- <span data-ttu-id="b82f2-154">dotnet CLI</span><span class="sxs-lookup"><span data-stu-id="b82f2-154">the dotnet CLI</span></span>

<span data-ttu-id="b82f2-155">SDK에는 끝점 라우팅, 기본 제공 IoC 및 로깅에 대 한 도구가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-155">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="b82f2-156">오픈 소스 Kestrel 웹 서버는 HTTP/2 연결을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-156">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="b82f2-157">그림 4-20에는 gRPC 서비스에 대 한 기본 프로젝트를 스 캐 폴드 Visual Studio 2019 템플릿이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-157">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="b82f2-158">.NET이 Windows, Linux 및 macOS를 완전히 지 원하는 것을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-158">Note how .NET fully supports Windows, Linux, and macOS.</span></span>

![Visual Studio 2019의 gRPC 지원](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="b82f2-160">**그림 4-20**.</span><span class="sxs-lookup"><span data-stu-id="b82f2-160">**Figure 4-20**.</span></span> <span data-ttu-id="b82f2-161">Visual Studio 2019의 gRPC 지원</span><span class="sxs-lookup"><span data-stu-id="b82f2-161">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="b82f2-162">그림 4-21에는 Visual Studio 2019에 포함 된 기본 제공 스 캐 폴딩에서 생성 된 기본 gRPC 서비스가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-162">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![Visual Studio 2019의 gRPC 프로젝트](./media/grpc-project.png  )

<span data-ttu-id="b82f2-164">**그림 4-21**.</span><span class="sxs-lookup"><span data-stu-id="b82f2-164">**Figure 4-21**.</span></span> <span data-ttu-id="b82f2-165">Visual Studio 2019의 gRPC 프로젝트</span><span class="sxs-lookup"><span data-stu-id="b82f2-165">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="b82f2-166">위의 그림에서 프로토콜 설명 파일 및 서비스 코드를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-166">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="b82f2-167">곧 볼 수 있듯이 Visual Studio는 시작 클래스와 기본 프로젝트 파일 모두에 추가 구성을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-167">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="b82f2-168">gRPC 사용</span><span class="sxs-lookup"><span data-stu-id="b82f2-168">gRPC usage</span></span>

<span data-ttu-id="b82f2-169">다음 시나리오에서는 gRPC를 선호 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-169">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="b82f2-170">동기식 백 엔드 마이크로 서비스-마이크로 서비스 통신을 계속 하려면 즉각적인 응답이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-170">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="b82f2-171">혼합 프로그래밍 플랫폼을 지원 해야 하는 Polyglot 환경</span><span class="sxs-lookup"><span data-stu-id="b82f2-171">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="b82f2-172">성능이 중요 한 낮은 대기 시간 및 높은 처리량의 통신.</span><span class="sxs-lookup"><span data-stu-id="b82f2-172">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="b82f2-173">지점 간 실시간 통신-gRPC는 폴링을 사용 하지 않고 실시간으로 메시지를 푸시 하 고 양방향 스트리밍을 매우 잘 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-173">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="b82f2-174">네트워크 제한 환경 – 이진 gRPC 메시지는 항상 동등한 텍스트 기반 JSON 메시지 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-174">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="b82f2-175">이 문서를 작성할 당시에는 gRPC가 백 엔드 서비스에서 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-175">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="b82f2-176">최신 브라우저는 프런트 엔드 gRPC 클라이언트를 지 원하는 데 필요한 HTTP/2 제어 수준을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-176">Modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="b82f2-177">즉, JavaScript 또는 기술을 사용 하 여 빌드된 브라우저 기반 앱에서 gRPC 통신을 가능 하 게 하는 [.net을 사용 하는 grpc-웹](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) 을 지원 Blazor WebAssembly 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-177">That said, there's support for [gRPC-Web with .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="b82f2-178">[grpc-웹](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) 을 사용 하면 ASP.NET Core grpc 앱이 브라우저 앱에서 grpc 기능을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="b82f2-179">강력 하 게 형식화 된 코드 생성 클라이언트</span><span class="sxs-lookup"><span data-stu-id="b82f2-179">Strongly typed, code-generated clients</span></span>
- <span data-ttu-id="b82f2-180">Compact Protobuf 메시지</span><span class="sxs-lookup"><span data-stu-id="b82f2-180">Compact Protobuf messages</span></span>
- <span data-ttu-id="b82f2-181">서버 스트리밍</span><span class="sxs-lookup"><span data-stu-id="b82f2-181">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="b82f2-182">gRPC 구현</span><span class="sxs-lookup"><span data-stu-id="b82f2-182">gRPC implementation</span></span>

<span data-ttu-id="b82f2-183">Microsoft의 마이크로 서비스 참조 아키텍처 인 [컨테이너의 eShop](https://github.com/dotnet-architecture/eShopOnContainers)는 .net 응용 프로그램에서 grpc 서비스를 구현 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-183">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET applications.</span></span> <span data-ttu-id="b82f2-184">그림 4-22에서는 백 엔드 아키텍처를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-184">Figure 4-22 presents the back-end architecture.</span></span>

![컨테이너의 eShop 백 엔드 아키텍처](./media/eshop-with-aggregators.png)

<span data-ttu-id="b82f2-186">**그림 4-22**.</span><span class="sxs-lookup"><span data-stu-id="b82f2-186">**Figure 4-22**.</span></span> <span data-ttu-id="b82f2-187">컨테이너의 eShop 백 엔드 아키텍처</span><span class="sxs-lookup"><span data-stu-id="b82f2-187">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="b82f2-188">위의 그림에서 eShop 여러 API 게이트웨이를 노출 하 여 bff ( [프런트 엔드 패턴](/azure/architecture/patterns/backends-for-frontends) )를 수용 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-188">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="b82f2-189">이 챕터의 앞부분에서 BFF 패턴에 대해 설명 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-189">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="b82f2-190">Web-Shopping API 게이트웨이와 백엔드 마이크로 서비스 사이에 있는 집계 마이크로 서비스 (회색)에 주의 하세요.</span><span class="sxs-lookup"><span data-stu-id="b82f2-190">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="b82f2-191">집계는 클라이언트에서 단일 요청을 수신 하 고, 다양 한 마이크로 서비스에 디스패치 하 고, 결과를 집계 하 고, 요청 클라이언트로 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-191">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="b82f2-192">이러한 작업에는 일반적으로 즉각적인 응답을 생성 하기 위해 동기식 통신이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-192">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="b82f2-193">EShop에서 집계의 백 엔드 호출은 그림 4-23에 표시 된 것 처럼 gRPC를 사용 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-193">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![컨테이너의 eShop의 gRPC](./media/grpc-implementation.png)

<span data-ttu-id="b82f2-195">**그림 4-23**</span><span class="sxs-lookup"><span data-stu-id="b82f2-195">**Figure 4-23**.</span></span> <span data-ttu-id="b82f2-196">컨테이너의 eShop의 gRPC</span><span class="sxs-lookup"><span data-stu-id="b82f2-196">gRPC in eShop on Containers</span></span>

<span data-ttu-id="b82f2-197">gRPC 통신에는 클라이언트 및 서버 구성 요소가 모두 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-197">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="b82f2-198">위의 그림에서 쇼핑 집계가 gRPC 클라이언트를 구현 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-198">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="b82f2-199">클라이언트는 각에 gRPC 서버를 구현 하는 동기 gRPC 호출 (빨간색)을 백 엔드 마이크로 서비스에 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-199">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="b82f2-200">클라이언트와 서버는 모두 .NET SDK에서 제공 되는 기본 제공 gRPC를 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-200">Both the client and server take advantage of the built-in gRPC plumbing from the .NET SDK.</span></span> <span data-ttu-id="b82f2-201">클라이언트 쪽 *스텁은* 원격 grpc 호출을 호출 하는 통로를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-201">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="b82f2-202">서버 쪽 구성 요소는 사용자 지정 서비스 클래스가 상속 및 소비할 수 있는 gRPC 배관을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-202">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="b82f2-203">RESTful API 및 gRPC 통신을 모두 노출 하는 마이크로 서비스에는 트래픽을 관리 하는 여러 끝점이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-203">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="b82f2-204">RESTful 호출 및 gRPC 호출에 대 한 HTTP 트래픽을 수신 대기 하는 끝점을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-204">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="b82f2-205">Grpc 통신에 필요한 HTTP/2 프로토콜에 대해 gRPC 끝점을 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-205">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="b82f2-206">마이크로 서비스를 비동기 통신 패턴으로 분리 하려고 하지만 일부 작업은 직접 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-206">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="b82f2-207">gRPC는 마이크로 서비스 간의 직접 동기식 통신을 위한 기본 선택 사항 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-207">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="b82f2-208">HTTP/2 및 프로토콜 버퍼를 기준으로 하는 고성능 통신 프로토콜을 사용 하면 완벽 하 게 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-208">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="b82f2-209">미리 보기</span><span class="sxs-lookup"><span data-stu-id="b82f2-209">Looking ahead</span></span>

<span data-ttu-id="b82f2-210">잘 살펴보면, grpc는 클라우드 네이티브 시스템에 대해 트랙 션을 계속 해 서 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-210">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="b82f2-211">성능 이점과 개발의 용이성은 매우 강력 합니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-211">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="b82f2-212">그러나 REST는 오랜 시간 동안 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b82f2-212">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="b82f2-213">공개적으로 노출 된 Api 및 이전 버전과의 호환성을 위해 뛰어나지만.</span><span class="sxs-lookup"><span data-stu-id="b82f2-213">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="b82f2-214">[이전](service-to-service-communication.md)
>[다음](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="b82f2-214">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
